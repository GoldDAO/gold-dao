/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_components_Hero_tsx"],{

/***/ "(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/actor.js":
/*!******************************************************!*\
  !*** ./node_modules/@dfinity/agent/lib/esm/actor.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ACTOR_METHOD_WITH_CERTIFICATE: function() { return /* binding */ ACTOR_METHOD_WITH_CERTIFICATE; },\n/* harmony export */   ACTOR_METHOD_WITH_HTTP_DETAILS: function() { return /* binding */ ACTOR_METHOD_WITH_HTTP_DETAILS; },\n/* harmony export */   Actor: function() { return /* binding */ Actor; },\n/* harmony export */   ActorCallError: function() { return /* binding */ ActorCallError; },\n/* harmony export */   AdvancedActor: function() { return /* binding */ AdvancedActor; },\n/* harmony export */   QueryCallRejectedError: function() { return /* binding */ QueryCallRejectedError; },\n/* harmony export */   UpdateCallRejectedError: function() { return /* binding */ UpdateCallRejectedError; },\n/* harmony export */   getManagementCanister: function() { return /* binding */ getManagementCanister; }\n/* harmony export */ });\n/* harmony import */ var buffer___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer/ */ \"(app-pages-browser)/../../node_modules/buffer/index.js\");\n/* harmony import */ var _agent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./agent */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/agent/index.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/errors.js\");\n/* harmony import */ var _dfinity_candid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @dfinity/candid */ \"(app-pages-browser)/./node_modules/@dfinity/candid/lib/esm/index.js\");\n/* harmony import */ var _polling__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./polling */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/polling/index.js\");\n/* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @dfinity/principal */ \"(app-pages-browser)/./node_modules/@dfinity/principal/lib/esm/index.js\");\n/* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/buffer */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/utils/buffer.js\");\n/* harmony import */ var _certificate__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./certificate */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/certificate.js\");\n/* harmony import */ var _canisters_management_idl__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./canisters/management_idl */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/canisters/management_idl.js\");\n\n\n\n\n\n\n\n\n\nclass ActorCallError extends _errors__WEBPACK_IMPORTED_MODULE_2__.AgentError {\n    constructor(canisterId, methodName, type, props) {\n        super([\n            `Call failed:`,\n            `  Canister: ${canisterId.toText()}`,\n            `  Method: ${methodName} (${type})`,\n            ...Object.getOwnPropertyNames(props).map(n => `  \"${n}\": ${JSON.stringify(props[n])}`),\n        ].join('\\n'));\n        this.canisterId = canisterId;\n        this.methodName = methodName;\n        this.type = type;\n        this.props = props;\n    }\n}\nclass QueryCallRejectedError extends ActorCallError {\n    constructor(canisterId, methodName, result) {\n        var _a;\n        super(canisterId, methodName, 'query', {\n            Status: result.status,\n            Code: (_a = _agent__WEBPACK_IMPORTED_MODULE_1__.ReplicaRejectCode[result.reject_code]) !== null && _a !== void 0 ? _a : `Unknown Code \"${result.reject_code}\"`,\n            Message: result.reject_message,\n        });\n        this.result = result;\n    }\n}\nclass UpdateCallRejectedError extends ActorCallError {\n    constructor(canisterId, methodName, requestId, response) {\n        super(canisterId, methodName, 'update', Object.assign({ 'Request ID': (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_6__.toHex)(requestId) }, (response.body\n            ? Object.assign(Object.assign({}, (response.body.error_code\n                ? {\n                    'Error code': response.body.error_code,\n                }\n                : {})), { 'Reject code': String(response.body.reject_code), 'Reject message': response.body.reject_message }) : {\n            'HTTP status code': response.status.toString(),\n            'HTTP status text': response.statusText,\n        })));\n        this.requestId = requestId;\n        this.response = response;\n    }\n}\nconst metadataSymbol = Symbol.for('ic-agent-metadata');\n/**\n * An actor base class. An actor is an object containing only functions that will\n * return a promise. These functions are derived from the IDL definition.\n */\nclass Actor {\n    constructor(metadata) {\n        this[metadataSymbol] = Object.freeze(metadata);\n    }\n    /**\n     * Get the Agent class this Actor would call, or undefined if the Actor would use\n     * the default agent (global.ic.agent).\n     * @param actor The actor to get the agent of.\n     */\n    static agentOf(actor) {\n        return actor[metadataSymbol].config.agent;\n    }\n    /**\n     * Get the interface of an actor, in the form of an instance of a Service.\n     * @param actor The actor to get the interface of.\n     */\n    static interfaceOf(actor) {\n        return actor[metadataSymbol].service;\n    }\n    static canisterIdOf(actor) {\n        return _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.from(actor[metadataSymbol].config.canisterId);\n    }\n    static async install(fields, config) {\n        const mode = fields.mode === undefined ? { install: null } : fields.mode;\n        // Need to transform the arg into a number array.\n        const arg = fields.arg ? [...new Uint8Array(fields.arg)] : [];\n        // Same for module.\n        const wasmModule = [...new Uint8Array(fields.module)];\n        const canisterId = typeof config.canisterId === 'string'\n            ? _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.fromText(config.canisterId)\n            : config.canisterId;\n        await getManagementCanister(config).install_code({\n            mode,\n            arg,\n            wasm_module: wasmModule,\n            canister_id: canisterId,\n            sender_canister_version: [],\n        });\n    }\n    static async createCanister(config, settings) {\n        function settingsToCanisterSettings(settings) {\n            return [\n                {\n                    controllers: settings.controllers ? [settings.controllers] : [],\n                    compute_allocation: settings.compute_allocation ? [settings.compute_allocation] : [],\n                    freezing_threshold: settings.freezing_threshold ? [settings.freezing_threshold] : [],\n                    memory_allocation: settings.memory_allocation ? [settings.memory_allocation] : [],\n                    reserved_cycles_limit: [],\n                    log_visibility: [],\n                    wasm_memory_limit: [],\n                },\n            ];\n        }\n        const { canister_id: canisterId } = await getManagementCanister(config || {}).provisional_create_canister_with_cycles({\n            amount: [],\n            settings: settingsToCanisterSettings(settings || {}),\n            specified_id: [],\n            sender_canister_version: [],\n        });\n        return canisterId;\n    }\n    static async createAndInstallCanister(interfaceFactory, fields, config) {\n        const canisterId = await this.createCanister(config);\n        await this.install(Object.assign({}, fields), Object.assign(Object.assign({}, config), { canisterId }));\n        return this.createActor(interfaceFactory, Object.assign(Object.assign({}, config), { canisterId }));\n    }\n    static createActorClass(interfaceFactory, options) {\n        const service = interfaceFactory({ IDL: _dfinity_candid__WEBPACK_IMPORTED_MODULE_3__.IDL });\n        class CanisterActor extends Actor {\n            constructor(config) {\n                if (!config.canisterId)\n                    throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AgentError(`Canister ID is required, but received ${typeof config.canisterId} instead. If you are using automatically generated declarations, this may be because your application is not setting the canister ID in process.env correctly.`);\n                const canisterId = typeof config.canisterId === 'string'\n                    ? _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.fromText(config.canisterId)\n                    : config.canisterId;\n                super({\n                    config: Object.assign(Object.assign(Object.assign({}, DEFAULT_ACTOR_CONFIG), config), { canisterId }),\n                    service,\n                });\n                for (const [methodName, func] of service._fields) {\n                    if (options === null || options === void 0 ? void 0 : options.httpDetails) {\n                        func.annotations.push(ACTOR_METHOD_WITH_HTTP_DETAILS);\n                    }\n                    if (options === null || options === void 0 ? void 0 : options.certificate) {\n                        func.annotations.push(ACTOR_METHOD_WITH_CERTIFICATE);\n                    }\n                    this[methodName] = _createActorMethod(this, methodName, func, config.blsVerify);\n                }\n            }\n        }\n        return CanisterActor;\n    }\n    static createActor(interfaceFactory, configuration) {\n        if (!configuration.canisterId) {\n            throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AgentError(`Canister ID is required, but received ${typeof configuration.canisterId} instead. If you are using automatically generated declarations, this may be because your application is not setting the canister ID in process.env correctly.`);\n        }\n        return new (this.createActorClass(interfaceFactory))(configuration);\n    }\n    /**\n     * Returns an actor with methods that return the http response details along with the result\n     * @param interfaceFactory - the interface factory for the actor\n     * @param configuration - the configuration for the actor\n     * @deprecated - use createActor with actorClassOptions instead\n     */\n    static createActorWithHttpDetails(interfaceFactory, configuration) {\n        return new (this.createActorClass(interfaceFactory, { httpDetails: true }))(configuration);\n    }\n    /**\n     * Returns an actor with methods that return the http response details along with the result\n     * @param interfaceFactory - the interface factory for the actor\n     * @param configuration - the configuration for the actor\n     * @param actorClassOptions - options for the actor class extended details to return with the result\n     */\n    static createActorWithExtendedDetails(interfaceFactory, configuration, actorClassOptions = {\n        httpDetails: true,\n        certificate: true,\n    }) {\n        return new (this.createActorClass(interfaceFactory, actorClassOptions))(configuration);\n    }\n}\n// IDL functions can have multiple return values, so decoding always\n// produces an array. Ensure that functions with single or zero return\n// values behave as expected.\nfunction decodeReturnValue(types, msg) {\n    const returnValues = _dfinity_candid__WEBPACK_IMPORTED_MODULE_3__.IDL.decode(types, buffer___WEBPACK_IMPORTED_MODULE_0__.Buffer.from(msg));\n    switch (returnValues.length) {\n        case 0:\n            return undefined;\n        case 1:\n            return returnValues[0];\n        default:\n            return returnValues;\n    }\n}\nconst DEFAULT_ACTOR_CONFIG = {\n    pollingStrategyFactory: _polling__WEBPACK_IMPORTED_MODULE_4__.strategy.defaultStrategy,\n};\nconst ACTOR_METHOD_WITH_HTTP_DETAILS = 'http-details';\nconst ACTOR_METHOD_WITH_CERTIFICATE = 'certificate';\nfunction _createActorMethod(actor, methodName, func, blsVerify) {\n    let caller;\n    if (func.annotations.includes('query') || func.annotations.includes('composite_query')) {\n        caller = async (options, ...args) => {\n            var _a, _b;\n            // First, if there's a config transformation, call it.\n            options = Object.assign(Object.assign({}, options), (_b = (_a = actor[metadataSymbol].config).queryTransform) === null || _b === void 0 ? void 0 : _b.call(_a, methodName, args, Object.assign(Object.assign({}, actor[metadataSymbol].config), options)));\n            const agent = options.agent || actor[metadataSymbol].config.agent || (0,_agent__WEBPACK_IMPORTED_MODULE_1__.getDefaultAgent)();\n            const cid = _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.from(options.canisterId || actor[metadataSymbol].config.canisterId);\n            const arg = _dfinity_candid__WEBPACK_IMPORTED_MODULE_3__.IDL.encode(func.argTypes, args);\n            const result = await agent.query(cid, {\n                methodName,\n                arg,\n                effectiveCanisterId: options.effectiveCanisterId,\n            });\n            const httpDetails = Object.assign(Object.assign({}, result.httpDetails), { requestDetails: result.requestDetails });\n            switch (result.status) {\n                case \"rejected\" /* QueryResponseStatus.Rejected */:\n                    throw new QueryCallRejectedError(cid, methodName, result);\n                case \"replied\" /* QueryResponseStatus.Replied */:\n                    return func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS)\n                        ? {\n                            httpDetails,\n                            result: decodeReturnValue(func.retTypes, result.reply.arg),\n                        }\n                        : decodeReturnValue(func.retTypes, result.reply.arg);\n            }\n        };\n    }\n    else {\n        caller = async (options, ...args) => {\n            var _a, _b;\n            // First, if there's a config transformation, call it.\n            options = Object.assign(Object.assign({}, options), (_b = (_a = actor[metadataSymbol].config).callTransform) === null || _b === void 0 ? void 0 : _b.call(_a, methodName, args, Object.assign(Object.assign({}, actor[metadataSymbol].config), options)));\n            const agent = options.agent || actor[metadataSymbol].config.agent || (0,_agent__WEBPACK_IMPORTED_MODULE_1__.getDefaultAgent)();\n            const { canisterId, effectiveCanisterId, pollingStrategyFactory } = Object.assign(Object.assign(Object.assign({}, DEFAULT_ACTOR_CONFIG), actor[metadataSymbol].config), options);\n            const cid = _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.from(canisterId);\n            const ecid = effectiveCanisterId !== undefined ? _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.from(effectiveCanisterId) : cid;\n            const arg = _dfinity_candid__WEBPACK_IMPORTED_MODULE_3__.IDL.encode(func.argTypes, args);\n            if (agent.rootKey == null)\n                throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AgentError('Agent root key not initialized before making call');\n            const { requestId, response, requestDetails } = await agent.call(cid, {\n                methodName,\n                arg,\n                effectiveCanisterId: ecid,\n            });\n            let reply;\n            let certificate;\n            if (response.body && response.body.certificate) {\n                const cert = response.body.certificate;\n                certificate = await _certificate__WEBPACK_IMPORTED_MODULE_7__.Certificate.create({\n                    certificate: (0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_3__.bufFromBufLike)(cert),\n                    rootKey: agent.rootKey,\n                    canisterId: _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.from(canisterId),\n                    blsVerify,\n                });\n                const path = [new TextEncoder().encode('request_status'), requestId];\n                const status = new TextDecoder().decode((0,_certificate__WEBPACK_IMPORTED_MODULE_7__.lookupResultToBuffer)(certificate.lookup([...path, 'status'])));\n                switch (status) {\n                    case 'replied':\n                        reply = (0,_certificate__WEBPACK_IMPORTED_MODULE_7__.lookupResultToBuffer)(certificate.lookup([...path, 'reply']));\n                        break;\n                    case 'rejected':\n                        throw new UpdateCallRejectedError(cid, methodName, requestId, response);\n                }\n            }\n            // Fall back to polling if we recieve an Accepted response code\n            if (response.status === 202) {\n                const pollStrategy = pollingStrategyFactory();\n                // Contains the certificate and the reply from the boundary node\n                const response = await (0,_polling__WEBPACK_IMPORTED_MODULE_4__.pollForResponse)(agent, ecid, requestId, pollStrategy, blsVerify);\n                certificate = response.certificate;\n                reply = response.reply;\n            }\n            const shouldIncludeHttpDetails = func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS);\n            const shouldIncludeCertificate = func.annotations.includes(ACTOR_METHOD_WITH_CERTIFICATE);\n            const httpDetails = Object.assign(Object.assign({}, response), { requestDetails });\n            if (reply !== undefined) {\n                if (shouldIncludeHttpDetails && shouldIncludeCertificate) {\n                    return {\n                        httpDetails,\n                        certificate,\n                        result: decodeReturnValue(func.retTypes, reply),\n                    };\n                }\n                else if (shouldIncludeCertificate) {\n                    return {\n                        certificate,\n                        result: decodeReturnValue(func.retTypes, reply),\n                    };\n                }\n                else if (shouldIncludeHttpDetails) {\n                    return {\n                        httpDetails,\n                        result: decodeReturnValue(func.retTypes, reply),\n                    };\n                }\n                return decodeReturnValue(func.retTypes, reply);\n            }\n            else if (func.retTypes.length === 0) {\n                return shouldIncludeHttpDetails\n                    ? {\n                        httpDetails: response,\n                        result: undefined,\n                    }\n                    : undefined;\n            }\n            else {\n                throw new Error(`Call was returned undefined, but type [${func.retTypes.join(',')}].`);\n            }\n        };\n    }\n    const handler = (...args) => caller({}, ...args);\n    handler.withOptions =\n        (options) => (...args) => caller(options, ...args);\n    return handler;\n}\n/**\n * Create a management canister actor\n * @param config - a CallConfig\n */\nfunction getManagementCanister(config) {\n    function transform(_methodName, args) {\n        if (config.effectiveCanisterId) {\n            return { effectiveCanisterId: _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.from(config.effectiveCanisterId) };\n        }\n        const first = args[0];\n        let effectiveCanisterId = _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.fromHex('');\n        if (first && typeof first === 'object' && first.canister_id) {\n            effectiveCanisterId = _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.from(first.canister_id);\n        }\n        return { effectiveCanisterId };\n    }\n    return Actor.createActor(_canisters_management_idl__WEBPACK_IMPORTED_MODULE_8__[\"default\"], Object.assign(Object.assign(Object.assign({}, config), { canisterId: _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.fromHex('') }), {\n        callTransform: transform,\n        queryTransform: transform,\n    }));\n}\nclass AdvancedActor extends Actor {\n    constructor(metadata) {\n        super(metadata);\n    }\n}\n//# sourceMappingURL=actor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2FjdG9yLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWlDO0FBQzZCO0FBQ3hCO0FBQ2dCO0FBQ0E7QUFDUDtBQUNSO0FBQzJCO0FBQ0g7QUFDeEQsNkJBQTZCLCtDQUFVO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQkFBb0I7QUFDL0MseUJBQXlCLFlBQVksR0FBRyxLQUFLO0FBQzdDLGdFQUFnRSxFQUFFLEtBQUsseUJBQXlCO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxREFBaUIsd0VBQXdFLG1CQUFtQjtBQUNwSTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsZ0VBQWdFLGNBQWMsb0RBQUssYUFBYTtBQUNoRyw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU0sa0dBQWtHO0FBQzVIO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseURBQVM7QUFDeEI7QUFDQTtBQUNBLG1EQUFtRCxnQkFBZ0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMseURBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxnQkFBZ0IsMEJBQTBC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S0FBSztBQUNMO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2FjdG9yLmpzPzMyYmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSAnYnVmZmVyLyc7XG5pbXBvcnQgeyBnZXREZWZhdWx0QWdlbnQsIFJlcGxpY2FSZWplY3RDb2RlLCB9IGZyb20gJy4vYWdlbnQnO1xuaW1wb3J0IHsgQWdlbnRFcnJvciB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB7IGJ1ZkZyb21CdWZMaWtlLCBJREwgfSBmcm9tICdAZGZpbml0eS9jYW5kaWQnO1xuaW1wb3J0IHsgcG9sbEZvclJlc3BvbnNlLCBzdHJhdGVneSB9IGZyb20gJy4vcG9sbGluZyc7XG5pbXBvcnQgeyBQcmluY2lwYWwgfSBmcm9tICdAZGZpbml0eS9wcmluY2lwYWwnO1xuaW1wb3J0IHsgdG9IZXggfSBmcm9tICcuL3V0aWxzL2J1ZmZlcic7XG5pbXBvcnQgeyBDZXJ0aWZpY2F0ZSwgbG9va3VwUmVzdWx0VG9CdWZmZXIgfSBmcm9tICcuL2NlcnRpZmljYXRlJztcbmltcG9ydCBtYW5hZ2VtZW50Q2FuaXN0ZXJJZGwgZnJvbSAnLi9jYW5pc3RlcnMvbWFuYWdlbWVudF9pZGwnO1xuZXhwb3J0IGNsYXNzIEFjdG9yQ2FsbEVycm9yIGV4dGVuZHMgQWdlbnRFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY2FuaXN0ZXJJZCwgbWV0aG9kTmFtZSwgdHlwZSwgcHJvcHMpIHtcbiAgICAgICAgc3VwZXIoW1xuICAgICAgICAgICAgYENhbGwgZmFpbGVkOmAsXG4gICAgICAgICAgICBgICBDYW5pc3RlcjogJHtjYW5pc3RlcklkLnRvVGV4dCgpfWAsXG4gICAgICAgICAgICBgICBNZXRob2Q6ICR7bWV0aG9kTmFtZX0gKCR7dHlwZX0pYCxcbiAgICAgICAgICAgIC4uLk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3BzKS5tYXAobiA9PiBgICBcIiR7bn1cIjogJHtKU09OLnN0cmluZ2lmeShwcm9wc1tuXSl9YCksXG4gICAgICAgIF0uam9pbignXFxuJykpO1xuICAgICAgICB0aGlzLmNhbmlzdGVySWQgPSBjYW5pc3RlcklkO1xuICAgICAgICB0aGlzLm1ldGhvZE5hbWUgPSBtZXRob2ROYW1lO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFF1ZXJ5Q2FsbFJlamVjdGVkRXJyb3IgZXh0ZW5kcyBBY3RvckNhbGxFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY2FuaXN0ZXJJZCwgbWV0aG9kTmFtZSwgcmVzdWx0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgc3VwZXIoY2FuaXN0ZXJJZCwgbWV0aG9kTmFtZSwgJ3F1ZXJ5Jywge1xuICAgICAgICAgICAgU3RhdHVzOiByZXN1bHQuc3RhdHVzLFxuICAgICAgICAgICAgQ29kZTogKF9hID0gUmVwbGljYVJlamVjdENvZGVbcmVzdWx0LnJlamVjdF9jb2RlXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogYFVua25vd24gQ29kZSBcIiR7cmVzdWx0LnJlamVjdF9jb2RlfVwiYCxcbiAgICAgICAgICAgIE1lc3NhZ2U6IHJlc3VsdC5yZWplY3RfbWVzc2FnZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVzdWx0ID0gcmVzdWx0O1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBVcGRhdGVDYWxsUmVqZWN0ZWRFcnJvciBleHRlbmRzIEFjdG9yQ2FsbEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihjYW5pc3RlcklkLCBtZXRob2ROYW1lLCByZXF1ZXN0SWQsIHJlc3BvbnNlKSB7XG4gICAgICAgIHN1cGVyKGNhbmlzdGVySWQsIG1ldGhvZE5hbWUsICd1cGRhdGUnLCBPYmplY3QuYXNzaWduKHsgJ1JlcXVlc3QgSUQnOiB0b0hleChyZXF1ZXN0SWQpIH0sIChyZXNwb25zZS5ib2R5XG4gICAgICAgICAgICA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKHJlc3BvbnNlLmJvZHkuZXJyb3JfY29kZVxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAnRXJyb3IgY29kZSc6IHJlc3BvbnNlLmJvZHkuZXJyb3JfY29kZSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiB7fSkpLCB7ICdSZWplY3QgY29kZSc6IFN0cmluZyhyZXNwb25zZS5ib2R5LnJlamVjdF9jb2RlKSwgJ1JlamVjdCBtZXNzYWdlJzogcmVzcG9uc2UuYm9keS5yZWplY3RfbWVzc2FnZSB9KSA6IHtcbiAgICAgICAgICAgICdIVFRQIHN0YXR1cyBjb2RlJzogcmVzcG9uc2Uuc3RhdHVzLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAnSFRUUCBzdGF0dXMgdGV4dCc6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgIH0pKSk7XG4gICAgICAgIHRoaXMucmVxdWVzdElkID0gcmVxdWVzdElkO1xuICAgICAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgfVxufVxuY29uc3QgbWV0YWRhdGFTeW1ib2wgPSBTeW1ib2wuZm9yKCdpYy1hZ2VudC1tZXRhZGF0YScpO1xuLyoqXG4gKiBBbiBhY3RvciBiYXNlIGNsYXNzLiBBbiBhY3RvciBpcyBhbiBvYmplY3QgY29udGFpbmluZyBvbmx5IGZ1bmN0aW9ucyB0aGF0IHdpbGxcbiAqIHJldHVybiBhIHByb21pc2UuIFRoZXNlIGZ1bmN0aW9ucyBhcmUgZGVyaXZlZCBmcm9tIHRoZSBJREwgZGVmaW5pdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIEFjdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRhZGF0YSkge1xuICAgICAgICB0aGlzW21ldGFkYXRhU3ltYm9sXSA9IE9iamVjdC5mcmVlemUobWV0YWRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIEFnZW50IGNsYXNzIHRoaXMgQWN0b3Igd291bGQgY2FsbCwgb3IgdW5kZWZpbmVkIGlmIHRoZSBBY3RvciB3b3VsZCB1c2VcbiAgICAgKiB0aGUgZGVmYXVsdCBhZ2VudCAoZ2xvYmFsLmljLmFnZW50KS5cbiAgICAgKiBAcGFyYW0gYWN0b3IgVGhlIGFjdG9yIHRvIGdldCB0aGUgYWdlbnQgb2YuXG4gICAgICovXG4gICAgc3RhdGljIGFnZW50T2YoYWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIGFjdG9yW21ldGFkYXRhU3ltYm9sXS5jb25maWcuYWdlbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaW50ZXJmYWNlIG9mIGFuIGFjdG9yLCBpbiB0aGUgZm9ybSBvZiBhbiBpbnN0YW5jZSBvZiBhIFNlcnZpY2UuXG4gICAgICogQHBhcmFtIGFjdG9yIFRoZSBhY3RvciB0byBnZXQgdGhlIGludGVyZmFjZSBvZi5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50ZXJmYWNlT2YoYWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIGFjdG9yW21ldGFkYXRhU3ltYm9sXS5zZXJ2aWNlO1xuICAgIH1cbiAgICBzdGF0aWMgY2FuaXN0ZXJJZE9mKGFjdG9yKSB7XG4gICAgICAgIHJldHVybiBQcmluY2lwYWwuZnJvbShhY3RvclttZXRhZGF0YVN5bWJvbF0uY29uZmlnLmNhbmlzdGVySWQpO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgaW5zdGFsbChmaWVsZHMsIGNvbmZpZykge1xuICAgICAgICBjb25zdCBtb2RlID0gZmllbGRzLm1vZGUgPT09IHVuZGVmaW5lZCA/IHsgaW5zdGFsbDogbnVsbCB9IDogZmllbGRzLm1vZGU7XG4gICAgICAgIC8vIE5lZWQgdG8gdHJhbnNmb3JtIHRoZSBhcmcgaW50byBhIG51bWJlciBhcnJheS5cbiAgICAgICAgY29uc3QgYXJnID0gZmllbGRzLmFyZyA/IFsuLi5uZXcgVWludDhBcnJheShmaWVsZHMuYXJnKV0gOiBbXTtcbiAgICAgICAgLy8gU2FtZSBmb3IgbW9kdWxlLlxuICAgICAgICBjb25zdCB3YXNtTW9kdWxlID0gWy4uLm5ldyBVaW50OEFycmF5KGZpZWxkcy5tb2R1bGUpXTtcbiAgICAgICAgY29uc3QgY2FuaXN0ZXJJZCA9IHR5cGVvZiBjb25maWcuY2FuaXN0ZXJJZCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gUHJpbmNpcGFsLmZyb21UZXh0KGNvbmZpZy5jYW5pc3RlcklkKVxuICAgICAgICAgICAgOiBjb25maWcuY2FuaXN0ZXJJZDtcbiAgICAgICAgYXdhaXQgZ2V0TWFuYWdlbWVudENhbmlzdGVyKGNvbmZpZykuaW5zdGFsbF9jb2RlKHtcbiAgICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgICBhcmcsXG4gICAgICAgICAgICB3YXNtX21vZHVsZTogd2FzbU1vZHVsZSxcbiAgICAgICAgICAgIGNhbmlzdGVyX2lkOiBjYW5pc3RlcklkLFxuICAgICAgICAgICAgc2VuZGVyX2NhbmlzdGVyX3ZlcnNpb246IFtdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGNyZWF0ZUNhbmlzdGVyKGNvbmZpZywgc2V0dGluZ3MpIHtcbiAgICAgICAgZnVuY3Rpb24gc2V0dGluZ3NUb0NhbmlzdGVyU2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyczogc2V0dGluZ3MuY29udHJvbGxlcnMgPyBbc2V0dGluZ3MuY29udHJvbGxlcnNdIDogW10sXG4gICAgICAgICAgICAgICAgICAgIGNvbXB1dGVfYWxsb2NhdGlvbjogc2V0dGluZ3MuY29tcHV0ZV9hbGxvY2F0aW9uID8gW3NldHRpbmdzLmNvbXB1dGVfYWxsb2NhdGlvbl0gOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgZnJlZXppbmdfdGhyZXNob2xkOiBzZXR0aW5ncy5mcmVlemluZ190aHJlc2hvbGQgPyBbc2V0dGluZ3MuZnJlZXppbmdfdGhyZXNob2xkXSA6IFtdLFxuICAgICAgICAgICAgICAgICAgICBtZW1vcnlfYWxsb2NhdGlvbjogc2V0dGluZ3MubWVtb3J5X2FsbG9jYXRpb24gPyBbc2V0dGluZ3MubWVtb3J5X2FsbG9jYXRpb25dIDogW10sXG4gICAgICAgICAgICAgICAgICAgIHJlc2VydmVkX2N5Y2xlc19saW1pdDogW10sXG4gICAgICAgICAgICAgICAgICAgIGxvZ192aXNpYmlsaXR5OiBbXSxcbiAgICAgICAgICAgICAgICAgICAgd2FzbV9tZW1vcnlfbGltaXQ6IFtdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgY2FuaXN0ZXJfaWQ6IGNhbmlzdGVySWQgfSA9IGF3YWl0IGdldE1hbmFnZW1lbnRDYW5pc3Rlcihjb25maWcgfHwge30pLnByb3Zpc2lvbmFsX2NyZWF0ZV9jYW5pc3Rlcl93aXRoX2N5Y2xlcyh7XG4gICAgICAgICAgICBhbW91bnQ6IFtdLFxuICAgICAgICAgICAgc2V0dGluZ3M6IHNldHRpbmdzVG9DYW5pc3RlclNldHRpbmdzKHNldHRpbmdzIHx8IHt9KSxcbiAgICAgICAgICAgIHNwZWNpZmllZF9pZDogW10sXG4gICAgICAgICAgICBzZW5kZXJfY2FuaXN0ZXJfdmVyc2lvbjogW10sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2FuaXN0ZXJJZDtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGNyZWF0ZUFuZEluc3RhbGxDYW5pc3RlcihpbnRlcmZhY2VGYWN0b3J5LCBmaWVsZHMsIGNvbmZpZykge1xuICAgICAgICBjb25zdCBjYW5pc3RlcklkID0gYXdhaXQgdGhpcy5jcmVhdGVDYW5pc3Rlcihjb25maWcpO1xuICAgICAgICBhd2FpdCB0aGlzLmluc3RhbGwoT2JqZWN0LmFzc2lnbih7fSwgZmllbGRzKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb25maWcpLCB7IGNhbmlzdGVySWQgfSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVBY3RvcihpbnRlcmZhY2VGYWN0b3J5LCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZyksIHsgY2FuaXN0ZXJJZCB9KSk7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVBY3RvckNsYXNzKGludGVyZmFjZUZhY3RvcnksIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc2VydmljZSA9IGludGVyZmFjZUZhY3RvcnkoeyBJREwgfSk7XG4gICAgICAgIGNsYXNzIENhbmlzdGVyQWN0b3IgZXh0ZW5kcyBBY3RvciB7XG4gICAgICAgICAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbmZpZy5jYW5pc3RlcklkKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQWdlbnRFcnJvcihgQ2FuaXN0ZXIgSUQgaXMgcmVxdWlyZWQsIGJ1dCByZWNlaXZlZCAke3R5cGVvZiBjb25maWcuY2FuaXN0ZXJJZH0gaW5zdGVhZC4gSWYgeW91IGFyZSB1c2luZyBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBkZWNsYXJhdGlvbnMsIHRoaXMgbWF5IGJlIGJlY2F1c2UgeW91ciBhcHBsaWNhdGlvbiBpcyBub3Qgc2V0dGluZyB0aGUgY2FuaXN0ZXIgSUQgaW4gcHJvY2Vzcy5lbnYgY29ycmVjdGx5LmApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbmlzdGVySWQgPSB0eXBlb2YgY29uZmlnLmNhbmlzdGVySWQgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgID8gUHJpbmNpcGFsLmZyb21UZXh0KGNvbmZpZy5jYW5pc3RlcklkKVxuICAgICAgICAgICAgICAgICAgICA6IGNvbmZpZy5jYW5pc3RlcklkO1xuICAgICAgICAgICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9BQ1RPUl9DT05GSUcpLCBjb25maWcpLCB7IGNhbmlzdGVySWQgfSksXG4gICAgICAgICAgICAgICAgICAgIHNlcnZpY2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbbWV0aG9kTmFtZSwgZnVuY10gb2Ygc2VydmljZS5fZmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaHR0cERldGFpbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmMuYW5ub3RhdGlvbnMucHVzaChBQ1RPUl9NRVRIT0RfV0lUSF9IVFRQX0RFVEFJTFMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2VydGlmaWNhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmMuYW5ub3RhdGlvbnMucHVzaChBQ1RPUl9NRVRIT0RfV0lUSF9DRVJUSUZJQ0FURSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXSA9IF9jcmVhdGVBY3Rvck1ldGhvZCh0aGlzLCBtZXRob2ROYW1lLCBmdW5jLCBjb25maWcuYmxzVmVyaWZ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENhbmlzdGVyQWN0b3I7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVBY3RvcihpbnRlcmZhY2VGYWN0b3J5LCBjb25maWd1cmF0aW9uKSB7XG4gICAgICAgIGlmICghY29uZmlndXJhdGlvbi5jYW5pc3RlcklkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQWdlbnRFcnJvcihgQ2FuaXN0ZXIgSUQgaXMgcmVxdWlyZWQsIGJ1dCByZWNlaXZlZCAke3R5cGVvZiBjb25maWd1cmF0aW9uLmNhbmlzdGVySWR9IGluc3RlYWQuIElmIHlvdSBhcmUgdXNpbmcgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgZGVjbGFyYXRpb25zLCB0aGlzIG1heSBiZSBiZWNhdXNlIHlvdXIgYXBwbGljYXRpb24gaXMgbm90IHNldHRpbmcgdGhlIGNhbmlzdGVyIElEIGluIHByb2Nlc3MuZW52IGNvcnJlY3RseS5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3ICh0aGlzLmNyZWF0ZUFjdG9yQ2xhc3MoaW50ZXJmYWNlRmFjdG9yeSkpKGNvbmZpZ3VyYXRpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFjdG9yIHdpdGggbWV0aG9kcyB0aGF0IHJldHVybiB0aGUgaHR0cCByZXNwb25zZSBkZXRhaWxzIGFsb25nIHdpdGggdGhlIHJlc3VsdFxuICAgICAqIEBwYXJhbSBpbnRlcmZhY2VGYWN0b3J5IC0gdGhlIGludGVyZmFjZSBmYWN0b3J5IGZvciB0aGUgYWN0b3JcbiAgICAgKiBAcGFyYW0gY29uZmlndXJhdGlvbiAtIHRoZSBjb25maWd1cmF0aW9uIGZvciB0aGUgYWN0b3JcbiAgICAgKiBAZGVwcmVjYXRlZCAtIHVzZSBjcmVhdGVBY3RvciB3aXRoIGFjdG9yQ2xhc3NPcHRpb25zIGluc3RlYWRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlQWN0b3JXaXRoSHR0cERldGFpbHMoaW50ZXJmYWNlRmFjdG9yeSwgY29uZmlndXJhdGlvbikge1xuICAgICAgICByZXR1cm4gbmV3ICh0aGlzLmNyZWF0ZUFjdG9yQ2xhc3MoaW50ZXJmYWNlRmFjdG9yeSwgeyBodHRwRGV0YWlsczogdHJ1ZSB9KSkoY29uZmlndXJhdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYWN0b3Igd2l0aCBtZXRob2RzIHRoYXQgcmV0dXJuIHRoZSBodHRwIHJlc3BvbnNlIGRldGFpbHMgYWxvbmcgd2l0aCB0aGUgcmVzdWx0XG4gICAgICogQHBhcmFtIGludGVyZmFjZUZhY3RvcnkgLSB0aGUgaW50ZXJmYWNlIGZhY3RvcnkgZm9yIHRoZSBhY3RvclxuICAgICAqIEBwYXJhbSBjb25maWd1cmF0aW9uIC0gdGhlIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBhY3RvclxuICAgICAqIEBwYXJhbSBhY3RvckNsYXNzT3B0aW9ucyAtIG9wdGlvbnMgZm9yIHRoZSBhY3RvciBjbGFzcyBleHRlbmRlZCBkZXRhaWxzIHRvIHJldHVybiB3aXRoIHRoZSByZXN1bHRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlQWN0b3JXaXRoRXh0ZW5kZWREZXRhaWxzKGludGVyZmFjZUZhY3RvcnksIGNvbmZpZ3VyYXRpb24sIGFjdG9yQ2xhc3NPcHRpb25zID0ge1xuICAgICAgICBodHRwRGV0YWlsczogdHJ1ZSxcbiAgICAgICAgY2VydGlmaWNhdGU6IHRydWUsXG4gICAgfSkge1xuICAgICAgICByZXR1cm4gbmV3ICh0aGlzLmNyZWF0ZUFjdG9yQ2xhc3MoaW50ZXJmYWNlRmFjdG9yeSwgYWN0b3JDbGFzc09wdGlvbnMpKShjb25maWd1cmF0aW9uKTtcbiAgICB9XG59XG4vLyBJREwgZnVuY3Rpb25zIGNhbiBoYXZlIG11bHRpcGxlIHJldHVybiB2YWx1ZXMsIHNvIGRlY29kaW5nIGFsd2F5c1xuLy8gcHJvZHVjZXMgYW4gYXJyYXkuIEVuc3VyZSB0aGF0IGZ1bmN0aW9ucyB3aXRoIHNpbmdsZSBvciB6ZXJvIHJldHVyblxuLy8gdmFsdWVzIGJlaGF2ZSBhcyBleHBlY3RlZC5cbmZ1bmN0aW9uIGRlY29kZVJldHVyblZhbHVlKHR5cGVzLCBtc2cpIHtcbiAgICBjb25zdCByZXR1cm5WYWx1ZXMgPSBJREwuZGVjb2RlKHR5cGVzLCBCdWZmZXIuZnJvbShtc2cpKTtcbiAgICBzd2l0Y2ggKHJldHVyblZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlc1swXTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG4gICAgfVxufVxuY29uc3QgREVGQVVMVF9BQ1RPUl9DT05GSUcgPSB7XG4gICAgcG9sbGluZ1N0cmF0ZWd5RmFjdG9yeTogc3RyYXRlZ3kuZGVmYXVsdFN0cmF0ZWd5LFxufTtcbmV4cG9ydCBjb25zdCBBQ1RPUl9NRVRIT0RfV0lUSF9IVFRQX0RFVEFJTFMgPSAnaHR0cC1kZXRhaWxzJztcbmV4cG9ydCBjb25zdCBBQ1RPUl9NRVRIT0RfV0lUSF9DRVJUSUZJQ0FURSA9ICdjZXJ0aWZpY2F0ZSc7XG5mdW5jdGlvbiBfY3JlYXRlQWN0b3JNZXRob2QoYWN0b3IsIG1ldGhvZE5hbWUsIGZ1bmMsIGJsc1ZlcmlmeSkge1xuICAgIGxldCBjYWxsZXI7XG4gICAgaWYgKGZ1bmMuYW5ub3RhdGlvbnMuaW5jbHVkZXMoJ3F1ZXJ5JykgfHwgZnVuYy5hbm5vdGF0aW9ucy5pbmNsdWRlcygnY29tcG9zaXRlX3F1ZXJ5JykpIHtcbiAgICAgICAgY2FsbGVyID0gYXN5bmMgKG9wdGlvbnMsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAvLyBGaXJzdCwgaWYgdGhlcmUncyBhIGNvbmZpZyB0cmFuc2Zvcm1hdGlvbiwgY2FsbCBpdC5cbiAgICAgICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCAoX2IgPSAoX2EgPSBhY3RvclttZXRhZGF0YVN5bWJvbF0uY29uZmlnKS5xdWVyeVRyYW5zZm9ybSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIG1ldGhvZE5hbWUsIGFyZ3MsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYWN0b3JbbWV0YWRhdGFTeW1ib2xdLmNvbmZpZyksIG9wdGlvbnMpKSk7XG4gICAgICAgICAgICBjb25zdCBhZ2VudCA9IG9wdGlvbnMuYWdlbnQgfHwgYWN0b3JbbWV0YWRhdGFTeW1ib2xdLmNvbmZpZy5hZ2VudCB8fCBnZXREZWZhdWx0QWdlbnQoKTtcbiAgICAgICAgICAgIGNvbnN0IGNpZCA9IFByaW5jaXBhbC5mcm9tKG9wdGlvbnMuY2FuaXN0ZXJJZCB8fCBhY3RvclttZXRhZGF0YVN5bWJvbF0uY29uZmlnLmNhbmlzdGVySWQpO1xuICAgICAgICAgICAgY29uc3QgYXJnID0gSURMLmVuY29kZShmdW5jLmFyZ1R5cGVzLCBhcmdzKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFnZW50LnF1ZXJ5KGNpZCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZE5hbWUsXG4gICAgICAgICAgICAgICAgYXJnLFxuICAgICAgICAgICAgICAgIGVmZmVjdGl2ZUNhbmlzdGVySWQ6IG9wdGlvbnMuZWZmZWN0aXZlQ2FuaXN0ZXJJZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgaHR0cERldGFpbHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3VsdC5odHRwRGV0YWlscyksIHsgcmVxdWVzdERldGFpbHM6IHJlc3VsdC5yZXF1ZXN0RGV0YWlscyB9KTtcbiAgICAgICAgICAgIHN3aXRjaCAocmVzdWx0LnN0YXR1cykge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJyZWplY3RlZFwiIC8qIFF1ZXJ5UmVzcG9uc2VTdGF0dXMuUmVqZWN0ZWQgKi86XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBRdWVyeUNhbGxSZWplY3RlZEVycm9yKGNpZCwgbWV0aG9kTmFtZSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVwbGllZFwiIC8qIFF1ZXJ5UmVzcG9uc2VTdGF0dXMuUmVwbGllZCAqLzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYW5ub3RhdGlvbnMuaW5jbHVkZXMoQUNUT1JfTUVUSE9EX1dJVEhfSFRUUF9ERVRBSUxTKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHR0cERldGFpbHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBkZWNvZGVSZXR1cm5WYWx1ZShmdW5jLnJldFR5cGVzLCByZXN1bHQucmVwbHkuYXJnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogZGVjb2RlUmV0dXJuVmFsdWUoZnVuYy5yZXRUeXBlcywgcmVzdWx0LnJlcGx5LmFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjYWxsZXIgPSBhc3luYyAob3B0aW9ucywgLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIC8vIEZpcnN0LCBpZiB0aGVyZSdzIGEgY29uZmlnIHRyYW5zZm9ybWF0aW9uLCBjYWxsIGl0LlxuICAgICAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIChfYiA9IChfYSA9IGFjdG9yW21ldGFkYXRhU3ltYm9sXS5jb25maWcpLmNhbGxUcmFuc2Zvcm0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBtZXRob2ROYW1lLCBhcmdzLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFjdG9yW21ldGFkYXRhU3ltYm9sXS5jb25maWcpLCBvcHRpb25zKSkpO1xuICAgICAgICAgICAgY29uc3QgYWdlbnQgPSBvcHRpb25zLmFnZW50IHx8IGFjdG9yW21ldGFkYXRhU3ltYm9sXS5jb25maWcuYWdlbnQgfHwgZ2V0RGVmYXVsdEFnZW50KCk7XG4gICAgICAgICAgICBjb25zdCB7IGNhbmlzdGVySWQsIGVmZmVjdGl2ZUNhbmlzdGVySWQsIHBvbGxpbmdTdHJhdGVneUZhY3RvcnkgfSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX0FDVE9SX0NPTkZJRyksIGFjdG9yW21ldGFkYXRhU3ltYm9sXS5jb25maWcpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGNpZCA9IFByaW5jaXBhbC5mcm9tKGNhbmlzdGVySWQpO1xuICAgICAgICAgICAgY29uc3QgZWNpZCA9IGVmZmVjdGl2ZUNhbmlzdGVySWQgIT09IHVuZGVmaW5lZCA/IFByaW5jaXBhbC5mcm9tKGVmZmVjdGl2ZUNhbmlzdGVySWQpIDogY2lkO1xuICAgICAgICAgICAgY29uc3QgYXJnID0gSURMLmVuY29kZShmdW5jLmFyZ1R5cGVzLCBhcmdzKTtcbiAgICAgICAgICAgIGlmIChhZ2VudC5yb290S2V5ID09IG51bGwpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFnZW50RXJyb3IoJ0FnZW50IHJvb3Qga2V5IG5vdCBpbml0aWFsaXplZCBiZWZvcmUgbWFraW5nIGNhbGwnKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVxdWVzdElkLCByZXNwb25zZSwgcmVxdWVzdERldGFpbHMgfSA9IGF3YWl0IGFnZW50LmNhbGwoY2lkLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kTmFtZSxcbiAgICAgICAgICAgICAgICBhcmcsXG4gICAgICAgICAgICAgICAgZWZmZWN0aXZlQ2FuaXN0ZXJJZDogZWNpZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IHJlcGx5O1xuICAgICAgICAgICAgbGV0IGNlcnRpZmljYXRlO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmJvZHkgJiYgcmVzcG9uc2UuYm9keS5jZXJ0aWZpY2F0ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlcnQgPSByZXNwb25zZS5ib2R5LmNlcnRpZmljYXRlO1xuICAgICAgICAgICAgICAgIGNlcnRpZmljYXRlID0gYXdhaXQgQ2VydGlmaWNhdGUuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgY2VydGlmaWNhdGU6IGJ1ZkZyb21CdWZMaWtlKGNlcnQpLFxuICAgICAgICAgICAgICAgICAgICByb290S2V5OiBhZ2VudC5yb290S2V5LFxuICAgICAgICAgICAgICAgICAgICBjYW5pc3RlcklkOiBQcmluY2lwYWwuZnJvbShjYW5pc3RlcklkKSxcbiAgICAgICAgICAgICAgICAgICAgYmxzVmVyaWZ5LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSBbbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKCdyZXF1ZXN0X3N0YXR1cycpLCByZXF1ZXN0SWRdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShsb29rdXBSZXN1bHRUb0J1ZmZlcihjZXJ0aWZpY2F0ZS5sb29rdXAoWy4uLnBhdGgsICdzdGF0dXMnXSkpKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdyZXBsaWVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGx5ID0gbG9va3VwUmVzdWx0VG9CdWZmZXIoY2VydGlmaWNhdGUubG9va3VwKFsuLi5wYXRoLCAncmVwbHknXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JlamVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVcGRhdGVDYWxsUmVqZWN0ZWRFcnJvcihjaWQsIG1ldGhvZE5hbWUsIHJlcXVlc3RJZCwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZhbGwgYmFjayB0byBwb2xsaW5nIGlmIHdlIHJlY2lldmUgYW4gQWNjZXB0ZWQgcmVzcG9uc2UgY29kZVxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9sbFN0cmF0ZWd5ID0gcG9sbGluZ1N0cmF0ZWd5RmFjdG9yeSgpO1xuICAgICAgICAgICAgICAgIC8vIENvbnRhaW5zIHRoZSBjZXJ0aWZpY2F0ZSBhbmQgdGhlIHJlcGx5IGZyb20gdGhlIGJvdW5kYXJ5IG5vZGVcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHBvbGxGb3JSZXNwb25zZShhZ2VudCwgZWNpZCwgcmVxdWVzdElkLCBwb2xsU3RyYXRlZ3ksIGJsc1ZlcmlmeSk7XG4gICAgICAgICAgICAgICAgY2VydGlmaWNhdGUgPSByZXNwb25zZS5jZXJ0aWZpY2F0ZTtcbiAgICAgICAgICAgICAgICByZXBseSA9IHJlc3BvbnNlLnJlcGx5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2hvdWxkSW5jbHVkZUh0dHBEZXRhaWxzID0gZnVuYy5hbm5vdGF0aW9ucy5pbmNsdWRlcyhBQ1RPUl9NRVRIT0RfV0lUSF9IVFRQX0RFVEFJTFMpO1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkSW5jbHVkZUNlcnRpZmljYXRlID0gZnVuYy5hbm5vdGF0aW9ucy5pbmNsdWRlcyhBQ1RPUl9NRVRIT0RfV0lUSF9DRVJUSUZJQ0FURSk7XG4gICAgICAgICAgICBjb25zdCBodHRwRGV0YWlscyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVzcG9uc2UpLCB7IHJlcXVlc3REZXRhaWxzIH0pO1xuICAgICAgICAgICAgaWYgKHJlcGx5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkSW5jbHVkZUh0dHBEZXRhaWxzICYmIHNob3VsZEluY2x1ZGVDZXJ0aWZpY2F0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHR0cERldGFpbHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjZXJ0aWZpY2F0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogZGVjb2RlUmV0dXJuVmFsdWUoZnVuYy5yZXRUeXBlcywgcmVwbHkpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaG91bGRJbmNsdWRlQ2VydGlmaWNhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlcnRpZmljYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBkZWNvZGVSZXR1cm5WYWx1ZShmdW5jLnJldFR5cGVzLCByZXBseSksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNob3VsZEluY2x1ZGVIdHRwRGV0YWlscykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHR0cERldGFpbHMsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IGRlY29kZVJldHVyblZhbHVlKGZ1bmMucmV0VHlwZXMsIHJlcGx5KSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZVJldHVyblZhbHVlKGZ1bmMucmV0VHlwZXMsIHJlcGx5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZ1bmMucmV0VHlwZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNob3VsZEluY2x1ZGVIdHRwRGV0YWlsc1xuICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0dHBEZXRhaWxzOiByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYWxsIHdhcyByZXR1cm5lZCB1bmRlZmluZWQsIGJ1dCB0eXBlIFske2Z1bmMucmV0VHlwZXMuam9pbignLCcpfV0uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZXIgPSAoLi4uYXJncykgPT4gY2FsbGVyKHt9LCAuLi5hcmdzKTtcbiAgICBoYW5kbGVyLndpdGhPcHRpb25zID1cbiAgICAgICAgKG9wdGlvbnMpID0+ICguLi5hcmdzKSA9PiBjYWxsZXIob3B0aW9ucywgLi4uYXJncyk7XG4gICAgcmV0dXJuIGhhbmRsZXI7XG59XG4vKipcbiAqIENyZWF0ZSBhIG1hbmFnZW1lbnQgY2FuaXN0ZXIgYWN0b3JcbiAqIEBwYXJhbSBjb25maWcgLSBhIENhbGxDb25maWdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1hbmFnZW1lbnRDYW5pc3Rlcihjb25maWcpIHtcbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm0oX21ldGhvZE5hbWUsIGFyZ3MpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5lZmZlY3RpdmVDYW5pc3RlcklkKSB7XG4gICAgICAgICAgICByZXR1cm4geyBlZmZlY3RpdmVDYW5pc3RlcklkOiBQcmluY2lwYWwuZnJvbShjb25maWcuZWZmZWN0aXZlQ2FuaXN0ZXJJZCkgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaXJzdCA9IGFyZ3NbMF07XG4gICAgICAgIGxldCBlZmZlY3RpdmVDYW5pc3RlcklkID0gUHJpbmNpcGFsLmZyb21IZXgoJycpO1xuICAgICAgICBpZiAoZmlyc3QgJiYgdHlwZW9mIGZpcnN0ID09PSAnb2JqZWN0JyAmJiBmaXJzdC5jYW5pc3Rlcl9pZCkge1xuICAgICAgICAgICAgZWZmZWN0aXZlQ2FuaXN0ZXJJZCA9IFByaW5jaXBhbC5mcm9tKGZpcnN0LmNhbmlzdGVyX2lkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBlZmZlY3RpdmVDYW5pc3RlcklkIH07XG4gICAgfVxuICAgIHJldHVybiBBY3Rvci5jcmVhdGVBY3RvcihtYW5hZ2VtZW50Q2FuaXN0ZXJJZGwsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb25maWcpLCB7IGNhbmlzdGVySWQ6IFByaW5jaXBhbC5mcm9tSGV4KCcnKSB9KSwge1xuICAgICAgICBjYWxsVHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgICAgIHF1ZXJ5VHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgfSkpO1xufVxuZXhwb3J0IGNsYXNzIEFkdmFuY2VkQWN0b3IgZXh0ZW5kcyBBY3RvciB7XG4gICAgY29uc3RydWN0b3IobWV0YWRhdGEpIHtcbiAgICAgICAgc3VwZXIobWV0YWRhdGEpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjdG9yLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/actor.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/agent/api.js":
/*!**********************************************************!*\
  !*** ./node_modules/@dfinity/agent/lib/esm/agent/api.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ReplicaRejectCode: function() { return /* binding */ ReplicaRejectCode; }\n/* harmony export */ });\n/**\n * Codes used by the replica for rejecting a message.\n * See {@link https://sdk.dfinity.org/docs/interface-spec/#reject-codes | the interface spec}.\n */\nvar ReplicaRejectCode;\n(function (ReplicaRejectCode) {\n    ReplicaRejectCode[ReplicaRejectCode[\"SysFatal\"] = 1] = \"SysFatal\";\n    ReplicaRejectCode[ReplicaRejectCode[\"SysTransient\"] = 2] = \"SysTransient\";\n    ReplicaRejectCode[ReplicaRejectCode[\"DestinationInvalid\"] = 3] = \"DestinationInvalid\";\n    ReplicaRejectCode[ReplicaRejectCode[\"CanisterReject\"] = 4] = \"CanisterReject\";\n    ReplicaRejectCode[ReplicaRejectCode[\"CanisterError\"] = 5] = \"CanisterError\";\n})(ReplicaRejectCode || (ReplicaRejectCode = {}));\n//# sourceMappingURL=api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2FnZW50L2FwaS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBLFFBQVEscUZBQXFGO0FBQzdGO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhDQUE4QztBQUMvQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGRmaW5pdHkvYWdlbnQvbGliL2VzbS9hZ2VudC9hcGkuanM/NTg4NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvZGVzIHVzZWQgYnkgdGhlIHJlcGxpY2EgZm9yIHJlamVjdGluZyBhIG1lc3NhZ2UuXG4gKiBTZWUge0BsaW5rIGh0dHBzOi8vc2RrLmRmaW5pdHkub3JnL2RvY3MvaW50ZXJmYWNlLXNwZWMvI3JlamVjdC1jb2RlcyB8IHRoZSBpbnRlcmZhY2Ugc3BlY30uXG4gKi9cbmV4cG9ydCB2YXIgUmVwbGljYVJlamVjdENvZGU7XG4oZnVuY3Rpb24gKFJlcGxpY2FSZWplY3RDb2RlKSB7XG4gICAgUmVwbGljYVJlamVjdENvZGVbUmVwbGljYVJlamVjdENvZGVbXCJTeXNGYXRhbFwiXSA9IDFdID0gXCJTeXNGYXRhbFwiO1xuICAgIFJlcGxpY2FSZWplY3RDb2RlW1JlcGxpY2FSZWplY3RDb2RlW1wiU3lzVHJhbnNpZW50XCJdID0gMl0gPSBcIlN5c1RyYW5zaWVudFwiO1xuICAgIFJlcGxpY2FSZWplY3RDb2RlW1JlcGxpY2FSZWplY3RDb2RlW1wiRGVzdGluYXRpb25JbnZhbGlkXCJdID0gM10gPSBcIkRlc3RpbmF0aW9uSW52YWxpZFwiO1xuICAgIFJlcGxpY2FSZWplY3RDb2RlW1JlcGxpY2FSZWplY3RDb2RlW1wiQ2FuaXN0ZXJSZWplY3RcIl0gPSA0XSA9IFwiQ2FuaXN0ZXJSZWplY3RcIjtcbiAgICBSZXBsaWNhUmVqZWN0Q29kZVtSZXBsaWNhUmVqZWN0Q29kZVtcIkNhbmlzdGVyRXJyb3JcIl0gPSA1XSA9IFwiQ2FuaXN0ZXJFcnJvclwiO1xufSkoUmVwbGljYVJlamVjdENvZGUgfHwgKFJlcGxpY2FSZWplY3RDb2RlID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwaS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/agent/api.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/agent/http/errors.js":
/*!******************************************************************!*\
  !*** ./node_modules/@dfinity/agent/lib/esm/agent/http/errors.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AgentHTTPResponseError: function() { return /* binding */ AgentHTTPResponseError; }\n/* harmony export */ });\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../errors */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/errors.js\");\n\nclass AgentHTTPResponseError extends _errors__WEBPACK_IMPORTED_MODULE_0__.AgentError {\n    constructor(message, response) {\n        super(message);\n        this.response = response;\n        this.name = this.constructor.name;\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2FnZW50L2h0dHAvZXJyb3JzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTBDO0FBQ25DLHFDQUFxQywrQ0FBVTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2FnZW50L2h0dHAvZXJyb3JzLmpzPzcxMGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWdlbnRFcnJvciB9IGZyb20gJy4uLy4uL2Vycm9ycyc7XG5leHBvcnQgY2xhc3MgQWdlbnRIVFRQUmVzcG9uc2VFcnJvciBleHRlbmRzIEFnZW50RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHJlc3BvbnNlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/agent/http/errors.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/agent/http/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@dfinity/agent/lib/esm/agent/http/index.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Expiry: function() { return /* reexport safe */ _transforms__WEBPACK_IMPORTED_MODULE_6__.Expiry; },\n/* harmony export */   HttpAgent: function() { return /* binding */ HttpAgent; },\n/* harmony export */   IC_ROOT_KEY: function() { return /* binding */ IC_ROOT_KEY; },\n/* harmony export */   IdentityInvalidError: function() { return /* binding */ IdentityInvalidError; },\n/* harmony export */   MANAGEMENT_CANISTER_ID: function() { return /* binding */ MANAGEMENT_CANISTER_ID; },\n/* harmony export */   RequestStatusResponseStatus: function() { return /* binding */ RequestStatusResponseStatus; },\n/* harmony export */   httpHeadersTransform: function() { return /* reexport safe */ _transforms__WEBPACK_IMPORTED_MODULE_6__.httpHeadersTransform; },\n/* harmony export */   makeExpiryTransform: function() { return /* reexport safe */ _transforms__WEBPACK_IMPORTED_MODULE_6__.makeExpiryTransform; },\n/* harmony export */   makeNonce: function() { return /* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_7__.makeNonce; },\n/* harmony export */   makeNonceTransform: function() { return /* reexport safe */ _transforms__WEBPACK_IMPORTED_MODULE_6__.makeNonceTransform; }\n/* harmony export */ });\n/* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/principal */ \"(app-pages-browser)/./node_modules/@dfinity/principal/lib/esm/index.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../errors */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/errors.js\");\n/* harmony import */ var _auth__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../auth */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/auth.js\");\n/* harmony import */ var _cbor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../cbor */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/cbor.js\");\n/* harmony import */ var _request_id__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../request_id */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/request_id.js\");\n/* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils/buffer */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/utils/buffer.js\");\n/* harmony import */ var _transforms__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./transforms */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/agent/http/transforms.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./types */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/agent/http/types.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./errors */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/agent/http/errors.js\");\n/* harmony import */ var _canisterStatus__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../canisterStatus */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/canisterStatus/index.js\");\n/* harmony import */ var _certificate__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../certificate */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/certificate.js\");\n/* harmony import */ var _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @noble/curves/ed25519 */ \"(app-pages-browser)/../../node_modules/@noble/curves/esm/ed25519.js\");\n/* harmony import */ var _utils_expirableMap__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../utils/expirableMap */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/utils/expirableMap.js\");\n/* harmony import */ var _public_key__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../public_key */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/public_key.js\");\n/* harmony import */ var _utils_leb__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../utils/leb */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/utils/leb.js\");\n/* harmony import */ var _observable__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../observable */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/observable.js\");\n/* harmony import */ var _polling_backoff__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../polling/backoff */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/polling/backoff.js\");\nvar __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _HttpAgent_instances, _HttpAgent_identity, _HttpAgent_fetch, _HttpAgent_fetchOptions, _HttpAgent_callOptions, _HttpAgent_timeDiffMsecs, _HttpAgent_credentials, _HttpAgent_rootKeyFetched, _HttpAgent_retryTimes, _HttpAgent_backoffStrategy, _HttpAgent_waterMark, _HttpAgent_queryPipeline, _HttpAgent_updatePipeline, _HttpAgent_subnetKeys, _HttpAgent_verifyQuerySignatures, _HttpAgent_requestAndRetryQuery, _HttpAgent_requestAndRetry, _HttpAgent_verifyQueryResponse;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar RequestStatusResponseStatus;\n(function (RequestStatusResponseStatus) {\n    RequestStatusResponseStatus[\"Received\"] = \"received\";\n    RequestStatusResponseStatus[\"Processing\"] = \"processing\";\n    RequestStatusResponseStatus[\"Replied\"] = \"replied\";\n    RequestStatusResponseStatus[\"Rejected\"] = \"rejected\";\n    RequestStatusResponseStatus[\"Unknown\"] = \"unknown\";\n    RequestStatusResponseStatus[\"Done\"] = \"done\";\n})(RequestStatusResponseStatus || (RequestStatusResponseStatus = {}));\n// Default delta for ingress expiry is 5 minutes.\nconst DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS = 5 * 60 * 1000;\n// Root public key for the IC, encoded as hex\nconst IC_ROOT_KEY = '308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100814' +\n    'c0e6ec71fab583b08bd81373c255c3c371b2e84863c98a4f1e08b74235d14fb5d9c0cd546d968' +\n    '5f913a0c0b2cc5341583bf4b4392e467db96d65b9bb4cb717112f8472e0d5a4d14505ffd7484' +\n    'b01291091c5f87b98883463f98091a0baaae';\nconst MANAGEMENT_CANISTER_ID = 'aaaaa-aa';\n// IC0 domain info\nconst IC0_DOMAIN = 'ic0.app';\nconst IC0_SUB_DOMAIN = '.ic0.app';\nconst ICP0_DOMAIN = 'icp0.io';\nconst ICP0_SUB_DOMAIN = '.icp0.io';\nconst ICP_API_DOMAIN = 'icp-api.io';\nconst ICP_API_SUB_DOMAIN = '.icp-api.io';\nclass HttpDefaultFetchError extends _errors__WEBPACK_IMPORTED_MODULE_1__.AgentError {\n    constructor(message) {\n        super(message);\n        this.message = message;\n    }\n}\nclass IdentityInvalidError extends _errors__WEBPACK_IMPORTED_MODULE_1__.AgentError {\n    constructor(message) {\n        super(message);\n        this.message = message;\n    }\n}\nfunction getDefaultFetch() {\n    let defaultFetch;\n    if (typeof window !== 'undefined') {\n        // Browser context\n        if (window.fetch) {\n            defaultFetch = window.fetch.bind(window);\n        }\n        else {\n            throw new HttpDefaultFetchError('Fetch implementation was not available. You appear to be in a browser context, but window.fetch was not present.');\n        }\n    }\n    else if (typeof __webpack_require__.g !== 'undefined') {\n        // Node context\n        if (__webpack_require__.g.fetch) {\n            defaultFetch = __webpack_require__.g.fetch.bind(__webpack_require__.g);\n        }\n        else {\n            throw new HttpDefaultFetchError('Fetch implementation was not available. You appear to be in a Node.js context, but global.fetch was not available.');\n        }\n    }\n    else if (typeof self !== 'undefined') {\n        if (self.fetch) {\n            defaultFetch = self.fetch.bind(self);\n        }\n    }\n    if (defaultFetch) {\n        return defaultFetch;\n    }\n    throw new HttpDefaultFetchError('Fetch implementation was not available. Please provide fetch to the HttpAgent constructor, or ensure it is available in the window or global context.');\n}\nfunction determineHost(configuredHost) {\n    let host;\n    if (configuredHost !== undefined) {\n        if (!configuredHost.match(/^[a-z]+:/) && typeof window !== 'undefined') {\n            host = new URL(window.location.protocol + '//' + configuredHost);\n        }\n        else {\n            host = new URL(configuredHost);\n        }\n    }\n    else {\n        // Mainnet, local, and remote environments will have the api route available\n        const knownHosts = ['ic0.app', 'icp0.io', '127.0.0.1', 'localhost'];\n        const remoteHosts = ['.github.dev', '.gitpod.io'];\n        const location = typeof window !== 'undefined' ? window.location : undefined;\n        const hostname = location === null || location === void 0 ? void 0 : location.hostname;\n        let knownHost;\n        if (hostname && typeof hostname === 'string') {\n            if (remoteHosts.some(host => hostname.endsWith(host))) {\n                knownHost = hostname;\n            }\n            else {\n                knownHost = knownHosts.find(host => hostname.endsWith(host));\n            }\n        }\n        if (location && knownHost) {\n            // If the user is on a boundary-node provided host, we can use the same host for the agent\n            host = new URL(`${location.protocol}//${knownHost}${location.port ? ':' + location.port : ''}`);\n        }\n        else {\n            host = new URL('https://icp-api.io');\n        }\n    }\n    return host.toString();\n}\n/**\n * A HTTP agent allows users to interact with a client of the internet computer\nusing the available methods. It exposes an API that closely follows the\npublic view of the internet computer, and is not intended to be exposed\ndirectly to the majority of users due to its low-level interface.\n * There is a pipeline to apply transformations to the request before sending\nit to the client. This is to decouple signature, nonce generation and\nother computations so that this class can stay as simple as possible while\nallowing extensions.\n */\nclass HttpAgent {\n    /**\n     * @param options - Options for the HttpAgent\n     * @deprecated Use `HttpAgent.create` or `HttpAgent.createSync` instead\n     */\n    constructor(options = {}) {\n        var _a;\n        _HttpAgent_instances.add(this);\n        _HttpAgent_identity.set(this, void 0);\n        _HttpAgent_fetch.set(this, void 0);\n        _HttpAgent_fetchOptions.set(this, void 0);\n        _HttpAgent_callOptions.set(this, void 0);\n        _HttpAgent_timeDiffMsecs.set(this, 0);\n        _HttpAgent_credentials.set(this, void 0);\n        _HttpAgent_rootKeyFetched.set(this, false);\n        _HttpAgent_retryTimes.set(this, void 0); // Retry requests N times before erroring by default\n        _HttpAgent_backoffStrategy.set(this, void 0);\n        // Public signature to help with type checking.\n        this._isAgent = true;\n        this.config = {};\n        // The UTC time in milliseconds when the latest request was made\n        _HttpAgent_waterMark.set(this, 0);\n        this.log = new _observable__WEBPACK_IMPORTED_MODULE_14__.ObservableLog();\n        _HttpAgent_queryPipeline.set(this, []);\n        _HttpAgent_updatePipeline.set(this, []);\n        _HttpAgent_subnetKeys.set(this, new _utils_expirableMap__WEBPACK_IMPORTED_MODULE_11__.ExpirableMap({\n            expirationTime: 5 * 60 * 1000, // 5 minutes\n        }));\n        _HttpAgent_verifyQuerySignatures.set(this, true);\n        /**\n         * See https://internetcomputer.org/docs/current/references/ic-interface-spec/#http-query for details on validation\n         * @param queryResponse - The response from the query\n         * @param subnetStatus - The subnet status, including all node keys\n         * @returns ApiQueryResponse\n         */\n        _HttpAgent_verifyQueryResponse.set(this, (queryResponse, subnetStatus) => {\n            if (__classPrivateFieldGet(this, _HttpAgent_verifyQuerySignatures, \"f\") === false) {\n                // This should not be called if the user has disabled verification\n                return queryResponse;\n            }\n            if (!subnetStatus) {\n                throw new _certificate__WEBPACK_IMPORTED_MODULE_10__.CertificateVerificationError('Invalid signature from replica signed query: no matching node key found.');\n            }\n            const { status, signatures = [], requestId } = queryResponse;\n            const domainSeparator = new TextEncoder().encode('\\x0Bic-response');\n            for (const sig of signatures) {\n                const { timestamp, identity } = sig;\n                const nodeId = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.fromUint8Array(identity).toText();\n                let hash;\n                // Hash is constructed differently depending on the status\n                if (status === 'replied') {\n                    const { reply } = queryResponse;\n                    hash = (0,_request_id__WEBPACK_IMPORTED_MODULE_4__.hashOfMap)({\n                        status: status,\n                        reply: reply,\n                        timestamp: BigInt(timestamp),\n                        request_id: requestId,\n                    });\n                }\n                else if (status === 'rejected') {\n                    const { reject_code, reject_message, error_code } = queryResponse;\n                    hash = (0,_request_id__WEBPACK_IMPORTED_MODULE_4__.hashOfMap)({\n                        status: status,\n                        reject_code: reject_code,\n                        reject_message: reject_message,\n                        error_code: error_code,\n                        timestamp: BigInt(timestamp),\n                        request_id: requestId,\n                    });\n                }\n                else {\n                    throw new Error(`Unknown status: ${status}`);\n                }\n                const separatorWithHash = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_5__.concat)(domainSeparator, new Uint8Array(hash));\n                // FIX: check for match without verifying N times\n                const pubKey = subnetStatus === null || subnetStatus === void 0 ? void 0 : subnetStatus.nodeKeys.get(nodeId);\n                if (!pubKey) {\n                    throw new _certificate__WEBPACK_IMPORTED_MODULE_10__.CertificateVerificationError('Invalid signature from replica signed query: no matching node key found.');\n                }\n                const rawKey = _public_key__WEBPACK_IMPORTED_MODULE_12__.Ed25519PublicKey.fromDer(pubKey).rawKey;\n                const valid = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_16__.ed25519.verify(sig.signature, new Uint8Array(separatorWithHash), new Uint8Array(rawKey));\n                if (valid)\n                    return queryResponse;\n                throw new _certificate__WEBPACK_IMPORTED_MODULE_10__.CertificateVerificationError(`Invalid signature from replica ${nodeId} signed query.`);\n            }\n            return queryResponse;\n        });\n        this.config = options;\n        __classPrivateFieldSet(this, _HttpAgent_fetch, options.fetch || getDefaultFetch() || fetch.bind(__webpack_require__.g), \"f\");\n        __classPrivateFieldSet(this, _HttpAgent_fetchOptions, options.fetchOptions, \"f\");\n        __classPrivateFieldSet(this, _HttpAgent_callOptions, options.callOptions, \"f\");\n        this.rootKey = options.rootKey ? options.rootKey : (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_5__.fromHex)(IC_ROOT_KEY);\n        const host = determineHost(options.host);\n        this.host = new URL(host);\n        if (options.verifyQuerySignatures !== undefined) {\n            __classPrivateFieldSet(this, _HttpAgent_verifyQuerySignatures, options.verifyQuerySignatures, \"f\");\n        }\n        // Default is 3\n        __classPrivateFieldSet(this, _HttpAgent_retryTimes, (_a = options.retryTimes) !== null && _a !== void 0 ? _a : 3, \"f\");\n        // Delay strategy for retries. Default is exponential backoff\n        const defaultBackoffFactory = () => new _polling_backoff__WEBPACK_IMPORTED_MODULE_15__.ExponentialBackoff({\n            maxIterations: __classPrivateFieldGet(this, _HttpAgent_retryTimes, \"f\"),\n        });\n        __classPrivateFieldSet(this, _HttpAgent_backoffStrategy, options.backoffStrategy || defaultBackoffFactory, \"f\");\n        // Rewrite to avoid redirects\n        if (this.host.hostname.endsWith(IC0_SUB_DOMAIN)) {\n            this.host.hostname = IC0_DOMAIN;\n        }\n        else if (this.host.hostname.endsWith(ICP0_SUB_DOMAIN)) {\n            this.host.hostname = ICP0_DOMAIN;\n        }\n        else if (this.host.hostname.endsWith(ICP_API_SUB_DOMAIN)) {\n            this.host.hostname = ICP_API_DOMAIN;\n        }\n        if (options.credentials) {\n            const { name, password } = options.credentials;\n            __classPrivateFieldSet(this, _HttpAgent_credentials, `${name}${password ? ':' + password : ''}`, \"f\");\n        }\n        __classPrivateFieldSet(this, _HttpAgent_identity, Promise.resolve(options.identity || new _auth__WEBPACK_IMPORTED_MODULE_2__.AnonymousIdentity()), \"f\");\n        // Add a nonce transform to ensure calls are unique\n        this.addTransform('update', (0,_transforms__WEBPACK_IMPORTED_MODULE_6__.makeNonceTransform)(_types__WEBPACK_IMPORTED_MODULE_7__.makeNonce));\n        if (options.useQueryNonces) {\n            this.addTransform('query', (0,_transforms__WEBPACK_IMPORTED_MODULE_6__.makeNonceTransform)(_types__WEBPACK_IMPORTED_MODULE_7__.makeNonce));\n        }\n        if (options.logToConsole) {\n            this.log.subscribe(log => {\n                if (log.level === 'error') {\n                    console.error(log.message);\n                }\n                else if (log.level === 'warn') {\n                    console.warn(log.message);\n                }\n                else {\n                    console.log(log.message);\n                }\n            });\n        }\n    }\n    get waterMark() {\n        return __classPrivateFieldGet(this, _HttpAgent_waterMark, \"f\");\n    }\n    static createSync(options = {}) {\n        return new this(Object.assign({}, options));\n    }\n    static async create(options = {\n        shouldFetchRootKey: false,\n    }) {\n        const agent = HttpAgent.createSync(options);\n        const initPromises = [agent.syncTime()];\n        if (agent.host.toString() !== 'https://icp-api.io' && options.shouldFetchRootKey) {\n            initPromises.push(agent.fetchRootKey());\n        }\n        await Promise.all(initPromises);\n        return agent;\n    }\n    static async from(agent) {\n        var _a;\n        try {\n            if ('config' in agent) {\n                return await HttpAgent.create(agent.config);\n            }\n            return await HttpAgent.create({\n                fetch: agent._fetch,\n                fetchOptions: agent._fetchOptions,\n                callOptions: agent._callOptions,\n                host: agent._host.toString(),\n                identity: (_a = agent._identity) !== null && _a !== void 0 ? _a : undefined,\n            });\n        }\n        catch (_b) {\n            throw new _errors__WEBPACK_IMPORTED_MODULE_1__.AgentError('Failed to create agent from provided agent');\n        }\n    }\n    isLocal() {\n        const hostname = this.host.hostname;\n        return hostname === '127.0.0.1' || hostname.endsWith('127.0.0.1');\n    }\n    addTransform(type, fn, priority = fn.priority || 0) {\n        if (type === 'update') {\n            // Keep the pipeline sorted at all time, by priority.\n            const i = __classPrivateFieldGet(this, _HttpAgent_updatePipeline, \"f\").findIndex(x => (x.priority || 0) < priority);\n            __classPrivateFieldGet(this, _HttpAgent_updatePipeline, \"f\").splice(i >= 0 ? i : __classPrivateFieldGet(this, _HttpAgent_updatePipeline, \"f\").length, 0, Object.assign(fn, { priority }));\n        }\n        else if (type === 'query') {\n            // Keep the pipeline sorted at all time, by priority.\n            const i = __classPrivateFieldGet(this, _HttpAgent_queryPipeline, \"f\").findIndex(x => (x.priority || 0) < priority);\n            __classPrivateFieldGet(this, _HttpAgent_queryPipeline, \"f\").splice(i >= 0 ? i : __classPrivateFieldGet(this, _HttpAgent_queryPipeline, \"f\").length, 0, Object.assign(fn, { priority }));\n        }\n    }\n    async getPrincipal() {\n        if (!__classPrivateFieldGet(this, _HttpAgent_identity, \"f\")) {\n            throw new IdentityInvalidError(\"This identity has expired due this application's security policy. Please refresh your authentication.\");\n        }\n        return (await __classPrivateFieldGet(this, _HttpAgent_identity, \"f\")).getPrincipal();\n    }\n    async call(canisterId, options, identity) {\n        var _a;\n        const callSync = (_a = options.callSync) !== null && _a !== void 0 ? _a : true;\n        const id = await (identity !== undefined ? await identity : await __classPrivateFieldGet(this, _HttpAgent_identity, \"f\"));\n        if (!id) {\n            throw new IdentityInvalidError(\"This identity has expired due this application's security policy. Please refresh your authentication.\");\n        }\n        const canister = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.from(canisterId);\n        const ecid = options.effectiveCanisterId\n            ? _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.from(options.effectiveCanisterId)\n            : canister;\n        const sender = id.getPrincipal() || _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.anonymous();\n        let ingress_expiry = new _transforms__WEBPACK_IMPORTED_MODULE_6__.Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS);\n        // If the value is off by more than 30 seconds, reconcile system time with the network\n        if (Math.abs(__classPrivateFieldGet(this, _HttpAgent_timeDiffMsecs, \"f\")) > 1000 * 30) {\n            ingress_expiry = new _transforms__WEBPACK_IMPORTED_MODULE_6__.Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS + __classPrivateFieldGet(this, _HttpAgent_timeDiffMsecs, \"f\"));\n        }\n        const submit = {\n            request_type: _types__WEBPACK_IMPORTED_MODULE_7__.SubmitRequestType.Call,\n            canister_id: canister,\n            method_name: options.methodName,\n            arg: options.arg,\n            sender,\n            ingress_expiry,\n        };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let transformedRequest = (await this._transform({\n            request: {\n                body: null,\n                method: 'POST',\n                headers: Object.assign({ 'Content-Type': 'application/cbor' }, (__classPrivateFieldGet(this, _HttpAgent_credentials, \"f\") ? { Authorization: 'Basic ' + btoa(__classPrivateFieldGet(this, _HttpAgent_credentials, \"f\")) } : {})),\n            },\n            endpoint: \"call\" /* Endpoint.Call */,\n            body: submit,\n        }));\n        const nonce = transformedRequest.body.nonce\n            ? toNonce(transformedRequest.body.nonce)\n            : undefined;\n        submit.nonce = nonce;\n        function toNonce(buf) {\n            return new Uint8Array(buf);\n        }\n        // Apply transform for identity.\n        transformedRequest = await id.transformRequest(transformedRequest);\n        const body = _cbor__WEBPACK_IMPORTED_MODULE_3__.encode(transformedRequest.body);\n        const backoff = __classPrivateFieldGet(this, _HttpAgent_backoffStrategy, \"f\").call(this);\n        try {\n            // Attempt v3 sync call\n            const requestSync = () => {\n                this.log.print(`fetching \"/api/v3/canister/${ecid.toText()}/call\" with request:`, transformedRequest);\n                return __classPrivateFieldGet(this, _HttpAgent_fetch, \"f\").call(this, '' + new URL(`/api/v3/canister/${ecid.toText()}/call`, this.host), Object.assign(Object.assign(Object.assign({}, __classPrivateFieldGet(this, _HttpAgent_callOptions, \"f\")), transformedRequest.request), { body }));\n            };\n            const requestAsync = () => {\n                this.log.print(`fetching \"/api/v2/canister/${ecid.toText()}/call\" with request:`, transformedRequest);\n                return __classPrivateFieldGet(this, _HttpAgent_fetch, \"f\").call(this, '' + new URL(`/api/v2/canister/${ecid.toText()}/call`, this.host), Object.assign(Object.assign(Object.assign({}, __classPrivateFieldGet(this, _HttpAgent_callOptions, \"f\")), transformedRequest.request), { body }));\n            };\n            const request = __classPrivateFieldGet(this, _HttpAgent_instances, \"m\", _HttpAgent_requestAndRetry).call(this, {\n                request: callSync ? requestSync : requestAsync,\n                backoff,\n                tries: 0,\n            });\n            const [response, requestId] = await Promise.all([request, (0,_request_id__WEBPACK_IMPORTED_MODULE_4__.requestIdOf)(submit)]);\n            const responseBuffer = await response.arrayBuffer();\n            const responseBody = (response.status === 200 && responseBuffer.byteLength > 0\n                ? _cbor__WEBPACK_IMPORTED_MODULE_3__.decode(responseBuffer)\n                : null);\n            // Update the watermark with the latest time from consensus\n            if (responseBody === null || responseBody === void 0 ? void 0 : responseBody.certificate) {\n                const time = await this.parseTimeFromResponse({ certificate: responseBody.certificate });\n                __classPrivateFieldSet(this, _HttpAgent_waterMark, time, \"f\");\n            }\n            return {\n                requestId,\n                response: {\n                    ok: response.ok,\n                    status: response.status,\n                    statusText: response.statusText,\n                    body: responseBody,\n                    headers: (0,_transforms__WEBPACK_IMPORTED_MODULE_6__.httpHeadersTransform)(response.headers),\n                },\n                requestDetails: submit,\n            };\n        }\n        catch (error) {\n            // If the error is due to the v3 api not being supported, fall back to v2\n            if (error.message.includes('v3 api not supported.')) {\n                this.log.warn('v3 api not supported. Fall back to v2');\n                return this.call(canisterId, Object.assign(Object.assign({}, options), { \n                    // disable v3 api\n                    callSync: false }), identity);\n            }\n            this.log.error('Error while making call:', error);\n            throw error;\n        }\n    }\n    async query(canisterId, fields, identity) {\n        const backoff = __classPrivateFieldGet(this, _HttpAgent_backoffStrategy, \"f\").call(this);\n        const ecid = fields.effectiveCanisterId\n            ? _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.from(fields.effectiveCanisterId)\n            : _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.from(canisterId);\n        this.log.print(`ecid ${ecid.toString()}`);\n        this.log.print(`canisterId ${canisterId.toString()}`);\n        const makeQuery = async () => {\n            const id = await (identity !== undefined ? await identity : await __classPrivateFieldGet(this, _HttpAgent_identity, \"f\"));\n            if (!id) {\n                throw new IdentityInvalidError(\"This identity has expired due this application's security policy. Please refresh your authentication.\");\n            }\n            const canister = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.from(canisterId);\n            const sender = (id === null || id === void 0 ? void 0 : id.getPrincipal()) || _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.anonymous();\n            const request = {\n                request_type: \"query\" /* ReadRequestType.Query */,\n                canister_id: canister,\n                method_name: fields.methodName,\n                arg: fields.arg,\n                sender,\n                ingress_expiry: new _transforms__WEBPACK_IMPORTED_MODULE_6__.Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS),\n            };\n            const requestId = await (0,_request_id__WEBPACK_IMPORTED_MODULE_4__.requestIdOf)(request);\n            // TODO: remove this any. This can be a Signed or UnSigned request.\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            let transformedRequest = await this._transform({\n                request: {\n                    method: 'POST',\n                    headers: Object.assign({ 'Content-Type': 'application/cbor' }, (__classPrivateFieldGet(this, _HttpAgent_credentials, \"f\") ? { Authorization: 'Basic ' + btoa(__classPrivateFieldGet(this, _HttpAgent_credentials, \"f\")) } : {})),\n                },\n                endpoint: \"read\" /* Endpoint.Query */,\n                body: request,\n            });\n            // Apply transform for identity.\n            transformedRequest = (await (id === null || id === void 0 ? void 0 : id.transformRequest(transformedRequest)));\n            const body = _cbor__WEBPACK_IMPORTED_MODULE_3__.encode(transformedRequest.body);\n            const args = {\n                canister: canister.toText(),\n                ecid,\n                transformedRequest,\n                body,\n                requestId,\n                backoff,\n                tries: 0,\n            };\n            return {\n                requestDetails: request,\n                query: await __classPrivateFieldGet(this, _HttpAgent_instances, \"m\", _HttpAgent_requestAndRetryQuery).call(this, args),\n            };\n        };\n        const getSubnetStatus = async () => {\n            if (!__classPrivateFieldGet(this, _HttpAgent_verifyQuerySignatures, \"f\")) {\n                return undefined;\n            }\n            const subnetStatus = __classPrivateFieldGet(this, _HttpAgent_subnetKeys, \"f\").get(ecid.toString());\n            if (subnetStatus) {\n                return subnetStatus;\n            }\n            await this.fetchSubnetKeys(ecid.toString());\n            return __classPrivateFieldGet(this, _HttpAgent_subnetKeys, \"f\").get(ecid.toString());\n        };\n        // Attempt to make the query i=retryTimes times\n        // Make query and fetch subnet keys in parallel\n        const [queryResult, subnetStatus] = await Promise.all([makeQuery(), getSubnetStatus()]);\n        const { requestDetails, query } = queryResult;\n        const queryWithDetails = Object.assign(Object.assign({}, query), { requestDetails });\n        this.log.print('Query response:', queryWithDetails);\n        // Skip verification if the user has disabled it\n        if (!__classPrivateFieldGet(this, _HttpAgent_verifyQuerySignatures, \"f\")) {\n            return queryWithDetails;\n        }\n        try {\n            return __classPrivateFieldGet(this, _HttpAgent_verifyQueryResponse, \"f\").call(this, queryWithDetails, subnetStatus);\n        }\n        catch (_a) {\n            // In case the node signatures have changed, refresh the subnet keys and try again\n            this.log.warn('Query response verification failed. Retrying with fresh subnet keys.');\n            __classPrivateFieldGet(this, _HttpAgent_subnetKeys, \"f\").delete(canisterId.toString());\n            await this.fetchSubnetKeys(ecid.toString());\n            const updatedSubnetStatus = __classPrivateFieldGet(this, _HttpAgent_subnetKeys, \"f\").get(canisterId.toString());\n            if (!updatedSubnetStatus) {\n                throw new _certificate__WEBPACK_IMPORTED_MODULE_10__.CertificateVerificationError('Invalid signature from replica signed query: no matching node key found.');\n            }\n            return __classPrivateFieldGet(this, _HttpAgent_verifyQueryResponse, \"f\").call(this, queryWithDetails, updatedSubnetStatus);\n        }\n    }\n    async createReadStateRequest(fields, identity) {\n        const id = await (identity !== undefined ? await identity : await __classPrivateFieldGet(this, _HttpAgent_identity, \"f\"));\n        if (!id) {\n            throw new IdentityInvalidError(\"This identity has expired due this application's security policy. Please refresh your authentication.\");\n        }\n        const sender = (id === null || id === void 0 ? void 0 : id.getPrincipal()) || _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.anonymous();\n        // TODO: remove this any. This can be a Signed or UnSigned request.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const transformedRequest = await this._transform({\n            request: {\n                method: 'POST',\n                headers: Object.assign({ 'Content-Type': 'application/cbor' }, (__classPrivateFieldGet(this, _HttpAgent_credentials, \"f\") ? { Authorization: 'Basic ' + btoa(__classPrivateFieldGet(this, _HttpAgent_credentials, \"f\")) } : {})),\n            },\n            endpoint: \"read_state\" /* Endpoint.ReadState */,\n            body: {\n                request_type: \"read_state\" /* ReadRequestType.ReadState */,\n                paths: fields.paths,\n                sender,\n                ingress_expiry: new _transforms__WEBPACK_IMPORTED_MODULE_6__.Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS),\n            },\n        });\n        // Apply transform for identity.\n        return id === null || id === void 0 ? void 0 : id.transformRequest(transformedRequest);\n    }\n    async readState(canisterId, fields, identity, \n    // eslint-disable-next-line\n    request) {\n        const canister = typeof canisterId === 'string' ? _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.fromText(canisterId) : canisterId;\n        const transformedRequest = request !== null && request !== void 0 ? request : (await this.createReadStateRequest(fields, identity));\n        const body = _cbor__WEBPACK_IMPORTED_MODULE_3__.encode(transformedRequest.body);\n        this.log.print(`fetching \"/api/v2/canister/${canister}/read_state\" with request:`, transformedRequest);\n        // TODO - https://dfinity.atlassian.net/browse/SDK-1092\n        const backoff = __classPrivateFieldGet(this, _HttpAgent_backoffStrategy, \"f\").call(this);\n        try {\n            const response = await __classPrivateFieldGet(this, _HttpAgent_instances, \"m\", _HttpAgent_requestAndRetry).call(this, {\n                request: () => __classPrivateFieldGet(this, _HttpAgent_fetch, \"f\").call(this, '' + new URL(`/api/v2/canister/${canister.toString()}/read_state`, this.host), Object.assign(Object.assign(Object.assign({}, __classPrivateFieldGet(this, _HttpAgent_fetchOptions, \"f\")), transformedRequest.request), { body })),\n                backoff,\n                tries: 0,\n            });\n            if (!response.ok) {\n                throw new Error(`Server returned an error:\\n` +\n                    `  Code: ${response.status} (${response.statusText})\\n` +\n                    `  Body: ${await response.text()}\\n`);\n            }\n            const decodedResponse = _cbor__WEBPACK_IMPORTED_MODULE_3__.decode(await response.arrayBuffer());\n            this.log.print('Read state response:', decodedResponse);\n            const parsedTime = await this.parseTimeFromResponse(decodedResponse);\n            if (parsedTime > 0) {\n                this.log.print('Read state response time:', parsedTime);\n                __classPrivateFieldSet(this, _HttpAgent_waterMark, parsedTime, \"f\");\n            }\n            return decodedResponse;\n        }\n        catch (error) {\n            this.log.error('Caught exception while attempting to read state', error);\n            throw error;\n        }\n    }\n    async parseTimeFromResponse(response) {\n        let tree;\n        if (response.certificate) {\n            const decoded = _cbor__WEBPACK_IMPORTED_MODULE_3__.decode(response.certificate);\n            if (decoded && 'tree' in decoded) {\n                tree = decoded.tree;\n            }\n            else {\n                throw new Error('Could not decode time from response');\n            }\n            const timeLookup = (0,_certificate__WEBPACK_IMPORTED_MODULE_10__.lookup_path)(['time'], tree);\n            if (timeLookup.status !== _certificate__WEBPACK_IMPORTED_MODULE_10__.LookupStatus.Found) {\n                throw new Error('Time was not found in the response or was not in its expected format.');\n            }\n            if (!(timeLookup.value instanceof ArrayBuffer) && !ArrayBuffer.isView(timeLookup)) {\n                throw new Error('Time was not found in the response or was not in its expected format.');\n            }\n            const date = (0,_utils_leb__WEBPACK_IMPORTED_MODULE_13__.decodeTime)((0,_utils_buffer__WEBPACK_IMPORTED_MODULE_5__.bufFromBufLike)(timeLookup.value));\n            this.log.print('Time from response:', date);\n            this.log.print('Time from response in milliseconds:', Number(date));\n            return Number(date);\n        }\n        else {\n            this.log.warn('No certificate found in response');\n        }\n        return 0;\n    }\n    /**\n     * Allows agent to sync its time with the network. Can be called during intialization or mid-lifecycle if the device's clock has drifted away from the network time. This is necessary to set the Expiry for a request\n     * @param {Principal} canisterId - Pass a canister ID if you need to sync the time with a particular replica. Uses the management canister by default\n     */\n    async syncTime(canisterId) {\n        const CanisterStatus = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../../canisterStatus */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/canisterStatus/index.js\"));\n        const callTime = Date.now();\n        try {\n            if (!canisterId) {\n                this.log.print('Syncing time with the IC. No canisterId provided, so falling back to ryjl3-tyaaa-aaaaa-aaaba-cai');\n            }\n            const status = await CanisterStatus.request({\n                // Fall back with canisterId of the ICP Ledger\n                canisterId: canisterId !== null && canisterId !== void 0 ? canisterId : _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.from('ryjl3-tyaaa-aaaaa-aaaba-cai'),\n                agent: this,\n                paths: ['time'],\n            });\n            const replicaTime = status.get('time');\n            if (replicaTime) {\n                __classPrivateFieldSet(this, _HttpAgent_timeDiffMsecs, Number(replicaTime) - Number(callTime), \"f\");\n            }\n        }\n        catch (error) {\n            this.log.error('Caught exception while attempting to sync time', error);\n        }\n    }\n    async status() {\n        const headers = __classPrivateFieldGet(this, _HttpAgent_credentials, \"f\")\n            ? {\n                Authorization: 'Basic ' + btoa(__classPrivateFieldGet(this, _HttpAgent_credentials, \"f\")),\n            }\n            : {};\n        this.log.print(`fetching \"/api/v2/status\"`);\n        const backoff = __classPrivateFieldGet(this, _HttpAgent_backoffStrategy, \"f\").call(this);\n        const response = await __classPrivateFieldGet(this, _HttpAgent_instances, \"m\", _HttpAgent_requestAndRetry).call(this, {\n            backoff,\n            request: () => __classPrivateFieldGet(this, _HttpAgent_fetch, \"f\").call(this, '' + new URL(`/api/v2/status`, this.host), Object.assign({ headers }, __classPrivateFieldGet(this, _HttpAgent_fetchOptions, \"f\"))),\n            tries: 0,\n        });\n        return _cbor__WEBPACK_IMPORTED_MODULE_3__.decode(await response.arrayBuffer());\n    }\n    async fetchRootKey() {\n        if (!__classPrivateFieldGet(this, _HttpAgent_rootKeyFetched, \"f\")) {\n            const status = await this.status();\n            // Hex-encoded version of the replica root key\n            this.rootKey = status.root_key;\n            __classPrivateFieldSet(this, _HttpAgent_rootKeyFetched, true, \"f\");\n        }\n        return this.rootKey;\n    }\n    invalidateIdentity() {\n        __classPrivateFieldSet(this, _HttpAgent_identity, null, \"f\");\n    }\n    replaceIdentity(identity) {\n        __classPrivateFieldSet(this, _HttpAgent_identity, Promise.resolve(identity), \"f\");\n    }\n    async fetchSubnetKeys(canisterId) {\n        const effectiveCanisterId = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.from(canisterId);\n        const response = await (0,_canisterStatus__WEBPACK_IMPORTED_MODULE_9__.request)({\n            canisterId: effectiveCanisterId,\n            paths: ['subnet'],\n            agent: this,\n        });\n        const subnetResponse = response.get('subnet');\n        if (subnetResponse && typeof subnetResponse === 'object' && 'nodeKeys' in subnetResponse) {\n            __classPrivateFieldGet(this, _HttpAgent_subnetKeys, \"f\").set(effectiveCanisterId.toText(), subnetResponse);\n            return subnetResponse;\n        }\n        // If the subnet status is not returned, return undefined\n        return undefined;\n    }\n    _transform(request) {\n        let p = Promise.resolve(request);\n        if (request.endpoint === \"call\" /* Endpoint.Call */) {\n            for (const fn of __classPrivateFieldGet(this, _HttpAgent_updatePipeline, \"f\")) {\n                p = p.then(r => fn(r).then(r2 => r2 || r));\n            }\n        }\n        else {\n            for (const fn of __classPrivateFieldGet(this, _HttpAgent_queryPipeline, \"f\")) {\n                p = p.then(r => fn(r).then(r2 => r2 || r));\n            }\n        }\n        return p;\n    }\n}\n_HttpAgent_identity = new WeakMap(), _HttpAgent_fetch = new WeakMap(), _HttpAgent_fetchOptions = new WeakMap(), _HttpAgent_callOptions = new WeakMap(), _HttpAgent_timeDiffMsecs = new WeakMap(), _HttpAgent_credentials = new WeakMap(), _HttpAgent_rootKeyFetched = new WeakMap(), _HttpAgent_retryTimes = new WeakMap(), _HttpAgent_backoffStrategy = new WeakMap(), _HttpAgent_waterMark = new WeakMap(), _HttpAgent_queryPipeline = new WeakMap(), _HttpAgent_updatePipeline = new WeakMap(), _HttpAgent_subnetKeys = new WeakMap(), _HttpAgent_verifyQuerySignatures = new WeakMap(), _HttpAgent_verifyQueryResponse = new WeakMap(), _HttpAgent_instances = new WeakSet(), _HttpAgent_requestAndRetryQuery = async function _HttpAgent_requestAndRetryQuery(args) {\n    var _a, _b;\n    const { ecid, transformedRequest, body, requestId, backoff, tries } = args;\n    const delay = tries === 0 ? 0 : backoff.next();\n    this.log.print(`fetching \"/api/v2/canister/${ecid.toString()}/query\" with tries:`, {\n        tries,\n        backoff,\n        delay,\n    });\n    // If delay is null, the backoff strategy is exhausted due to a maximum number of retries, duration, or other reason\n    if (delay === null) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_1__.AgentError(`Timestamp failed to pass the watermark after retrying the configured ${__classPrivateFieldGet(this, _HttpAgent_retryTimes, \"f\")} times. We cannot guarantee the integrity of the response since it could be a replay attack.`);\n    }\n    if (delay > 0) {\n        await new Promise(resolve => setTimeout(resolve, delay));\n    }\n    let response;\n    // Make the request and retry if it throws an error\n    try {\n        this.log.print(`fetching \"/api/v2/canister/${ecid.toString()}/query\" with request:`, transformedRequest);\n        const fetchResponse = await __classPrivateFieldGet(this, _HttpAgent_fetch, \"f\").call(this, '' + new URL(`/api/v2/canister/${ecid.toString()}/query`, this.host), Object.assign(Object.assign(Object.assign({}, __classPrivateFieldGet(this, _HttpAgent_fetchOptions, \"f\")), transformedRequest.request), { body }));\n        if (fetchResponse.status === 200) {\n            const queryResponse = _cbor__WEBPACK_IMPORTED_MODULE_3__.decode(await fetchResponse.arrayBuffer());\n            response = Object.assign(Object.assign({}, queryResponse), { httpDetails: {\n                    ok: fetchResponse.ok,\n                    status: fetchResponse.status,\n                    statusText: fetchResponse.statusText,\n                    headers: (0,_transforms__WEBPACK_IMPORTED_MODULE_6__.httpHeadersTransform)(fetchResponse.headers),\n                }, requestId });\n        }\n        else {\n            throw new _errors__WEBPACK_IMPORTED_MODULE_8__.AgentHTTPResponseError(`Gateway returned an error:\\n` +\n                `  Code: ${fetchResponse.status} (${fetchResponse.statusText})\\n` +\n                `  Body: ${await fetchResponse.text()}\\n`, {\n                ok: fetchResponse.ok,\n                status: fetchResponse.status,\n                statusText: fetchResponse.statusText,\n                headers: (0,_transforms__WEBPACK_IMPORTED_MODULE_6__.httpHeadersTransform)(fetchResponse.headers),\n            });\n        }\n    }\n    catch (error) {\n        if (tries < __classPrivateFieldGet(this, _HttpAgent_retryTimes, \"f\")) {\n            this.log.warn(`Caught exception while attempting to make query:\\n` +\n                `  ${error}\\n` +\n                `  Retrying query.`);\n            return await __classPrivateFieldGet(this, _HttpAgent_instances, \"m\", _HttpAgent_requestAndRetryQuery).call(this, Object.assign(Object.assign({}, args), { tries: tries + 1 }));\n        }\n        throw error;\n    }\n    const timestamp = (_b = (_a = response.signatures) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.timestamp;\n    // Skip watermark verification if the user has set verifyQuerySignatures to false\n    if (!__classPrivateFieldGet(this, _HttpAgent_verifyQuerySignatures, \"f\")) {\n        return response;\n    }\n    if (!timestamp) {\n        throw new Error('Timestamp not found in query response. This suggests a malformed or malicious response.');\n    }\n    // Convert the timestamp to milliseconds\n    const timeStampInMs = Number(BigInt(timestamp) / BigInt(1000000));\n    this.log.print('watermark and timestamp', {\n        waterMark: this.waterMark,\n        timestamp: timeStampInMs,\n    });\n    // If the timestamp is less than the watermark, retry the request up to the retry limit\n    if (Number(this.waterMark) > timeStampInMs) {\n        const error = new _errors__WEBPACK_IMPORTED_MODULE_1__.AgentError('Timestamp is below the watermark. Retrying query.');\n        this.log.error('Timestamp is below', error, {\n            timestamp,\n            waterMark: this.waterMark,\n        });\n        if (tries < __classPrivateFieldGet(this, _HttpAgent_retryTimes, \"f\")) {\n            return await __classPrivateFieldGet(this, _HttpAgent_instances, \"m\", _HttpAgent_requestAndRetryQuery).call(this, Object.assign(Object.assign({}, args), { tries: tries + 1 }));\n        }\n        {\n            throw new _errors__WEBPACK_IMPORTED_MODULE_1__.AgentError(`Timestamp failed to pass the watermark after retrying the configured ${__classPrivateFieldGet(this, _HttpAgent_retryTimes, \"f\")} times. We cannot guarantee the integrity of the response since it could be a replay attack.`);\n        }\n    }\n    return response;\n}, _HttpAgent_requestAndRetry = async function _HttpAgent_requestAndRetry(args) {\n    const { request, backoff, tries } = args;\n    const delay = tries === 0 ? 0 : backoff.next();\n    // If delay is null, the backoff strategy is exhausted due to a maximum number of retries, duration, or other reason\n    if (delay === null) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_1__.AgentError(`Timestamp failed to pass the watermark after retrying the configured ${__classPrivateFieldGet(this, _HttpAgent_retryTimes, \"f\")} times. We cannot guarantee the integrity of the response since it could be a replay attack.`);\n    }\n    if (delay > 0) {\n        await new Promise(resolve => setTimeout(resolve, delay));\n    }\n    let response;\n    try {\n        response = await request();\n    }\n    catch (error) {\n        if (__classPrivateFieldGet(this, _HttpAgent_retryTimes, \"f\") > tries) {\n            this.log.warn(`Caught exception while attempting to make request:\\n` +\n                `  ${error}\\n` +\n                `  Retrying request.`);\n            // Delay the request by the configured backoff strategy\n            return await __classPrivateFieldGet(this, _HttpAgent_instances, \"m\", _HttpAgent_requestAndRetry).call(this, { request, backoff, tries: tries + 1 });\n        }\n        throw error;\n    }\n    if (response.ok) {\n        return response;\n    }\n    const responseText = await response.clone().text();\n    const errorMessage = `Server returned an error:\\n` +\n        `  Code: ${response.status} (${response.statusText})\\n` +\n        `  Body: ${responseText}\\n`;\n    if (response.status === 404 && response.url.includes('api/v3')) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_8__.AgentHTTPResponseError('v3 api not supported. Fall back to v2', {\n            ok: response.ok,\n            status: response.status,\n            statusText: response.statusText,\n            headers: (0,_transforms__WEBPACK_IMPORTED_MODULE_6__.httpHeadersTransform)(response.headers),\n        });\n    }\n    if (tries < __classPrivateFieldGet(this, _HttpAgent_retryTimes, \"f\")) {\n        return await __classPrivateFieldGet(this, _HttpAgent_instances, \"m\", _HttpAgent_requestAndRetry).call(this, { request, backoff, tries: tries + 1 });\n    }\n    throw new _errors__WEBPACK_IMPORTED_MODULE_8__.AgentHTTPResponseError(errorMessage, {\n        ok: response.ok,\n        status: response.status,\n        statusText: response.statusText,\n        headers: (0,_transforms__WEBPACK_IMPORTED_MODULE_6__.httpHeadersTransform)(response.headers),\n    });\n};\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2FnZW50L2h0dHAvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsOEJBQThCLFNBQUksSUFBSSxTQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsU0FBSSxJQUFJLFNBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMrQztBQUNMO0FBQ0s7QUFDWjtBQUN1QjtBQUNXO0FBQ1c7QUFDeEI7QUFDTjtBQUNIO0FBQzhDO0FBQzdDO0FBQ1E7QUFDSjtBQUNQO0FBQ0k7QUFDVTtBQUM5QjtBQUNPO0FBQzdCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtFQUFrRTtBQUNuRTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsK0NBQVU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLG1DQUFtQywrQ0FBVTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBTTtBQUMxQjtBQUNBLFlBQVkscUJBQU07QUFDbEIsMkJBQTJCLHFCQUFNLFlBQVkscUJBQU07QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0Esc0hBQXNILG9DQUFvQztBQUMxSjtBQUNBLGNBQWMsMkRBQXNCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpRUFBb0I7QUFDckMsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vYWdlbnQvaHR0cC9pbmRleC5qcz82YjYwIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfSHR0cEFnZW50X2luc3RhbmNlcywgX0h0dHBBZ2VudF9pZGVudGl0eSwgX0h0dHBBZ2VudF9mZXRjaCwgX0h0dHBBZ2VudF9mZXRjaE9wdGlvbnMsIF9IdHRwQWdlbnRfY2FsbE9wdGlvbnMsIF9IdHRwQWdlbnRfdGltZURpZmZNc2VjcywgX0h0dHBBZ2VudF9jcmVkZW50aWFscywgX0h0dHBBZ2VudF9yb290S2V5RmV0Y2hlZCwgX0h0dHBBZ2VudF9yZXRyeVRpbWVzLCBfSHR0cEFnZW50X2JhY2tvZmZTdHJhdGVneSwgX0h0dHBBZ2VudF93YXRlck1hcmssIF9IdHRwQWdlbnRfcXVlcnlQaXBlbGluZSwgX0h0dHBBZ2VudF91cGRhdGVQaXBlbGluZSwgX0h0dHBBZ2VudF9zdWJuZXRLZXlzLCBfSHR0cEFnZW50X3ZlcmlmeVF1ZXJ5U2lnbmF0dXJlcywgX0h0dHBBZ2VudF9yZXF1ZXN0QW5kUmV0cnlRdWVyeSwgX0h0dHBBZ2VudF9yZXF1ZXN0QW5kUmV0cnksIF9IdHRwQWdlbnRfdmVyaWZ5UXVlcnlSZXNwb25zZTtcbmltcG9ydCB7IFByaW5jaXBhbCB9IGZyb20gJ0BkZmluaXR5L3ByaW5jaXBhbCc7XG5pbXBvcnQgeyBBZ2VudEVycm9yIH0gZnJvbSAnLi4vLi4vZXJyb3JzJztcbmltcG9ydCB7IEFub255bW91c0lkZW50aXR5IH0gZnJvbSAnLi4vLi4vYXV0aCc7XG5pbXBvcnQgKiBhcyBjYm9yIGZyb20gJy4uLy4uL2Nib3InO1xuaW1wb3J0IHsgaGFzaE9mTWFwLCByZXF1ZXN0SWRPZiB9IGZyb20gJy4uLy4uL3JlcXVlc3RfaWQnO1xuaW1wb3J0IHsgYnVmRnJvbUJ1Zkxpa2UsIGNvbmNhdCwgZnJvbUhleCB9IGZyb20gJy4uLy4uL3V0aWxzL2J1ZmZlcic7XG5pbXBvcnQgeyBFeHBpcnksIGh0dHBIZWFkZXJzVHJhbnNmb3JtLCBtYWtlTm9uY2VUcmFuc2Zvcm0gfSBmcm9tICcuL3RyYW5zZm9ybXMnO1xuaW1wb3J0IHsgbWFrZU5vbmNlLCBTdWJtaXRSZXF1ZXN0VHlwZSwgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IEFnZW50SFRUUFJlc3BvbnNlRXJyb3IgfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgeyByZXF1ZXN0IH0gZnJvbSAnLi4vLi4vY2FuaXN0ZXJTdGF0dXMnO1xuaW1wb3J0IHsgQ2VydGlmaWNhdGVWZXJpZmljYXRpb25FcnJvciwgTG9va3VwU3RhdHVzLCBsb29rdXBfcGF0aCwgfSBmcm9tICcuLi8uLi9jZXJ0aWZpY2F0ZSc7XG5pbXBvcnQgeyBlZDI1NTE5IH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9lZDI1NTE5JztcbmltcG9ydCB7IEV4cGlyYWJsZU1hcCB9IGZyb20gJy4uLy4uL3V0aWxzL2V4cGlyYWJsZU1hcCc7XG5pbXBvcnQgeyBFZDI1NTE5UHVibGljS2V5IH0gZnJvbSAnLi4vLi4vcHVibGljX2tleSc7XG5pbXBvcnQgeyBkZWNvZGVUaW1lIH0gZnJvbSAnLi4vLi4vdXRpbHMvbGViJztcbmltcG9ydCB7IE9ic2VydmFibGVMb2cgfSBmcm9tICcuLi8uLi9vYnNlcnZhYmxlJztcbmltcG9ydCB7IEV4cG9uZW50aWFsQmFja29mZiB9IGZyb20gJy4uLy4uL3BvbGxpbmcvYmFja29mZic7XG5leHBvcnQgKiBmcm9tICcuL3RyYW5zZm9ybXMnO1xuZXhwb3J0IHsgbWFrZU5vbmNlIH0gZnJvbSAnLi90eXBlcyc7XG5leHBvcnQgdmFyIFJlcXVlc3RTdGF0dXNSZXNwb25zZVN0YXR1cztcbihmdW5jdGlvbiAoUmVxdWVzdFN0YXR1c1Jlc3BvbnNlU3RhdHVzKSB7XG4gICAgUmVxdWVzdFN0YXR1c1Jlc3BvbnNlU3RhdHVzW1wiUmVjZWl2ZWRcIl0gPSBcInJlY2VpdmVkXCI7XG4gICAgUmVxdWVzdFN0YXR1c1Jlc3BvbnNlU3RhdHVzW1wiUHJvY2Vzc2luZ1wiXSA9IFwicHJvY2Vzc2luZ1wiO1xuICAgIFJlcXVlc3RTdGF0dXNSZXNwb25zZVN0YXR1c1tcIlJlcGxpZWRcIl0gPSBcInJlcGxpZWRcIjtcbiAgICBSZXF1ZXN0U3RhdHVzUmVzcG9uc2VTdGF0dXNbXCJSZWplY3RlZFwiXSA9IFwicmVqZWN0ZWRcIjtcbiAgICBSZXF1ZXN0U3RhdHVzUmVzcG9uc2VTdGF0dXNbXCJVbmtub3duXCJdID0gXCJ1bmtub3duXCI7XG4gICAgUmVxdWVzdFN0YXR1c1Jlc3BvbnNlU3RhdHVzW1wiRG9uZVwiXSA9IFwiZG9uZVwiO1xufSkoUmVxdWVzdFN0YXR1c1Jlc3BvbnNlU3RhdHVzIHx8IChSZXF1ZXN0U3RhdHVzUmVzcG9uc2VTdGF0dXMgPSB7fSkpO1xuLy8gRGVmYXVsdCBkZWx0YSBmb3IgaW5ncmVzcyBleHBpcnkgaXMgNSBtaW51dGVzLlxuY29uc3QgREVGQVVMVF9JTkdSRVNTX0VYUElSWV9ERUxUQV9JTl9NU0VDUyA9IDUgKiA2MCAqIDEwMDA7XG4vLyBSb290IHB1YmxpYyBrZXkgZm9yIHRoZSBJQywgZW5jb2RlZCBhcyBoZXhcbmV4cG9ydCBjb25zdCBJQ19ST09UX0tFWSA9ICczMDgxODIzMDFkMDYwZDJiMDYwMTA0MDE4MmRjN2MwNTAzMDEwMjAxMDYwYzJiMDYwMTA0MDE4MmRjN2MwNTAzMDIwMTAzNjEwMDgxNCcgK1xuICAgICdjMGU2ZWM3MWZhYjU4M2IwOGJkODEzNzNjMjU1YzNjMzcxYjJlODQ4NjNjOThhNGYxZTA4Yjc0MjM1ZDE0ZmI1ZDljMGNkNTQ2ZDk2OCcgK1xuICAgICc1ZjkxM2EwYzBiMmNjNTM0MTU4M2JmNGI0MzkyZTQ2N2RiOTZkNjViOWJiNGNiNzE3MTEyZjg0NzJlMGQ1YTRkMTQ1MDVmZmQ3NDg0JyArXG4gICAgJ2IwMTI5MTA5MWM1Zjg3Yjk4ODgzNDYzZjk4MDkxYTBiYWFhZSc7XG5leHBvcnQgY29uc3QgTUFOQUdFTUVOVF9DQU5JU1RFUl9JRCA9ICdhYWFhYS1hYSc7XG4vLyBJQzAgZG9tYWluIGluZm9cbmNvbnN0IElDMF9ET01BSU4gPSAnaWMwLmFwcCc7XG5jb25zdCBJQzBfU1VCX0RPTUFJTiA9ICcuaWMwLmFwcCc7XG5jb25zdCBJQ1AwX0RPTUFJTiA9ICdpY3AwLmlvJztcbmNvbnN0IElDUDBfU1VCX0RPTUFJTiA9ICcuaWNwMC5pbyc7XG5jb25zdCBJQ1BfQVBJX0RPTUFJTiA9ICdpY3AtYXBpLmlvJztcbmNvbnN0IElDUF9BUElfU1VCX0RPTUFJTiA9ICcuaWNwLWFwaS5pbyc7XG5jbGFzcyBIdHRwRGVmYXVsdEZldGNoRXJyb3IgZXh0ZW5kcyBBZ2VudEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBJZGVudGl0eUludmFsaWRFcnJvciBleHRlbmRzIEFnZW50RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdEZldGNoKCkge1xuICAgIGxldCBkZWZhdWx0RmV0Y2g7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIEJyb3dzZXIgY29udGV4dFxuICAgICAgICBpZiAod2luZG93LmZldGNoKSB7XG4gICAgICAgICAgICBkZWZhdWx0RmV0Y2ggPSB3aW5kb3cuZmV0Y2guYmluZCh3aW5kb3cpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEh0dHBEZWZhdWx0RmV0Y2hFcnJvcignRmV0Y2ggaW1wbGVtZW50YXRpb24gd2FzIG5vdCBhdmFpbGFibGUuIFlvdSBhcHBlYXIgdG8gYmUgaW4gYSBicm93c2VyIGNvbnRleHQsIGJ1dCB3aW5kb3cuZmV0Y2ggd2FzIG5vdCBwcmVzZW50LicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIE5vZGUgY29udGV4dFxuICAgICAgICBpZiAoZ2xvYmFsLmZldGNoKSB7XG4gICAgICAgICAgICBkZWZhdWx0RmV0Y2ggPSBnbG9iYWwuZmV0Y2guYmluZChnbG9iYWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEh0dHBEZWZhdWx0RmV0Y2hFcnJvcignRmV0Y2ggaW1wbGVtZW50YXRpb24gd2FzIG5vdCBhdmFpbGFibGUuIFlvdSBhcHBlYXIgdG8gYmUgaW4gYSBOb2RlLmpzIGNvbnRleHQsIGJ1dCBnbG9iYWwuZmV0Y2ggd2FzIG5vdCBhdmFpbGFibGUuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmIChzZWxmLmZldGNoKSB7XG4gICAgICAgICAgICBkZWZhdWx0RmV0Y2ggPSBzZWxmLmZldGNoLmJpbmQoc2VsZik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlZmF1bHRGZXRjaCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdEZldGNoO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgSHR0cERlZmF1bHRGZXRjaEVycm9yKCdGZXRjaCBpbXBsZW1lbnRhdGlvbiB3YXMgbm90IGF2YWlsYWJsZS4gUGxlYXNlIHByb3ZpZGUgZmV0Y2ggdG8gdGhlIEh0dHBBZ2VudCBjb25zdHJ1Y3Rvciwgb3IgZW5zdXJlIGl0IGlzIGF2YWlsYWJsZSBpbiB0aGUgd2luZG93IG9yIGdsb2JhbCBjb250ZXh0LicpO1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lSG9zdChjb25maWd1cmVkSG9zdCkge1xuICAgIGxldCBob3N0O1xuICAgIGlmIChjb25maWd1cmVkSG9zdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghY29uZmlndXJlZEhvc3QubWF0Y2goL15bYS16XSs6LykgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGhvc3QgPSBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArICcvLycgKyBjb25maWd1cmVkSG9zdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBob3N0ID0gbmV3IFVSTChjb25maWd1cmVkSG9zdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE1haW5uZXQsIGxvY2FsLCBhbmQgcmVtb3RlIGVudmlyb25tZW50cyB3aWxsIGhhdmUgdGhlIGFwaSByb3V0ZSBhdmFpbGFibGVcbiAgICAgICAgY29uc3Qga25vd25Ib3N0cyA9IFsnaWMwLmFwcCcsICdpY3AwLmlvJywgJzEyNy4wLjAuMScsICdsb2NhbGhvc3QnXTtcbiAgICAgICAgY29uc3QgcmVtb3RlSG9zdHMgPSBbJy5naXRodWIuZGV2JywgJy5naXRwb2QuaW8nXTtcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5sb2NhdGlvbiA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgaG9zdG5hbWUgPSBsb2NhdGlvbiA9PT0gbnVsbCB8fCBsb2NhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogbG9jYXRpb24uaG9zdG5hbWU7XG4gICAgICAgIGxldCBrbm93bkhvc3Q7XG4gICAgICAgIGlmIChob3N0bmFtZSAmJiB0eXBlb2YgaG9zdG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAocmVtb3RlSG9zdHMuc29tZShob3N0ID0+IGhvc3RuYW1lLmVuZHNXaXRoKGhvc3QpKSkge1xuICAgICAgICAgICAgICAgIGtub3duSG9zdCA9IGhvc3RuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAga25vd25Ib3N0ID0ga25vd25Ib3N0cy5maW5kKGhvc3QgPT4gaG9zdG5hbWUuZW5kc1dpdGgoaG9zdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhdGlvbiAmJiBrbm93bkhvc3QpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGlzIG9uIGEgYm91bmRhcnktbm9kZSBwcm92aWRlZCBob3N0LCB3ZSBjYW4gdXNlIHRoZSBzYW1lIGhvc3QgZm9yIHRoZSBhZ2VudFxuICAgICAgICAgICAgaG9zdCA9IG5ldyBVUkwoYCR7bG9jYXRpb24ucHJvdG9jb2x9Ly8ke2tub3duSG9zdH0ke2xvY2F0aW9uLnBvcnQgPyAnOicgKyBsb2NhdGlvbi5wb3J0IDogJyd9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBob3N0ID0gbmV3IFVSTCgnaHR0cHM6Ly9pY3AtYXBpLmlvJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhvc3QudG9TdHJpbmcoKTtcbn1cbi8qKlxuICogQSBIVFRQIGFnZW50IGFsbG93cyB1c2VycyB0byBpbnRlcmFjdCB3aXRoIGEgY2xpZW50IG9mIHRoZSBpbnRlcm5ldCBjb21wdXRlclxudXNpbmcgdGhlIGF2YWlsYWJsZSBtZXRob2RzLiBJdCBleHBvc2VzIGFuIEFQSSB0aGF0IGNsb3NlbHkgZm9sbG93cyB0aGVcbnB1YmxpYyB2aWV3IG9mIHRoZSBpbnRlcm5ldCBjb21wdXRlciwgYW5kIGlzIG5vdCBpbnRlbmRlZCB0byBiZSBleHBvc2VkXG5kaXJlY3RseSB0byB0aGUgbWFqb3JpdHkgb2YgdXNlcnMgZHVlIHRvIGl0cyBsb3ctbGV2ZWwgaW50ZXJmYWNlLlxuICogVGhlcmUgaXMgYSBwaXBlbGluZSB0byBhcHBseSB0cmFuc2Zvcm1hdGlvbnMgdG8gdGhlIHJlcXVlc3QgYmVmb3JlIHNlbmRpbmdcbml0IHRvIHRoZSBjbGllbnQuIFRoaXMgaXMgdG8gZGVjb3VwbGUgc2lnbmF0dXJlLCBub25jZSBnZW5lcmF0aW9uIGFuZFxub3RoZXIgY29tcHV0YXRpb25zIHNvIHRoYXQgdGhpcyBjbGFzcyBjYW4gc3RheSBhcyBzaW1wbGUgYXMgcG9zc2libGUgd2hpbGVcbmFsbG93aW5nIGV4dGVuc2lvbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBIdHRwQWdlbnQge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIEh0dHBBZ2VudFxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBgSHR0cEFnZW50LmNyZWF0ZWAgb3IgYEh0dHBBZ2VudC5jcmVhdGVTeW5jYCBpbnN0ZWFkXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgX0h0dHBBZ2VudF9pbnN0YW5jZXMuYWRkKHRoaXMpO1xuICAgICAgICBfSHR0cEFnZW50X2lkZW50aXR5LnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfSHR0cEFnZW50X2ZldGNoLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfSHR0cEFnZW50X2ZldGNoT3B0aW9ucy5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0h0dHBBZ2VudF9jYWxsT3B0aW9ucy5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0h0dHBBZ2VudF90aW1lRGlmZk1zZWNzLnNldCh0aGlzLCAwKTtcbiAgICAgICAgX0h0dHBBZ2VudF9jcmVkZW50aWFscy5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0h0dHBBZ2VudF9yb290S2V5RmV0Y2hlZC5zZXQodGhpcywgZmFsc2UpO1xuICAgICAgICBfSHR0cEFnZW50X3JldHJ5VGltZXMuc2V0KHRoaXMsIHZvaWQgMCk7IC8vIFJldHJ5IHJlcXVlc3RzIE4gdGltZXMgYmVmb3JlIGVycm9yaW5nIGJ5IGRlZmF1bHRcbiAgICAgICAgX0h0dHBBZ2VudF9iYWNrb2ZmU3RyYXRlZ3kuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIC8vIFB1YmxpYyBzaWduYXR1cmUgdG8gaGVscCB3aXRoIHR5cGUgY2hlY2tpbmcuXG4gICAgICAgIHRoaXMuX2lzQWdlbnQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IHt9O1xuICAgICAgICAvLyBUaGUgVVRDIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHdoZW4gdGhlIGxhdGVzdCByZXF1ZXN0IHdhcyBtYWRlXG4gICAgICAgIF9IdHRwQWdlbnRfd2F0ZXJNYXJrLnNldCh0aGlzLCAwKTtcbiAgICAgICAgdGhpcy5sb2cgPSBuZXcgT2JzZXJ2YWJsZUxvZygpO1xuICAgICAgICBfSHR0cEFnZW50X3F1ZXJ5UGlwZWxpbmUuc2V0KHRoaXMsIFtdKTtcbiAgICAgICAgX0h0dHBBZ2VudF91cGRhdGVQaXBlbGluZS5zZXQodGhpcywgW10pO1xuICAgICAgICBfSHR0cEFnZW50X3N1Ym5ldEtleXMuc2V0KHRoaXMsIG5ldyBFeHBpcmFibGVNYXAoe1xuICAgICAgICAgICAgZXhwaXJhdGlvblRpbWU6IDUgKiA2MCAqIDEwMDAsIC8vIDUgbWludXRlc1xuICAgICAgICB9KSk7XG4gICAgICAgIF9IdHRwQWdlbnRfdmVyaWZ5UXVlcnlTaWduYXR1cmVzLnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlZSBodHRwczovL2ludGVybmV0Y29tcHV0ZXIub3JnL2RvY3MvY3VycmVudC9yZWZlcmVuY2VzL2ljLWludGVyZmFjZS1zcGVjLyNodHRwLXF1ZXJ5IGZvciBkZXRhaWxzIG9uIHZhbGlkYXRpb25cbiAgICAgICAgICogQHBhcmFtIHF1ZXJ5UmVzcG9uc2UgLSBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgcXVlcnlcbiAgICAgICAgICogQHBhcmFtIHN1Ym5ldFN0YXR1cyAtIFRoZSBzdWJuZXQgc3RhdHVzLCBpbmNsdWRpbmcgYWxsIG5vZGUga2V5c1xuICAgICAgICAgKiBAcmV0dXJucyBBcGlRdWVyeVJlc3BvbnNlXG4gICAgICAgICAqL1xuICAgICAgICBfSHR0cEFnZW50X3ZlcmlmeVF1ZXJ5UmVzcG9uc2Uuc2V0KHRoaXMsIChxdWVyeVJlc3BvbnNlLCBzdWJuZXRTdGF0dXMpID0+IHtcbiAgICAgICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfdmVyaWZ5UXVlcnlTaWduYXR1cmVzLCBcImZcIikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgbm90IGJlIGNhbGxlZCBpZiB0aGUgdXNlciBoYXMgZGlzYWJsZWQgdmVyaWZpY2F0aW9uXG4gICAgICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5UmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN1Ym5ldFN0YXR1cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBDZXJ0aWZpY2F0ZVZlcmlmaWNhdGlvbkVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZSBmcm9tIHJlcGxpY2Egc2lnbmVkIHF1ZXJ5OiBubyBtYXRjaGluZyBub2RlIGtleSBmb3VuZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgc3RhdHVzLCBzaWduYXR1cmVzID0gW10sIHJlcXVlc3RJZCB9ID0gcXVlcnlSZXNwb25zZTtcbiAgICAgICAgICAgIGNvbnN0IGRvbWFpblNlcGFyYXRvciA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSgnXFx4MEJpYy1yZXNwb25zZScpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBzaWcgb2Ygc2lnbmF0dXJlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdGltZXN0YW1wLCBpZGVudGl0eSB9ID0gc2lnO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVJZCA9IFByaW5jaXBhbC5mcm9tVWludDhBcnJheShpZGVudGl0eSkudG9UZXh0KCk7XG4gICAgICAgICAgICAgICAgbGV0IGhhc2g7XG4gICAgICAgICAgICAgICAgLy8gSGFzaCBpcyBjb25zdHJ1Y3RlZCBkaWZmZXJlbnRseSBkZXBlbmRpbmcgb24gdGhlIHN0YXR1c1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgPT09ICdyZXBsaWVkJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHJlcGx5IH0gPSBxdWVyeVJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICBoYXNoID0gaGFzaE9mTWFwKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVwbHk6IHJlcGx5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBCaWdJbnQodGltZXN0YW1wKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RfaWQ6IHJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXR1cyA9PT0gJ3JlamVjdGVkJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHJlamVjdF9jb2RlLCByZWplY3RfbWVzc2FnZSwgZXJyb3JfY29kZSB9ID0gcXVlcnlSZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgaGFzaCA9IGhhc2hPZk1hcCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdF9jb2RlOiByZWplY3RfY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdF9tZXNzYWdlOiByZWplY3RfbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yX2NvZGU6IGVycm9yX2NvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IEJpZ0ludCh0aW1lc3RhbXApLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdF9pZDogcmVxdWVzdElkLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzdGF0dXM6ICR7c3RhdHVzfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzZXBhcmF0b3JXaXRoSGFzaCA9IGNvbmNhdChkb21haW5TZXBhcmF0b3IsIG5ldyBVaW50OEFycmF5KGhhc2gpKTtcbiAgICAgICAgICAgICAgICAvLyBGSVg6IGNoZWNrIGZvciBtYXRjaCB3aXRob3V0IHZlcmlmeWluZyBOIHRpbWVzXG4gICAgICAgICAgICAgICAgY29uc3QgcHViS2V5ID0gc3VibmV0U3RhdHVzID09PSBudWxsIHx8IHN1Ym5ldFN0YXR1cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3VibmV0U3RhdHVzLm5vZGVLZXlzLmdldChub2RlSWQpO1xuICAgICAgICAgICAgICAgIGlmICghcHViS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBDZXJ0aWZpY2F0ZVZlcmlmaWNhdGlvbkVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZSBmcm9tIHJlcGxpY2Egc2lnbmVkIHF1ZXJ5OiBubyBtYXRjaGluZyBub2RlIGtleSBmb3VuZC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmF3S2V5ID0gRWQyNTUxOVB1YmxpY0tleS5mcm9tRGVyKHB1YktleSkucmF3S2V5O1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkID0gZWQyNTUxOS52ZXJpZnkoc2lnLnNpZ25hdHVyZSwgbmV3IFVpbnQ4QXJyYXkoc2VwYXJhdG9yV2l0aEhhc2gpLCBuZXcgVWludDhBcnJheShyYXdLZXkpKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsaWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBxdWVyeVJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBDZXJ0aWZpY2F0ZVZlcmlmaWNhdGlvbkVycm9yKGBJbnZhbGlkIHNpZ25hdHVyZSBmcm9tIHJlcGxpY2EgJHtub2RlSWR9IHNpZ25lZCBxdWVyeS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBxdWVyeVJlc3BvbnNlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBvcHRpb25zO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9IdHRwQWdlbnRfZmV0Y2gsIG9wdGlvbnMuZmV0Y2ggfHwgZ2V0RGVmYXVsdEZldGNoKCkgfHwgZmV0Y2guYmluZChnbG9iYWwpLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0h0dHBBZ2VudF9mZXRjaE9wdGlvbnMsIG9wdGlvbnMuZmV0Y2hPcHRpb25zLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0h0dHBBZ2VudF9jYWxsT3B0aW9ucywgb3B0aW9ucy5jYWxsT3B0aW9ucywgXCJmXCIpO1xuICAgICAgICB0aGlzLnJvb3RLZXkgPSBvcHRpb25zLnJvb3RLZXkgPyBvcHRpb25zLnJvb3RLZXkgOiBmcm9tSGV4KElDX1JPT1RfS0VZKTtcbiAgICAgICAgY29uc3QgaG9zdCA9IGRldGVybWluZUhvc3Qob3B0aW9ucy5ob3N0KTtcbiAgICAgICAgdGhpcy5ob3N0ID0gbmV3IFVSTChob3N0KTtcbiAgICAgICAgaWYgKG9wdGlvbnMudmVyaWZ5UXVlcnlTaWduYXR1cmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0h0dHBBZ2VudF92ZXJpZnlRdWVyeVNpZ25hdHVyZXMsIG9wdGlvbnMudmVyaWZ5UXVlcnlTaWduYXR1cmVzLCBcImZcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVmYXVsdCBpcyAzXG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0h0dHBBZ2VudF9yZXRyeVRpbWVzLCAoX2EgPSBvcHRpb25zLnJldHJ5VGltZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDMsIFwiZlwiKTtcbiAgICAgICAgLy8gRGVsYXkgc3RyYXRlZ3kgZm9yIHJldHJpZXMuIERlZmF1bHQgaXMgZXhwb25lbnRpYWwgYmFja29mZlxuICAgICAgICBjb25zdCBkZWZhdWx0QmFja29mZkZhY3RvcnkgPSAoKSA9PiBuZXcgRXhwb25lbnRpYWxCYWNrb2ZmKHtcbiAgICAgICAgICAgIG1heEl0ZXJhdGlvbnM6IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF9yZXRyeVRpbWVzLCBcImZcIiksXG4gICAgICAgIH0pO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9IdHRwQWdlbnRfYmFja29mZlN0cmF0ZWd5LCBvcHRpb25zLmJhY2tvZmZTdHJhdGVneSB8fCBkZWZhdWx0QmFja29mZkZhY3RvcnksIFwiZlwiKTtcbiAgICAgICAgLy8gUmV3cml0ZSB0byBhdm9pZCByZWRpcmVjdHNcbiAgICAgICAgaWYgKHRoaXMuaG9zdC5ob3N0bmFtZS5lbmRzV2l0aChJQzBfU1VCX0RPTUFJTikpIHtcbiAgICAgICAgICAgIHRoaXMuaG9zdC5ob3N0bmFtZSA9IElDMF9ET01BSU47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5ob3N0Lmhvc3RuYW1lLmVuZHNXaXRoKElDUDBfU1VCX0RPTUFJTikpIHtcbiAgICAgICAgICAgIHRoaXMuaG9zdC5ob3N0bmFtZSA9IElDUDBfRE9NQUlOO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaG9zdC5ob3N0bmFtZS5lbmRzV2l0aChJQ1BfQVBJX1NVQl9ET01BSU4pKSB7XG4gICAgICAgICAgICB0aGlzLmhvc3QuaG9zdG5hbWUgPSBJQ1BfQVBJX0RPTUFJTjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5jcmVkZW50aWFscykge1xuICAgICAgICAgICAgY29uc3QgeyBuYW1lLCBwYXNzd29yZCB9ID0gb3B0aW9ucy5jcmVkZW50aWFscztcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0h0dHBBZ2VudF9jcmVkZW50aWFscywgYCR7bmFtZX0ke3Bhc3N3b3JkID8gJzonICsgcGFzc3dvcmQgOiAnJ31gLCBcImZcIik7XG4gICAgICAgIH1cbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfSHR0cEFnZW50X2lkZW50aXR5LCBQcm9taXNlLnJlc29sdmUob3B0aW9ucy5pZGVudGl0eSB8fCBuZXcgQW5vbnltb3VzSWRlbnRpdHkoKSksIFwiZlwiKTtcbiAgICAgICAgLy8gQWRkIGEgbm9uY2UgdHJhbnNmb3JtIHRvIGVuc3VyZSBjYWxscyBhcmUgdW5pcXVlXG4gICAgICAgIHRoaXMuYWRkVHJhbnNmb3JtKCd1cGRhdGUnLCBtYWtlTm9uY2VUcmFuc2Zvcm0obWFrZU5vbmNlKSk7XG4gICAgICAgIGlmIChvcHRpb25zLnVzZVF1ZXJ5Tm9uY2VzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFRyYW5zZm9ybSgncXVlcnknLCBtYWtlTm9uY2VUcmFuc2Zvcm0obWFrZU5vbmNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMubG9nVG9Db25zb2xlKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy5zdWJzY3JpYmUobG9nID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobG9nLmxldmVsID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobG9nLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsb2cubGV2ZWwgPT09ICd3YXJuJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4obG9nLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cobG9nLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCB3YXRlck1hcmsoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfd2F0ZXJNYXJrLCBcImZcIik7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVTeW5jKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMoT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucykpO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgY3JlYXRlKG9wdGlvbnMgPSB7XG4gICAgICAgIHNob3VsZEZldGNoUm9vdEtleTogZmFsc2UsXG4gICAgfSkge1xuICAgICAgICBjb25zdCBhZ2VudCA9IEh0dHBBZ2VudC5jcmVhdGVTeW5jKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBpbml0UHJvbWlzZXMgPSBbYWdlbnQuc3luY1RpbWUoKV07XG4gICAgICAgIGlmIChhZ2VudC5ob3N0LnRvU3RyaW5nKCkgIT09ICdodHRwczovL2ljcC1hcGkuaW8nICYmIG9wdGlvbnMuc2hvdWxkRmV0Y2hSb290S2V5KSB7XG4gICAgICAgICAgICBpbml0UHJvbWlzZXMucHVzaChhZ2VudC5mZXRjaFJvb3RLZXkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoaW5pdFByb21pc2VzKTtcbiAgICAgICAgcmV0dXJuIGFnZW50O1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgZnJvbShhZ2VudCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoJ2NvbmZpZycgaW4gYWdlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgSHR0cEFnZW50LmNyZWF0ZShhZ2VudC5jb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IEh0dHBBZ2VudC5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIGZldGNoOiBhZ2VudC5fZmV0Y2gsXG4gICAgICAgICAgICAgICAgZmV0Y2hPcHRpb25zOiBhZ2VudC5fZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIGNhbGxPcHRpb25zOiBhZ2VudC5fY2FsbE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgaG9zdDogYWdlbnQuX2hvc3QudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBpZGVudGl0eTogKF9hID0gYWdlbnQuX2lkZW50aXR5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBZ2VudEVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIGFnZW50IGZyb20gcHJvdmlkZWQgYWdlbnQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc0xvY2FsKCkge1xuICAgICAgICBjb25zdCBob3N0bmFtZSA9IHRoaXMuaG9zdC5ob3N0bmFtZTtcbiAgICAgICAgcmV0dXJuIGhvc3RuYW1lID09PSAnMTI3LjAuMC4xJyB8fCBob3N0bmFtZS5lbmRzV2l0aCgnMTI3LjAuMC4xJyk7XG4gICAgfVxuICAgIGFkZFRyYW5zZm9ybSh0eXBlLCBmbiwgcHJpb3JpdHkgPSBmbi5wcmlvcml0eSB8fCAwKSB7XG4gICAgICAgIGlmICh0eXBlID09PSAndXBkYXRlJykge1xuICAgICAgICAgICAgLy8gS2VlcCB0aGUgcGlwZWxpbmUgc29ydGVkIGF0IGFsbCB0aW1lLCBieSBwcmlvcml0eS5cbiAgICAgICAgICAgIGNvbnN0IGkgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfdXBkYXRlUGlwZWxpbmUsIFwiZlwiKS5maW5kSW5kZXgoeCA9PiAoeC5wcmlvcml0eSB8fCAwKSA8IHByaW9yaXR5KTtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF91cGRhdGVQaXBlbGluZSwgXCJmXCIpLnNwbGljZShpID49IDAgPyBpIDogX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X3VwZGF0ZVBpcGVsaW5lLCBcImZcIikubGVuZ3RoLCAwLCBPYmplY3QuYXNzaWduKGZuLCB7IHByaW9yaXR5IH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAncXVlcnknKSB7XG4gICAgICAgICAgICAvLyBLZWVwIHRoZSBwaXBlbGluZSBzb3J0ZWQgYXQgYWxsIHRpbWUsIGJ5IHByaW9yaXR5LlxuICAgICAgICAgICAgY29uc3QgaSA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF9xdWVyeVBpcGVsaW5lLCBcImZcIikuZmluZEluZGV4KHggPT4gKHgucHJpb3JpdHkgfHwgMCkgPCBwcmlvcml0eSk7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfcXVlcnlQaXBlbGluZSwgXCJmXCIpLnNwbGljZShpID49IDAgPyBpIDogX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X3F1ZXJ5UGlwZWxpbmUsIFwiZlwiKS5sZW5ndGgsIDAsIE9iamVjdC5hc3NpZ24oZm4sIHsgcHJpb3JpdHkgfSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFByaW5jaXBhbCgpIHtcbiAgICAgICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfaWRlbnRpdHksIFwiZlwiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IElkZW50aXR5SW52YWxpZEVycm9yKFwiVGhpcyBpZGVudGl0eSBoYXMgZXhwaXJlZCBkdWUgdGhpcyBhcHBsaWNhdGlvbidzIHNlY3VyaXR5IHBvbGljeS4gUGxlYXNlIHJlZnJlc2ggeW91ciBhdXRoZW50aWNhdGlvbi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfaWRlbnRpdHksIFwiZlwiKSkuZ2V0UHJpbmNpcGFsKCk7XG4gICAgfVxuICAgIGFzeW5jIGNhbGwoY2FuaXN0ZXJJZCwgb3B0aW9ucywgaWRlbnRpdHkpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjYWxsU3luYyA9IChfYSA9IG9wdGlvbnMuY2FsbFN5bmMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRydWU7XG4gICAgICAgIGNvbnN0IGlkID0gYXdhaXQgKGlkZW50aXR5ICE9PSB1bmRlZmluZWQgPyBhd2FpdCBpZGVudGl0eSA6IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF9pZGVudGl0eSwgXCJmXCIpKTtcbiAgICAgICAgaWYgKCFpZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IElkZW50aXR5SW52YWxpZEVycm9yKFwiVGhpcyBpZGVudGl0eSBoYXMgZXhwaXJlZCBkdWUgdGhpcyBhcHBsaWNhdGlvbidzIHNlY3VyaXR5IHBvbGljeS4gUGxlYXNlIHJlZnJlc2ggeW91ciBhdXRoZW50aWNhdGlvbi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FuaXN0ZXIgPSBQcmluY2lwYWwuZnJvbShjYW5pc3RlcklkKTtcbiAgICAgICAgY29uc3QgZWNpZCA9IG9wdGlvbnMuZWZmZWN0aXZlQ2FuaXN0ZXJJZFxuICAgICAgICAgICAgPyBQcmluY2lwYWwuZnJvbShvcHRpb25zLmVmZmVjdGl2ZUNhbmlzdGVySWQpXG4gICAgICAgICAgICA6IGNhbmlzdGVyO1xuICAgICAgICBjb25zdCBzZW5kZXIgPSBpZC5nZXRQcmluY2lwYWwoKSB8fCBQcmluY2lwYWwuYW5vbnltb3VzKCk7XG4gICAgICAgIGxldCBpbmdyZXNzX2V4cGlyeSA9IG5ldyBFeHBpcnkoREVGQVVMVF9JTkdSRVNTX0VYUElSWV9ERUxUQV9JTl9NU0VDUyk7XG4gICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBvZmYgYnkgbW9yZSB0aGFuIDMwIHNlY29uZHMsIHJlY29uY2lsZSBzeXN0ZW0gdGltZSB3aXRoIHRoZSBuZXR3b3JrXG4gICAgICAgIGlmIChNYXRoLmFicyhfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfdGltZURpZmZNc2VjcywgXCJmXCIpKSA+IDEwMDAgKiAzMCkge1xuICAgICAgICAgICAgaW5ncmVzc19leHBpcnkgPSBuZXcgRXhwaXJ5KERFRkFVTFRfSU5HUkVTU19FWFBJUllfREVMVEFfSU5fTVNFQ1MgKyBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfdGltZURpZmZNc2VjcywgXCJmXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdWJtaXQgPSB7XG4gICAgICAgICAgICByZXF1ZXN0X3R5cGU6IFN1Ym1pdFJlcXVlc3RUeXBlLkNhbGwsXG4gICAgICAgICAgICBjYW5pc3Rlcl9pZDogY2FuaXN0ZXIsXG4gICAgICAgICAgICBtZXRob2RfbmFtZTogb3B0aW9ucy5tZXRob2ROYW1lLFxuICAgICAgICAgICAgYXJnOiBvcHRpb25zLmFyZyxcbiAgICAgICAgICAgIHNlbmRlcixcbiAgICAgICAgICAgIGluZ3Jlc3NfZXhwaXJ5LFxuICAgICAgICB9O1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBsZXQgdHJhbnNmb3JtZWRSZXF1ZXN0ID0gKGF3YWl0IHRoaXMuX3RyYW5zZm9ybSh7XG4gICAgICAgICAgICByZXF1ZXN0OiB7XG4gICAgICAgICAgICAgICAgYm9keTogbnVsbCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9jYm9yJyB9LCAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X2NyZWRlbnRpYWxzLCBcImZcIikgPyB7IEF1dGhvcml6YXRpb246ICdCYXNpYyAnICsgYnRvYShfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfY3JlZGVudGlhbHMsIFwiZlwiKSkgfSA6IHt9KSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW5kcG9pbnQ6IFwiY2FsbFwiIC8qIEVuZHBvaW50LkNhbGwgKi8sXG4gICAgICAgICAgICBib2R5OiBzdWJtaXQsXG4gICAgICAgIH0pKTtcbiAgICAgICAgY29uc3Qgbm9uY2UgPSB0cmFuc2Zvcm1lZFJlcXVlc3QuYm9keS5ub25jZVxuICAgICAgICAgICAgPyB0b05vbmNlKHRyYW5zZm9ybWVkUmVxdWVzdC5ib2R5Lm5vbmNlKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHN1Ym1pdC5ub25jZSA9IG5vbmNlO1xuICAgICAgICBmdW5jdGlvbiB0b05vbmNlKGJ1Zikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1Zik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXBwbHkgdHJhbnNmb3JtIGZvciBpZGVudGl0eS5cbiAgICAgICAgdHJhbnNmb3JtZWRSZXF1ZXN0ID0gYXdhaXQgaWQudHJhbnNmb3JtUmVxdWVzdCh0cmFuc2Zvcm1lZFJlcXVlc3QpO1xuICAgICAgICBjb25zdCBib2R5ID0gY2Jvci5lbmNvZGUodHJhbnNmb3JtZWRSZXF1ZXN0LmJvZHkpO1xuICAgICAgICBjb25zdCBiYWNrb2ZmID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X2JhY2tvZmZTdHJhdGVneSwgXCJmXCIpLmNhbGwodGhpcyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBBdHRlbXB0IHYzIHN5bmMgY2FsbFxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdFN5bmMgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2cucHJpbnQoYGZldGNoaW5nIFwiL2FwaS92My9jYW5pc3Rlci8ke2VjaWQudG9UZXh0KCl9L2NhbGxcIiB3aXRoIHJlcXVlc3Q6YCwgdHJhbnNmb3JtZWRSZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X2ZldGNoLCBcImZcIikuY2FsbCh0aGlzLCAnJyArIG5ldyBVUkwoYC9hcGkvdjMvY2FuaXN0ZXIvJHtlY2lkLnRvVGV4dCgpfS9jYWxsYCwgdGhpcy5ob3N0KSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF9jYWxsT3B0aW9ucywgXCJmXCIpKSwgdHJhbnNmb3JtZWRSZXF1ZXN0LnJlcXVlc3QpLCB7IGJvZHkgfSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RBc3luYyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZy5wcmludChgZmV0Y2hpbmcgXCIvYXBpL3YyL2NhbmlzdGVyLyR7ZWNpZC50b1RleHQoKX0vY2FsbFwiIHdpdGggcmVxdWVzdDpgLCB0cmFuc2Zvcm1lZFJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfZmV0Y2gsIFwiZlwiKS5jYWxsKHRoaXMsICcnICsgbmV3IFVSTChgL2FwaS92Mi9jYW5pc3Rlci8ke2VjaWQudG9UZXh0KCl9L2NhbGxgLCB0aGlzLmhvc3QpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X2NhbGxPcHRpb25zLCBcImZcIikpLCB0cmFuc2Zvcm1lZFJlcXVlc3QucmVxdWVzdCksIHsgYm9keSB9KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF9pbnN0YW5jZXMsIFwibVwiLCBfSHR0cEFnZW50X3JlcXVlc3RBbmRSZXRyeSkuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdDogY2FsbFN5bmMgPyByZXF1ZXN0U3luYyA6IHJlcXVlc3RBc3luYyxcbiAgICAgICAgICAgICAgICBiYWNrb2ZmLFxuICAgICAgICAgICAgICAgIHRyaWVzOiAwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBbcmVzcG9uc2UsIHJlcXVlc3RJZF0gPSBhd2FpdCBQcm9taXNlLmFsbChbcmVxdWVzdCwgcmVxdWVzdElkT2Yoc3VibWl0KV0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VCdWZmZXIgPSBhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwICYmIHJlc3BvbnNlQnVmZmVyLmJ5dGVMZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgPyBjYm9yLmRlY29kZShyZXNwb25zZUJ1ZmZlcilcbiAgICAgICAgICAgICAgICA6IG51bGwpO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSB3YXRlcm1hcmsgd2l0aCB0aGUgbGF0ZXN0IHRpbWUgZnJvbSBjb25zZW5zdXNcbiAgICAgICAgICAgIGlmIChyZXNwb25zZUJvZHkgPT09IG51bGwgfHwgcmVzcG9uc2VCb2R5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZUJvZHkuY2VydGlmaWNhdGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0aW1lID0gYXdhaXQgdGhpcy5wYXJzZVRpbWVGcm9tUmVzcG9uc2UoeyBjZXJ0aWZpY2F0ZTogcmVzcG9uc2VCb2R5LmNlcnRpZmljYXRlIH0pO1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0h0dHBBZ2VudF93YXRlck1hcmssIHRpbWUsIFwiZlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICAgICAgICAgIG9rOiByZXNwb25zZS5vayxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHJlc3BvbnNlQm9keSxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cEhlYWRlcnNUcmFuc2Zvcm0ocmVzcG9uc2UuaGVhZGVycyksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0RGV0YWlsczogc3VibWl0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBlcnJvciBpcyBkdWUgdG8gdGhlIHYzIGFwaSBub3QgYmVpbmcgc3VwcG9ydGVkLCBmYWxsIGJhY2sgdG8gdjJcbiAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCd2MyBhcGkgbm90IHN1cHBvcnRlZC4nKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nLndhcm4oJ3YzIGFwaSBub3Qgc3VwcG9ydGVkLiBGYWxsIGJhY2sgdG8gdjInKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxsKGNhbmlzdGVySWQsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgXG4gICAgICAgICAgICAgICAgICAgIC8vIGRpc2FibGUgdjMgYXBpXG4gICAgICAgICAgICAgICAgICAgIGNhbGxTeW5jOiBmYWxzZSB9KSwgaWRlbnRpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ0Vycm9yIHdoaWxlIG1ha2luZyBjYWxsOicsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHF1ZXJ5KGNhbmlzdGVySWQsIGZpZWxkcywgaWRlbnRpdHkpIHtcbiAgICAgICAgY29uc3QgYmFja29mZiA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF9iYWNrb2ZmU3RyYXRlZ3ksIFwiZlwiKS5jYWxsKHRoaXMpO1xuICAgICAgICBjb25zdCBlY2lkID0gZmllbGRzLmVmZmVjdGl2ZUNhbmlzdGVySWRcbiAgICAgICAgICAgID8gUHJpbmNpcGFsLmZyb20oZmllbGRzLmVmZmVjdGl2ZUNhbmlzdGVySWQpXG4gICAgICAgICAgICA6IFByaW5jaXBhbC5mcm9tKGNhbmlzdGVySWQpO1xuICAgICAgICB0aGlzLmxvZy5wcmludChgZWNpZCAke2VjaWQudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgdGhpcy5sb2cucHJpbnQoYGNhbmlzdGVySWQgJHtjYW5pc3RlcklkLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgIGNvbnN0IG1ha2VRdWVyeSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gYXdhaXQgKGlkZW50aXR5ICE9PSB1bmRlZmluZWQgPyBhd2FpdCBpZGVudGl0eSA6IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF9pZGVudGl0eSwgXCJmXCIpKTtcbiAgICAgICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWRlbnRpdHlJbnZhbGlkRXJyb3IoXCJUaGlzIGlkZW50aXR5IGhhcyBleHBpcmVkIGR1ZSB0aGlzIGFwcGxpY2F0aW9uJ3Mgc2VjdXJpdHkgcG9saWN5LiBQbGVhc2UgcmVmcmVzaCB5b3VyIGF1dGhlbnRpY2F0aW9uLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNhbmlzdGVyID0gUHJpbmNpcGFsLmZyb20oY2FuaXN0ZXJJZCk7XG4gICAgICAgICAgICBjb25zdCBzZW5kZXIgPSAoaWQgPT09IG51bGwgfHwgaWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlkLmdldFByaW5jaXBhbCgpKSB8fCBQcmluY2lwYWwuYW5vbnltb3VzKCk7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RfdHlwZTogXCJxdWVyeVwiIC8qIFJlYWRSZXF1ZXN0VHlwZS5RdWVyeSAqLyxcbiAgICAgICAgICAgICAgICBjYW5pc3Rlcl9pZDogY2FuaXN0ZXIsXG4gICAgICAgICAgICAgICAgbWV0aG9kX25hbWU6IGZpZWxkcy5tZXRob2ROYW1lLFxuICAgICAgICAgICAgICAgIGFyZzogZmllbGRzLmFyZyxcbiAgICAgICAgICAgICAgICBzZW5kZXIsXG4gICAgICAgICAgICAgICAgaW5ncmVzc19leHBpcnk6IG5ldyBFeHBpcnkoREVGQVVMVF9JTkdSRVNTX0VYUElSWV9ERUxUQV9JTl9NU0VDUyksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdElkID0gYXdhaXQgcmVxdWVzdElkT2YocmVxdWVzdCk7XG4gICAgICAgICAgICAvLyBUT0RPOiByZW1vdmUgdGhpcyBhbnkuIFRoaXMgY2FuIGJlIGEgU2lnbmVkIG9yIFVuU2lnbmVkIHJlcXVlc3QuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgbGV0IHRyYW5zZm9ybWVkUmVxdWVzdCA9IGF3YWl0IHRoaXMuX3RyYW5zZm9ybSh7XG4gICAgICAgICAgICAgICAgcmVxdWVzdDoge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vY2JvcicgfSwgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF9jcmVkZW50aWFscywgXCJmXCIpID8geyBBdXRob3JpemF0aW9uOiAnQmFzaWMgJyArIGJ0b2EoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X2NyZWRlbnRpYWxzLCBcImZcIikpIH0gOiB7fSkpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW5kcG9pbnQ6IFwicmVhZFwiIC8qIEVuZHBvaW50LlF1ZXJ5ICovLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEFwcGx5IHRyYW5zZm9ybSBmb3IgaWRlbnRpdHkuXG4gICAgICAgICAgICB0cmFuc2Zvcm1lZFJlcXVlc3QgPSAoYXdhaXQgKGlkID09PSBudWxsIHx8IGlkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpZC50cmFuc2Zvcm1SZXF1ZXN0KHRyYW5zZm9ybWVkUmVxdWVzdCkpKTtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjYm9yLmVuY29kZSh0cmFuc2Zvcm1lZFJlcXVlc3QuYm9keSk7XG4gICAgICAgICAgICBjb25zdCBhcmdzID0ge1xuICAgICAgICAgICAgICAgIGNhbmlzdGVyOiBjYW5pc3Rlci50b1RleHQoKSxcbiAgICAgICAgICAgICAgICBlY2lkLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkUmVxdWVzdCxcbiAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgICBiYWNrb2ZmLFxuICAgICAgICAgICAgICAgIHRyaWVzOiAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdERldGFpbHM6IHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgcXVlcnk6IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF9pbnN0YW5jZXMsIFwibVwiLCBfSHR0cEFnZW50X3JlcXVlc3RBbmRSZXRyeVF1ZXJ5KS5jYWxsKHRoaXMsIGFyZ3MpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZ2V0U3VibmV0U3RhdHVzID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfdmVyaWZ5UXVlcnlTaWduYXR1cmVzLCBcImZcIikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3VibmV0U3RhdHVzID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X3N1Ym5ldEtleXMsIFwiZlwiKS5nZXQoZWNpZC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGlmIChzdWJuZXRTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VibmV0U3RhdHVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5mZXRjaFN1Ym5ldEtleXMoZWNpZC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfc3VibmV0S2V5cywgXCJmXCIpLmdldChlY2lkLnRvU3RyaW5nKCkpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBBdHRlbXB0IHRvIG1ha2UgdGhlIHF1ZXJ5IGk9cmV0cnlUaW1lcyB0aW1lc1xuICAgICAgICAvLyBNYWtlIHF1ZXJ5IGFuZCBmZXRjaCBzdWJuZXQga2V5cyBpbiBwYXJhbGxlbFxuICAgICAgICBjb25zdCBbcXVlcnlSZXN1bHQsIHN1Ym5ldFN0YXR1c10gPSBhd2FpdCBQcm9taXNlLmFsbChbbWFrZVF1ZXJ5KCksIGdldFN1Ym5ldFN0YXR1cygpXSk7XG4gICAgICAgIGNvbnN0IHsgcmVxdWVzdERldGFpbHMsIHF1ZXJ5IH0gPSBxdWVyeVJlc3VsdDtcbiAgICAgICAgY29uc3QgcXVlcnlXaXRoRGV0YWlscyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcXVlcnkpLCB7IHJlcXVlc3REZXRhaWxzIH0pO1xuICAgICAgICB0aGlzLmxvZy5wcmludCgnUXVlcnkgcmVzcG9uc2U6JywgcXVlcnlXaXRoRGV0YWlscyk7XG4gICAgICAgIC8vIFNraXAgdmVyaWZpY2F0aW9uIGlmIHRoZSB1c2VyIGhhcyBkaXNhYmxlZCBpdFxuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF92ZXJpZnlRdWVyeVNpZ25hdHVyZXMsIFwiZlwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5V2l0aERldGFpbHM7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfdmVyaWZ5UXVlcnlSZXNwb25zZSwgXCJmXCIpLmNhbGwodGhpcywgcXVlcnlXaXRoRGV0YWlscywgc3VibmV0U3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgIC8vIEluIGNhc2UgdGhlIG5vZGUgc2lnbmF0dXJlcyBoYXZlIGNoYW5nZWQsIHJlZnJlc2ggdGhlIHN1Ym5ldCBrZXlzIGFuZCB0cnkgYWdhaW5cbiAgICAgICAgICAgIHRoaXMubG9nLndhcm4oJ1F1ZXJ5IHJlc3BvbnNlIHZlcmlmaWNhdGlvbiBmYWlsZWQuIFJldHJ5aW5nIHdpdGggZnJlc2ggc3VibmV0IGtleXMuJyk7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfc3VibmV0S2V5cywgXCJmXCIpLmRlbGV0ZShjYW5pc3RlcklkLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5mZXRjaFN1Ym5ldEtleXMoZWNpZC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRTdWJuZXRTdGF0dXMgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfc3VibmV0S2V5cywgXCJmXCIpLmdldChjYW5pc3RlcklkLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgaWYgKCF1cGRhdGVkU3VibmV0U3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IENlcnRpZmljYXRlVmVyaWZpY2F0aW9uRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlIGZyb20gcmVwbGljYSBzaWduZWQgcXVlcnk6IG5vIG1hdGNoaW5nIG5vZGUga2V5IGZvdW5kLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF92ZXJpZnlRdWVyeVJlc3BvbnNlLCBcImZcIikuY2FsbCh0aGlzLCBxdWVyeVdpdGhEZXRhaWxzLCB1cGRhdGVkU3VibmV0U3RhdHVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBjcmVhdGVSZWFkU3RhdGVSZXF1ZXN0KGZpZWxkcywgaWRlbnRpdHkpIHtcbiAgICAgICAgY29uc3QgaWQgPSBhd2FpdCAoaWRlbnRpdHkgIT09IHVuZGVmaW5lZCA/IGF3YWl0IGlkZW50aXR5IDogYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X2lkZW50aXR5LCBcImZcIikpO1xuICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWRlbnRpdHlJbnZhbGlkRXJyb3IoXCJUaGlzIGlkZW50aXR5IGhhcyBleHBpcmVkIGR1ZSB0aGlzIGFwcGxpY2F0aW9uJ3Mgc2VjdXJpdHkgcG9saWN5LiBQbGVhc2UgcmVmcmVzaCB5b3VyIGF1dGhlbnRpY2F0aW9uLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZW5kZXIgPSAoaWQgPT09IG51bGwgfHwgaWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlkLmdldFByaW5jaXBhbCgpKSB8fCBQcmluY2lwYWwuYW5vbnltb3VzKCk7XG4gICAgICAgIC8vIFRPRE86IHJlbW92ZSB0aGlzIGFueS4gVGhpcyBjYW4gYmUgYSBTaWduZWQgb3IgVW5TaWduZWQgcmVxdWVzdC5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRSZXF1ZXN0ID0gYXdhaXQgdGhpcy5fdHJhbnNmb3JtKHtcbiAgICAgICAgICAgIHJlcXVlc3Q6IHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9jYm9yJyB9LCAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X2NyZWRlbnRpYWxzLCBcImZcIikgPyB7IEF1dGhvcml6YXRpb246ICdCYXNpYyAnICsgYnRvYShfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfY3JlZGVudGlhbHMsIFwiZlwiKSkgfSA6IHt9KSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW5kcG9pbnQ6IFwicmVhZF9zdGF0ZVwiIC8qIEVuZHBvaW50LlJlYWRTdGF0ZSAqLyxcbiAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0X3R5cGU6IFwicmVhZF9zdGF0ZVwiIC8qIFJlYWRSZXF1ZXN0VHlwZS5SZWFkU3RhdGUgKi8sXG4gICAgICAgICAgICAgICAgcGF0aHM6IGZpZWxkcy5wYXRocyxcbiAgICAgICAgICAgICAgICBzZW5kZXIsXG4gICAgICAgICAgICAgICAgaW5ncmVzc19leHBpcnk6IG5ldyBFeHBpcnkoREVGQVVMVF9JTkdSRVNTX0VYUElSWV9ERUxUQV9JTl9NU0VDUyksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQXBwbHkgdHJhbnNmb3JtIGZvciBpZGVudGl0eS5cbiAgICAgICAgcmV0dXJuIGlkID09PSBudWxsIHx8IGlkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpZC50cmFuc2Zvcm1SZXF1ZXN0KHRyYW5zZm9ybWVkUmVxdWVzdCk7XG4gICAgfVxuICAgIGFzeW5jIHJlYWRTdGF0ZShjYW5pc3RlcklkLCBmaWVsZHMsIGlkZW50aXR5LCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICByZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IGNhbmlzdGVyID0gdHlwZW9mIGNhbmlzdGVySWQgPT09ICdzdHJpbmcnID8gUHJpbmNpcGFsLmZyb21UZXh0KGNhbmlzdGVySWQpIDogY2FuaXN0ZXJJZDtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRSZXF1ZXN0ID0gcmVxdWVzdCAhPT0gbnVsbCAmJiByZXF1ZXN0ICE9PSB2b2lkIDAgPyByZXF1ZXN0IDogKGF3YWl0IHRoaXMuY3JlYXRlUmVhZFN0YXRlUmVxdWVzdChmaWVsZHMsIGlkZW50aXR5KSk7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBjYm9yLmVuY29kZSh0cmFuc2Zvcm1lZFJlcXVlc3QuYm9keSk7XG4gICAgICAgIHRoaXMubG9nLnByaW50KGBmZXRjaGluZyBcIi9hcGkvdjIvY2FuaXN0ZXIvJHtjYW5pc3Rlcn0vcmVhZF9zdGF0ZVwiIHdpdGggcmVxdWVzdDpgLCB0cmFuc2Zvcm1lZFJlcXVlc3QpO1xuICAgICAgICAvLyBUT0RPIC0gaHR0cHM6Ly9kZmluaXR5LmF0bGFzc2lhbi5uZXQvYnJvd3NlL1NESy0xMDkyXG4gICAgICAgIGNvbnN0IGJhY2tvZmYgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfYmFja29mZlN0cmF0ZWd5LCBcImZcIikuY2FsbCh0aGlzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X2luc3RhbmNlcywgXCJtXCIsIF9IdHRwQWdlbnRfcmVxdWVzdEFuZFJldHJ5KS5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiAoKSA9PiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfZmV0Y2gsIFwiZlwiKS5jYWxsKHRoaXMsICcnICsgbmV3IFVSTChgL2FwaS92Mi9jYW5pc3Rlci8ke2NhbmlzdGVyLnRvU3RyaW5nKCl9L3JlYWRfc3RhdGVgLCB0aGlzLmhvc3QpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X2ZldGNoT3B0aW9ucywgXCJmXCIpKSwgdHJhbnNmb3JtZWRSZXF1ZXN0LnJlcXVlc3QpLCB7IGJvZHkgfSkpLFxuICAgICAgICAgICAgICAgIGJhY2tvZmYsXG4gICAgICAgICAgICAgICAgdHJpZXM6IDAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlcnZlciByZXR1cm5lZCBhbiBlcnJvcjpcXG5gICtcbiAgICAgICAgICAgICAgICAgICAgYCAgQ29kZTogJHtyZXNwb25zZS5zdGF0dXN9ICgke3Jlc3BvbnNlLnN0YXR1c1RleHR9KVxcbmAgK1xuICAgICAgICAgICAgICAgICAgICBgICBCb2R5OiAke2F3YWl0IHJlc3BvbnNlLnRleHQoKX1cXG5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRlY29kZWRSZXNwb25zZSA9IGNib3IuZGVjb2RlKGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCkpO1xuICAgICAgICAgICAgdGhpcy5sb2cucHJpbnQoJ1JlYWQgc3RhdGUgcmVzcG9uc2U6JywgZGVjb2RlZFJlc3BvbnNlKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFRpbWUgPSBhd2FpdCB0aGlzLnBhcnNlVGltZUZyb21SZXNwb25zZShkZWNvZGVkUmVzcG9uc2UpO1xuICAgICAgICAgICAgaWYgKHBhcnNlZFRpbWUgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2cucHJpbnQoJ1JlYWQgc3RhdGUgcmVzcG9uc2UgdGltZTonLCBwYXJzZWRUaW1lKTtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9IdHRwQWdlbnRfd2F0ZXJNYXJrLCBwYXJzZWRUaW1lLCBcImZcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlZFJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ0NhdWdodCBleGNlcHRpb24gd2hpbGUgYXR0ZW1wdGluZyB0byByZWFkIHN0YXRlJywgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcGFyc2VUaW1lRnJvbVJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgICAgIGxldCB0cmVlO1xuICAgICAgICBpZiAocmVzcG9uc2UuY2VydGlmaWNhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlY29kZWQgPSBjYm9yLmRlY29kZShyZXNwb25zZS5jZXJ0aWZpY2F0ZSk7XG4gICAgICAgICAgICBpZiAoZGVjb2RlZCAmJiAndHJlZScgaW4gZGVjb2RlZCkge1xuICAgICAgICAgICAgICAgIHRyZWUgPSBkZWNvZGVkLnRyZWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkZWNvZGUgdGltZSBmcm9tIHJlc3BvbnNlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0aW1lTG9va3VwID0gbG9va3VwX3BhdGgoWyd0aW1lJ10sIHRyZWUpO1xuICAgICAgICAgICAgaWYgKHRpbWVMb29rdXAuc3RhdHVzICE9PSBMb29rdXBTdGF0dXMuRm91bmQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RpbWUgd2FzIG5vdCBmb3VuZCBpbiB0aGUgcmVzcG9uc2Ugb3Igd2FzIG5vdCBpbiBpdHMgZXhwZWN0ZWQgZm9ybWF0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEodGltZUxvb2t1cC52YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSAmJiAhQXJyYXlCdWZmZXIuaXNWaWV3KHRpbWVMb29rdXApKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaW1lIHdhcyBub3QgZm91bmQgaW4gdGhlIHJlc3BvbnNlIG9yIHdhcyBub3QgaW4gaXRzIGV4cGVjdGVkIGZvcm1hdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRhdGUgPSBkZWNvZGVUaW1lKGJ1ZkZyb21CdWZMaWtlKHRpbWVMb29rdXAudmFsdWUpKTtcbiAgICAgICAgICAgIHRoaXMubG9nLnByaW50KCdUaW1lIGZyb20gcmVzcG9uc2U6JywgZGF0ZSk7XG4gICAgICAgICAgICB0aGlzLmxvZy5wcmludCgnVGltZSBmcm9tIHJlc3BvbnNlIGluIG1pbGxpc2Vjb25kczonLCBOdW1iZXIoZGF0ZSkpO1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlcihkYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nLndhcm4oJ05vIGNlcnRpZmljYXRlIGZvdW5kIGluIHJlc3BvbnNlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsbG93cyBhZ2VudCB0byBzeW5jIGl0cyB0aW1lIHdpdGggdGhlIG5ldHdvcmsuIENhbiBiZSBjYWxsZWQgZHVyaW5nIGludGlhbGl6YXRpb24gb3IgbWlkLWxpZmVjeWNsZSBpZiB0aGUgZGV2aWNlJ3MgY2xvY2sgaGFzIGRyaWZ0ZWQgYXdheSBmcm9tIHRoZSBuZXR3b3JrIHRpbWUuIFRoaXMgaXMgbmVjZXNzYXJ5IHRvIHNldCB0aGUgRXhwaXJ5IGZvciBhIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0ge1ByaW5jaXBhbH0gY2FuaXN0ZXJJZCAtIFBhc3MgYSBjYW5pc3RlciBJRCBpZiB5b3UgbmVlZCB0byBzeW5jIHRoZSB0aW1lIHdpdGggYSBwYXJ0aWN1bGFyIHJlcGxpY2EuIFVzZXMgdGhlIG1hbmFnZW1lbnQgY2FuaXN0ZXIgYnkgZGVmYXVsdFxuICAgICAqL1xuICAgIGFzeW5jIHN5bmNUaW1lKGNhbmlzdGVySWQpIHtcbiAgICAgICAgY29uc3QgQ2FuaXN0ZXJTdGF0dXMgPSBhd2FpdCBpbXBvcnQoJy4uLy4uL2NhbmlzdGVyU3RhdHVzJyk7XG4gICAgICAgIGNvbnN0IGNhbGxUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghY2FuaXN0ZXJJZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nLnByaW50KCdTeW5jaW5nIHRpbWUgd2l0aCB0aGUgSUMuIE5vIGNhbmlzdGVySWQgcHJvdmlkZWQsIHNvIGZhbGxpbmcgYmFjayB0byByeWpsMy10eWFhYS1hYWFhYS1hYWFiYS1jYWknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IGF3YWl0IENhbmlzdGVyU3RhdHVzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIC8vIEZhbGwgYmFjayB3aXRoIGNhbmlzdGVySWQgb2YgdGhlIElDUCBMZWRnZXJcbiAgICAgICAgICAgICAgICBjYW5pc3RlcklkOiBjYW5pc3RlcklkICE9PSBudWxsICYmIGNhbmlzdGVySWQgIT09IHZvaWQgMCA/IGNhbmlzdGVySWQgOiBQcmluY2lwYWwuZnJvbSgncnlqbDMtdHlhYWEtYWFhYWEtYWFhYmEtY2FpJyksXG4gICAgICAgICAgICAgICAgYWdlbnQ6IHRoaXMsXG4gICAgICAgICAgICAgICAgcGF0aHM6IFsndGltZSddLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXBsaWNhVGltZSA9IHN0YXR1cy5nZXQoJ3RpbWUnKTtcbiAgICAgICAgICAgIGlmIChyZXBsaWNhVGltZSkge1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0h0dHBBZ2VudF90aW1lRGlmZk1zZWNzLCBOdW1iZXIocmVwbGljYVRpbWUpIC0gTnVtYmVyKGNhbGxUaW1lKSwgXCJmXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ0NhdWdodCBleGNlcHRpb24gd2hpbGUgYXR0ZW1wdGluZyB0byBzeW5jIHRpbWUnLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc3RhdHVzKCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X2NyZWRlbnRpYWxzLCBcImZcIilcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIEF1dGhvcml6YXRpb246ICdCYXNpYyAnICsgYnRvYShfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfY3JlZGVudGlhbHMsIFwiZlwiKSksXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHt9O1xuICAgICAgICB0aGlzLmxvZy5wcmludChgZmV0Y2hpbmcgXCIvYXBpL3YyL3N0YXR1c1wiYCk7XG4gICAgICAgIGNvbnN0IGJhY2tvZmYgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfYmFja29mZlN0cmF0ZWd5LCBcImZcIikuY2FsbCh0aGlzKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfaW5zdGFuY2VzLCBcIm1cIiwgX0h0dHBBZ2VudF9yZXF1ZXN0QW5kUmV0cnkpLmNhbGwodGhpcywge1xuICAgICAgICAgICAgYmFja29mZixcbiAgICAgICAgICAgIHJlcXVlc3Q6ICgpID0+IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF9mZXRjaCwgXCJmXCIpLmNhbGwodGhpcywgJycgKyBuZXcgVVJMKGAvYXBpL3YyL3N0YXR1c2AsIHRoaXMuaG9zdCksIE9iamVjdC5hc3NpZ24oeyBoZWFkZXJzIH0sIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF9mZXRjaE9wdGlvbnMsIFwiZlwiKSkpLFxuICAgICAgICAgICAgdHJpZXM6IDAsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2Jvci5kZWNvZGUoYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKSk7XG4gICAgfVxuICAgIGFzeW5jIGZldGNoUm9vdEtleSgpIHtcbiAgICAgICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfcm9vdEtleUZldGNoZWQsIFwiZlwiKSkge1xuICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gYXdhaXQgdGhpcy5zdGF0dXMoKTtcbiAgICAgICAgICAgIC8vIEhleC1lbmNvZGVkIHZlcnNpb24gb2YgdGhlIHJlcGxpY2Egcm9vdCBrZXlcbiAgICAgICAgICAgIHRoaXMucm9vdEtleSA9IHN0YXR1cy5yb290X2tleTtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0h0dHBBZ2VudF9yb290S2V5RmV0Y2hlZCwgdHJ1ZSwgXCJmXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3RLZXk7XG4gICAgfVxuICAgIGludmFsaWRhdGVJZGVudGl0eSgpIHtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfSHR0cEFnZW50X2lkZW50aXR5LCBudWxsLCBcImZcIik7XG4gICAgfVxuICAgIHJlcGxhY2VJZGVudGl0eShpZGVudGl0eSkge1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9IdHRwQWdlbnRfaWRlbnRpdHksIFByb21pc2UucmVzb2x2ZShpZGVudGl0eSksIFwiZlwiKTtcbiAgICB9XG4gICAgYXN5bmMgZmV0Y2hTdWJuZXRLZXlzKGNhbmlzdGVySWQpIHtcbiAgICAgICAgY29uc3QgZWZmZWN0aXZlQ2FuaXN0ZXJJZCA9IFByaW5jaXBhbC5mcm9tKGNhbmlzdGVySWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3Qoe1xuICAgICAgICAgICAgY2FuaXN0ZXJJZDogZWZmZWN0aXZlQ2FuaXN0ZXJJZCxcbiAgICAgICAgICAgIHBhdGhzOiBbJ3N1Ym5ldCddLFxuICAgICAgICAgICAgYWdlbnQ6IHRoaXMsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzdWJuZXRSZXNwb25zZSA9IHJlc3BvbnNlLmdldCgnc3VibmV0Jyk7XG4gICAgICAgIGlmIChzdWJuZXRSZXNwb25zZSAmJiB0eXBlb2Ygc3VibmV0UmVzcG9uc2UgPT09ICdvYmplY3QnICYmICdub2RlS2V5cycgaW4gc3VibmV0UmVzcG9uc2UpIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF9zdWJuZXRLZXlzLCBcImZcIikuc2V0KGVmZmVjdGl2ZUNhbmlzdGVySWQudG9UZXh0KCksIHN1Ym5ldFJlc3BvbnNlKTtcbiAgICAgICAgICAgIHJldHVybiBzdWJuZXRSZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgc3VibmV0IHN0YXR1cyBpcyBub3QgcmV0dXJuZWQsIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgX3RyYW5zZm9ybShyZXF1ZXN0KSB7XG4gICAgICAgIGxldCBwID0gUHJvbWlzZS5yZXNvbHZlKHJlcXVlc3QpO1xuICAgICAgICBpZiAocmVxdWVzdC5lbmRwb2ludCA9PT0gXCJjYWxsXCIgLyogRW5kcG9pbnQuQ2FsbCAqLykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBmbiBvZiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfdXBkYXRlUGlwZWxpbmUsIFwiZlwiKSkge1xuICAgICAgICAgICAgICAgIHAgPSBwLnRoZW4ociA9PiBmbihyKS50aGVuKHIyID0+IHIyIHx8IHIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZm4gb2YgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X3F1ZXJ5UGlwZWxpbmUsIFwiZlwiKSkge1xuICAgICAgICAgICAgICAgIHAgPSBwLnRoZW4ociA9PiBmbihyKS50aGVuKHIyID0+IHIyIHx8IHIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG59XG5fSHR0cEFnZW50X2lkZW50aXR5ID0gbmV3IFdlYWtNYXAoKSwgX0h0dHBBZ2VudF9mZXRjaCA9IG5ldyBXZWFrTWFwKCksIF9IdHRwQWdlbnRfZmV0Y2hPcHRpb25zID0gbmV3IFdlYWtNYXAoKSwgX0h0dHBBZ2VudF9jYWxsT3B0aW9ucyA9IG5ldyBXZWFrTWFwKCksIF9IdHRwQWdlbnRfdGltZURpZmZNc2VjcyA9IG5ldyBXZWFrTWFwKCksIF9IdHRwQWdlbnRfY3JlZGVudGlhbHMgPSBuZXcgV2Vha01hcCgpLCBfSHR0cEFnZW50X3Jvb3RLZXlGZXRjaGVkID0gbmV3IFdlYWtNYXAoKSwgX0h0dHBBZ2VudF9yZXRyeVRpbWVzID0gbmV3IFdlYWtNYXAoKSwgX0h0dHBBZ2VudF9iYWNrb2ZmU3RyYXRlZ3kgPSBuZXcgV2Vha01hcCgpLCBfSHR0cEFnZW50X3dhdGVyTWFyayA9IG5ldyBXZWFrTWFwKCksIF9IdHRwQWdlbnRfcXVlcnlQaXBlbGluZSA9IG5ldyBXZWFrTWFwKCksIF9IdHRwQWdlbnRfdXBkYXRlUGlwZWxpbmUgPSBuZXcgV2Vha01hcCgpLCBfSHR0cEFnZW50X3N1Ym5ldEtleXMgPSBuZXcgV2Vha01hcCgpLCBfSHR0cEFnZW50X3ZlcmlmeVF1ZXJ5U2lnbmF0dXJlcyA9IG5ldyBXZWFrTWFwKCksIF9IdHRwQWdlbnRfdmVyaWZ5UXVlcnlSZXNwb25zZSA9IG5ldyBXZWFrTWFwKCksIF9IdHRwQWdlbnRfaW5zdGFuY2VzID0gbmV3IFdlYWtTZXQoKSwgX0h0dHBBZ2VudF9yZXF1ZXN0QW5kUmV0cnlRdWVyeSA9IGFzeW5jIGZ1bmN0aW9uIF9IdHRwQWdlbnRfcmVxdWVzdEFuZFJldHJ5UXVlcnkoYXJncykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgeyBlY2lkLCB0cmFuc2Zvcm1lZFJlcXVlc3QsIGJvZHksIHJlcXVlc3RJZCwgYmFja29mZiwgdHJpZXMgfSA9IGFyZ3M7XG4gICAgY29uc3QgZGVsYXkgPSB0cmllcyA9PT0gMCA/IDAgOiBiYWNrb2ZmLm5leHQoKTtcbiAgICB0aGlzLmxvZy5wcmludChgZmV0Y2hpbmcgXCIvYXBpL3YyL2NhbmlzdGVyLyR7ZWNpZC50b1N0cmluZygpfS9xdWVyeVwiIHdpdGggdHJpZXM6YCwge1xuICAgICAgICB0cmllcyxcbiAgICAgICAgYmFja29mZixcbiAgICAgICAgZGVsYXksXG4gICAgfSk7XG4gICAgLy8gSWYgZGVsYXkgaXMgbnVsbCwgdGhlIGJhY2tvZmYgc3RyYXRlZ3kgaXMgZXhoYXVzdGVkIGR1ZSB0byBhIG1heGltdW0gbnVtYmVyIG9mIHJldHJpZXMsIGR1cmF0aW9uLCBvciBvdGhlciByZWFzb25cbiAgICBpZiAoZGVsYXkgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFnZW50RXJyb3IoYFRpbWVzdGFtcCBmYWlsZWQgdG8gcGFzcyB0aGUgd2F0ZXJtYXJrIGFmdGVyIHJldHJ5aW5nIHRoZSBjb25maWd1cmVkICR7X19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X3JldHJ5VGltZXMsIFwiZlwiKX0gdGltZXMuIFdlIGNhbm5vdCBndWFyYW50ZWUgdGhlIGludGVncml0eSBvZiB0aGUgcmVzcG9uc2Ugc2luY2UgaXQgY291bGQgYmUgYSByZXBsYXkgYXR0YWNrLmApO1xuICAgIH1cbiAgICBpZiAoZGVsYXkgPiAwKSB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSkpO1xuICAgIH1cbiAgICBsZXQgcmVzcG9uc2U7XG4gICAgLy8gTWFrZSB0aGUgcmVxdWVzdCBhbmQgcmV0cnkgaWYgaXQgdGhyb3dzIGFuIGVycm9yXG4gICAgdHJ5IHtcbiAgICAgICAgdGhpcy5sb2cucHJpbnQoYGZldGNoaW5nIFwiL2FwaS92Mi9jYW5pc3Rlci8ke2VjaWQudG9TdHJpbmcoKX0vcXVlcnlcIiB3aXRoIHJlcXVlc3Q6YCwgdHJhbnNmb3JtZWRSZXF1ZXN0KTtcbiAgICAgICAgY29uc3QgZmV0Y2hSZXNwb25zZSA9IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF9mZXRjaCwgXCJmXCIpLmNhbGwodGhpcywgJycgKyBuZXcgVVJMKGAvYXBpL3YyL2NhbmlzdGVyLyR7ZWNpZC50b1N0cmluZygpfS9xdWVyeWAsIHRoaXMuaG9zdCksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfZmV0Y2hPcHRpb25zLCBcImZcIikpLCB0cmFuc2Zvcm1lZFJlcXVlc3QucmVxdWVzdCksIHsgYm9keSB9KSk7XG4gICAgICAgIGlmIChmZXRjaFJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVJlc3BvbnNlID0gY2Jvci5kZWNvZGUoYXdhaXQgZmV0Y2hSZXNwb25zZS5hcnJheUJ1ZmZlcigpKTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBxdWVyeVJlc3BvbnNlKSwgeyBodHRwRGV0YWlsczoge1xuICAgICAgICAgICAgICAgICAgICBvazogZmV0Y2hSZXNwb25zZS5vayxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBmZXRjaFJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogZmV0Y2hSZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwSGVhZGVyc1RyYW5zZm9ybShmZXRjaFJlc3BvbnNlLmhlYWRlcnMpLFxuICAgICAgICAgICAgICAgIH0sIHJlcXVlc3RJZCB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBZ2VudEhUVFBSZXNwb25zZUVycm9yKGBHYXRld2F5IHJldHVybmVkIGFuIGVycm9yOlxcbmAgK1xuICAgICAgICAgICAgICAgIGAgIENvZGU6ICR7ZmV0Y2hSZXNwb25zZS5zdGF0dXN9ICgke2ZldGNoUmVzcG9uc2Uuc3RhdHVzVGV4dH0pXFxuYCArXG4gICAgICAgICAgICAgICAgYCAgQm9keTogJHthd2FpdCBmZXRjaFJlc3BvbnNlLnRleHQoKX1cXG5gLCB7XG4gICAgICAgICAgICAgICAgb2s6IGZldGNoUmVzcG9uc2Uub2ssXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBmZXRjaFJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiBmZXRjaFJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cEhlYWRlcnNUcmFuc2Zvcm0oZmV0Y2hSZXNwb25zZS5oZWFkZXJzKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAodHJpZXMgPCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfcmV0cnlUaW1lcywgXCJmXCIpKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy53YXJuKGBDYXVnaHQgZXhjZXB0aW9uIHdoaWxlIGF0dGVtcHRpbmcgdG8gbWFrZSBxdWVyeTpcXG5gICtcbiAgICAgICAgICAgICAgICBgICAke2Vycm9yfVxcbmAgK1xuICAgICAgICAgICAgICAgIGAgIFJldHJ5aW5nIHF1ZXJ5LmApO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF9pbnN0YW5jZXMsIFwibVwiLCBfSHR0cEFnZW50X3JlcXVlc3RBbmRSZXRyeVF1ZXJ5KS5jYWxsKHRoaXMsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYXJncyksIHsgdHJpZXM6IHRyaWVzICsgMSB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IHRpbWVzdGFtcCA9IChfYiA9IChfYSA9IHJlc3BvbnNlLnNpZ25hdHVyZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnRpbWVzdGFtcDtcbiAgICAvLyBTa2lwIHdhdGVybWFyayB2ZXJpZmljYXRpb24gaWYgdGhlIHVzZXIgaGFzIHNldCB2ZXJpZnlRdWVyeVNpZ25hdHVyZXMgdG8gZmFsc2VcbiAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF92ZXJpZnlRdWVyeVNpZ25hdHVyZXMsIFwiZlwiKSkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIGlmICghdGltZXN0YW1wKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGltZXN0YW1wIG5vdCBmb3VuZCBpbiBxdWVyeSByZXNwb25zZS4gVGhpcyBzdWdnZXN0cyBhIG1hbGZvcm1lZCBvciBtYWxpY2lvdXMgcmVzcG9uc2UuJyk7XG4gICAgfVxuICAgIC8vIENvbnZlcnQgdGhlIHRpbWVzdGFtcCB0byBtaWxsaXNlY29uZHNcbiAgICBjb25zdCB0aW1lU3RhbXBJbk1zID0gTnVtYmVyKEJpZ0ludCh0aW1lc3RhbXApIC8gQmlnSW50KDEwMDAwMDApKTtcbiAgICB0aGlzLmxvZy5wcmludCgnd2F0ZXJtYXJrIGFuZCB0aW1lc3RhbXAnLCB7XG4gICAgICAgIHdhdGVyTWFyazogdGhpcy53YXRlck1hcmssXG4gICAgICAgIHRpbWVzdGFtcDogdGltZVN0YW1wSW5NcyxcbiAgICB9KTtcbiAgICAvLyBJZiB0aGUgdGltZXN0YW1wIGlzIGxlc3MgdGhhbiB0aGUgd2F0ZXJtYXJrLCByZXRyeSB0aGUgcmVxdWVzdCB1cCB0byB0aGUgcmV0cnkgbGltaXRcbiAgICBpZiAoTnVtYmVyKHRoaXMud2F0ZXJNYXJrKSA+IHRpbWVTdGFtcEluTXMpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgQWdlbnRFcnJvcignVGltZXN0YW1wIGlzIGJlbG93IHRoZSB3YXRlcm1hcmsuIFJldHJ5aW5nIHF1ZXJ5LicpO1xuICAgICAgICB0aGlzLmxvZy5lcnJvcignVGltZXN0YW1wIGlzIGJlbG93JywgZXJyb3IsIHtcbiAgICAgICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgICAgIHdhdGVyTWFyazogdGhpcy53YXRlck1hcmssXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHJpZXMgPCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfcmV0cnlUaW1lcywgXCJmXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X2luc3RhbmNlcywgXCJtXCIsIF9IdHRwQWdlbnRfcmVxdWVzdEFuZFJldHJ5UXVlcnkpLmNhbGwodGhpcywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhcmdzKSwgeyB0cmllczogdHJpZXMgKyAxIH0pKTtcbiAgICAgICAgfVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQWdlbnRFcnJvcihgVGltZXN0YW1wIGZhaWxlZCB0byBwYXNzIHRoZSB3YXRlcm1hcmsgYWZ0ZXIgcmV0cnlpbmcgdGhlIGNvbmZpZ3VyZWQgJHtfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfcmV0cnlUaW1lcywgXCJmXCIpfSB0aW1lcy4gV2UgY2Fubm90IGd1YXJhbnRlZSB0aGUgaW50ZWdyaXR5IG9mIHRoZSByZXNwb25zZSBzaW5jZSBpdCBjb3VsZCBiZSBhIHJlcGxheSBhdHRhY2suYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xufSwgX0h0dHBBZ2VudF9yZXF1ZXN0QW5kUmV0cnkgPSBhc3luYyBmdW5jdGlvbiBfSHR0cEFnZW50X3JlcXVlc3RBbmRSZXRyeShhcmdzKSB7XG4gICAgY29uc3QgeyByZXF1ZXN0LCBiYWNrb2ZmLCB0cmllcyB9ID0gYXJncztcbiAgICBjb25zdCBkZWxheSA9IHRyaWVzID09PSAwID8gMCA6IGJhY2tvZmYubmV4dCgpO1xuICAgIC8vIElmIGRlbGF5IGlzIG51bGwsIHRoZSBiYWNrb2ZmIHN0cmF0ZWd5IGlzIGV4aGF1c3RlZCBkdWUgdG8gYSBtYXhpbXVtIG51bWJlciBvZiByZXRyaWVzLCBkdXJhdGlvbiwgb3Igb3RoZXIgcmVhc29uXG4gICAgaWYgKGRlbGF5ID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBBZ2VudEVycm9yKGBUaW1lc3RhbXAgZmFpbGVkIHRvIHBhc3MgdGhlIHdhdGVybWFyayBhZnRlciByZXRyeWluZyB0aGUgY29uZmlndXJlZCAke19fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF9yZXRyeVRpbWVzLCBcImZcIil9IHRpbWVzLiBXZSBjYW5ub3QgZ3VhcmFudGVlIHRoZSBpbnRlZ3JpdHkgb2YgdGhlIHJlc3BvbnNlIHNpbmNlIGl0IGNvdWxkIGJlIGEgcmVwbGF5IGF0dGFjay5gKTtcbiAgICB9XG4gICAgaWYgKGRlbGF5ID4gMCkge1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXkpKTtcbiAgICB9XG4gICAgbGV0IHJlc3BvbnNlO1xuICAgIHRyeSB7XG4gICAgICAgIHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdCgpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF9yZXRyeVRpbWVzLCBcImZcIikgPiB0cmllcykge1xuICAgICAgICAgICAgdGhpcy5sb2cud2FybihgQ2F1Z2h0IGV4Y2VwdGlvbiB3aGlsZSBhdHRlbXB0aW5nIHRvIG1ha2UgcmVxdWVzdDpcXG5gICtcbiAgICAgICAgICAgICAgICBgICAke2Vycm9yfVxcbmAgK1xuICAgICAgICAgICAgICAgIGAgIFJldHJ5aW5nIHJlcXVlc3QuYCk7XG4gICAgICAgICAgICAvLyBEZWxheSB0aGUgcmVxdWVzdCBieSB0aGUgY29uZmlndXJlZCBiYWNrb2ZmIHN0cmF0ZWd5XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X2luc3RhbmNlcywgXCJtXCIsIF9IdHRwQWdlbnRfcmVxdWVzdEFuZFJldHJ5KS5jYWxsKHRoaXMsIHsgcmVxdWVzdCwgYmFja29mZiwgdHJpZXM6IHRyaWVzICsgMSB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2VUZXh0ID0gYXdhaXQgcmVzcG9uc2UuY2xvbmUoKS50ZXh0KCk7XG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID0gYFNlcnZlciByZXR1cm5lZCBhbiBlcnJvcjpcXG5gICtcbiAgICAgICAgYCAgQ29kZTogJHtyZXNwb25zZS5zdGF0dXN9ICgke3Jlc3BvbnNlLnN0YXR1c1RleHR9KVxcbmAgK1xuICAgICAgICBgICBCb2R5OiAke3Jlc3BvbnNlVGV4dH1cXG5gO1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCAmJiByZXNwb25zZS51cmwuaW5jbHVkZXMoJ2FwaS92MycpKSB7XG4gICAgICAgIHRocm93IG5ldyBBZ2VudEhUVFBSZXNwb25zZUVycm9yKCd2MyBhcGkgbm90IHN1cHBvcnRlZC4gRmFsbCBiYWNrIHRvIHYyJywge1xuICAgICAgICAgICAgb2s6IHJlc3BvbnNlLm9rLFxuICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgaGVhZGVyczogaHR0cEhlYWRlcnNUcmFuc2Zvcm0ocmVzcG9uc2UuaGVhZGVycyksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodHJpZXMgPCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfcmV0cnlUaW1lcywgXCJmXCIpKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfaW5zdGFuY2VzLCBcIm1cIiwgX0h0dHBBZ2VudF9yZXF1ZXN0QW5kUmV0cnkpLmNhbGwodGhpcywgeyByZXF1ZXN0LCBiYWNrb2ZmLCB0cmllczogdHJpZXMgKyAxIH0pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgQWdlbnRIVFRQUmVzcG9uc2VFcnJvcihlcnJvck1lc3NhZ2UsIHtcbiAgICAgICAgb2s6IHJlc3BvbnNlLm9rLFxuICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogaHR0cEhlYWRlcnNUcmFuc2Zvcm0ocmVzcG9uc2UuaGVhZGVycyksXG4gICAgfSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/agent/http/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/agent/http/transforms.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@dfinity/agent/lib/esm/agent/http/transforms.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Expiry: function() { return /* binding */ Expiry; },\n/* harmony export */   httpHeadersTransform: function() { return /* binding */ httpHeadersTransform; },\n/* harmony export */   makeExpiryTransform: function() { return /* binding */ makeExpiryTransform; },\n/* harmony export */   makeNonceTransform: function() { return /* binding */ makeNonceTransform; }\n/* harmony export */ });\n/* harmony import */ var _dfinity_candid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/candid */ \"(app-pages-browser)/./node_modules/@dfinity/candid/lib/esm/index.js\");\n/* harmony import */ var simple_cbor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! simple-cbor */ \"(app-pages-browser)/../../node_modules/simple-cbor/src/index.js\");\n/* harmony import */ var simple_cbor__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(simple_cbor__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/agent/http/types.js\");\n\n\n\nconst NANOSECONDS_PER_MILLISECONDS = BigInt(1000000);\nconst REPLICA_PERMITTED_DRIFT_MILLISECONDS = 60 * 1000;\nclass Expiry {\n    constructor(deltaInMSec) {\n        // Use bigint because it can overflow the maximum number allowed in a double float.\n        const raw_value = BigInt(Math.floor(Date.now() + deltaInMSec - REPLICA_PERMITTED_DRIFT_MILLISECONDS)) *\n            NANOSECONDS_PER_MILLISECONDS;\n        // round down to the nearest second\n        const ingress_as_seconds = raw_value / BigInt(1000000000);\n        // round down to nearest minute\n        const ingress_as_minutes = ingress_as_seconds / BigInt(60);\n        const rounded_down_nanos = ingress_as_minutes * BigInt(60) * BigInt(1000000000);\n        this._value = rounded_down_nanos;\n    }\n    toCBOR() {\n        // TODO: change this to take the minimum amount of space (it always takes 8 bytes now).\n        return simple_cbor__WEBPACK_IMPORTED_MODULE_1__.value.u64(this._value.toString(16), 16);\n    }\n    toHash() {\n        return (0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_0__.lebEncode)(this._value);\n    }\n}\n/**\n * Create a Nonce transform, which takes a function that returns a Buffer, and adds it\n * as the nonce to every call requests.\n * @param nonceFn A function that returns a buffer. By default uses a semi-random method.\n */\nfunction makeNonceTransform(nonceFn = _types__WEBPACK_IMPORTED_MODULE_2__.makeNonce) {\n    return async (request) => {\n        // Nonce needs to be inserted into the header for all requests, to enable logs to be correlated with requests.\n        const headers = request.request.headers;\n        // TODO: uncomment this when the http proxy supports it.\n        // headers.set('X-IC-Request-ID', toHex(new Uint8Array(nonce)));\n        request.request.headers = headers;\n        // Nonce only needs to be inserted into the body for async calls, to prevent replay attacks.\n        if (request.endpoint === \"call\" /* Endpoint.Call */) {\n            request.body.nonce = nonceFn();\n        }\n    };\n}\n/**\n * Create a transform that adds a delay (by default 5 minutes) to the expiry.\n *\n * @param delayInMilliseconds The delay to add to the call time, in milliseconds.\n */\nfunction makeExpiryTransform(delayInMilliseconds) {\n    return async (request) => {\n        request.body.ingress_expiry = new Expiry(delayInMilliseconds);\n    };\n}\n/**\n * Maps the default fetch headers field to the serializable HttpHeaderField.\n *\n * @param headers Fetch definition of the headers type\n * @returns array of header fields\n */\nfunction httpHeadersTransform(headers) {\n    const headerFields = [];\n    headers.forEach((value, key) => {\n        headerFields.push([key, value]);\n    });\n    return headerFields;\n}\n//# sourceMappingURL=transforms.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2FnZW50L2h0dHAvdHJhbnNmb3Jtcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUE0QztBQUNSO0FBQ0M7QUFDckM7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDhDQUFVO0FBQ3pCO0FBQ0E7QUFDQSxlQUFlLDBEQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sc0NBQXNDLDZDQUFTO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2FnZW50L2h0dHAvdHJhbnNmb3Jtcy5qcz81YTg4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGxlYkVuY29kZSB9IGZyb20gJ0BkZmluaXR5L2NhbmRpZCc7XG5pbXBvcnQgKiBhcyBjYm9yIGZyb20gJ3NpbXBsZS1jYm9yJztcbmltcG9ydCB7IG1ha2VOb25jZSwgfSBmcm9tICcuL3R5cGVzJztcbmNvbnN0IE5BTk9TRUNPTkRTX1BFUl9NSUxMSVNFQ09ORFMgPSBCaWdJbnQoMTAwMDAwMCk7XG5jb25zdCBSRVBMSUNBX1BFUk1JVFRFRF9EUklGVF9NSUxMSVNFQ09ORFMgPSA2MCAqIDEwMDA7XG5leHBvcnQgY2xhc3MgRXhwaXJ5IHtcbiAgICBjb25zdHJ1Y3RvcihkZWx0YUluTVNlYykge1xuICAgICAgICAvLyBVc2UgYmlnaW50IGJlY2F1c2UgaXQgY2FuIG92ZXJmbG93IHRoZSBtYXhpbXVtIG51bWJlciBhbGxvd2VkIGluIGEgZG91YmxlIGZsb2F0LlxuICAgICAgICBjb25zdCByYXdfdmFsdWUgPSBCaWdJbnQoTWF0aC5mbG9vcihEYXRlLm5vdygpICsgZGVsdGFJbk1TZWMgLSBSRVBMSUNBX1BFUk1JVFRFRF9EUklGVF9NSUxMSVNFQ09ORFMpKSAqXG4gICAgICAgICAgICBOQU5PU0VDT05EU19QRVJfTUlMTElTRUNPTkRTO1xuICAgICAgICAvLyByb3VuZCBkb3duIHRvIHRoZSBuZWFyZXN0IHNlY29uZFxuICAgICAgICBjb25zdCBpbmdyZXNzX2FzX3NlY29uZHMgPSByYXdfdmFsdWUgLyBCaWdJbnQoMTAwMDAwMDAwMCk7XG4gICAgICAgIC8vIHJvdW5kIGRvd24gdG8gbmVhcmVzdCBtaW51dGVcbiAgICAgICAgY29uc3QgaW5ncmVzc19hc19taW51dGVzID0gaW5ncmVzc19hc19zZWNvbmRzIC8gQmlnSW50KDYwKTtcbiAgICAgICAgY29uc3Qgcm91bmRlZF9kb3duX25hbm9zID0gaW5ncmVzc19hc19taW51dGVzICogQmlnSW50KDYwKSAqIEJpZ0ludCgxMDAwMDAwMDAwKTtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSByb3VuZGVkX2Rvd25fbmFub3M7XG4gICAgfVxuICAgIHRvQ0JPUigpIHtcbiAgICAgICAgLy8gVE9ETzogY2hhbmdlIHRoaXMgdG8gdGFrZSB0aGUgbWluaW11bSBhbW91bnQgb2Ygc3BhY2UgKGl0IGFsd2F5cyB0YWtlcyA4IGJ5dGVzIG5vdykuXG4gICAgICAgIHJldHVybiBjYm9yLnZhbHVlLnU2NCh0aGlzLl92YWx1ZS50b1N0cmluZygxNiksIDE2KTtcbiAgICB9XG4gICAgdG9IYXNoKCkge1xuICAgICAgICByZXR1cm4gbGViRW5jb2RlKHRoaXMuX3ZhbHVlKTtcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZSBhIE5vbmNlIHRyYW5zZm9ybSwgd2hpY2ggdGFrZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBCdWZmZXIsIGFuZCBhZGRzIGl0XG4gKiBhcyB0aGUgbm9uY2UgdG8gZXZlcnkgY2FsbCByZXF1ZXN0cy5cbiAqIEBwYXJhbSBub25jZUZuIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgYnVmZmVyLiBCeSBkZWZhdWx0IHVzZXMgYSBzZW1pLXJhbmRvbSBtZXRob2QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlTm9uY2VUcmFuc2Zvcm0obm9uY2VGbiA9IG1ha2VOb25jZSkge1xuICAgIHJldHVybiBhc3luYyAocmVxdWVzdCkgPT4ge1xuICAgICAgICAvLyBOb25jZSBuZWVkcyB0byBiZSBpbnNlcnRlZCBpbnRvIHRoZSBoZWFkZXIgZm9yIGFsbCByZXF1ZXN0cywgdG8gZW5hYmxlIGxvZ3MgdG8gYmUgY29ycmVsYXRlZCB3aXRoIHJlcXVlc3RzLlxuICAgICAgICBjb25zdCBoZWFkZXJzID0gcmVxdWVzdC5yZXF1ZXN0LmhlYWRlcnM7XG4gICAgICAgIC8vIFRPRE86IHVuY29tbWVudCB0aGlzIHdoZW4gdGhlIGh0dHAgcHJveHkgc3VwcG9ydHMgaXQuXG4gICAgICAgIC8vIGhlYWRlcnMuc2V0KCdYLUlDLVJlcXVlc3QtSUQnLCB0b0hleChuZXcgVWludDhBcnJheShub25jZSkpKTtcbiAgICAgICAgcmVxdWVzdC5yZXF1ZXN0LmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICAvLyBOb25jZSBvbmx5IG5lZWRzIHRvIGJlIGluc2VydGVkIGludG8gdGhlIGJvZHkgZm9yIGFzeW5jIGNhbGxzLCB0byBwcmV2ZW50IHJlcGxheSBhdHRhY2tzLlxuICAgICAgICBpZiAocmVxdWVzdC5lbmRwb2ludCA9PT0gXCJjYWxsXCIgLyogRW5kcG9pbnQuQ2FsbCAqLykge1xuICAgICAgICAgICAgcmVxdWVzdC5ib2R5Lm5vbmNlID0gbm9uY2VGbigpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgdHJhbnNmb3JtIHRoYXQgYWRkcyBhIGRlbGF5IChieSBkZWZhdWx0IDUgbWludXRlcykgdG8gdGhlIGV4cGlyeS5cbiAqXG4gKiBAcGFyYW0gZGVsYXlJbk1pbGxpc2Vjb25kcyBUaGUgZGVsYXkgdG8gYWRkIHRvIHRoZSBjYWxsIHRpbWUsIGluIG1pbGxpc2Vjb25kcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VFeHBpcnlUcmFuc2Zvcm0oZGVsYXlJbk1pbGxpc2Vjb25kcykge1xuICAgIHJldHVybiBhc3luYyAocmVxdWVzdCkgPT4ge1xuICAgICAgICByZXF1ZXN0LmJvZHkuaW5ncmVzc19leHBpcnkgPSBuZXcgRXhwaXJ5KGRlbGF5SW5NaWxsaXNlY29uZHMpO1xuICAgIH07XG59XG4vKipcbiAqIE1hcHMgdGhlIGRlZmF1bHQgZmV0Y2ggaGVhZGVycyBmaWVsZCB0byB0aGUgc2VyaWFsaXphYmxlIEh0dHBIZWFkZXJGaWVsZC5cbiAqXG4gKiBAcGFyYW0gaGVhZGVycyBGZXRjaCBkZWZpbml0aW9uIG9mIHRoZSBoZWFkZXJzIHR5cGVcbiAqIEByZXR1cm5zIGFycmF5IG9mIGhlYWRlciBmaWVsZHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGh0dHBIZWFkZXJzVHJhbnNmb3JtKGhlYWRlcnMpIHtcbiAgICBjb25zdCBoZWFkZXJGaWVsZHMgPSBbXTtcbiAgICBoZWFkZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgaGVhZGVyRmllbGRzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gaGVhZGVyRmllbGRzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNmb3Jtcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/agent/http/transforms.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/agent/http/types.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@dfinity/agent/lib/esm/agent/http/types.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SubmitRequestType: function() { return /* binding */ SubmitRequestType; },\n/* harmony export */   makeNonce: function() { return /* binding */ makeNonce; }\n/* harmony export */ });\n/* harmony import */ var _utils_random__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/random */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/utils/random.js\");\n\n// The types of values allowed in the `request_type` field for submit requests.\nvar SubmitRequestType;\n(function (SubmitRequestType) {\n    SubmitRequestType[\"Call\"] = \"call\";\n})(SubmitRequestType || (SubmitRequestType = {}));\n/**\n * Create a random Nonce, based on random values\n */\nfunction makeNonce() {\n    // Encode 128 bits.\n    const buffer = new ArrayBuffer(16);\n    const view = new DataView(buffer);\n    const rand1 = (0,_utils_random__WEBPACK_IMPORTED_MODULE_0__.randomNumber)();\n    const rand2 = (0,_utils_random__WEBPACK_IMPORTED_MODULE_0__.randomNumber)();\n    const rand3 = (0,_utils_random__WEBPACK_IMPORTED_MODULE_0__.randomNumber)();\n    const rand4 = (0,_utils_random__WEBPACK_IMPORTED_MODULE_0__.randomNumber)();\n    view.setUint32(0, rand1);\n    view.setUint32(4, rand2);\n    view.setUint32(8, rand3);\n    view.setUint32(12, rand4);\n    return buffer;\n}\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2FnZW50L2h0dHAvdHlwZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWtEO0FBQ2xEO0FBQ087QUFDUDtBQUNBO0FBQ0EsQ0FBQyw4Q0FBOEM7QUFDL0M7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMkRBQVk7QUFDOUIsa0JBQWtCLDJEQUFZO0FBQzlCLGtCQUFrQiwyREFBWTtBQUM5QixrQkFBa0IsMkRBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vYWdlbnQvaHR0cC90eXBlcy5qcz80YTRjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJhbmRvbU51bWJlciB9IGZyb20gJy4uLy4uL3V0aWxzL3JhbmRvbSc7XG4vLyBUaGUgdHlwZXMgb2YgdmFsdWVzIGFsbG93ZWQgaW4gdGhlIGByZXF1ZXN0X3R5cGVgIGZpZWxkIGZvciBzdWJtaXQgcmVxdWVzdHMuXG5leHBvcnQgdmFyIFN1Ym1pdFJlcXVlc3RUeXBlO1xuKGZ1bmN0aW9uIChTdWJtaXRSZXF1ZXN0VHlwZSkge1xuICAgIFN1Ym1pdFJlcXVlc3RUeXBlW1wiQ2FsbFwiXSA9IFwiY2FsbFwiO1xufSkoU3VibWl0UmVxdWVzdFR5cGUgfHwgKFN1Ym1pdFJlcXVlc3RUeXBlID0ge30pKTtcbi8qKlxuICogQ3JlYXRlIGEgcmFuZG9tIE5vbmNlLCBiYXNlZCBvbiByYW5kb20gdmFsdWVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlTm9uY2UoKSB7XG4gICAgLy8gRW5jb2RlIDEyOCBiaXRzLlxuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcigxNik7XG4gICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgIGNvbnN0IHJhbmQxID0gcmFuZG9tTnVtYmVyKCk7XG4gICAgY29uc3QgcmFuZDIgPSByYW5kb21OdW1iZXIoKTtcbiAgICBjb25zdCByYW5kMyA9IHJhbmRvbU51bWJlcigpO1xuICAgIGNvbnN0IHJhbmQ0ID0gcmFuZG9tTnVtYmVyKCk7XG4gICAgdmlldy5zZXRVaW50MzIoMCwgcmFuZDEpO1xuICAgIHZpZXcuc2V0VWludDMyKDQsIHJhbmQyKTtcbiAgICB2aWV3LnNldFVpbnQzMig4LCByYW5kMyk7XG4gICAgdmlldy5zZXRVaW50MzIoMTIsIHJhbmQ0KTtcbiAgICByZXR1cm4gYnVmZmVyO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/agent/http/types.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/agent/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@dfinity/agent/lib/esm/agent/index.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AgentHTTPResponseError: function() { return /* reexport safe */ _http_errors__WEBPACK_IMPORTED_MODULE_2__.AgentHTTPResponseError; },\n/* harmony export */   Expiry: function() { return /* reexport safe */ _http__WEBPACK_IMPORTED_MODULE_1__.Expiry; },\n/* harmony export */   HttpAgent: function() { return /* reexport safe */ _http__WEBPACK_IMPORTED_MODULE_1__.HttpAgent; },\n/* harmony export */   IC_ROOT_KEY: function() { return /* reexport safe */ _http__WEBPACK_IMPORTED_MODULE_1__.IC_ROOT_KEY; },\n/* harmony export */   IdentityInvalidError: function() { return /* reexport safe */ _http__WEBPACK_IMPORTED_MODULE_1__.IdentityInvalidError; },\n/* harmony export */   MANAGEMENT_CANISTER_ID: function() { return /* reexport safe */ _http__WEBPACK_IMPORTED_MODULE_1__.MANAGEMENT_CANISTER_ID; },\n/* harmony export */   ProxyAgent: function() { return /* reexport safe */ _proxy__WEBPACK_IMPORTED_MODULE_3__.ProxyAgent; },\n/* harmony export */   ProxyMessageKind: function() { return /* reexport safe */ _proxy__WEBPACK_IMPORTED_MODULE_3__.ProxyMessageKind; },\n/* harmony export */   ProxyStubAgent: function() { return /* reexport safe */ _proxy__WEBPACK_IMPORTED_MODULE_3__.ProxyStubAgent; },\n/* harmony export */   ReplicaRejectCode: function() { return /* reexport safe */ _api__WEBPACK_IMPORTED_MODULE_0__.ReplicaRejectCode; },\n/* harmony export */   RequestStatusResponseStatus: function() { return /* reexport safe */ _http__WEBPACK_IMPORTED_MODULE_1__.RequestStatusResponseStatus; },\n/* harmony export */   getDefaultAgent: function() { return /* binding */ getDefaultAgent; },\n/* harmony export */   httpHeadersTransform: function() { return /* reexport safe */ _http__WEBPACK_IMPORTED_MODULE_1__.httpHeadersTransform; },\n/* harmony export */   makeExpiryTransform: function() { return /* reexport safe */ _http__WEBPACK_IMPORTED_MODULE_1__.makeExpiryTransform; },\n/* harmony export */   makeNonce: function() { return /* reexport safe */ _http__WEBPACK_IMPORTED_MODULE_1__.makeNonce; },\n/* harmony export */   makeNonceTransform: function() { return /* reexport safe */ _http__WEBPACK_IMPORTED_MODULE_1__.makeNonceTransform; }\n/* harmony export */ });\n/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/agent/api.js\");\n/* harmony import */ var _http__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./http */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/agent/http/index.js\");\n/* harmony import */ var _http_errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./http/errors */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/agent/http/errors.js\");\n/* harmony import */ var _proxy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./proxy */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/agent/proxy.js\");\n\n\n\n\nfunction getDefaultAgent() {\n    const agent = typeof window === 'undefined'\n        ? typeof __webpack_require__.g === 'undefined'\n            ? typeof self === 'undefined'\n                ? undefined\n                : self.ic.agent\n            : __webpack_require__.g.ic.agent\n        : window.ic.agent;\n    if (!agent) {\n        throw new Error('No Agent could be found.');\n    }\n    return agent;\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2FnZW50L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXNCO0FBQ0M7QUFDTztBQUNOO0FBQ2pCO0FBQ1A7QUFDQSxpQkFBaUIscUJBQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxQkFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGRmaW5pdHkvYWdlbnQvbGliL2VzbS9hZ2VudC9pbmRleC5qcz9iODJkIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4vYXBpJztcbmV4cG9ydCAqIGZyb20gJy4vaHR0cCc7XG5leHBvcnQgKiBmcm9tICcuL2h0dHAvZXJyb3JzJztcbmV4cG9ydCAqIGZyb20gJy4vcHJveHknO1xuZXhwb3J0IGZ1bmN0aW9uIGdldERlZmF1bHRBZ2VudCgpIHtcbiAgICBjb25zdCBhZ2VudCA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gdHlwZW9mIGdsb2JhbCA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgID8gdHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA6IHNlbGYuaWMuYWdlbnRcbiAgICAgICAgICAgIDogZ2xvYmFsLmljLmFnZW50XG4gICAgICAgIDogd2luZG93LmljLmFnZW50O1xuICAgIGlmICghYWdlbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBBZ2VudCBjb3VsZCBiZSBmb3VuZC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGFnZW50O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/agent/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/agent/proxy.js":
/*!************************************************************!*\
  !*** ./node_modules/@dfinity/agent/lib/esm/agent/proxy.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ProxyAgent: function() { return /* binding */ ProxyAgent; },\n/* harmony export */   ProxyMessageKind: function() { return /* binding */ ProxyMessageKind; },\n/* harmony export */   ProxyStubAgent: function() { return /* binding */ ProxyStubAgent; }\n/* harmony export */ });\n/* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/principal */ \"(app-pages-browser)/./node_modules/@dfinity/principal/lib/esm/index.js\");\n\nvar ProxyMessageKind;\n(function (ProxyMessageKind) {\n    ProxyMessageKind[\"Error\"] = \"err\";\n    ProxyMessageKind[\"GetPrincipal\"] = \"gp\";\n    ProxyMessageKind[\"GetPrincipalResponse\"] = \"gpr\";\n    ProxyMessageKind[\"Query\"] = \"q\";\n    ProxyMessageKind[\"QueryResponse\"] = \"qr\";\n    ProxyMessageKind[\"Call\"] = \"c\";\n    ProxyMessageKind[\"CallResponse\"] = \"cr\";\n    ProxyMessageKind[\"ReadState\"] = \"rs\";\n    ProxyMessageKind[\"ReadStateResponse\"] = \"rsr\";\n    ProxyMessageKind[\"Status\"] = \"s\";\n    ProxyMessageKind[\"StatusResponse\"] = \"sr\";\n})(ProxyMessageKind || (ProxyMessageKind = {}));\n// A Stub Agent that forwards calls to another Agent implementation.\nclass ProxyStubAgent {\n    constructor(_frontend, _agent) {\n        this._frontend = _frontend;\n        this._agent = _agent;\n    }\n    onmessage(msg) {\n        switch (msg.type) {\n            case ProxyMessageKind.GetPrincipal:\n                this._agent.getPrincipal().then(response => {\n                    this._frontend({\n                        id: msg.id,\n                        type: ProxyMessageKind.GetPrincipalResponse,\n                        response: response.toText(),\n                    });\n                });\n                break;\n            case ProxyMessageKind.Query:\n                this._agent.query(...msg.args).then(response => {\n                    this._frontend({\n                        id: msg.id,\n                        type: ProxyMessageKind.QueryResponse,\n                        response,\n                    });\n                });\n                break;\n            case ProxyMessageKind.Call:\n                this._agent.call(...msg.args).then(response => {\n                    this._frontend({\n                        id: msg.id,\n                        type: ProxyMessageKind.CallResponse,\n                        response,\n                    });\n                });\n                break;\n            case ProxyMessageKind.ReadState:\n                this._agent.readState(...msg.args).then(response => {\n                    this._frontend({\n                        id: msg.id,\n                        type: ProxyMessageKind.ReadStateResponse,\n                        response,\n                    });\n                });\n                break;\n            case ProxyMessageKind.Status:\n                this._agent.status().then(response => {\n                    this._frontend({\n                        id: msg.id,\n                        type: ProxyMessageKind.StatusResponse,\n                        response,\n                    });\n                });\n                break;\n            default:\n                throw new Error(`Invalid message received: ${JSON.stringify(msg)}`);\n        }\n    }\n}\n// An Agent that forwards calls to a backend. The calls are serialized\nclass ProxyAgent {\n    constructor(_backend) {\n        this._backend = _backend;\n        this._nextId = 0;\n        this._pendingCalls = new Map();\n        this.rootKey = null;\n    }\n    onmessage(msg) {\n        const id = msg.id;\n        const maybePromise = this._pendingCalls.get(id);\n        if (!maybePromise) {\n            throw new Error('A proxy get the same message twice...');\n        }\n        this._pendingCalls.delete(id);\n        const [resolve, reject] = maybePromise;\n        switch (msg.type) {\n            case ProxyMessageKind.Error:\n                return reject(msg.error);\n            case ProxyMessageKind.GetPrincipalResponse:\n            case ProxyMessageKind.CallResponse:\n            case ProxyMessageKind.QueryResponse:\n            case ProxyMessageKind.ReadStateResponse:\n            case ProxyMessageKind.StatusResponse:\n                return resolve(msg.response);\n            default:\n                throw new Error(`Invalid message being sent to ProxyAgent: ${JSON.stringify(msg)}`);\n        }\n    }\n    async getPrincipal() {\n        return this._sendAndWait({\n            id: this._nextId++,\n            type: ProxyMessageKind.GetPrincipal,\n        }).then(principal => {\n            if (typeof principal !== 'string') {\n                throw new Error('Invalid principal received.');\n            }\n            return _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.fromText(principal);\n        });\n    }\n    readState(canisterId, fields) {\n        return this._sendAndWait({\n            id: this._nextId++,\n            type: ProxyMessageKind.ReadState,\n            args: [canisterId.toString(), fields],\n        });\n    }\n    call(canisterId, fields) {\n        return this._sendAndWait({\n            id: this._nextId++,\n            type: ProxyMessageKind.Call,\n            args: [canisterId.toString(), fields],\n        });\n    }\n    status() {\n        return this._sendAndWait({\n            id: this._nextId++,\n            type: ProxyMessageKind.Status,\n        });\n    }\n    query(canisterId, fields) {\n        return this._sendAndWait({\n            id: this._nextId++,\n            type: ProxyMessageKind.Query,\n            args: [canisterId.toString(), fields],\n        });\n    }\n    async _sendAndWait(msg) {\n        return new Promise((resolve, reject) => {\n            this._pendingCalls.set(msg.id, [resolve, reject]);\n            this._backend(msg);\n        });\n    }\n    async fetchRootKey() {\n        // Hex-encoded version of the replica root key\n        const rootKey = (await this.status()).root_key;\n        this.rootKey = rootKey;\n        return rootKey;\n    }\n}\n//# sourceMappingURL=proxy.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2FnZW50L3Byb3h5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBK0M7QUFDeEM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRDQUE0QztBQUM3QztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDZEQUE2RCxvQkFBb0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxvQkFBb0I7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5REFBUztBQUM1QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGRmaW5pdHkvYWdlbnQvbGliL2VzbS9hZ2VudC9wcm94eS5qcz85NTU4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFByaW5jaXBhbCB9IGZyb20gJ0BkZmluaXR5L3ByaW5jaXBhbCc7XG5leHBvcnQgdmFyIFByb3h5TWVzc2FnZUtpbmQ7XG4oZnVuY3Rpb24gKFByb3h5TWVzc2FnZUtpbmQpIHtcbiAgICBQcm94eU1lc3NhZ2VLaW5kW1wiRXJyb3JcIl0gPSBcImVyclwiO1xuICAgIFByb3h5TWVzc2FnZUtpbmRbXCJHZXRQcmluY2lwYWxcIl0gPSBcImdwXCI7XG4gICAgUHJveHlNZXNzYWdlS2luZFtcIkdldFByaW5jaXBhbFJlc3BvbnNlXCJdID0gXCJncHJcIjtcbiAgICBQcm94eU1lc3NhZ2VLaW5kW1wiUXVlcnlcIl0gPSBcInFcIjtcbiAgICBQcm94eU1lc3NhZ2VLaW5kW1wiUXVlcnlSZXNwb25zZVwiXSA9IFwicXJcIjtcbiAgICBQcm94eU1lc3NhZ2VLaW5kW1wiQ2FsbFwiXSA9IFwiY1wiO1xuICAgIFByb3h5TWVzc2FnZUtpbmRbXCJDYWxsUmVzcG9uc2VcIl0gPSBcImNyXCI7XG4gICAgUHJveHlNZXNzYWdlS2luZFtcIlJlYWRTdGF0ZVwiXSA9IFwicnNcIjtcbiAgICBQcm94eU1lc3NhZ2VLaW5kW1wiUmVhZFN0YXRlUmVzcG9uc2VcIl0gPSBcInJzclwiO1xuICAgIFByb3h5TWVzc2FnZUtpbmRbXCJTdGF0dXNcIl0gPSBcInNcIjtcbiAgICBQcm94eU1lc3NhZ2VLaW5kW1wiU3RhdHVzUmVzcG9uc2VcIl0gPSBcInNyXCI7XG59KShQcm94eU1lc3NhZ2VLaW5kIHx8IChQcm94eU1lc3NhZ2VLaW5kID0ge30pKTtcbi8vIEEgU3R1YiBBZ2VudCB0aGF0IGZvcndhcmRzIGNhbGxzIHRvIGFub3RoZXIgQWdlbnQgaW1wbGVtZW50YXRpb24uXG5leHBvcnQgY2xhc3MgUHJveHlTdHViQWdlbnQge1xuICAgIGNvbnN0cnVjdG9yKF9mcm9udGVuZCwgX2FnZW50KSB7XG4gICAgICAgIHRoaXMuX2Zyb250ZW5kID0gX2Zyb250ZW5kO1xuICAgICAgICB0aGlzLl9hZ2VudCA9IF9hZ2VudDtcbiAgICB9XG4gICAgb25tZXNzYWdlKG1zZykge1xuICAgICAgICBzd2l0Y2ggKG1zZy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFByb3h5TWVzc2FnZUtpbmQuR2V0UHJpbmNpcGFsOlxuICAgICAgICAgICAgICAgIHRoaXMuX2FnZW50LmdldFByaW5jaXBhbCgpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mcm9udGVuZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogbXNnLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogUHJveHlNZXNzYWdlS2luZC5HZXRQcmluY2lwYWxSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiByZXNwb25zZS50b1RleHQoKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFByb3h5TWVzc2FnZUtpbmQuUXVlcnk6XG4gICAgICAgICAgICAgICAgdGhpcy5fYWdlbnQucXVlcnkoLi4ubXNnLmFyZ3MpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mcm9udGVuZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogbXNnLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogUHJveHlNZXNzYWdlS2luZC5RdWVyeVJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBQcm94eU1lc3NhZ2VLaW5kLkNhbGw6XG4gICAgICAgICAgICAgICAgdGhpcy5fYWdlbnQuY2FsbCguLi5tc2cuYXJncykudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Zyb250ZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBtc2cuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBQcm94eU1lc3NhZ2VLaW5kLkNhbGxSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUHJveHlNZXNzYWdlS2luZC5SZWFkU3RhdGU6XG4gICAgICAgICAgICAgICAgdGhpcy5fYWdlbnQucmVhZFN0YXRlKC4uLm1zZy5hcmdzKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZnJvbnRlbmQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG1zZy5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFByb3h5TWVzc2FnZUtpbmQuUmVhZFN0YXRlUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFByb3h5TWVzc2FnZUtpbmQuU3RhdHVzOlxuICAgICAgICAgICAgICAgIHRoaXMuX2FnZW50LnN0YXR1cygpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mcm9udGVuZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogbXNnLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogUHJveHlNZXNzYWdlS2luZC5TdGF0dXNSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1lc3NhZ2UgcmVjZWl2ZWQ6ICR7SlNPTi5zdHJpbmdpZnkobXNnKX1gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIEFuIEFnZW50IHRoYXQgZm9yd2FyZHMgY2FsbHMgdG8gYSBiYWNrZW5kLiBUaGUgY2FsbHMgYXJlIHNlcmlhbGl6ZWRcbmV4cG9ydCBjbGFzcyBQcm94eUFnZW50IHtcbiAgICBjb25zdHJ1Y3RvcihfYmFja2VuZCkge1xuICAgICAgICB0aGlzLl9iYWNrZW5kID0gX2JhY2tlbmQ7XG4gICAgICAgIHRoaXMuX25leHRJZCA9IDA7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdDYWxscyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5yb290S2V5ID0gbnVsbDtcbiAgICB9XG4gICAgb25tZXNzYWdlKG1zZykge1xuICAgICAgICBjb25zdCBpZCA9IG1zZy5pZDtcbiAgICAgICAgY29uc3QgbWF5YmVQcm9taXNlID0gdGhpcy5fcGVuZGluZ0NhbGxzLmdldChpZCk7XG4gICAgICAgIGlmICghbWF5YmVQcm9taXNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgcHJveHkgZ2V0IHRoZSBzYW1lIG1lc3NhZ2UgdHdpY2UuLi4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wZW5kaW5nQ2FsbHMuZGVsZXRlKGlkKTtcbiAgICAgICAgY29uc3QgW3Jlc29sdmUsIHJlamVjdF0gPSBtYXliZVByb21pc2U7XG4gICAgICAgIHN3aXRjaCAobXNnLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgUHJveHlNZXNzYWdlS2luZC5FcnJvcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG1zZy5lcnJvcik7XG4gICAgICAgICAgICBjYXNlIFByb3h5TWVzc2FnZUtpbmQuR2V0UHJpbmNpcGFsUmVzcG9uc2U6XG4gICAgICAgICAgICBjYXNlIFByb3h5TWVzc2FnZUtpbmQuQ2FsbFJlc3BvbnNlOlxuICAgICAgICAgICAgY2FzZSBQcm94eU1lc3NhZ2VLaW5kLlF1ZXJ5UmVzcG9uc2U6XG4gICAgICAgICAgICBjYXNlIFByb3h5TWVzc2FnZUtpbmQuUmVhZFN0YXRlUmVzcG9uc2U6XG4gICAgICAgICAgICBjYXNlIFByb3h5TWVzc2FnZUtpbmQuU3RhdHVzUmVzcG9uc2U6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUobXNnLnJlc3BvbnNlKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1lc3NhZ2UgYmVpbmcgc2VudCB0byBQcm94eUFnZW50OiAke0pTT04uc3RyaW5naWZ5KG1zZyl9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0UHJpbmNpcGFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VuZEFuZFdhaXQoe1xuICAgICAgICAgICAgaWQ6IHRoaXMuX25leHRJZCsrLFxuICAgICAgICAgICAgdHlwZTogUHJveHlNZXNzYWdlS2luZC5HZXRQcmluY2lwYWwsXG4gICAgICAgIH0pLnRoZW4ocHJpbmNpcGFsID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJpbmNpcGFsICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcmluY2lwYWwgcmVjZWl2ZWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJpbmNpcGFsLmZyb21UZXh0KHByaW5jaXBhbCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZWFkU3RhdGUoY2FuaXN0ZXJJZCwgZmllbGRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZW5kQW5kV2FpdCh7XG4gICAgICAgICAgICBpZDogdGhpcy5fbmV4dElkKyssXG4gICAgICAgICAgICB0eXBlOiBQcm94eU1lc3NhZ2VLaW5kLlJlYWRTdGF0ZSxcbiAgICAgICAgICAgIGFyZ3M6IFtjYW5pc3RlcklkLnRvU3RyaW5nKCksIGZpZWxkc10sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYWxsKGNhbmlzdGVySWQsIGZpZWxkcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VuZEFuZFdhaXQoe1xuICAgICAgICAgICAgaWQ6IHRoaXMuX25leHRJZCsrLFxuICAgICAgICAgICAgdHlwZTogUHJveHlNZXNzYWdlS2luZC5DYWxsLFxuICAgICAgICAgICAgYXJnczogW2NhbmlzdGVySWQudG9TdHJpbmcoKSwgZmllbGRzXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXR1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbmRBbmRXYWl0KHtcbiAgICAgICAgICAgIGlkOiB0aGlzLl9uZXh0SWQrKyxcbiAgICAgICAgICAgIHR5cGU6IFByb3h5TWVzc2FnZUtpbmQuU3RhdHVzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcXVlcnkoY2FuaXN0ZXJJZCwgZmllbGRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZW5kQW5kV2FpdCh7XG4gICAgICAgICAgICBpZDogdGhpcy5fbmV4dElkKyssXG4gICAgICAgICAgICB0eXBlOiBQcm94eU1lc3NhZ2VLaW5kLlF1ZXJ5LFxuICAgICAgICAgICAgYXJnczogW2NhbmlzdGVySWQudG9TdHJpbmcoKSwgZmllbGRzXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIF9zZW5kQW5kV2FpdChtc2cpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdDYWxscy5zZXQobXNnLmlkLCBbcmVzb2x2ZSwgcmVqZWN0XSk7XG4gICAgICAgICAgICB0aGlzLl9iYWNrZW5kKG1zZyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaFJvb3RLZXkoKSB7XG4gICAgICAgIC8vIEhleC1lbmNvZGVkIHZlcnNpb24gb2YgdGhlIHJlcGxpY2Egcm9vdCBrZXlcbiAgICAgICAgY29uc3Qgcm9vdEtleSA9IChhd2FpdCB0aGlzLnN0YXR1cygpKS5yb290X2tleTtcbiAgICAgICAgdGhpcy5yb290S2V5ID0gcm9vdEtleTtcbiAgICAgICAgcmV0dXJuIHJvb3RLZXk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJveHkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/agent/proxy.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/auth.js":
/*!*****************************************************!*\
  !*** ./node_modules/@dfinity/agent/lib/esm/auth.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnonymousIdentity: function() { return /* binding */ AnonymousIdentity; },\n/* harmony export */   SignIdentity: function() { return /* binding */ SignIdentity; },\n/* harmony export */   createIdentityDescriptor: function() { return /* binding */ createIdentityDescriptor; }\n/* harmony export */ });\n/* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/principal */ \"(app-pages-browser)/./node_modules/@dfinity/principal/lib/esm/index.js\");\n/* harmony import */ var _request_id__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./request_id */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/request_id.js\");\n/* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/buffer */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/utils/buffer.js\");\nvar __rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n\n\n\nconst domainSeparator = new TextEncoder().encode('\\x0Aic-request');\n/**\n * An Identity that can sign blobs.\n */\nclass SignIdentity {\n    /**\n     * Get the principal represented by this identity. Normally should be a\n     * `Principal.selfAuthenticating()`.\n     */\n    getPrincipal() {\n        if (!this._principal) {\n            this._principal = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.selfAuthenticating(new Uint8Array(this.getPublicKey().toDer()));\n        }\n        return this._principal;\n    }\n    /**\n     * Transform a request into a signed version of the request. This is done last\n     * after the transforms on the body of a request. The returned object can be\n     * anything, but must be serializable to CBOR.\n     * @param request - internet computer request to transform\n     */\n    async transformRequest(request) {\n        const { body } = request, fields = __rest(request, [\"body\"]);\n        const requestId = await (0,_request_id__WEBPACK_IMPORTED_MODULE_1__.requestIdOf)(body);\n        return Object.assign(Object.assign({}, fields), { body: {\n                content: body,\n                sender_pubkey: this.getPublicKey().toDer(),\n                sender_sig: await this.sign((0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.concat)(domainSeparator, requestId)),\n            } });\n    }\n}\nclass AnonymousIdentity {\n    getPrincipal() {\n        return _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.anonymous();\n    }\n    async transformRequest(request) {\n        return Object.assign(Object.assign({}, request), { body: { content: request.body } });\n    }\n}\n/**\n * Create an IdentityDescriptor from a @dfinity/identity Identity\n * @param identity - identity describe in returned descriptor\n */\nfunction createIdentityDescriptor(identity) {\n    const identityIndicator = 'getPublicKey' in identity\n        ? { type: 'PublicKeyIdentity', publicKey: (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.toHex)(identity.getPublicKey().toDer()) }\n        : { type: 'AnonymousIdentity' };\n    return identityIndicator;\n}\n//# sourceMappingURL=auth.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2F1dGguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsY0FBYyxTQUFJLElBQUksU0FBSTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxjQUFjO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDK0M7QUFDSjtBQUNJO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIseURBQVM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixnQ0FBZ0Msd0RBQVc7QUFDM0MsNkNBQTZDLGFBQWE7QUFDMUQ7QUFDQTtBQUNBLDRDQUE0QyxxREFBTTtBQUNsRCxlQUFlO0FBQ2Y7QUFDQTtBQUNPO0FBQ1A7QUFDQSxlQUFlLHlEQUFTO0FBQ3hCO0FBQ0E7QUFDQSw2Q0FBNkMsY0FBYyxRQUFRLHlCQUF5QjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsWUFBWSxzQ0FBc0Msb0RBQUs7QUFDdkQsWUFBWTtBQUNaO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGRmaW5pdHkvYWdlbnQvbGliL2VzbS9hdXRoLmpzPzcwZjkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xuaW1wb3J0IHsgUHJpbmNpcGFsIH0gZnJvbSAnQGRmaW5pdHkvcHJpbmNpcGFsJztcbmltcG9ydCB7IHJlcXVlc3RJZE9mIH0gZnJvbSAnLi9yZXF1ZXN0X2lkJztcbmltcG9ydCB7IGNvbmNhdCwgdG9IZXggfSBmcm9tICcuL3V0aWxzL2J1ZmZlcic7XG5jb25zdCBkb21haW5TZXBhcmF0b3IgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoJ1xceDBBaWMtcmVxdWVzdCcpO1xuLyoqXG4gKiBBbiBJZGVudGl0eSB0aGF0IGNhbiBzaWduIGJsb2JzLlxuICovXG5leHBvcnQgY2xhc3MgU2lnbklkZW50aXR5IHtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHByaW5jaXBhbCByZXByZXNlbnRlZCBieSB0aGlzIGlkZW50aXR5LiBOb3JtYWxseSBzaG91bGQgYmUgYVxuICAgICAqIGBQcmluY2lwYWwuc2VsZkF1dGhlbnRpY2F0aW5nKClgLlxuICAgICAqL1xuICAgIGdldFByaW5jaXBhbCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wcmluY2lwYWwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaW5jaXBhbCA9IFByaW5jaXBhbC5zZWxmQXV0aGVudGljYXRpbmcobmV3IFVpbnQ4QXJyYXkodGhpcy5nZXRQdWJsaWNLZXkoKS50b0RlcigpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaW5jaXBhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtIGEgcmVxdWVzdCBpbnRvIGEgc2lnbmVkIHZlcnNpb24gb2YgdGhlIHJlcXVlc3QuIFRoaXMgaXMgZG9uZSBsYXN0XG4gICAgICogYWZ0ZXIgdGhlIHRyYW5zZm9ybXMgb24gdGhlIGJvZHkgb2YgYSByZXF1ZXN0LiBUaGUgcmV0dXJuZWQgb2JqZWN0IGNhbiBiZVxuICAgICAqIGFueXRoaW5nLCBidXQgbXVzdCBiZSBzZXJpYWxpemFibGUgdG8gQ0JPUi5cbiAgICAgKiBAcGFyYW0gcmVxdWVzdCAtIGludGVybmV0IGNvbXB1dGVyIHJlcXVlc3QgdG8gdHJhbnNmb3JtXG4gICAgICovXG4gICAgYXN5bmMgdHJhbnNmb3JtUmVxdWVzdChyZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IHsgYm9keSB9ID0gcmVxdWVzdCwgZmllbGRzID0gX19yZXN0KHJlcXVlc3QsIFtcImJvZHlcIl0pO1xuICAgICAgICBjb25zdCByZXF1ZXN0SWQgPSBhd2FpdCByZXF1ZXN0SWRPZihib2R5KTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZmllbGRzKSwgeyBib2R5OiB7XG4gICAgICAgICAgICAgICAgY29udGVudDogYm9keSxcbiAgICAgICAgICAgICAgICBzZW5kZXJfcHVia2V5OiB0aGlzLmdldFB1YmxpY0tleSgpLnRvRGVyKCksXG4gICAgICAgICAgICAgICAgc2VuZGVyX3NpZzogYXdhaXQgdGhpcy5zaWduKGNvbmNhdChkb21haW5TZXBhcmF0b3IsIHJlcXVlc3RJZCkpLFxuICAgICAgICAgICAgfSB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQW5vbnltb3VzSWRlbnRpdHkge1xuICAgIGdldFByaW5jaXBhbCgpIHtcbiAgICAgICAgcmV0dXJuIFByaW5jaXBhbC5hbm9ueW1vdXMoKTtcbiAgICB9XG4gICAgYXN5bmMgdHJhbnNmb3JtUmVxdWVzdChyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlcXVlc3QpLCB7IGJvZHk6IHsgY29udGVudDogcmVxdWVzdC5ib2R5IH0gfSk7XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGUgYW4gSWRlbnRpdHlEZXNjcmlwdG9yIGZyb20gYSBAZGZpbml0eS9pZGVudGl0eSBJZGVudGl0eVxuICogQHBhcmFtIGlkZW50aXR5IC0gaWRlbnRpdHkgZGVzY3JpYmUgaW4gcmV0dXJuZWQgZGVzY3JpcHRvclxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSWRlbnRpdHlEZXNjcmlwdG9yKGlkZW50aXR5KSB7XG4gICAgY29uc3QgaWRlbnRpdHlJbmRpY2F0b3IgPSAnZ2V0UHVibGljS2V5JyBpbiBpZGVudGl0eVxuICAgICAgICA/IHsgdHlwZTogJ1B1YmxpY0tleUlkZW50aXR5JywgcHVibGljS2V5OiB0b0hleChpZGVudGl0eS5nZXRQdWJsaWNLZXkoKS50b0RlcigpKSB9XG4gICAgICAgIDogeyB0eXBlOiAnQW5vbnltb3VzSWRlbnRpdHknIH07XG4gICAgcmV0dXJuIGlkZW50aXR5SW5kaWNhdG9yO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0aC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/auth.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/canisterStatus/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@dfinity/agent/lib/esm/canisterStatus/index.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CustomPath: function() { return /* binding */ CustomPath; },\n/* harmony export */   encodePath: function() { return /* binding */ encodePath; },\n/* harmony export */   fetchNodeKeys: function() { return /* binding */ fetchNodeKeys; },\n/* harmony export */   request: function() { return /* binding */ request; }\n/* harmony export */ });\n/* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/principal */ \"(app-pages-browser)/./node_modules/@dfinity/principal/lib/esm/index.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/errors.js\");\n/* harmony import */ var _certificate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../certificate */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/certificate.js\");\n/* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/buffer */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/utils/buffer.js\");\n/* harmony import */ var _cbor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../cbor */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/cbor.js\");\n/* harmony import */ var _utils_leb__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/leb */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/utils/leb.js\");\n/** @module CanisterStatus */\n\n\n\n\n\n\n/**\n * Interface to define a custom path. Nested paths will be represented as individual buffers, and can be created from text using TextEncoder.\n * @param {string} key the key to use to access the returned value in the canisterStatus map\n * @param {ArrayBuffer[]} path the path to the desired value, represented as an array of buffers\n * @param {string} decodeStrategy the strategy to use to decode the returned value\n */\nclass CustomPath {\n    constructor(key, path, decodeStrategy) {\n        this.key = key;\n        this.path = path;\n        this.decodeStrategy = decodeStrategy;\n    }\n}\n/**\n * Request information in the request_status state tree for a given canister.\n * Can be used to request information about the canister's controllers, time, module hash, candid interface, and more.\n * @param {CanisterStatusOptions} options {@link CanisterStatusOptions}\n * @param {CanisterStatusOptions['canisterId']} options.canisterId {@link Principal}\n * @param {CanisterStatusOptions['agent']} options.agent {@link HttpAgent} optional authenticated agent to use to make the canister request. Useful for accessing private metadata under icp:private\n * @param {CanisterStatusOptions['paths']} options.paths {@link Path[]}\n * @returns {Status} object populated with data from the requested paths\n * @example\n * const status = await canisterStatus({\n *   paths: ['controllers', 'candid'],\n *   ...options\n * });\n *\n * const controllers = status.get('controllers');\n */\nconst request = async (options) => {\n    const { agent, paths } = options;\n    const canisterId = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.from(options.canisterId);\n    const uniquePaths = [...new Set(paths)];\n    // Map path options to their correct formats\n    const encodedPaths = uniquePaths.map(path => {\n        return encodePath(path, canisterId);\n    });\n    const status = new Map();\n    const promises = uniquePaths.map((path, index) => {\n        return (async () => {\n            var _a;\n            try {\n                const response = await agent.readState(canisterId, {\n                    paths: [encodedPaths[index]],\n                });\n                const cert = await _certificate__WEBPACK_IMPORTED_MODULE_2__.Certificate.create({\n                    certificate: response.certificate,\n                    rootKey: agent.rootKey,\n                    canisterId: canisterId,\n                });\n                const lookup = (cert, path) => {\n                    if (path === 'subnet') {\n                        const data = fetchNodeKeys(response.certificate, canisterId, agent.rootKey);\n                        return {\n                            path: path,\n                            data,\n                        };\n                    }\n                    else {\n                        return {\n                            path: path,\n                            data: (0,_certificate__WEBPACK_IMPORTED_MODULE_2__.lookupResultToBuffer)(cert.lookup(encodePath(path, canisterId))),\n                        };\n                    }\n                };\n                // must pass in the rootKey if we have no delegation\n                const { path, data } = lookup(cert, uniquePaths[index]);\n                if (!data) {\n                    // Typically, the cert lookup will throw\n                    console.warn(`Expected to find result for path ${path}, but instead found nothing.`);\n                    if (typeof path === 'string') {\n                        status.set(path, null);\n                    }\n                    else {\n                        status.set(path.key, null);\n                    }\n                }\n                else {\n                    switch (path) {\n                        case 'time': {\n                            status.set(path, (0,_utils_leb__WEBPACK_IMPORTED_MODULE_5__.decodeTime)(data));\n                            break;\n                        }\n                        case 'controllers': {\n                            status.set(path, decodeControllers(data));\n                            break;\n                        }\n                        case 'module_hash': {\n                            status.set(path, decodeHex(data));\n                            break;\n                        }\n                        case 'subnet': {\n                            status.set(path, data);\n                            break;\n                        }\n                        case 'candid': {\n                            status.set(path, new TextDecoder().decode(data));\n                            break;\n                        }\n                        default: {\n                            // Check for CustomPath signature\n                            if (typeof path !== 'string' && 'key' in path && 'path' in path) {\n                                switch (path.decodeStrategy) {\n                                    case 'raw':\n                                        status.set(path.key, data);\n                                        break;\n                                    case 'leb128': {\n                                        status.set(path.key, (0,_utils_leb__WEBPACK_IMPORTED_MODULE_5__.decodeLeb128)(data));\n                                        break;\n                                    }\n                                    case 'cbor': {\n                                        status.set(path.key, decodeCbor(data));\n                                        break;\n                                    }\n                                    case 'hex': {\n                                        status.set(path.key, decodeHex(data));\n                                        break;\n                                    }\n                                    case 'utf-8': {\n                                        status.set(path.key, decodeUtf8(data));\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            catch (error) {\n                // Break on signature verification errors\n                if ((_a = error === null || error === void 0 ? void 0 : error.message) === null || _a === void 0 ? void 0 : _a.includes('Invalid certificate')) {\n                    throw new _errors__WEBPACK_IMPORTED_MODULE_1__.AgentError(error.message);\n                }\n                if (typeof path !== 'string' && 'key' in path && 'path' in path) {\n                    status.set(path.key, null);\n                }\n                else {\n                    status.set(path, null);\n                }\n                console.group();\n                console.warn(`Expected to find result for path ${path}, but instead found nothing.`);\n                console.warn(error);\n                console.groupEnd();\n            }\n        })();\n    });\n    // Fetch all values separately, as each option can fail\n    await Promise.all(promises);\n    return status;\n};\nconst fetchNodeKeys = (certificate, canisterId, root_key) => {\n    if (!canisterId._isPrincipal) {\n        throw new Error('Invalid canisterId');\n    }\n    const cert = _cbor__WEBPACK_IMPORTED_MODULE_4__.decode(new Uint8Array(certificate));\n    const tree = cert.tree;\n    let delegation = cert.delegation;\n    let subnetId;\n    if (delegation && delegation.subnet_id) {\n        subnetId = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.fromUint8Array(new Uint8Array(delegation.subnet_id));\n    }\n    // On local replica, with System type subnet, there is no delegation\n    else if (!delegation && typeof root_key !== 'undefined') {\n        subnetId = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.selfAuthenticating(new Uint8Array(root_key));\n        delegation = {\n            subnet_id: subnetId.toUint8Array(),\n            certificate: new ArrayBuffer(0),\n        };\n    }\n    // otherwise use default NNS subnet id\n    else {\n        subnetId = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.selfAuthenticating(_dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.fromText('tdb26-jop6k-aogll-7ltgs-eruif-6kk7m-qpktf-gdiqx-mxtrf-vb5e6-eqe').toUint8Array());\n        delegation = {\n            subnet_id: subnetId.toUint8Array(),\n            certificate: new ArrayBuffer(0),\n        };\n    }\n    const canisterInRange = (0,_certificate__WEBPACK_IMPORTED_MODULE_2__.check_canister_ranges)({ canisterId, subnetId, tree });\n    if (!canisterInRange) {\n        throw new Error('Canister not in range');\n    }\n    const subnetLookupResult = (0,_certificate__WEBPACK_IMPORTED_MODULE_2__.lookup_path)(['subnet', delegation.subnet_id, 'node'], tree);\n    if (subnetLookupResult.status !== _certificate__WEBPACK_IMPORTED_MODULE_2__.LookupStatus.Found) {\n        throw new Error('Node not found');\n    }\n    if (subnetLookupResult.value instanceof ArrayBuffer) {\n        throw new Error('Invalid node tree');\n    }\n    const nodeForks = (0,_certificate__WEBPACK_IMPORTED_MODULE_2__.flatten_forks)(subnetLookupResult.value);\n    const nodeKeys = new Map();\n    nodeForks.forEach(fork => {\n        const node_id = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.from(new Uint8Array(fork[1])).toText();\n        const publicKeyLookupResult = (0,_certificate__WEBPACK_IMPORTED_MODULE_2__.lookup_path)(['public_key'], fork[2]);\n        if (publicKeyLookupResult.status !== _certificate__WEBPACK_IMPORTED_MODULE_2__.LookupStatus.Found) {\n            throw new Error('Public key not found');\n        }\n        const derEncodedPublicKey = publicKeyLookupResult.value;\n        if (derEncodedPublicKey.byteLength !== 44) {\n            throw new Error('Invalid public key length');\n        }\n        else {\n            nodeKeys.set(node_id, derEncodedPublicKey);\n        }\n    });\n    return {\n        subnetId: _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.fromUint8Array(new Uint8Array(delegation.subnet_id)).toText(),\n        nodeKeys,\n    };\n};\nconst encodePath = (path, canisterId) => {\n    const encoder = new TextEncoder();\n    const encode = (arg) => {\n        return new DataView(encoder.encode(arg).buffer).buffer;\n    };\n    const canisterBuffer = new DataView(canisterId.toUint8Array().buffer).buffer;\n    switch (path) {\n        case 'time':\n            return [encode('time')];\n        case 'controllers':\n            return [encode('canister'), canisterBuffer, encode('controllers')];\n        case 'module_hash':\n            return [encode('canister'), canisterBuffer, encode('module_hash')];\n        case 'subnet':\n            return [encode('subnet')];\n        case 'candid':\n            return [encode('canister'), canisterBuffer, encode('metadata'), encode('candid:service')];\n        default: {\n            // Check for CustomPath signature\n            if ('key' in path && 'path' in path) {\n                // For simplified metadata queries\n                if (typeof path['path'] === 'string' || path['path'] instanceof ArrayBuffer) {\n                    const metaPath = path.path;\n                    const encoded = typeof metaPath === 'string' ? encode(metaPath) : metaPath;\n                    return [encode('canister'), canisterBuffer, encode('metadata'), encoded];\n                    // For non-metadata, return the provided custompath\n                }\n                else {\n                    return path['path'];\n                }\n            }\n        }\n    }\n    throw new Error(`An unexpeected error was encountered while encoding your path for canister status. Please ensure that your path, ${path} was formatted correctly.`);\n};\nconst decodeHex = (buf) => {\n    return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.toHex)(buf);\n};\nconst decodeCbor = (buf) => {\n    return _cbor__WEBPACK_IMPORTED_MODULE_4__.decode(buf);\n};\nconst decodeUtf8 = (buf) => {\n    return new TextDecoder().decode(buf);\n};\n// Controllers are CBOR-encoded buffers\nconst decodeControllers = (buf) => {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const controllersRaw = decodeCbor(buf);\n    return controllersRaw.map((buf) => {\n        return _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.fromUint8Array(new Uint8Array(buf));\n    });\n};\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2NhbmlzdGVyU3RhdHVzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUMrQztBQUNSO0FBQzhGO0FBQzdGO0FBQ1I7QUFDd0I7QUFDeEQ7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QixTQUFTO0FBQzNDLFdBQVcscUNBQXFDLG9CQUFvQjtBQUNwRSxXQUFXLGdDQUFnQyxlQUFlLGlCQUFpQjtBQUMzRSxXQUFXLGdDQUFnQyxlQUFlO0FBQzFELGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksZUFBZTtBQUMzQix1QkFBdUIseURBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsbUNBQW1DLHFEQUFXO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtFQUFvQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7QUFDQSxxRUFBcUUsS0FBSztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxzREFBVTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELHdEQUFZO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLCtDQUFVO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsS0FBSztBQUN0RTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUNBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseURBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlEQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlEQUFTLG9CQUFvQix5REFBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1FQUFxQixHQUFHLDRCQUE0QjtBQUNoRjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IseURBQVc7QUFDMUMsc0NBQXNDLHNEQUFZO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkRBQWE7QUFDbkM7QUFDQTtBQUNBLHdCQUF3Qix5REFBUztBQUNqQyxzQ0FBc0MseURBQVc7QUFDakQsNkNBQTZDLHNEQUFZO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGtCQUFrQix5REFBUztBQUMzQjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3SUFBd0ksTUFBTTtBQUM5STtBQUNBO0FBQ0EsV0FBVyxvREFBSztBQUNoQjtBQUNBO0FBQ0EsV0FBVyx5Q0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlEQUFTO0FBQ3hCLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2NhbmlzdGVyU3RhdHVzL2luZGV4LmpzP2Q3ZGQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBtb2R1bGUgQ2FuaXN0ZXJTdGF0dXMgKi9cbmltcG9ydCB7IFByaW5jaXBhbCB9IGZyb20gJ0BkZmluaXR5L3ByaW5jaXBhbCc7XG5pbXBvcnQgeyBBZ2VudEVycm9yIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IENlcnRpZmljYXRlLCBmbGF0dGVuX2ZvcmtzLCBjaGVja19jYW5pc3Rlcl9yYW5nZXMsIExvb2t1cFN0YXR1cywgbG9va3VwX3BhdGgsIGxvb2t1cFJlc3VsdFRvQnVmZmVyLCB9IGZyb20gJy4uL2NlcnRpZmljYXRlJztcbmltcG9ydCB7IHRvSGV4IH0gZnJvbSAnLi4vdXRpbHMvYnVmZmVyJztcbmltcG9ydCAqIGFzIENib3IgZnJvbSAnLi4vY2Jvcic7XG5pbXBvcnQgeyBkZWNvZGVMZWIxMjgsIGRlY29kZVRpbWUgfSBmcm9tICcuLi91dGlscy9sZWInO1xuLyoqXG4gKiBJbnRlcmZhY2UgdG8gZGVmaW5lIGEgY3VzdG9tIHBhdGguIE5lc3RlZCBwYXRocyB3aWxsIGJlIHJlcHJlc2VudGVkIGFzIGluZGl2aWR1YWwgYnVmZmVycywgYW5kIGNhbiBiZSBjcmVhdGVkIGZyb20gdGV4dCB1c2luZyBUZXh0RW5jb2Rlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdGhlIGtleSB0byB1c2UgdG8gYWNjZXNzIHRoZSByZXR1cm5lZCB2YWx1ZSBpbiB0aGUgY2FuaXN0ZXJTdGF0dXMgbWFwXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyW119IHBhdGggdGhlIHBhdGggdG8gdGhlIGRlc2lyZWQgdmFsdWUsIHJlcHJlc2VudGVkIGFzIGFuIGFycmF5IG9mIGJ1ZmZlcnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBkZWNvZGVTdHJhdGVneSB0aGUgc3RyYXRlZ3kgdG8gdXNlIHRvIGRlY29kZSB0aGUgcmV0dXJuZWQgdmFsdWVcbiAqL1xuZXhwb3J0IGNsYXNzIEN1c3RvbVBhdGgge1xuICAgIGNvbnN0cnVjdG9yKGtleSwgcGF0aCwgZGVjb2RlU3RyYXRlZ3kpIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMuZGVjb2RlU3RyYXRlZ3kgPSBkZWNvZGVTdHJhdGVneTtcbiAgICB9XG59XG4vKipcbiAqIFJlcXVlc3QgaW5mb3JtYXRpb24gaW4gdGhlIHJlcXVlc3Rfc3RhdHVzIHN0YXRlIHRyZWUgZm9yIGEgZ2l2ZW4gY2FuaXN0ZXIuXG4gKiBDYW4gYmUgdXNlZCB0byByZXF1ZXN0IGluZm9ybWF0aW9uIGFib3V0IHRoZSBjYW5pc3RlcidzIGNvbnRyb2xsZXJzLCB0aW1lLCBtb2R1bGUgaGFzaCwgY2FuZGlkIGludGVyZmFjZSwgYW5kIG1vcmUuXG4gKiBAcGFyYW0ge0NhbmlzdGVyU3RhdHVzT3B0aW9uc30gb3B0aW9ucyB7QGxpbmsgQ2FuaXN0ZXJTdGF0dXNPcHRpb25zfVxuICogQHBhcmFtIHtDYW5pc3RlclN0YXR1c09wdGlvbnNbJ2NhbmlzdGVySWQnXX0gb3B0aW9ucy5jYW5pc3RlcklkIHtAbGluayBQcmluY2lwYWx9XG4gKiBAcGFyYW0ge0NhbmlzdGVyU3RhdHVzT3B0aW9uc1snYWdlbnQnXX0gb3B0aW9ucy5hZ2VudCB7QGxpbmsgSHR0cEFnZW50fSBvcHRpb25hbCBhdXRoZW50aWNhdGVkIGFnZW50IHRvIHVzZSB0byBtYWtlIHRoZSBjYW5pc3RlciByZXF1ZXN0LiBVc2VmdWwgZm9yIGFjY2Vzc2luZyBwcml2YXRlIG1ldGFkYXRhIHVuZGVyIGljcDpwcml2YXRlXG4gKiBAcGFyYW0ge0NhbmlzdGVyU3RhdHVzT3B0aW9uc1sncGF0aHMnXX0gb3B0aW9ucy5wYXRocyB7QGxpbmsgUGF0aFtdfVxuICogQHJldHVybnMge1N0YXR1c30gb2JqZWN0IHBvcHVsYXRlZCB3aXRoIGRhdGEgZnJvbSB0aGUgcmVxdWVzdGVkIHBhdGhzXG4gKiBAZXhhbXBsZVxuICogY29uc3Qgc3RhdHVzID0gYXdhaXQgY2FuaXN0ZXJTdGF0dXMoe1xuICogICBwYXRoczogWydjb250cm9sbGVycycsICdjYW5kaWQnXSxcbiAqICAgLi4ub3B0aW9uc1xuICogfSk7XG4gKlxuICogY29uc3QgY29udHJvbGxlcnMgPSBzdGF0dXMuZ2V0KCdjb250cm9sbGVycycpO1xuICovXG5leHBvcnQgY29uc3QgcmVxdWVzdCA9IGFzeW5jIChvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgeyBhZ2VudCwgcGF0aHMgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgY2FuaXN0ZXJJZCA9IFByaW5jaXBhbC5mcm9tKG9wdGlvbnMuY2FuaXN0ZXJJZCk7XG4gICAgY29uc3QgdW5pcXVlUGF0aHMgPSBbLi4ubmV3IFNldChwYXRocyldO1xuICAgIC8vIE1hcCBwYXRoIG9wdGlvbnMgdG8gdGhlaXIgY29ycmVjdCBmb3JtYXRzXG4gICAgY29uc3QgZW5jb2RlZFBhdGhzID0gdW5pcXVlUGF0aHMubWFwKHBhdGggPT4ge1xuICAgICAgICByZXR1cm4gZW5jb2RlUGF0aChwYXRoLCBjYW5pc3RlcklkKTtcbiAgICB9KTtcbiAgICBjb25zdCBzdGF0dXMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgcHJvbWlzZXMgPSB1bmlxdWVQYXRocy5tYXAoKHBhdGgsIGluZGV4KSA9PiB7XG4gICAgICAgIHJldHVybiAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFnZW50LnJlYWRTdGF0ZShjYW5pc3RlcklkLCB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhzOiBbZW5jb2RlZFBhdGhzW2luZGV4XV0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2VydCA9IGF3YWl0IENlcnRpZmljYXRlLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGNlcnRpZmljYXRlOiByZXNwb25zZS5jZXJ0aWZpY2F0ZSxcbiAgICAgICAgICAgICAgICAgICAgcm9vdEtleTogYWdlbnQucm9vdEtleSxcbiAgICAgICAgICAgICAgICAgICAgY2FuaXN0ZXJJZDogY2FuaXN0ZXJJZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb29rdXAgPSAoY2VydCwgcGF0aCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGF0aCA9PT0gJ3N1Ym5ldCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBmZXRjaE5vZGVLZXlzKHJlc3BvbnNlLmNlcnRpZmljYXRlLCBjYW5pc3RlcklkLCBhZ2VudC5yb290S2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBsb29rdXBSZXN1bHRUb0J1ZmZlcihjZXJ0Lmxvb2t1cChlbmNvZGVQYXRoKHBhdGgsIGNhbmlzdGVySWQpKSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBtdXN0IHBhc3MgaW4gdGhlIHJvb3RLZXkgaWYgd2UgaGF2ZSBubyBkZWxlZ2F0aW9uXG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYXRoLCBkYXRhIH0gPSBsb29rdXAoY2VydCwgdW5pcXVlUGF0aHNbaW5kZXhdKTtcbiAgICAgICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVHlwaWNhbGx5LCB0aGUgY2VydCBsb29rdXAgd2lsbCB0aHJvd1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEV4cGVjdGVkIHRvIGZpbmQgcmVzdWx0IGZvciBwYXRoICR7cGF0aH0sIGJ1dCBpbnN0ZWFkIGZvdW5kIG5vdGhpbmcuYCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cy5zZXQocGF0aCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMuc2V0KHBhdGgua2V5LCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd0aW1lJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cy5zZXQocGF0aCwgZGVjb2RlVGltZShkYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjb250cm9sbGVycyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMuc2V0KHBhdGgsIGRlY29kZUNvbnRyb2xsZXJzKGRhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ21vZHVsZV9oYXNoJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cy5zZXQocGF0aCwgZGVjb2RlSGV4KGRhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N1Ym5ldCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMuc2V0KHBhdGgsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2FuZGlkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cy5zZXQocGF0aCwgbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGRhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgQ3VzdG9tUGF0aCBzaWduYXR1cmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnICYmICdrZXknIGluIHBhdGggJiYgJ3BhdGgnIGluIHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChwYXRoLmRlY29kZVN0cmF0ZWd5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdyYXcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cy5zZXQocGF0aC5rZXksIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbGViMTI4Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cy5zZXQocGF0aC5rZXksIGRlY29kZUxlYjEyOChkYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjYm9yJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cy5zZXQocGF0aC5rZXksIGRlY29kZUNib3IoZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnaGV4Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cy5zZXQocGF0aC5rZXksIGRlY29kZUhleChkYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd1dGYtOCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMuc2V0KHBhdGgua2V5LCBkZWNvZGVVdGY4KGRhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIEJyZWFrIG9uIHNpZ25hdHVyZSB2ZXJpZmljYXRpb24gZXJyb3JzXG4gICAgICAgICAgICAgICAgaWYgKChfYSA9IGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5tZXNzYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5jbHVkZXMoJ0ludmFsaWQgY2VydGlmaWNhdGUnKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQWdlbnRFcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJyAmJiAna2V5JyBpbiBwYXRoICYmICdwYXRoJyBpbiBwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5zZXQocGF0aC5rZXksIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLnNldChwYXRoLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS5ncm91cCgpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgRXhwZWN0ZWQgdG8gZmluZCByZXN1bHQgZm9yIHBhdGggJHtwYXRofSwgYnV0IGluc3RlYWQgZm91bmQgbm90aGluZy5gKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oZXJyb3IpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICB9KTtcbiAgICAvLyBGZXRjaCBhbGwgdmFsdWVzIHNlcGFyYXRlbHksIGFzIGVhY2ggb3B0aW9uIGNhbiBmYWlsXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIHJldHVybiBzdGF0dXM7XG59O1xuZXhwb3J0IGNvbnN0IGZldGNoTm9kZUtleXMgPSAoY2VydGlmaWNhdGUsIGNhbmlzdGVySWQsIHJvb3Rfa2V5KSA9PiB7XG4gICAgaWYgKCFjYW5pc3RlcklkLl9pc1ByaW5jaXBhbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY2FuaXN0ZXJJZCcpO1xuICAgIH1cbiAgICBjb25zdCBjZXJ0ID0gQ2Jvci5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoY2VydGlmaWNhdGUpKTtcbiAgICBjb25zdCB0cmVlID0gY2VydC50cmVlO1xuICAgIGxldCBkZWxlZ2F0aW9uID0gY2VydC5kZWxlZ2F0aW9uO1xuICAgIGxldCBzdWJuZXRJZDtcbiAgICBpZiAoZGVsZWdhdGlvbiAmJiBkZWxlZ2F0aW9uLnN1Ym5ldF9pZCkge1xuICAgICAgICBzdWJuZXRJZCA9IFByaW5jaXBhbC5mcm9tVWludDhBcnJheShuZXcgVWludDhBcnJheShkZWxlZ2F0aW9uLnN1Ym5ldF9pZCkpO1xuICAgIH1cbiAgICAvLyBPbiBsb2NhbCByZXBsaWNhLCB3aXRoIFN5c3RlbSB0eXBlIHN1Ym5ldCwgdGhlcmUgaXMgbm8gZGVsZWdhdGlvblxuICAgIGVsc2UgaWYgKCFkZWxlZ2F0aW9uICYmIHR5cGVvZiByb290X2tleSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc3VibmV0SWQgPSBQcmluY2lwYWwuc2VsZkF1dGhlbnRpY2F0aW5nKG5ldyBVaW50OEFycmF5KHJvb3Rfa2V5KSk7XG4gICAgICAgIGRlbGVnYXRpb24gPSB7XG4gICAgICAgICAgICBzdWJuZXRfaWQ6IHN1Ym5ldElkLnRvVWludDhBcnJheSgpLFxuICAgICAgICAgICAgY2VydGlmaWNhdGU6IG5ldyBBcnJheUJ1ZmZlcigwKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gb3RoZXJ3aXNlIHVzZSBkZWZhdWx0IE5OUyBzdWJuZXQgaWRcbiAgICBlbHNlIHtcbiAgICAgICAgc3VibmV0SWQgPSBQcmluY2lwYWwuc2VsZkF1dGhlbnRpY2F0aW5nKFByaW5jaXBhbC5mcm9tVGV4dCgndGRiMjYtam9wNmstYW9nbGwtN2x0Z3MtZXJ1aWYtNmtrN20tcXBrdGYtZ2RpcXgtbXh0cmYtdmI1ZTYtZXFlJykudG9VaW50OEFycmF5KCkpO1xuICAgICAgICBkZWxlZ2F0aW9uID0ge1xuICAgICAgICAgICAgc3VibmV0X2lkOiBzdWJuZXRJZC50b1VpbnQ4QXJyYXkoKSxcbiAgICAgICAgICAgIGNlcnRpZmljYXRlOiBuZXcgQXJyYXlCdWZmZXIoMCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGNhbmlzdGVySW5SYW5nZSA9IGNoZWNrX2NhbmlzdGVyX3Jhbmdlcyh7IGNhbmlzdGVySWQsIHN1Ym5ldElkLCB0cmVlIH0pO1xuICAgIGlmICghY2FuaXN0ZXJJblJhbmdlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuaXN0ZXIgbm90IGluIHJhbmdlJyk7XG4gICAgfVxuICAgIGNvbnN0IHN1Ym5ldExvb2t1cFJlc3VsdCA9IGxvb2t1cF9wYXRoKFsnc3VibmV0JywgZGVsZWdhdGlvbi5zdWJuZXRfaWQsICdub2RlJ10sIHRyZWUpO1xuICAgIGlmIChzdWJuZXRMb29rdXBSZXN1bHQuc3RhdHVzICE9PSBMb29rdXBTdGF0dXMuRm91bmQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb2RlIG5vdCBmb3VuZCcpO1xuICAgIH1cbiAgICBpZiAoc3VibmV0TG9va3VwUmVzdWx0LnZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG5vZGUgdHJlZScpO1xuICAgIH1cbiAgICBjb25zdCBub2RlRm9ya3MgPSBmbGF0dGVuX2ZvcmtzKHN1Ym5ldExvb2t1cFJlc3VsdC52YWx1ZSk7XG4gICAgY29uc3Qgbm9kZUtleXMgPSBuZXcgTWFwKCk7XG4gICAgbm9kZUZvcmtzLmZvckVhY2goZm9yayA9PiB7XG4gICAgICAgIGNvbnN0IG5vZGVfaWQgPSBQcmluY2lwYWwuZnJvbShuZXcgVWludDhBcnJheShmb3JrWzFdKSkudG9UZXh0KCk7XG4gICAgICAgIGNvbnN0IHB1YmxpY0tleUxvb2t1cFJlc3VsdCA9IGxvb2t1cF9wYXRoKFsncHVibGljX2tleSddLCBmb3JrWzJdKTtcbiAgICAgICAgaWYgKHB1YmxpY0tleUxvb2t1cFJlc3VsdC5zdGF0dXMgIT09IExvb2t1cFN0YXR1cy5Gb3VuZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQdWJsaWMga2V5IG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlckVuY29kZWRQdWJsaWNLZXkgPSBwdWJsaWNLZXlMb29rdXBSZXN1bHQudmFsdWU7XG4gICAgICAgIGlmIChkZXJFbmNvZGVkUHVibGljS2V5LmJ5dGVMZW5ndGggIT09IDQ0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHVibGljIGtleSBsZW5ndGgnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vZGVLZXlzLnNldChub2RlX2lkLCBkZXJFbmNvZGVkUHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN1Ym5ldElkOiBQcmluY2lwYWwuZnJvbVVpbnQ4QXJyYXkobmV3IFVpbnQ4QXJyYXkoZGVsZWdhdGlvbi5zdWJuZXRfaWQpKS50b1RleHQoKSxcbiAgICAgICAgbm9kZUtleXMsXG4gICAgfTtcbn07XG5leHBvcnQgY29uc3QgZW5jb2RlUGF0aCA9IChwYXRoLCBjYW5pc3RlcklkKSA9PiB7XG4gICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIGNvbnN0IGVuY29kZSA9IChhcmcpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRhVmlldyhlbmNvZGVyLmVuY29kZShhcmcpLmJ1ZmZlcikuYnVmZmVyO1xuICAgIH07XG4gICAgY29uc3QgY2FuaXN0ZXJCdWZmZXIgPSBuZXcgRGF0YVZpZXcoY2FuaXN0ZXJJZC50b1VpbnQ4QXJyYXkoKS5idWZmZXIpLmJ1ZmZlcjtcbiAgICBzd2l0Y2ggKHBhdGgpIHtcbiAgICAgICAgY2FzZSAndGltZSc6XG4gICAgICAgICAgICByZXR1cm4gW2VuY29kZSgndGltZScpXTtcbiAgICAgICAgY2FzZSAnY29udHJvbGxlcnMnOlxuICAgICAgICAgICAgcmV0dXJuIFtlbmNvZGUoJ2NhbmlzdGVyJyksIGNhbmlzdGVyQnVmZmVyLCBlbmNvZGUoJ2NvbnRyb2xsZXJzJyldO1xuICAgICAgICBjYXNlICdtb2R1bGVfaGFzaCc6XG4gICAgICAgICAgICByZXR1cm4gW2VuY29kZSgnY2FuaXN0ZXInKSwgY2FuaXN0ZXJCdWZmZXIsIGVuY29kZSgnbW9kdWxlX2hhc2gnKV07XG4gICAgICAgIGNhc2UgJ3N1Ym5ldCc6XG4gICAgICAgICAgICByZXR1cm4gW2VuY29kZSgnc3VibmV0JyldO1xuICAgICAgICBjYXNlICdjYW5kaWQnOlxuICAgICAgICAgICAgcmV0dXJuIFtlbmNvZGUoJ2NhbmlzdGVyJyksIGNhbmlzdGVyQnVmZmVyLCBlbmNvZGUoJ21ldGFkYXRhJyksIGVuY29kZSgnY2FuZGlkOnNlcnZpY2UnKV07XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBDdXN0b21QYXRoIHNpZ25hdHVyZVxuICAgICAgICAgICAgaWYgKCdrZXknIGluIHBhdGggJiYgJ3BhdGgnIGluIHBhdGgpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3Igc2ltcGxpZmllZCBtZXRhZGF0YSBxdWVyaWVzXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXRoWydwYXRoJ10gPT09ICdzdHJpbmcnIHx8IHBhdGhbJ3BhdGgnXSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFQYXRoID0gcGF0aC5wYXRoO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmNvZGVkID0gdHlwZW9mIG1ldGFQYXRoID09PSAnc3RyaW5nJyA/IGVuY29kZShtZXRhUGF0aCkgOiBtZXRhUGF0aDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtlbmNvZGUoJ2NhbmlzdGVyJyksIGNhbmlzdGVyQnVmZmVyLCBlbmNvZGUoJ21ldGFkYXRhJyksIGVuY29kZWRdO1xuICAgICAgICAgICAgICAgICAgICAvLyBGb3Igbm9uLW1ldGFkYXRhLCByZXR1cm4gdGhlIHByb3ZpZGVkIGN1c3RvbXBhdGhcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXRoWydwYXRoJ107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgQW4gdW5leHBlZWN0ZWQgZXJyb3Igd2FzIGVuY291bnRlcmVkIHdoaWxlIGVuY29kaW5nIHlvdXIgcGF0aCBmb3IgY2FuaXN0ZXIgc3RhdHVzLiBQbGVhc2UgZW5zdXJlIHRoYXQgeW91ciBwYXRoLCAke3BhdGh9IHdhcyBmb3JtYXR0ZWQgY29ycmVjdGx5LmApO1xufTtcbmNvbnN0IGRlY29kZUhleCA9IChidWYpID0+IHtcbiAgICByZXR1cm4gdG9IZXgoYnVmKTtcbn07XG5jb25zdCBkZWNvZGVDYm9yID0gKGJ1ZikgPT4ge1xuICAgIHJldHVybiBDYm9yLmRlY29kZShidWYpO1xufTtcbmNvbnN0IGRlY29kZVV0ZjggPSAoYnVmKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShidWYpO1xufTtcbi8vIENvbnRyb2xsZXJzIGFyZSBDQk9SLWVuY29kZWQgYnVmZmVyc1xuY29uc3QgZGVjb2RlQ29udHJvbGxlcnMgPSAoYnVmKSA9PiB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGNvbnN0IGNvbnRyb2xsZXJzUmF3ID0gZGVjb2RlQ2JvcihidWYpO1xuICAgIHJldHVybiBjb250cm9sbGVyc1Jhdy5tYXAoKGJ1ZikgPT4ge1xuICAgICAgICByZXR1cm4gUHJpbmNpcGFsLmZyb21VaW50OEFycmF5KG5ldyBVaW50OEFycmF5KGJ1ZikpO1xuICAgIH0pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/canisterStatus/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/canisters/asset.js":
/*!****************************************************************!*\
  !*** ./node_modules/@dfinity/agent/lib/esm/canisters/asset.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createAssetCanisterActor: function() { return /* binding */ createAssetCanisterActor; }\n/* harmony export */ });\n/* harmony import */ var _actor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../actor */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/actor.js\");\n/* harmony import */ var _asset_idl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./asset_idl */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/canisters/asset_idl.js\");\n\n\n/**\n * Create a management canister actor.\n * @param config\n */\nfunction createAssetCanisterActor(config) {\n    return _actor__WEBPACK_IMPORTED_MODULE_0__.Actor.createActor(_asset_idl__WEBPACK_IMPORTED_MODULE_1__[\"default\"], config);\n}\n//# sourceMappingURL=asset.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2NhbmlzdGVycy9hc3NldC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBaUM7QUFDTztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyx5Q0FBSyxhQUFhLGtEQUFhO0FBQzFDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vY2FuaXN0ZXJzL2Fzc2V0LmpzP2Y5MzEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWN0b3IgfSBmcm9tICcuLi9hY3Rvcic7XG5pbXBvcnQgYXNzZXRDYW5pc3RlciBmcm9tICcuL2Fzc2V0X2lkbCc7XG4vKipcbiAqIENyZWF0ZSBhIG1hbmFnZW1lbnQgY2FuaXN0ZXIgYWN0b3IuXG4gKiBAcGFyYW0gY29uZmlnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBc3NldENhbmlzdGVyQWN0b3IoY29uZmlnKSB7XG4gICAgcmV0dXJuIEFjdG9yLmNyZWF0ZUFjdG9yKGFzc2V0Q2FuaXN0ZXIsIGNvbmZpZyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3NldC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/canisters/asset.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/canisters/asset_idl.js":
/*!********************************************************************!*\
  !*** ./node_modules/@dfinity/agent/lib/esm/canisters/asset_idl.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/**\n * This file is generated from the candid for asset management.\n */\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\n/* harmony default export */ __webpack_exports__[\"default\"] = (({ IDL }) => {\n    return IDL.Service({\n        retrieve: IDL.Func([IDL.Text], [IDL.Vec(IDL.Nat8)], ['query']),\n        store: IDL.Func([IDL.Text, IDL.Vec(IDL.Nat8)], [], []),\n    });\n});\n//# sourceMappingURL=asset_idl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2NhbmlzdGVycy9hc3NldF9pZGwuanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBZSxHQUFHLEtBQUs7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUMsRUFBQztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2NhbmlzdGVycy9hc3NldF9pZGwuanM/OTUxOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgZnJvbSB0aGUgY2FuZGlkIGZvciBhc3NldCBtYW5hZ2VtZW50LlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4vLyBAdHMtaWdub3JlXG5leHBvcnQgZGVmYXVsdCAoeyBJREwgfSkgPT4ge1xuICAgIHJldHVybiBJREwuU2VydmljZSh7XG4gICAgICAgIHJldHJpZXZlOiBJREwuRnVuYyhbSURMLlRleHRdLCBbSURMLlZlYyhJREwuTmF0OCldLCBbJ3F1ZXJ5J10pLFxuICAgICAgICBzdG9yZTogSURMLkZ1bmMoW0lETC5UZXh0LCBJREwuVmVjKElETC5OYXQ4KV0sIFtdLCBbXSksXG4gICAgfSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNzZXRfaWRsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/canisters/asset_idl.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/canisters/management_idl.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@dfinity/agent/lib/esm/canisters/management_idl.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/*\n * This file is generated from the candid for asset management.\n * didc version: 0.4.0\n */\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\n/* harmony default export */ __webpack_exports__[\"default\"] = (({ IDL }) => {\n    const bitcoin_network = IDL.Variant({\n        mainnet: IDL.Null,\n        testnet: IDL.Null,\n    });\n    const bitcoin_address = IDL.Text;\n    const bitcoin_get_balance_args = IDL.Record({\n        network: bitcoin_network,\n        address: bitcoin_address,\n        min_confirmations: IDL.Opt(IDL.Nat32),\n    });\n    const satoshi = IDL.Nat64;\n    const bitcoin_get_balance_result = satoshi;\n    const bitcoin_get_current_fee_percentiles_args = IDL.Record({\n        network: bitcoin_network,\n    });\n    const millisatoshi_per_byte = IDL.Nat64;\n    const bitcoin_get_current_fee_percentiles_result = IDL.Vec(millisatoshi_per_byte);\n    const bitcoin_get_utxos_args = IDL.Record({\n        network: bitcoin_network,\n        filter: IDL.Opt(IDL.Variant({\n            page: IDL.Vec(IDL.Nat8),\n            min_confirmations: IDL.Nat32,\n        })),\n        address: bitcoin_address,\n    });\n    const block_hash = IDL.Vec(IDL.Nat8);\n    const outpoint = IDL.Record({\n        txid: IDL.Vec(IDL.Nat8),\n        vout: IDL.Nat32,\n    });\n    const utxo = IDL.Record({\n        height: IDL.Nat32,\n        value: satoshi,\n        outpoint: outpoint,\n    });\n    const bitcoin_get_utxos_result = IDL.Record({\n        next_page: IDL.Opt(IDL.Vec(IDL.Nat8)),\n        tip_height: IDL.Nat32,\n        tip_block_hash: block_hash,\n        utxos: IDL.Vec(utxo),\n    });\n    const bitcoin_send_transaction_args = IDL.Record({\n        transaction: IDL.Vec(IDL.Nat8),\n        network: bitcoin_network,\n    });\n    const canister_id = IDL.Principal;\n    const canister_info_args = IDL.Record({\n        canister_id: canister_id,\n        num_requested_changes: IDL.Opt(IDL.Nat64),\n    });\n    const change_origin = IDL.Variant({\n        from_user: IDL.Record({ user_id: IDL.Principal }),\n        from_canister: IDL.Record({\n            canister_version: IDL.Opt(IDL.Nat64),\n            canister_id: IDL.Principal,\n        }),\n    });\n    const change_details = IDL.Variant({\n        creation: IDL.Record({ controllers: IDL.Vec(IDL.Principal) }),\n        code_deployment: IDL.Record({\n            mode: IDL.Variant({\n                reinstall: IDL.Null,\n                upgrade: IDL.Null,\n                install: IDL.Null,\n            }),\n            module_hash: IDL.Vec(IDL.Nat8),\n        }),\n        controllers_change: IDL.Record({\n            controllers: IDL.Vec(IDL.Principal),\n        }),\n        code_uninstall: IDL.Null,\n    });\n    const change = IDL.Record({\n        timestamp_nanos: IDL.Nat64,\n        canister_version: IDL.Nat64,\n        origin: change_origin,\n        details: change_details,\n    });\n    const canister_info_result = IDL.Record({\n        controllers: IDL.Vec(IDL.Principal),\n        module_hash: IDL.Opt(IDL.Vec(IDL.Nat8)),\n        recent_changes: IDL.Vec(change),\n        total_num_changes: IDL.Nat64,\n    });\n    const canister_status_args = IDL.Record({ canister_id: canister_id });\n    const log_visibility = IDL.Variant({\n        controllers: IDL.Null,\n        public: IDL.Null,\n    });\n    const definite_canister_settings = IDL.Record({\n        freezing_threshold: IDL.Nat,\n        controllers: IDL.Vec(IDL.Principal),\n        reserved_cycles_limit: IDL.Nat,\n        log_visibility: log_visibility,\n        wasm_memory_limit: IDL.Nat,\n        memory_allocation: IDL.Nat,\n        compute_allocation: IDL.Nat,\n    });\n    const canister_status_result = IDL.Record({\n        status: IDL.Variant({\n            stopped: IDL.Null,\n            stopping: IDL.Null,\n            running: IDL.Null,\n        }),\n        memory_size: IDL.Nat,\n        cycles: IDL.Nat,\n        settings: definite_canister_settings,\n        query_stats: IDL.Record({\n            response_payload_bytes_total: IDL.Nat,\n            num_instructions_total: IDL.Nat,\n            num_calls_total: IDL.Nat,\n            request_payload_bytes_total: IDL.Nat,\n        }),\n        idle_cycles_burned_per_day: IDL.Nat,\n        module_hash: IDL.Opt(IDL.Vec(IDL.Nat8)),\n        reserved_cycles: IDL.Nat,\n    });\n    const clear_chunk_store_args = IDL.Record({ canister_id: canister_id });\n    const canister_settings = IDL.Record({\n        freezing_threshold: IDL.Opt(IDL.Nat),\n        controllers: IDL.Opt(IDL.Vec(IDL.Principal)),\n        reserved_cycles_limit: IDL.Opt(IDL.Nat),\n        log_visibility: IDL.Opt(log_visibility),\n        wasm_memory_limit: IDL.Opt(IDL.Nat),\n        memory_allocation: IDL.Opt(IDL.Nat),\n        compute_allocation: IDL.Opt(IDL.Nat),\n    });\n    const create_canister_args = IDL.Record({\n        settings: IDL.Opt(canister_settings),\n        sender_canister_version: IDL.Opt(IDL.Nat64),\n    });\n    const create_canister_result = IDL.Record({ canister_id: canister_id });\n    const delete_canister_args = IDL.Record({ canister_id: canister_id });\n    const deposit_cycles_args = IDL.Record({ canister_id: canister_id });\n    const ecdsa_curve = IDL.Variant({ secp256k1: IDL.Null });\n    const ecdsa_public_key_args = IDL.Record({\n        key_id: IDL.Record({ name: IDL.Text, curve: ecdsa_curve }),\n        canister_id: IDL.Opt(canister_id),\n        derivation_path: IDL.Vec(IDL.Vec(IDL.Nat8)),\n    });\n    const ecdsa_public_key_result = IDL.Record({\n        public_key: IDL.Vec(IDL.Nat8),\n        chain_code: IDL.Vec(IDL.Nat8),\n    });\n    const fetch_canister_logs_args = IDL.Record({ canister_id: canister_id });\n    const canister_log_record = IDL.Record({\n        idx: IDL.Nat64,\n        timestamp_nanos: IDL.Nat64,\n        content: IDL.Vec(IDL.Nat8),\n    });\n    const fetch_canister_logs_result = IDL.Record({\n        canister_log_records: IDL.Vec(canister_log_record),\n    });\n    const http_header = IDL.Record({ value: IDL.Text, name: IDL.Text });\n    const http_request_result = IDL.Record({\n        status: IDL.Nat,\n        body: IDL.Vec(IDL.Nat8),\n        headers: IDL.Vec(http_header),\n    });\n    const http_request_args = IDL.Record({\n        url: IDL.Text,\n        method: IDL.Variant({\n            get: IDL.Null,\n            head: IDL.Null,\n            post: IDL.Null,\n        }),\n        max_response_bytes: IDL.Opt(IDL.Nat64),\n        body: IDL.Opt(IDL.Vec(IDL.Nat8)),\n        transform: IDL.Opt(IDL.Record({\n            function: IDL.Func([\n                IDL.Record({\n                    context: IDL.Vec(IDL.Nat8),\n                    response: http_request_result,\n                }),\n            ], [http_request_result], ['query']),\n            context: IDL.Vec(IDL.Nat8),\n        })),\n        headers: IDL.Vec(http_header),\n    });\n    const canister_install_mode = IDL.Variant({\n        reinstall: IDL.Null,\n        upgrade: IDL.Opt(IDL.Record({\n            wasm_memory_persistence: IDL.Opt(IDL.Variant({ keep: IDL.Null, replace: IDL.Null })),\n            skip_pre_upgrade: IDL.Opt(IDL.Bool),\n        })),\n        install: IDL.Null,\n    });\n    const chunk_hash = IDL.Record({ hash: IDL.Vec(IDL.Nat8) });\n    const install_chunked_code_args = IDL.Record({\n        arg: IDL.Vec(IDL.Nat8),\n        wasm_module_hash: IDL.Vec(IDL.Nat8),\n        mode: canister_install_mode,\n        chunk_hashes_list: IDL.Vec(chunk_hash),\n        target_canister: canister_id,\n        store_canister: IDL.Opt(canister_id),\n        sender_canister_version: IDL.Opt(IDL.Nat64),\n    });\n    const wasm_module = IDL.Vec(IDL.Nat8);\n    const install_code_args = IDL.Record({\n        arg: IDL.Vec(IDL.Nat8),\n        wasm_module: wasm_module,\n        mode: canister_install_mode,\n        canister_id: canister_id,\n        sender_canister_version: IDL.Opt(IDL.Nat64),\n    });\n    const node_metrics_history_args = IDL.Record({\n        start_at_timestamp_nanos: IDL.Nat64,\n        subnet_id: IDL.Principal,\n    });\n    const node_metrics = IDL.Record({\n        num_block_failures_total: IDL.Nat64,\n        node_id: IDL.Principal,\n        num_blocks_proposed_total: IDL.Nat64,\n    });\n    const node_metrics_history_result = IDL.Vec(IDL.Record({\n        timestamp_nanos: IDL.Nat64,\n        node_metrics: IDL.Vec(node_metrics),\n    }));\n    const provisional_create_canister_with_cycles_args = IDL.Record({\n        settings: IDL.Opt(canister_settings),\n        specified_id: IDL.Opt(canister_id),\n        amount: IDL.Opt(IDL.Nat),\n        sender_canister_version: IDL.Opt(IDL.Nat64),\n    });\n    const provisional_create_canister_with_cycles_result = IDL.Record({\n        canister_id: canister_id,\n    });\n    const provisional_top_up_canister_args = IDL.Record({\n        canister_id: canister_id,\n        amount: IDL.Nat,\n    });\n    const raw_rand_result = IDL.Vec(IDL.Nat8);\n    const schnorr_algorithm = IDL.Variant({\n        ed25519: IDL.Null,\n        bip340secp256k1: IDL.Null,\n    });\n    const schnorr_public_key_args = IDL.Record({\n        key_id: IDL.Record({\n            algorithm: schnorr_algorithm,\n            name: IDL.Text,\n        }),\n        canister_id: IDL.Opt(canister_id),\n        derivation_path: IDL.Vec(IDL.Vec(IDL.Nat8)),\n    });\n    const schnorr_public_key_result = IDL.Record({\n        public_key: IDL.Vec(IDL.Nat8),\n        chain_code: IDL.Vec(IDL.Nat8),\n    });\n    const sign_with_ecdsa_args = IDL.Record({\n        key_id: IDL.Record({ name: IDL.Text, curve: ecdsa_curve }),\n        derivation_path: IDL.Vec(IDL.Vec(IDL.Nat8)),\n        message_hash: IDL.Vec(IDL.Nat8),\n    });\n    const sign_with_ecdsa_result = IDL.Record({\n        signature: IDL.Vec(IDL.Nat8),\n    });\n    const sign_with_schnorr_args = IDL.Record({\n        key_id: IDL.Record({\n            algorithm: schnorr_algorithm,\n            name: IDL.Text,\n        }),\n        derivation_path: IDL.Vec(IDL.Vec(IDL.Nat8)),\n        message: IDL.Vec(IDL.Nat8),\n    });\n    const sign_with_schnorr_result = IDL.Record({\n        signature: IDL.Vec(IDL.Nat8),\n    });\n    const start_canister_args = IDL.Record({ canister_id: canister_id });\n    const stop_canister_args = IDL.Record({ canister_id: canister_id });\n    const stored_chunks_args = IDL.Record({ canister_id: canister_id });\n    const stored_chunks_result = IDL.Vec(chunk_hash);\n    const uninstall_code_args = IDL.Record({\n        canister_id: canister_id,\n        sender_canister_version: IDL.Opt(IDL.Nat64),\n    });\n    const update_settings_args = IDL.Record({\n        canister_id: IDL.Principal,\n        settings: canister_settings,\n        sender_canister_version: IDL.Opt(IDL.Nat64),\n    });\n    const upload_chunk_args = IDL.Record({\n        chunk: IDL.Vec(IDL.Nat8),\n        canister_id: IDL.Principal,\n    });\n    const upload_chunk_result = chunk_hash;\n    return IDL.Service({\n        bitcoin_get_balance: IDL.Func([bitcoin_get_balance_args], [bitcoin_get_balance_result], []),\n        bitcoin_get_current_fee_percentiles: IDL.Func([bitcoin_get_current_fee_percentiles_args], [bitcoin_get_current_fee_percentiles_result], []),\n        bitcoin_get_utxos: IDL.Func([bitcoin_get_utxos_args], [bitcoin_get_utxos_result], []),\n        bitcoin_send_transaction: IDL.Func([bitcoin_send_transaction_args], [], []),\n        canister_info: IDL.Func([canister_info_args], [canister_info_result], []),\n        canister_status: IDL.Func([canister_status_args], [canister_status_result], []),\n        clear_chunk_store: IDL.Func([clear_chunk_store_args], [], []),\n        create_canister: IDL.Func([create_canister_args], [create_canister_result], []),\n        delete_canister: IDL.Func([delete_canister_args], [], []),\n        deposit_cycles: IDL.Func([deposit_cycles_args], [], []),\n        ecdsa_public_key: IDL.Func([ecdsa_public_key_args], [ecdsa_public_key_result], []),\n        fetch_canister_logs: IDL.Func([fetch_canister_logs_args], [fetch_canister_logs_result], ['query']),\n        http_request: IDL.Func([http_request_args], [http_request_result], []),\n        install_chunked_code: IDL.Func([install_chunked_code_args], [], []),\n        install_code: IDL.Func([install_code_args], [], []),\n        node_metrics_history: IDL.Func([node_metrics_history_args], [node_metrics_history_result], []),\n        provisional_create_canister_with_cycles: IDL.Func([provisional_create_canister_with_cycles_args], [provisional_create_canister_with_cycles_result], []),\n        provisional_top_up_canister: IDL.Func([provisional_top_up_canister_args], [], []),\n        raw_rand: IDL.Func([], [raw_rand_result], []),\n        schnorr_public_key: IDL.Func([schnorr_public_key_args], [schnorr_public_key_result], []),\n        sign_with_ecdsa: IDL.Func([sign_with_ecdsa_args], [sign_with_ecdsa_result], []),\n        sign_with_schnorr: IDL.Func([sign_with_schnorr_args], [sign_with_schnorr_result], []),\n        start_canister: IDL.Func([start_canister_args], [], []),\n        stop_canister: IDL.Func([stop_canister_args], [], []),\n        stored_chunks: IDL.Func([stored_chunks_args], [stored_chunks_result], []),\n        uninstall_code: IDL.Func([uninstall_code_args], [], []),\n        update_settings: IDL.Func([update_settings_args], [], []),\n        upload_chunk: IDL.Func([upload_chunk_args], [upload_chunk_result], []),\n    });\n});\n//# sourceMappingURL=management_idl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2NhbmlzdGVycy9tYW5hZ2VtZW50X2lkbC5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQWUsR0FBRyxLQUFLO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0NBQWdDLHdCQUF3QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EsK0JBQStCLHFDQUFxQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDhDQUE4QywwQkFBMEI7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnREFBZ0QsMEJBQTBCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdEQUFnRCwwQkFBMEI7QUFDMUUsOENBQThDLDBCQUEwQjtBQUN4RSw2Q0FBNkMsMEJBQTBCO0FBQ3ZFLHNDQUFzQyxxQkFBcUI7QUFDM0Q7QUFDQSw2QkFBNkIsb0NBQW9DO0FBQ2pFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGtEQUFrRCwwQkFBMEI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxxQ0FBcUMsaUNBQWlDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxtQ0FBbUM7QUFDOUY7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsb0NBQW9DLHlCQUF5QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDZCQUE2QixvQ0FBb0M7QUFDakU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCw2Q0FBNkMsMEJBQTBCO0FBQ3ZFLDRDQUE0QywwQkFBMEI7QUFDdEUsNENBQTRDLDBCQUEwQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUMsRUFBQztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2NhbmlzdGVycy9tYW5hZ2VtZW50X2lkbC5qcz9iYjg5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGZyb20gdGhlIGNhbmRpZCBmb3IgYXNzZXQgbWFuYWdlbWVudC5cbiAqIGRpZGMgdmVyc2lvbjogMC40LjBcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuLy8gQHRzLWlnbm9yZVxuZXhwb3J0IGRlZmF1bHQgKHsgSURMIH0pID0+IHtcbiAgICBjb25zdCBiaXRjb2luX25ldHdvcmsgPSBJREwuVmFyaWFudCh7XG4gICAgICAgIG1haW5uZXQ6IElETC5OdWxsLFxuICAgICAgICB0ZXN0bmV0OiBJREwuTnVsbCxcbiAgICB9KTtcbiAgICBjb25zdCBiaXRjb2luX2FkZHJlc3MgPSBJREwuVGV4dDtcbiAgICBjb25zdCBiaXRjb2luX2dldF9iYWxhbmNlX2FyZ3MgPSBJREwuUmVjb3JkKHtcbiAgICAgICAgbmV0d29yazogYml0Y29pbl9uZXR3b3JrLFxuICAgICAgICBhZGRyZXNzOiBiaXRjb2luX2FkZHJlc3MsXG4gICAgICAgIG1pbl9jb25maXJtYXRpb25zOiBJREwuT3B0KElETC5OYXQzMiksXG4gICAgfSk7XG4gICAgY29uc3Qgc2F0b3NoaSA9IElETC5OYXQ2NDtcbiAgICBjb25zdCBiaXRjb2luX2dldF9iYWxhbmNlX3Jlc3VsdCA9IHNhdG9zaGk7XG4gICAgY29uc3QgYml0Y29pbl9nZXRfY3VycmVudF9mZWVfcGVyY2VudGlsZXNfYXJncyA9IElETC5SZWNvcmQoe1xuICAgICAgICBuZXR3b3JrOiBiaXRjb2luX25ldHdvcmssXG4gICAgfSk7XG4gICAgY29uc3QgbWlsbGlzYXRvc2hpX3Blcl9ieXRlID0gSURMLk5hdDY0O1xuICAgIGNvbnN0IGJpdGNvaW5fZ2V0X2N1cnJlbnRfZmVlX3BlcmNlbnRpbGVzX3Jlc3VsdCA9IElETC5WZWMobWlsbGlzYXRvc2hpX3Blcl9ieXRlKTtcbiAgICBjb25zdCBiaXRjb2luX2dldF91dHhvc19hcmdzID0gSURMLlJlY29yZCh7XG4gICAgICAgIG5ldHdvcms6IGJpdGNvaW5fbmV0d29yayxcbiAgICAgICAgZmlsdGVyOiBJREwuT3B0KElETC5WYXJpYW50KHtcbiAgICAgICAgICAgIHBhZ2U6IElETC5WZWMoSURMLk5hdDgpLFxuICAgICAgICAgICAgbWluX2NvbmZpcm1hdGlvbnM6IElETC5OYXQzMixcbiAgICAgICAgfSkpLFxuICAgICAgICBhZGRyZXNzOiBiaXRjb2luX2FkZHJlc3MsXG4gICAgfSk7XG4gICAgY29uc3QgYmxvY2tfaGFzaCA9IElETC5WZWMoSURMLk5hdDgpO1xuICAgIGNvbnN0IG91dHBvaW50ID0gSURMLlJlY29yZCh7XG4gICAgICAgIHR4aWQ6IElETC5WZWMoSURMLk5hdDgpLFxuICAgICAgICB2b3V0OiBJREwuTmF0MzIsXG4gICAgfSk7XG4gICAgY29uc3QgdXR4byA9IElETC5SZWNvcmQoe1xuICAgICAgICBoZWlnaHQ6IElETC5OYXQzMixcbiAgICAgICAgdmFsdWU6IHNhdG9zaGksXG4gICAgICAgIG91dHBvaW50OiBvdXRwb2ludCxcbiAgICB9KTtcbiAgICBjb25zdCBiaXRjb2luX2dldF91dHhvc19yZXN1bHQgPSBJREwuUmVjb3JkKHtcbiAgICAgICAgbmV4dF9wYWdlOiBJREwuT3B0KElETC5WZWMoSURMLk5hdDgpKSxcbiAgICAgICAgdGlwX2hlaWdodDogSURMLk5hdDMyLFxuICAgICAgICB0aXBfYmxvY2tfaGFzaDogYmxvY2tfaGFzaCxcbiAgICAgICAgdXR4b3M6IElETC5WZWModXR4byksXG4gICAgfSk7XG4gICAgY29uc3QgYml0Y29pbl9zZW5kX3RyYW5zYWN0aW9uX2FyZ3MgPSBJREwuUmVjb3JkKHtcbiAgICAgICAgdHJhbnNhY3Rpb246IElETC5WZWMoSURMLk5hdDgpLFxuICAgICAgICBuZXR3b3JrOiBiaXRjb2luX25ldHdvcmssXG4gICAgfSk7XG4gICAgY29uc3QgY2FuaXN0ZXJfaWQgPSBJREwuUHJpbmNpcGFsO1xuICAgIGNvbnN0IGNhbmlzdGVyX2luZm9fYXJncyA9IElETC5SZWNvcmQoe1xuICAgICAgICBjYW5pc3Rlcl9pZDogY2FuaXN0ZXJfaWQsXG4gICAgICAgIG51bV9yZXF1ZXN0ZWRfY2hhbmdlczogSURMLk9wdChJREwuTmF0NjQpLFxuICAgIH0pO1xuICAgIGNvbnN0IGNoYW5nZV9vcmlnaW4gPSBJREwuVmFyaWFudCh7XG4gICAgICAgIGZyb21fdXNlcjogSURMLlJlY29yZCh7IHVzZXJfaWQ6IElETC5QcmluY2lwYWwgfSksXG4gICAgICAgIGZyb21fY2FuaXN0ZXI6IElETC5SZWNvcmQoe1xuICAgICAgICAgICAgY2FuaXN0ZXJfdmVyc2lvbjogSURMLk9wdChJREwuTmF0NjQpLFxuICAgICAgICAgICAgY2FuaXN0ZXJfaWQ6IElETC5QcmluY2lwYWwsXG4gICAgICAgIH0pLFxuICAgIH0pO1xuICAgIGNvbnN0IGNoYW5nZV9kZXRhaWxzID0gSURMLlZhcmlhbnQoe1xuICAgICAgICBjcmVhdGlvbjogSURMLlJlY29yZCh7IGNvbnRyb2xsZXJzOiBJREwuVmVjKElETC5QcmluY2lwYWwpIH0pLFxuICAgICAgICBjb2RlX2RlcGxveW1lbnQ6IElETC5SZWNvcmQoe1xuICAgICAgICAgICAgbW9kZTogSURMLlZhcmlhbnQoe1xuICAgICAgICAgICAgICAgIHJlaW5zdGFsbDogSURMLk51bGwsXG4gICAgICAgICAgICAgICAgdXBncmFkZTogSURMLk51bGwsXG4gICAgICAgICAgICAgICAgaW5zdGFsbDogSURMLk51bGwsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG1vZHVsZV9oYXNoOiBJREwuVmVjKElETC5OYXQ4KSxcbiAgICAgICAgfSksXG4gICAgICAgIGNvbnRyb2xsZXJzX2NoYW5nZTogSURMLlJlY29yZCh7XG4gICAgICAgICAgICBjb250cm9sbGVyczogSURMLlZlYyhJREwuUHJpbmNpcGFsKSxcbiAgICAgICAgfSksXG4gICAgICAgIGNvZGVfdW5pbnN0YWxsOiBJREwuTnVsbCxcbiAgICB9KTtcbiAgICBjb25zdCBjaGFuZ2UgPSBJREwuUmVjb3JkKHtcbiAgICAgICAgdGltZXN0YW1wX25hbm9zOiBJREwuTmF0NjQsXG4gICAgICAgIGNhbmlzdGVyX3ZlcnNpb246IElETC5OYXQ2NCxcbiAgICAgICAgb3JpZ2luOiBjaGFuZ2Vfb3JpZ2luLFxuICAgICAgICBkZXRhaWxzOiBjaGFuZ2VfZGV0YWlscyxcbiAgICB9KTtcbiAgICBjb25zdCBjYW5pc3Rlcl9pbmZvX3Jlc3VsdCA9IElETC5SZWNvcmQoe1xuICAgICAgICBjb250cm9sbGVyczogSURMLlZlYyhJREwuUHJpbmNpcGFsKSxcbiAgICAgICAgbW9kdWxlX2hhc2g6IElETC5PcHQoSURMLlZlYyhJREwuTmF0OCkpLFxuICAgICAgICByZWNlbnRfY2hhbmdlczogSURMLlZlYyhjaGFuZ2UpLFxuICAgICAgICB0b3RhbF9udW1fY2hhbmdlczogSURMLk5hdDY0LFxuICAgIH0pO1xuICAgIGNvbnN0IGNhbmlzdGVyX3N0YXR1c19hcmdzID0gSURMLlJlY29yZCh7IGNhbmlzdGVyX2lkOiBjYW5pc3Rlcl9pZCB9KTtcbiAgICBjb25zdCBsb2dfdmlzaWJpbGl0eSA9IElETC5WYXJpYW50KHtcbiAgICAgICAgY29udHJvbGxlcnM6IElETC5OdWxsLFxuICAgICAgICBwdWJsaWM6IElETC5OdWxsLFxuICAgIH0pO1xuICAgIGNvbnN0IGRlZmluaXRlX2NhbmlzdGVyX3NldHRpbmdzID0gSURMLlJlY29yZCh7XG4gICAgICAgIGZyZWV6aW5nX3RocmVzaG9sZDogSURMLk5hdCxcbiAgICAgICAgY29udHJvbGxlcnM6IElETC5WZWMoSURMLlByaW5jaXBhbCksXG4gICAgICAgIHJlc2VydmVkX2N5Y2xlc19saW1pdDogSURMLk5hdCxcbiAgICAgICAgbG9nX3Zpc2liaWxpdHk6IGxvZ192aXNpYmlsaXR5LFxuICAgICAgICB3YXNtX21lbW9yeV9saW1pdDogSURMLk5hdCxcbiAgICAgICAgbWVtb3J5X2FsbG9jYXRpb246IElETC5OYXQsXG4gICAgICAgIGNvbXB1dGVfYWxsb2NhdGlvbjogSURMLk5hdCxcbiAgICB9KTtcbiAgICBjb25zdCBjYW5pc3Rlcl9zdGF0dXNfcmVzdWx0ID0gSURMLlJlY29yZCh7XG4gICAgICAgIHN0YXR1czogSURMLlZhcmlhbnQoe1xuICAgICAgICAgICAgc3RvcHBlZDogSURMLk51bGwsXG4gICAgICAgICAgICBzdG9wcGluZzogSURMLk51bGwsXG4gICAgICAgICAgICBydW5uaW5nOiBJREwuTnVsbCxcbiAgICAgICAgfSksXG4gICAgICAgIG1lbW9yeV9zaXplOiBJREwuTmF0LFxuICAgICAgICBjeWNsZXM6IElETC5OYXQsXG4gICAgICAgIHNldHRpbmdzOiBkZWZpbml0ZV9jYW5pc3Rlcl9zZXR0aW5ncyxcbiAgICAgICAgcXVlcnlfc3RhdHM6IElETC5SZWNvcmQoe1xuICAgICAgICAgICAgcmVzcG9uc2VfcGF5bG9hZF9ieXRlc190b3RhbDogSURMLk5hdCxcbiAgICAgICAgICAgIG51bV9pbnN0cnVjdGlvbnNfdG90YWw6IElETC5OYXQsXG4gICAgICAgICAgICBudW1fY2FsbHNfdG90YWw6IElETC5OYXQsXG4gICAgICAgICAgICByZXF1ZXN0X3BheWxvYWRfYnl0ZXNfdG90YWw6IElETC5OYXQsXG4gICAgICAgIH0pLFxuICAgICAgICBpZGxlX2N5Y2xlc19idXJuZWRfcGVyX2RheTogSURMLk5hdCxcbiAgICAgICAgbW9kdWxlX2hhc2g6IElETC5PcHQoSURMLlZlYyhJREwuTmF0OCkpLFxuICAgICAgICByZXNlcnZlZF9jeWNsZXM6IElETC5OYXQsXG4gICAgfSk7XG4gICAgY29uc3QgY2xlYXJfY2h1bmtfc3RvcmVfYXJncyA9IElETC5SZWNvcmQoeyBjYW5pc3Rlcl9pZDogY2FuaXN0ZXJfaWQgfSk7XG4gICAgY29uc3QgY2FuaXN0ZXJfc2V0dGluZ3MgPSBJREwuUmVjb3JkKHtcbiAgICAgICAgZnJlZXppbmdfdGhyZXNob2xkOiBJREwuT3B0KElETC5OYXQpLFxuICAgICAgICBjb250cm9sbGVyczogSURMLk9wdChJREwuVmVjKElETC5QcmluY2lwYWwpKSxcbiAgICAgICAgcmVzZXJ2ZWRfY3ljbGVzX2xpbWl0OiBJREwuT3B0KElETC5OYXQpLFxuICAgICAgICBsb2dfdmlzaWJpbGl0eTogSURMLk9wdChsb2dfdmlzaWJpbGl0eSksXG4gICAgICAgIHdhc21fbWVtb3J5X2xpbWl0OiBJREwuT3B0KElETC5OYXQpLFxuICAgICAgICBtZW1vcnlfYWxsb2NhdGlvbjogSURMLk9wdChJREwuTmF0KSxcbiAgICAgICAgY29tcHV0ZV9hbGxvY2F0aW9uOiBJREwuT3B0KElETC5OYXQpLFxuICAgIH0pO1xuICAgIGNvbnN0IGNyZWF0ZV9jYW5pc3Rlcl9hcmdzID0gSURMLlJlY29yZCh7XG4gICAgICAgIHNldHRpbmdzOiBJREwuT3B0KGNhbmlzdGVyX3NldHRpbmdzKSxcbiAgICAgICAgc2VuZGVyX2NhbmlzdGVyX3ZlcnNpb246IElETC5PcHQoSURMLk5hdDY0KSxcbiAgICB9KTtcbiAgICBjb25zdCBjcmVhdGVfY2FuaXN0ZXJfcmVzdWx0ID0gSURMLlJlY29yZCh7IGNhbmlzdGVyX2lkOiBjYW5pc3Rlcl9pZCB9KTtcbiAgICBjb25zdCBkZWxldGVfY2FuaXN0ZXJfYXJncyA9IElETC5SZWNvcmQoeyBjYW5pc3Rlcl9pZDogY2FuaXN0ZXJfaWQgfSk7XG4gICAgY29uc3QgZGVwb3NpdF9jeWNsZXNfYXJncyA9IElETC5SZWNvcmQoeyBjYW5pc3Rlcl9pZDogY2FuaXN0ZXJfaWQgfSk7XG4gICAgY29uc3QgZWNkc2FfY3VydmUgPSBJREwuVmFyaWFudCh7IHNlY3AyNTZrMTogSURMLk51bGwgfSk7XG4gICAgY29uc3QgZWNkc2FfcHVibGljX2tleV9hcmdzID0gSURMLlJlY29yZCh7XG4gICAgICAgIGtleV9pZDogSURMLlJlY29yZCh7IG5hbWU6IElETC5UZXh0LCBjdXJ2ZTogZWNkc2FfY3VydmUgfSksXG4gICAgICAgIGNhbmlzdGVyX2lkOiBJREwuT3B0KGNhbmlzdGVyX2lkKSxcbiAgICAgICAgZGVyaXZhdGlvbl9wYXRoOiBJREwuVmVjKElETC5WZWMoSURMLk5hdDgpKSxcbiAgICB9KTtcbiAgICBjb25zdCBlY2RzYV9wdWJsaWNfa2V5X3Jlc3VsdCA9IElETC5SZWNvcmQoe1xuICAgICAgICBwdWJsaWNfa2V5OiBJREwuVmVjKElETC5OYXQ4KSxcbiAgICAgICAgY2hhaW5fY29kZTogSURMLlZlYyhJREwuTmF0OCksXG4gICAgfSk7XG4gICAgY29uc3QgZmV0Y2hfY2FuaXN0ZXJfbG9nc19hcmdzID0gSURMLlJlY29yZCh7IGNhbmlzdGVyX2lkOiBjYW5pc3Rlcl9pZCB9KTtcbiAgICBjb25zdCBjYW5pc3Rlcl9sb2dfcmVjb3JkID0gSURMLlJlY29yZCh7XG4gICAgICAgIGlkeDogSURMLk5hdDY0LFxuICAgICAgICB0aW1lc3RhbXBfbmFub3M6IElETC5OYXQ2NCxcbiAgICAgICAgY29udGVudDogSURMLlZlYyhJREwuTmF0OCksXG4gICAgfSk7XG4gICAgY29uc3QgZmV0Y2hfY2FuaXN0ZXJfbG9nc19yZXN1bHQgPSBJREwuUmVjb3JkKHtcbiAgICAgICAgY2FuaXN0ZXJfbG9nX3JlY29yZHM6IElETC5WZWMoY2FuaXN0ZXJfbG9nX3JlY29yZCksXG4gICAgfSk7XG4gICAgY29uc3QgaHR0cF9oZWFkZXIgPSBJREwuUmVjb3JkKHsgdmFsdWU6IElETC5UZXh0LCBuYW1lOiBJREwuVGV4dCB9KTtcbiAgICBjb25zdCBodHRwX3JlcXVlc3RfcmVzdWx0ID0gSURMLlJlY29yZCh7XG4gICAgICAgIHN0YXR1czogSURMLk5hdCxcbiAgICAgICAgYm9keTogSURMLlZlYyhJREwuTmF0OCksXG4gICAgICAgIGhlYWRlcnM6IElETC5WZWMoaHR0cF9oZWFkZXIpLFxuICAgIH0pO1xuICAgIGNvbnN0IGh0dHBfcmVxdWVzdF9hcmdzID0gSURMLlJlY29yZCh7XG4gICAgICAgIHVybDogSURMLlRleHQsXG4gICAgICAgIG1ldGhvZDogSURMLlZhcmlhbnQoe1xuICAgICAgICAgICAgZ2V0OiBJREwuTnVsbCxcbiAgICAgICAgICAgIGhlYWQ6IElETC5OdWxsLFxuICAgICAgICAgICAgcG9zdDogSURMLk51bGwsXG4gICAgICAgIH0pLFxuICAgICAgICBtYXhfcmVzcG9uc2VfYnl0ZXM6IElETC5PcHQoSURMLk5hdDY0KSxcbiAgICAgICAgYm9keTogSURMLk9wdChJREwuVmVjKElETC5OYXQ4KSksXG4gICAgICAgIHRyYW5zZm9ybTogSURMLk9wdChJREwuUmVjb3JkKHtcbiAgICAgICAgICAgIGZ1bmN0aW9uOiBJREwuRnVuYyhbXG4gICAgICAgICAgICAgICAgSURMLlJlY29yZCh7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IElETC5WZWMoSURMLk5hdDgpLFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogaHR0cF9yZXF1ZXN0X3Jlc3VsdCxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF0sIFtodHRwX3JlcXVlc3RfcmVzdWx0XSwgWydxdWVyeSddKSxcbiAgICAgICAgICAgIGNvbnRleHQ6IElETC5WZWMoSURMLk5hdDgpLFxuICAgICAgICB9KSksXG4gICAgICAgIGhlYWRlcnM6IElETC5WZWMoaHR0cF9oZWFkZXIpLFxuICAgIH0pO1xuICAgIGNvbnN0IGNhbmlzdGVyX2luc3RhbGxfbW9kZSA9IElETC5WYXJpYW50KHtcbiAgICAgICAgcmVpbnN0YWxsOiBJREwuTnVsbCxcbiAgICAgICAgdXBncmFkZTogSURMLk9wdChJREwuUmVjb3JkKHtcbiAgICAgICAgICAgIHdhc21fbWVtb3J5X3BlcnNpc3RlbmNlOiBJREwuT3B0KElETC5WYXJpYW50KHsga2VlcDogSURMLk51bGwsIHJlcGxhY2U6IElETC5OdWxsIH0pKSxcbiAgICAgICAgICAgIHNraXBfcHJlX3VwZ3JhZGU6IElETC5PcHQoSURMLkJvb2wpLFxuICAgICAgICB9KSksXG4gICAgICAgIGluc3RhbGw6IElETC5OdWxsLFxuICAgIH0pO1xuICAgIGNvbnN0IGNodW5rX2hhc2ggPSBJREwuUmVjb3JkKHsgaGFzaDogSURMLlZlYyhJREwuTmF0OCkgfSk7XG4gICAgY29uc3QgaW5zdGFsbF9jaHVua2VkX2NvZGVfYXJncyA9IElETC5SZWNvcmQoe1xuICAgICAgICBhcmc6IElETC5WZWMoSURMLk5hdDgpLFxuICAgICAgICB3YXNtX21vZHVsZV9oYXNoOiBJREwuVmVjKElETC5OYXQ4KSxcbiAgICAgICAgbW9kZTogY2FuaXN0ZXJfaW5zdGFsbF9tb2RlLFxuICAgICAgICBjaHVua19oYXNoZXNfbGlzdDogSURMLlZlYyhjaHVua19oYXNoKSxcbiAgICAgICAgdGFyZ2V0X2NhbmlzdGVyOiBjYW5pc3Rlcl9pZCxcbiAgICAgICAgc3RvcmVfY2FuaXN0ZXI6IElETC5PcHQoY2FuaXN0ZXJfaWQpLFxuICAgICAgICBzZW5kZXJfY2FuaXN0ZXJfdmVyc2lvbjogSURMLk9wdChJREwuTmF0NjQpLFxuICAgIH0pO1xuICAgIGNvbnN0IHdhc21fbW9kdWxlID0gSURMLlZlYyhJREwuTmF0OCk7XG4gICAgY29uc3QgaW5zdGFsbF9jb2RlX2FyZ3MgPSBJREwuUmVjb3JkKHtcbiAgICAgICAgYXJnOiBJREwuVmVjKElETC5OYXQ4KSxcbiAgICAgICAgd2FzbV9tb2R1bGU6IHdhc21fbW9kdWxlLFxuICAgICAgICBtb2RlOiBjYW5pc3Rlcl9pbnN0YWxsX21vZGUsXG4gICAgICAgIGNhbmlzdGVyX2lkOiBjYW5pc3Rlcl9pZCxcbiAgICAgICAgc2VuZGVyX2NhbmlzdGVyX3ZlcnNpb246IElETC5PcHQoSURMLk5hdDY0KSxcbiAgICB9KTtcbiAgICBjb25zdCBub2RlX21ldHJpY3NfaGlzdG9yeV9hcmdzID0gSURMLlJlY29yZCh7XG4gICAgICAgIHN0YXJ0X2F0X3RpbWVzdGFtcF9uYW5vczogSURMLk5hdDY0LFxuICAgICAgICBzdWJuZXRfaWQ6IElETC5QcmluY2lwYWwsXG4gICAgfSk7XG4gICAgY29uc3Qgbm9kZV9tZXRyaWNzID0gSURMLlJlY29yZCh7XG4gICAgICAgIG51bV9ibG9ja19mYWlsdXJlc190b3RhbDogSURMLk5hdDY0LFxuICAgICAgICBub2RlX2lkOiBJREwuUHJpbmNpcGFsLFxuICAgICAgICBudW1fYmxvY2tzX3Byb3Bvc2VkX3RvdGFsOiBJREwuTmF0NjQsXG4gICAgfSk7XG4gICAgY29uc3Qgbm9kZV9tZXRyaWNzX2hpc3RvcnlfcmVzdWx0ID0gSURMLlZlYyhJREwuUmVjb3JkKHtcbiAgICAgICAgdGltZXN0YW1wX25hbm9zOiBJREwuTmF0NjQsXG4gICAgICAgIG5vZGVfbWV0cmljczogSURMLlZlYyhub2RlX21ldHJpY3MpLFxuICAgIH0pKTtcbiAgICBjb25zdCBwcm92aXNpb25hbF9jcmVhdGVfY2FuaXN0ZXJfd2l0aF9jeWNsZXNfYXJncyA9IElETC5SZWNvcmQoe1xuICAgICAgICBzZXR0aW5nczogSURMLk9wdChjYW5pc3Rlcl9zZXR0aW5ncyksXG4gICAgICAgIHNwZWNpZmllZF9pZDogSURMLk9wdChjYW5pc3Rlcl9pZCksXG4gICAgICAgIGFtb3VudDogSURMLk9wdChJREwuTmF0KSxcbiAgICAgICAgc2VuZGVyX2NhbmlzdGVyX3ZlcnNpb246IElETC5PcHQoSURMLk5hdDY0KSxcbiAgICB9KTtcbiAgICBjb25zdCBwcm92aXNpb25hbF9jcmVhdGVfY2FuaXN0ZXJfd2l0aF9jeWNsZXNfcmVzdWx0ID0gSURMLlJlY29yZCh7XG4gICAgICAgIGNhbmlzdGVyX2lkOiBjYW5pc3Rlcl9pZCxcbiAgICB9KTtcbiAgICBjb25zdCBwcm92aXNpb25hbF90b3BfdXBfY2FuaXN0ZXJfYXJncyA9IElETC5SZWNvcmQoe1xuICAgICAgICBjYW5pc3Rlcl9pZDogY2FuaXN0ZXJfaWQsXG4gICAgICAgIGFtb3VudDogSURMLk5hdCxcbiAgICB9KTtcbiAgICBjb25zdCByYXdfcmFuZF9yZXN1bHQgPSBJREwuVmVjKElETC5OYXQ4KTtcbiAgICBjb25zdCBzY2hub3JyX2FsZ29yaXRobSA9IElETC5WYXJpYW50KHtcbiAgICAgICAgZWQyNTUxOTogSURMLk51bGwsXG4gICAgICAgIGJpcDM0MHNlY3AyNTZrMTogSURMLk51bGwsXG4gICAgfSk7XG4gICAgY29uc3Qgc2Nobm9ycl9wdWJsaWNfa2V5X2FyZ3MgPSBJREwuUmVjb3JkKHtcbiAgICAgICAga2V5X2lkOiBJREwuUmVjb3JkKHtcbiAgICAgICAgICAgIGFsZ29yaXRobTogc2Nobm9ycl9hbGdvcml0aG0sXG4gICAgICAgICAgICBuYW1lOiBJREwuVGV4dCxcbiAgICAgICAgfSksXG4gICAgICAgIGNhbmlzdGVyX2lkOiBJREwuT3B0KGNhbmlzdGVyX2lkKSxcbiAgICAgICAgZGVyaXZhdGlvbl9wYXRoOiBJREwuVmVjKElETC5WZWMoSURMLk5hdDgpKSxcbiAgICB9KTtcbiAgICBjb25zdCBzY2hub3JyX3B1YmxpY19rZXlfcmVzdWx0ID0gSURMLlJlY29yZCh7XG4gICAgICAgIHB1YmxpY19rZXk6IElETC5WZWMoSURMLk5hdDgpLFxuICAgICAgICBjaGFpbl9jb2RlOiBJREwuVmVjKElETC5OYXQ4KSxcbiAgICB9KTtcbiAgICBjb25zdCBzaWduX3dpdGhfZWNkc2FfYXJncyA9IElETC5SZWNvcmQoe1xuICAgICAgICBrZXlfaWQ6IElETC5SZWNvcmQoeyBuYW1lOiBJREwuVGV4dCwgY3VydmU6IGVjZHNhX2N1cnZlIH0pLFxuICAgICAgICBkZXJpdmF0aW9uX3BhdGg6IElETC5WZWMoSURMLlZlYyhJREwuTmF0OCkpLFxuICAgICAgICBtZXNzYWdlX2hhc2g6IElETC5WZWMoSURMLk5hdDgpLFxuICAgIH0pO1xuICAgIGNvbnN0IHNpZ25fd2l0aF9lY2RzYV9yZXN1bHQgPSBJREwuUmVjb3JkKHtcbiAgICAgICAgc2lnbmF0dXJlOiBJREwuVmVjKElETC5OYXQ4KSxcbiAgICB9KTtcbiAgICBjb25zdCBzaWduX3dpdGhfc2Nobm9ycl9hcmdzID0gSURMLlJlY29yZCh7XG4gICAgICAgIGtleV9pZDogSURMLlJlY29yZCh7XG4gICAgICAgICAgICBhbGdvcml0aG06IHNjaG5vcnJfYWxnb3JpdGhtLFxuICAgICAgICAgICAgbmFtZTogSURMLlRleHQsXG4gICAgICAgIH0pLFxuICAgICAgICBkZXJpdmF0aW9uX3BhdGg6IElETC5WZWMoSURMLlZlYyhJREwuTmF0OCkpLFxuICAgICAgICBtZXNzYWdlOiBJREwuVmVjKElETC5OYXQ4KSxcbiAgICB9KTtcbiAgICBjb25zdCBzaWduX3dpdGhfc2Nobm9ycl9yZXN1bHQgPSBJREwuUmVjb3JkKHtcbiAgICAgICAgc2lnbmF0dXJlOiBJREwuVmVjKElETC5OYXQ4KSxcbiAgICB9KTtcbiAgICBjb25zdCBzdGFydF9jYW5pc3Rlcl9hcmdzID0gSURMLlJlY29yZCh7IGNhbmlzdGVyX2lkOiBjYW5pc3Rlcl9pZCB9KTtcbiAgICBjb25zdCBzdG9wX2NhbmlzdGVyX2FyZ3MgPSBJREwuUmVjb3JkKHsgY2FuaXN0ZXJfaWQ6IGNhbmlzdGVyX2lkIH0pO1xuICAgIGNvbnN0IHN0b3JlZF9jaHVua3NfYXJncyA9IElETC5SZWNvcmQoeyBjYW5pc3Rlcl9pZDogY2FuaXN0ZXJfaWQgfSk7XG4gICAgY29uc3Qgc3RvcmVkX2NodW5rc19yZXN1bHQgPSBJREwuVmVjKGNodW5rX2hhc2gpO1xuICAgIGNvbnN0IHVuaW5zdGFsbF9jb2RlX2FyZ3MgPSBJREwuUmVjb3JkKHtcbiAgICAgICAgY2FuaXN0ZXJfaWQ6IGNhbmlzdGVyX2lkLFxuICAgICAgICBzZW5kZXJfY2FuaXN0ZXJfdmVyc2lvbjogSURMLk9wdChJREwuTmF0NjQpLFxuICAgIH0pO1xuICAgIGNvbnN0IHVwZGF0ZV9zZXR0aW5nc19hcmdzID0gSURMLlJlY29yZCh7XG4gICAgICAgIGNhbmlzdGVyX2lkOiBJREwuUHJpbmNpcGFsLFxuICAgICAgICBzZXR0aW5nczogY2FuaXN0ZXJfc2V0dGluZ3MsXG4gICAgICAgIHNlbmRlcl9jYW5pc3Rlcl92ZXJzaW9uOiBJREwuT3B0KElETC5OYXQ2NCksXG4gICAgfSk7XG4gICAgY29uc3QgdXBsb2FkX2NodW5rX2FyZ3MgPSBJREwuUmVjb3JkKHtcbiAgICAgICAgY2h1bms6IElETC5WZWMoSURMLk5hdDgpLFxuICAgICAgICBjYW5pc3Rlcl9pZDogSURMLlByaW5jaXBhbCxcbiAgICB9KTtcbiAgICBjb25zdCB1cGxvYWRfY2h1bmtfcmVzdWx0ID0gY2h1bmtfaGFzaDtcbiAgICByZXR1cm4gSURMLlNlcnZpY2Uoe1xuICAgICAgICBiaXRjb2luX2dldF9iYWxhbmNlOiBJREwuRnVuYyhbYml0Y29pbl9nZXRfYmFsYW5jZV9hcmdzXSwgW2JpdGNvaW5fZ2V0X2JhbGFuY2VfcmVzdWx0XSwgW10pLFxuICAgICAgICBiaXRjb2luX2dldF9jdXJyZW50X2ZlZV9wZXJjZW50aWxlczogSURMLkZ1bmMoW2JpdGNvaW5fZ2V0X2N1cnJlbnRfZmVlX3BlcmNlbnRpbGVzX2FyZ3NdLCBbYml0Y29pbl9nZXRfY3VycmVudF9mZWVfcGVyY2VudGlsZXNfcmVzdWx0XSwgW10pLFxuICAgICAgICBiaXRjb2luX2dldF91dHhvczogSURMLkZ1bmMoW2JpdGNvaW5fZ2V0X3V0eG9zX2FyZ3NdLCBbYml0Y29pbl9nZXRfdXR4b3NfcmVzdWx0XSwgW10pLFxuICAgICAgICBiaXRjb2luX3NlbmRfdHJhbnNhY3Rpb246IElETC5GdW5jKFtiaXRjb2luX3NlbmRfdHJhbnNhY3Rpb25fYXJnc10sIFtdLCBbXSksXG4gICAgICAgIGNhbmlzdGVyX2luZm86IElETC5GdW5jKFtjYW5pc3Rlcl9pbmZvX2FyZ3NdLCBbY2FuaXN0ZXJfaW5mb19yZXN1bHRdLCBbXSksXG4gICAgICAgIGNhbmlzdGVyX3N0YXR1czogSURMLkZ1bmMoW2NhbmlzdGVyX3N0YXR1c19hcmdzXSwgW2NhbmlzdGVyX3N0YXR1c19yZXN1bHRdLCBbXSksXG4gICAgICAgIGNsZWFyX2NodW5rX3N0b3JlOiBJREwuRnVuYyhbY2xlYXJfY2h1bmtfc3RvcmVfYXJnc10sIFtdLCBbXSksXG4gICAgICAgIGNyZWF0ZV9jYW5pc3RlcjogSURMLkZ1bmMoW2NyZWF0ZV9jYW5pc3Rlcl9hcmdzXSwgW2NyZWF0ZV9jYW5pc3Rlcl9yZXN1bHRdLCBbXSksXG4gICAgICAgIGRlbGV0ZV9jYW5pc3RlcjogSURMLkZ1bmMoW2RlbGV0ZV9jYW5pc3Rlcl9hcmdzXSwgW10sIFtdKSxcbiAgICAgICAgZGVwb3NpdF9jeWNsZXM6IElETC5GdW5jKFtkZXBvc2l0X2N5Y2xlc19hcmdzXSwgW10sIFtdKSxcbiAgICAgICAgZWNkc2FfcHVibGljX2tleTogSURMLkZ1bmMoW2VjZHNhX3B1YmxpY19rZXlfYXJnc10sIFtlY2RzYV9wdWJsaWNfa2V5X3Jlc3VsdF0sIFtdKSxcbiAgICAgICAgZmV0Y2hfY2FuaXN0ZXJfbG9nczogSURMLkZ1bmMoW2ZldGNoX2NhbmlzdGVyX2xvZ3NfYXJnc10sIFtmZXRjaF9jYW5pc3Rlcl9sb2dzX3Jlc3VsdF0sIFsncXVlcnknXSksXG4gICAgICAgIGh0dHBfcmVxdWVzdDogSURMLkZ1bmMoW2h0dHBfcmVxdWVzdF9hcmdzXSwgW2h0dHBfcmVxdWVzdF9yZXN1bHRdLCBbXSksXG4gICAgICAgIGluc3RhbGxfY2h1bmtlZF9jb2RlOiBJREwuRnVuYyhbaW5zdGFsbF9jaHVua2VkX2NvZGVfYXJnc10sIFtdLCBbXSksXG4gICAgICAgIGluc3RhbGxfY29kZTogSURMLkZ1bmMoW2luc3RhbGxfY29kZV9hcmdzXSwgW10sIFtdKSxcbiAgICAgICAgbm9kZV9tZXRyaWNzX2hpc3Rvcnk6IElETC5GdW5jKFtub2RlX21ldHJpY3NfaGlzdG9yeV9hcmdzXSwgW25vZGVfbWV0cmljc19oaXN0b3J5X3Jlc3VsdF0sIFtdKSxcbiAgICAgICAgcHJvdmlzaW9uYWxfY3JlYXRlX2NhbmlzdGVyX3dpdGhfY3ljbGVzOiBJREwuRnVuYyhbcHJvdmlzaW9uYWxfY3JlYXRlX2NhbmlzdGVyX3dpdGhfY3ljbGVzX2FyZ3NdLCBbcHJvdmlzaW9uYWxfY3JlYXRlX2NhbmlzdGVyX3dpdGhfY3ljbGVzX3Jlc3VsdF0sIFtdKSxcbiAgICAgICAgcHJvdmlzaW9uYWxfdG9wX3VwX2NhbmlzdGVyOiBJREwuRnVuYyhbcHJvdmlzaW9uYWxfdG9wX3VwX2NhbmlzdGVyX2FyZ3NdLCBbXSwgW10pLFxuICAgICAgICByYXdfcmFuZDogSURMLkZ1bmMoW10sIFtyYXdfcmFuZF9yZXN1bHRdLCBbXSksXG4gICAgICAgIHNjaG5vcnJfcHVibGljX2tleTogSURMLkZ1bmMoW3NjaG5vcnJfcHVibGljX2tleV9hcmdzXSwgW3NjaG5vcnJfcHVibGljX2tleV9yZXN1bHRdLCBbXSksXG4gICAgICAgIHNpZ25fd2l0aF9lY2RzYTogSURMLkZ1bmMoW3NpZ25fd2l0aF9lY2RzYV9hcmdzXSwgW3NpZ25fd2l0aF9lY2RzYV9yZXN1bHRdLCBbXSksXG4gICAgICAgIHNpZ25fd2l0aF9zY2hub3JyOiBJREwuRnVuYyhbc2lnbl93aXRoX3NjaG5vcnJfYXJnc10sIFtzaWduX3dpdGhfc2Nobm9ycl9yZXN1bHRdLCBbXSksXG4gICAgICAgIHN0YXJ0X2NhbmlzdGVyOiBJREwuRnVuYyhbc3RhcnRfY2FuaXN0ZXJfYXJnc10sIFtdLCBbXSksXG4gICAgICAgIHN0b3BfY2FuaXN0ZXI6IElETC5GdW5jKFtzdG9wX2NhbmlzdGVyX2FyZ3NdLCBbXSwgW10pLFxuICAgICAgICBzdG9yZWRfY2h1bmtzOiBJREwuRnVuYyhbc3RvcmVkX2NodW5rc19hcmdzXSwgW3N0b3JlZF9jaHVua3NfcmVzdWx0XSwgW10pLFxuICAgICAgICB1bmluc3RhbGxfY29kZTogSURMLkZ1bmMoW3VuaW5zdGFsbF9jb2RlX2FyZ3NdLCBbXSwgW10pLFxuICAgICAgICB1cGRhdGVfc2V0dGluZ3M6IElETC5GdW5jKFt1cGRhdGVfc2V0dGluZ3NfYXJnc10sIFtdLCBbXSksXG4gICAgICAgIHVwbG9hZF9jaHVuazogSURMLkZ1bmMoW3VwbG9hZF9jaHVua19hcmdzXSwgW3VwbG9hZF9jaHVua19yZXN1bHRdLCBbXSksXG4gICAgfSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFuYWdlbWVudF9pZGwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/canisters/management_idl.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/cbor.js":
/*!*****************************************************!*\
  !*** ./node_modules/@dfinity/agent/lib/esm/cbor.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CborTag: function() { return /* binding */ CborTag; },\n/* harmony export */   decode: function() { return /* binding */ decode; },\n/* harmony export */   encode: function() { return /* binding */ encode; }\n/* harmony export */ });\n/* harmony import */ var borc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! borc */ \"(app-pages-browser)/../../node_modules/borc/src/index.js\");\n/* harmony import */ var simple_cbor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! simple-cbor */ \"(app-pages-browser)/../../node_modules/simple-cbor/src/index.js\");\n/* harmony import */ var simple_cbor__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(simple_cbor__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/buffer */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/utils/buffer.js\");\n// This file is based on:\n// https://github.com/dfinity-lab/dfinity/blob/9bca65f8edd65701ea6bdb00e0752f9186bbc893/docs/spec/public/index.adoc#cbor-encoding-of-requests-and-responses\n\n\n\n\n// We are using hansl/simple-cbor for CBOR serialization, to avoid issues with\n// encoding the uint64 values that the HTTP handler of the client expects for\n// canister IDs. However, simple-cbor does not yet provide deserialization so\n// we are using `Uint8Array` so that we can use the dignifiedquire/borc CBOR\n// decoder.\nclass PrincipalEncoder {\n    get name() {\n        return 'Principal';\n    }\n    get priority() {\n        return 0;\n    }\n    match(value) {\n        return value && value._isPrincipal === true;\n    }\n    encode(v) {\n        return simple_cbor__WEBPACK_IMPORTED_MODULE_1__.value.bytes(v.toUint8Array());\n    }\n}\nclass BufferEncoder {\n    get name() {\n        return 'Buffer';\n    }\n    get priority() {\n        return 1;\n    }\n    match(value) {\n        return value instanceof ArrayBuffer || ArrayBuffer.isView(value);\n    }\n    encode(v) {\n        return simple_cbor__WEBPACK_IMPORTED_MODULE_1__.value.bytes(new Uint8Array(v));\n    }\n}\nclass BigIntEncoder {\n    get name() {\n        return 'BigInt';\n    }\n    get priority() {\n        return 1;\n    }\n    match(value) {\n        return typeof value === `bigint`;\n    }\n    encode(v) {\n        // Always use a bigint encoding.\n        if (v > BigInt(0)) {\n            return simple_cbor__WEBPACK_IMPORTED_MODULE_1__.value.tagged(2, simple_cbor__WEBPACK_IMPORTED_MODULE_1__.value.bytes((0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.fromHex)(v.toString(16))));\n        }\n        else {\n            return simple_cbor__WEBPACK_IMPORTED_MODULE_1__.value.tagged(3, simple_cbor__WEBPACK_IMPORTED_MODULE_1__.value.bytes((0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.fromHex)((BigInt('-1') * v).toString(16))));\n        }\n    }\n}\nconst serializer = simple_cbor__WEBPACK_IMPORTED_MODULE_1__.SelfDescribeCborSerializer.withDefaultEncoders(true);\nserializer.addEncoder(new PrincipalEncoder());\nserializer.addEncoder(new BufferEncoder());\nserializer.addEncoder(new BigIntEncoder());\nvar CborTag;\n(function (CborTag) {\n    CborTag[CborTag[\"Uint64LittleEndian\"] = 71] = \"Uint64LittleEndian\";\n    CborTag[CborTag[\"Semantic\"] = 55799] = \"Semantic\";\n})(CborTag || (CborTag = {}));\n/**\n * Encode a JavaScript value into CBOR.\n */\nfunction encode(value) {\n    return serializer.serialize(value);\n}\nfunction decodePositiveBigInt(buf) {\n    const len = buf.byteLength;\n    let res = BigInt(0);\n    for (let i = 0; i < len; i++) {\n        res = res * BigInt(0x100) + BigInt(buf[i]);\n    }\n    return res;\n}\n// A BORC subclass that decodes byte strings to ArrayBuffer instead of the Buffer class.\nclass Uint8ArrayDecoder extends borc__WEBPACK_IMPORTED_MODULE_0__.Decoder {\n    createByteString(raw) {\n        return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.concat)(...raw);\n    }\n    createByteStringFromHeap(start, end) {\n        if (start === end) {\n            return new ArrayBuffer(0);\n        }\n        return new Uint8Array(this._heap.slice(start, end));\n    }\n}\nfunction decode(input) {\n    const buffer = new Uint8Array(input);\n    const decoder = new Uint8ArrayDecoder({\n        size: buffer.byteLength,\n        tags: {\n            // Override tags 2 and 3 for BigInt support (borc supports only BigNumber).\n            2: val => decodePositiveBigInt(val),\n            3: val => -decodePositiveBigInt(val),\n            [CborTag.Semantic]: (value) => value,\n        },\n    });\n    try {\n        return decoder.decodeFirst(buffer);\n    }\n    catch (e) {\n        throw new Error(`Failed to decode CBOR: ${e}, input: ${(0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.toHex)(buffer)}`);\n    }\n}\n//# sourceMappingURL=cbor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2Nib3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDd0I7QUFDWTtBQUNxQjtBQUNEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4Q0FBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOENBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhDQUFVLFdBQVcsOENBQVUsT0FBTyxzREFBTztBQUNoRTtBQUNBO0FBQ0EsbUJBQW1CLDhDQUFVLFdBQVcsOENBQVUsT0FBTyxzREFBTztBQUNoRTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUVBQTBCO0FBQzdDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQkFBMEI7QUFDM0I7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx5Q0FBWTtBQUM1QztBQUNBLGVBQWUscURBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsRUFBRSxXQUFXLG9EQUFLLFNBQVM7QUFDN0U7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2Nib3IuanM/YzM0NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGlzIGZpbGUgaXMgYmFzZWQgb246XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZGZpbml0eS1sYWIvZGZpbml0eS9ibG9iLzliY2E2NWY4ZWRkNjU3MDFlYTZiZGIwMGUwNzUyZjkxODZiYmM4OTMvZG9jcy9zcGVjL3B1YmxpYy9pbmRleC5hZG9jI2Nib3ItZW5jb2Rpbmctb2YtcmVxdWVzdHMtYW5kLXJlc3BvbnNlc1xuaW1wb3J0IGJvcmMgZnJvbSAnYm9yYyc7XG5pbXBvcnQgKiBhcyBjYm9yIGZyb20gJ3NpbXBsZS1jYm9yJztcbmltcG9ydCB7IFNlbGZEZXNjcmliZUNib3JTZXJpYWxpemVyIH0gZnJvbSAnc2ltcGxlLWNib3InO1xuaW1wb3J0IHsgY29uY2F0LCBmcm9tSGV4LCB0b0hleCB9IGZyb20gJy4vdXRpbHMvYnVmZmVyJztcbi8vIFdlIGFyZSB1c2luZyBoYW5zbC9zaW1wbGUtY2JvciBmb3IgQ0JPUiBzZXJpYWxpemF0aW9uLCB0byBhdm9pZCBpc3N1ZXMgd2l0aFxuLy8gZW5jb2RpbmcgdGhlIHVpbnQ2NCB2YWx1ZXMgdGhhdCB0aGUgSFRUUCBoYW5kbGVyIG9mIHRoZSBjbGllbnQgZXhwZWN0cyBmb3Jcbi8vIGNhbmlzdGVyIElEcy4gSG93ZXZlciwgc2ltcGxlLWNib3IgZG9lcyBub3QgeWV0IHByb3ZpZGUgZGVzZXJpYWxpemF0aW9uIHNvXG4vLyB3ZSBhcmUgdXNpbmcgYFVpbnQ4QXJyYXlgIHNvIHRoYXQgd2UgY2FuIHVzZSB0aGUgZGlnbmlmaWVkcXVpcmUvYm9yYyBDQk9SXG4vLyBkZWNvZGVyLlxuY2xhc3MgUHJpbmNpcGFsRW5jb2RlciB7XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnUHJpbmNpcGFsJztcbiAgICB9XG4gICAgZ2V0IHByaW9yaXR5KCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgbWF0Y2godmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICYmIHZhbHVlLl9pc1ByaW5jaXBhbCA9PT0gdHJ1ZTtcbiAgICB9XG4gICAgZW5jb2RlKHYpIHtcbiAgICAgICAgcmV0dXJuIGNib3IudmFsdWUuYnl0ZXModi50b1VpbnQ4QXJyYXkoKSk7XG4gICAgfVxufVxuY2xhc3MgQnVmZmVyRW5jb2RlciB7XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnQnVmZmVyJztcbiAgICB9XG4gICAgZ2V0IHByaW9yaXR5KCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgbWF0Y2godmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKTtcbiAgICB9XG4gICAgZW5jb2RlKHYpIHtcbiAgICAgICAgcmV0dXJuIGNib3IudmFsdWUuYnl0ZXMobmV3IFVpbnQ4QXJyYXkodikpO1xuICAgIH1cbn1cbmNsYXNzIEJpZ0ludEVuY29kZXIge1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gJ0JpZ0ludCc7XG4gICAgfVxuICAgIGdldCBwcmlvcml0eSgpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIG1hdGNoKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IGBiaWdpbnRgO1xuICAgIH1cbiAgICBlbmNvZGUodikge1xuICAgICAgICAvLyBBbHdheXMgdXNlIGEgYmlnaW50IGVuY29kaW5nLlxuICAgICAgICBpZiAodiA+IEJpZ0ludCgwKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNib3IudmFsdWUudGFnZ2VkKDIsIGNib3IudmFsdWUuYnl0ZXMoZnJvbUhleCh2LnRvU3RyaW5nKDE2KSkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjYm9yLnZhbHVlLnRhZ2dlZCgzLCBjYm9yLnZhbHVlLmJ5dGVzKGZyb21IZXgoKEJpZ0ludCgnLTEnKSAqIHYpLnRvU3RyaW5nKDE2KSkpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IHNlcmlhbGl6ZXIgPSBTZWxmRGVzY3JpYmVDYm9yU2VyaWFsaXplci53aXRoRGVmYXVsdEVuY29kZXJzKHRydWUpO1xuc2VyaWFsaXplci5hZGRFbmNvZGVyKG5ldyBQcmluY2lwYWxFbmNvZGVyKCkpO1xuc2VyaWFsaXplci5hZGRFbmNvZGVyKG5ldyBCdWZmZXJFbmNvZGVyKCkpO1xuc2VyaWFsaXplci5hZGRFbmNvZGVyKG5ldyBCaWdJbnRFbmNvZGVyKCkpO1xuZXhwb3J0IHZhciBDYm9yVGFnO1xuKGZ1bmN0aW9uIChDYm9yVGFnKSB7XG4gICAgQ2JvclRhZ1tDYm9yVGFnW1wiVWludDY0TGl0dGxlRW5kaWFuXCJdID0gNzFdID0gXCJVaW50NjRMaXR0bGVFbmRpYW5cIjtcbiAgICBDYm9yVGFnW0Nib3JUYWdbXCJTZW1hbnRpY1wiXSA9IDU1Nzk5XSA9IFwiU2VtYW50aWNcIjtcbn0pKENib3JUYWcgfHwgKENib3JUYWcgPSB7fSkpO1xuLyoqXG4gKiBFbmNvZGUgYSBKYXZhU2NyaXB0IHZhbHVlIGludG8gQ0JPUi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZSh2YWx1ZSkge1xuICAgIHJldHVybiBzZXJpYWxpemVyLnNlcmlhbGl6ZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBkZWNvZGVQb3NpdGl2ZUJpZ0ludChidWYpIHtcbiAgICBjb25zdCBsZW4gPSBidWYuYnl0ZUxlbmd0aDtcbiAgICBsZXQgcmVzID0gQmlnSW50KDApO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcmVzID0gcmVzICogQmlnSW50KDB4MTAwKSArIEJpZ0ludChidWZbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLy8gQSBCT1JDIHN1YmNsYXNzIHRoYXQgZGVjb2RlcyBieXRlIHN0cmluZ3MgdG8gQXJyYXlCdWZmZXIgaW5zdGVhZCBvZiB0aGUgQnVmZmVyIGNsYXNzLlxuY2xhc3MgVWludDhBcnJheURlY29kZXIgZXh0ZW5kcyBib3JjLkRlY29kZXIge1xuICAgIGNyZWF0ZUJ5dGVTdHJpbmcocmF3KSB7XG4gICAgICAgIHJldHVybiBjb25jYXQoLi4ucmF3KTtcbiAgICB9XG4gICAgY3JlYXRlQnl0ZVN0cmluZ0Zyb21IZWFwKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSBlbmQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMuX2hlYXAuc2xpY2Uoc3RhcnQsIGVuZCkpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShpbnB1dCk7XG4gICAgY29uc3QgZGVjb2RlciA9IG5ldyBVaW50OEFycmF5RGVjb2Rlcih7XG4gICAgICAgIHNpemU6IGJ1ZmZlci5ieXRlTGVuZ3RoLFxuICAgICAgICB0YWdzOiB7XG4gICAgICAgICAgICAvLyBPdmVycmlkZSB0YWdzIDIgYW5kIDMgZm9yIEJpZ0ludCBzdXBwb3J0IChib3JjIHN1cHBvcnRzIG9ubHkgQmlnTnVtYmVyKS5cbiAgICAgICAgICAgIDI6IHZhbCA9PiBkZWNvZGVQb3NpdGl2ZUJpZ0ludCh2YWwpLFxuICAgICAgICAgICAgMzogdmFsID0+IC1kZWNvZGVQb3NpdGl2ZUJpZ0ludCh2YWwpLFxuICAgICAgICAgICAgW0Nib3JUYWcuU2VtYW50aWNdOiAodmFsdWUpID0+IHZhbHVlLFxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVyLmRlY29kZUZpcnN0KGJ1ZmZlcik7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGRlY29kZSBDQk9SOiAke2V9LCBpbnB1dDogJHt0b0hleChidWZmZXIpfWApO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNib3IuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/cbor.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/certificate.js":
/*!************************************************************!*\
  !*** ./node_modules/@dfinity/agent/lib/esm/certificate.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Certificate: function() { return /* binding */ Certificate; },\n/* harmony export */   CertificateVerificationError: function() { return /* binding */ CertificateVerificationError; },\n/* harmony export */   LookupStatus: function() { return /* binding */ LookupStatus; },\n/* harmony export */   NodeType: function() { return /* binding */ NodeType; },\n/* harmony export */   check_canister_ranges: function() { return /* binding */ check_canister_ranges; },\n/* harmony export */   find_label: function() { return /* binding */ find_label; },\n/* harmony export */   flatten_forks: function() { return /* binding */ flatten_forks; },\n/* harmony export */   hashTreeToString: function() { return /* binding */ hashTreeToString; },\n/* harmony export */   lookupResultToBuffer: function() { return /* binding */ lookupResultToBuffer; },\n/* harmony export */   lookup_path: function() { return /* binding */ lookup_path; },\n/* harmony export */   reconstruct: function() { return /* binding */ reconstruct; }\n/* harmony export */ });\n/* harmony import */ var _cbor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cbor */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/cbor.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/errors.js\");\n/* harmony import */ var _request_id__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./request_id */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/request_id.js\");\n/* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/buffer */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/utils/buffer.js\");\n/* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @dfinity/principal */ \"(app-pages-browser)/./node_modules/@dfinity/principal/lib/esm/index.js\");\n/* harmony import */ var _utils_bls__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/bls */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/utils/bls.js\");\n/* harmony import */ var _utils_leb__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/leb */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/utils/leb.js\");\n\n\n\n\n\n\n\n/**\n * A certificate may fail verification with respect to the provided public key\n */\nclass CertificateVerificationError extends _errors__WEBPACK_IMPORTED_MODULE_1__.AgentError {\n    constructor(reason) {\n        super(`Invalid certificate: ${reason}`);\n    }\n}\nvar NodeType;\n(function (NodeType) {\n    NodeType[NodeType[\"Empty\"] = 0] = \"Empty\";\n    NodeType[NodeType[\"Fork\"] = 1] = \"Fork\";\n    NodeType[NodeType[\"Labeled\"] = 2] = \"Labeled\";\n    NodeType[NodeType[\"Leaf\"] = 3] = \"Leaf\";\n    NodeType[NodeType[\"Pruned\"] = 4] = \"Pruned\";\n})(NodeType || (NodeType = {}));\n/**\n * Make a human readable string out of a hash tree.\n * @param tree\n */\nfunction hashTreeToString(tree) {\n    const indent = (s) => s\n        .split('\\n')\n        .map(x => '  ' + x)\n        .join('\\n');\n    function labelToString(label) {\n        const decoder = new TextDecoder(undefined, { fatal: true });\n        try {\n            return JSON.stringify(decoder.decode(label));\n        }\n        catch (e) {\n            return `data(...${label.byteLength} bytes)`;\n        }\n    }\n    switch (tree[0]) {\n        case NodeType.Empty:\n            return '()';\n        case NodeType.Fork: {\n            if (tree[1] instanceof Array && tree[2] instanceof ArrayBuffer) {\n                const left = hashTreeToString(tree[1]);\n                const right = hashTreeToString(tree[2]);\n                return `sub(\\n left:\\n${indent(left)}\\n---\\n right:\\n${indent(right)}\\n)`;\n            }\n            else {\n                throw new Error('Invalid tree structure for fork');\n            }\n        }\n        case NodeType.Labeled: {\n            if (tree[1] instanceof ArrayBuffer && tree[2] instanceof ArrayBuffer) {\n                const label = labelToString(tree[1]);\n                const sub = hashTreeToString(tree[2]);\n                return `label(\\n label:\\n${indent(label)}\\n sub:\\n${indent(sub)}\\n)`;\n            }\n            else {\n                throw new Error('Invalid tree structure for labeled');\n            }\n        }\n        case NodeType.Leaf: {\n            if (!tree[1]) {\n                throw new Error('Invalid tree structure for leaf');\n            }\n            else if (Array.isArray(tree[1])) {\n                return JSON.stringify(tree[1]);\n            }\n            return `leaf(...${tree[1].byteLength} bytes)`;\n        }\n        case NodeType.Pruned: {\n            if (!tree[1]) {\n                throw new Error('Invalid tree structure for pruned');\n            }\n            else if (Array.isArray(tree[1])) {\n                return JSON.stringify(tree[1]);\n            }\n            return `pruned(${(0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.toHex)(new Uint8Array(tree[1]))}`;\n        }\n        default: {\n            return `unknown(${JSON.stringify(tree[0])})`;\n        }\n    }\n}\nfunction isBufferGreaterThan(a, b) {\n    const a8 = new Uint8Array(a);\n    const b8 = new Uint8Array(b);\n    for (let i = 0; i < a8.length; i++) {\n        if (a8[i] > b8[i]) {\n            return true;\n        }\n    }\n    return false;\n}\nclass Certificate {\n    constructor(certificate, _rootKey, _canisterId, _blsVerify, \n    // Default to 5 minutes\n    _maxAgeInMinutes = 5) {\n        this._rootKey = _rootKey;\n        this._canisterId = _canisterId;\n        this._blsVerify = _blsVerify;\n        this._maxAgeInMinutes = _maxAgeInMinutes;\n        this.cert = _cbor__WEBPACK_IMPORTED_MODULE_0__.decode(new Uint8Array(certificate));\n    }\n    /**\n     * Create a new instance of a certificate, automatically verifying it. Throws a\n     * CertificateVerificationError if the certificate cannot be verified.\n     * @constructs  Certificate\n     * @param {CreateCertificateOptions} options {@link CreateCertificateOptions}\n     * @param {ArrayBuffer} options.certificate The bytes of the certificate\n     * @param {ArrayBuffer} options.rootKey The root key to verify against\n     * @param {Principal} options.canisterId The effective or signing canister ID\n     * @param {number} options.maxAgeInMinutes The maximum age of the certificate in minutes. Default is 5 minutes.\n     * @throws {CertificateVerificationError}\n     */\n    static async create(options) {\n        const cert = Certificate.createUnverified(options);\n        await cert.verify();\n        return cert;\n    }\n    static createUnverified(options) {\n        let blsVerify = options.blsVerify;\n        if (!blsVerify) {\n            blsVerify = _utils_bls__WEBPACK_IMPORTED_MODULE_5__.blsVerify;\n        }\n        return new Certificate(options.certificate, options.rootKey, options.canisterId, blsVerify, options.maxAgeInMinutes);\n    }\n    lookup(path) {\n        // constrain the type of the result, so that empty HashTree is undefined\n        return lookup_path(path, this.cert.tree);\n    }\n    lookup_label(label) {\n        return this.lookup([label]);\n    }\n    async verify() {\n        const rootHash = await reconstruct(this.cert.tree);\n        const derKey = await this._checkDelegationAndGetKey(this.cert.delegation);\n        const sig = this.cert.signature;\n        const key = extractDER(derKey);\n        const msg = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.concat)(domain_sep('ic-state-root'), rootHash);\n        let sigVer = false;\n        const lookupTime = lookupResultToBuffer(this.lookup(['time']));\n        if (!lookupTime) {\n            // Should never happen - time is always present in IC certificates\n            throw new CertificateVerificationError('Certificate does not contain a time');\n        }\n        const FIVE_MINUTES_IN_MSEC = 5 * 60 * 1000;\n        const MAX_AGE_IN_MSEC = this._maxAgeInMinutes * 60 * 1000;\n        const now = Date.now();\n        const earliestCertificateTime = now - MAX_AGE_IN_MSEC;\n        const fiveMinutesFromNow = now + FIVE_MINUTES_IN_MSEC;\n        const certTime = (0,_utils_leb__WEBPACK_IMPORTED_MODULE_6__.decodeTime)(lookupTime);\n        if (certTime.getTime() < earliestCertificateTime) {\n            throw new CertificateVerificationError(`Certificate is signed more than ${this._maxAgeInMinutes} minutes in the past. Certificate time: ` +\n                certTime.toISOString() +\n                ' Current time: ' +\n                new Date(now).toISOString());\n        }\n        else if (certTime.getTime() > fiveMinutesFromNow) {\n            throw new CertificateVerificationError('Certificate is signed more than 5 minutes in the future. Certificate time: ' +\n                certTime.toISOString() +\n                ' Current time: ' +\n                new Date(now).toISOString());\n        }\n        try {\n            sigVer = await this._blsVerify(new Uint8Array(key), new Uint8Array(sig), new Uint8Array(msg));\n        }\n        catch (err) {\n            sigVer = false;\n        }\n        if (!sigVer) {\n            throw new CertificateVerificationError('Signature verification failed');\n        }\n    }\n    async _checkDelegationAndGetKey(d) {\n        if (!d) {\n            return this._rootKey;\n        }\n        const cert = await Certificate.createUnverified({\n            certificate: d.certificate,\n            rootKey: this._rootKey,\n            canisterId: this._canisterId,\n            blsVerify: this._blsVerify,\n            // Do not check max age for delegation certificates\n            maxAgeInMinutes: Infinity,\n        });\n        if (cert.cert.delegation) {\n            throw new CertificateVerificationError('Delegation certificates cannot be nested');\n        }\n        await cert.verify();\n        const canisterInRange = check_canister_ranges({\n            canisterId: this._canisterId,\n            subnetId: _dfinity_principal__WEBPACK_IMPORTED_MODULE_4__.Principal.fromUint8Array(new Uint8Array(d.subnet_id)),\n            tree: cert.cert.tree,\n        });\n        if (!canisterInRange) {\n            throw new CertificateVerificationError(`Canister ${this._canisterId} not in range of delegations for subnet 0x${(0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.toHex)(d.subnet_id)}`);\n        }\n        const publicKeyLookup = lookupResultToBuffer(cert.lookup(['subnet', d.subnet_id, 'public_key']));\n        if (!publicKeyLookup) {\n            throw new Error(`Could not find subnet key for subnet 0x${(0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.toHex)(d.subnet_id)}`);\n        }\n        return publicKeyLookup;\n    }\n}\nconst DER_PREFIX = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.fromHex)('308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100');\nconst KEY_LENGTH = 96;\nfunction extractDER(buf) {\n    const expectedLength = DER_PREFIX.byteLength + KEY_LENGTH;\n    if (buf.byteLength !== expectedLength) {\n        throw new TypeError(`BLS DER-encoded public key must be ${expectedLength} bytes long`);\n    }\n    const prefix = buf.slice(0, DER_PREFIX.byteLength);\n    if (!(0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.bufEquals)(prefix, DER_PREFIX)) {\n        throw new TypeError(`BLS DER-encoded public key is invalid. Expect the following prefix: ${DER_PREFIX}, but get ${prefix}`);\n    }\n    return buf.slice(DER_PREFIX.byteLength);\n}\n/**\n * utility function to constrain the type of a path\n * @param {ArrayBuffer | HashTree | undefined} result - the result of a lookup\n * @returns ArrayBuffer or Undefined\n */\nfunction lookupResultToBuffer(result) {\n    if (result.status !== LookupStatus.Found) {\n        return undefined;\n    }\n    if (result.value instanceof ArrayBuffer) {\n        return result.value;\n    }\n    if (result.value instanceof Uint8Array) {\n        return result.value.buffer;\n    }\n    return undefined;\n}\n/**\n * @param t\n */\nasync function reconstruct(t) {\n    switch (t[0]) {\n        case NodeType.Empty:\n            return (0,_request_id__WEBPACK_IMPORTED_MODULE_2__.hash)(domain_sep('ic-hashtree-empty'));\n        case NodeType.Pruned:\n            return t[1];\n        case NodeType.Leaf:\n            return (0,_request_id__WEBPACK_IMPORTED_MODULE_2__.hash)((0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.concat)(domain_sep('ic-hashtree-leaf'), t[1]));\n        case NodeType.Labeled:\n            return (0,_request_id__WEBPACK_IMPORTED_MODULE_2__.hash)((0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.concat)(domain_sep('ic-hashtree-labeled'), t[1], await reconstruct(t[2])));\n        case NodeType.Fork:\n            return (0,_request_id__WEBPACK_IMPORTED_MODULE_2__.hash)((0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.concat)(domain_sep('ic-hashtree-fork'), await reconstruct(t[1]), await reconstruct(t[2])));\n        default:\n            throw new Error('unreachable');\n    }\n}\nfunction domain_sep(s) {\n    const len = new Uint8Array([s.length]);\n    const str = new TextEncoder().encode(s);\n    return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.concat)(len, str);\n}\nvar LookupStatus;\n(function (LookupStatus) {\n    LookupStatus[\"Unknown\"] = \"unknown\";\n    LookupStatus[\"Absent\"] = \"absent\";\n    LookupStatus[\"Found\"] = \"found\";\n})(LookupStatus || (LookupStatus = {}));\nvar LabelLookupStatus;\n(function (LabelLookupStatus) {\n    LabelLookupStatus[\"Less\"] = \"less\";\n    LabelLookupStatus[\"Greater\"] = \"greater\";\n})(LabelLookupStatus || (LabelLookupStatus = {}));\nfunction lookup_path(path, tree) {\n    if (path.length === 0) {\n        switch (tree[0]) {\n            case NodeType.Leaf: {\n                if (!tree[1]) {\n                    throw new Error('Invalid tree structure for leaf');\n                }\n                if (tree[1] instanceof ArrayBuffer) {\n                    return {\n                        status: LookupStatus.Found,\n                        value: tree[1],\n                    };\n                }\n                if (tree[1] instanceof Uint8Array) {\n                    return {\n                        status: LookupStatus.Found,\n                        value: tree[1].buffer,\n                    };\n                }\n                return {\n                    status: LookupStatus.Found,\n                    value: tree[1],\n                };\n            }\n            default: {\n                return {\n                    status: LookupStatus.Found,\n                    value: tree,\n                };\n            }\n        }\n    }\n    const label = typeof path[0] === 'string' ? new TextEncoder().encode(path[0]) : path[0];\n    const lookupResult = find_label(label, tree);\n    switch (lookupResult.status) {\n        case LookupStatus.Found: {\n            return lookup_path(path.slice(1), lookupResult.value);\n        }\n        case LabelLookupStatus.Greater:\n        case LabelLookupStatus.Less: {\n            return {\n                status: LookupStatus.Absent,\n            };\n        }\n        default: {\n            return lookupResult;\n        }\n    }\n}\n/**\n * If the tree is a fork, flatten it into an array of trees\n * @param t - the tree to flatten\n * @returns HashTree[] - the flattened tree\n */\nfunction flatten_forks(t) {\n    switch (t[0]) {\n        case NodeType.Empty:\n            return [];\n        case NodeType.Fork:\n            return flatten_forks(t[1]).concat(flatten_forks(t[2]));\n        default:\n            return [t];\n    }\n}\nfunction find_label(label, tree) {\n    switch (tree[0]) {\n        // if we have a labelled node, compare the node's label to the one we are\n        // looking for\n        case NodeType.Labeled:\n            // if the label we're searching for is greater than this node's label,\n            // we need to keep searching\n            if (isBufferGreaterThan(label, tree[1])) {\n                return {\n                    status: LabelLookupStatus.Greater,\n                };\n            }\n            // if the label we're searching for is equal this node's label, we can\n            // stop searching and return the found node\n            if ((0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.bufEquals)(label, tree[1])) {\n                return {\n                    status: LookupStatus.Found,\n                    value: tree[2],\n                };\n            }\n            // if the label we're searching for is not greater than or equal to this\n            // node's label, then it's less than this node's label, and we can stop\n            // searching because we've looked too far\n            return {\n                status: LabelLookupStatus.Less,\n            };\n        // if we have a fork node, we need to search both sides, starting with the left\n        case NodeType.Fork:\n            // search in the left node\n            const leftLookupResult = find_label(label, tree[1]);\n            switch (leftLookupResult.status) {\n                // if the label we're searching for is greater than the left node lookup,\n                // we need to search the right node\n                case LabelLookupStatus.Greater: {\n                    const rightLookupResult = find_label(label, tree[2]);\n                    // if the label we're searching for is less than the right node lookup,\n                    // then we can stop searching and say that the label is provably Absent\n                    if (rightLookupResult.status === LabelLookupStatus.Less) {\n                        return {\n                            status: LookupStatus.Absent,\n                        };\n                    }\n                    // if the label we're searching for is less than or equal to the right\n                    // node lookup, then we let the caller handle it\n                    return rightLookupResult;\n                }\n                // if the left node returns an uncertain result, we need to search the\n                // right node\n                case LookupStatus.Unknown: {\n                    let rightLookupResult = find_label(label, tree[2]);\n                    // if the label we're searching for is less than the right node lookup,\n                    // then we also need to return an uncertain result\n                    if (rightLookupResult.status === LabelLookupStatus.Less) {\n                        return {\n                            status: LookupStatus.Unknown,\n                        };\n                    }\n                    // if the label we're searching for is less than or equal to the right\n                    // node lookup, then we let the caller handle it\n                    return rightLookupResult;\n                }\n                // if the label we're searching for is not greater than the left node\n                // lookup, or the result is not uncertain, we stop searching and return\n                // whatever the result of the left node lookup was, which can be either\n                // Found or Absent\n                default: {\n                    return leftLookupResult;\n                }\n            }\n        // if we encounter a Pruned node, we can't know for certain if the label\n        // we're searching for is present or not\n        case NodeType.Pruned:\n            return {\n                status: LookupStatus.Unknown,\n            };\n        // if the current node is Empty, or a Leaf, we can stop searching because\n        // we know for sure that the label we're searching for is not present\n        default:\n            return {\n                status: LookupStatus.Absent,\n            };\n    }\n}\n/**\n * Check if a canister falls within a range of canisters\n * @param canisterId Principal\n * @param ranges [Principal, Principal][]\n * @returns\n */\nfunction check_canister_ranges(params) {\n    const { canisterId, subnetId, tree } = params;\n    const rangeLookup = lookup_path(['subnet', subnetId.toUint8Array(), 'canister_ranges'], tree);\n    if (rangeLookup.status !== LookupStatus.Found || !(rangeLookup.value instanceof ArrayBuffer)) {\n        throw new Error(`Could not find canister ranges for subnet ${subnetId}`);\n    }\n    const ranges_arr = _cbor__WEBPACK_IMPORTED_MODULE_0__.decode(rangeLookup.value);\n    const ranges = ranges_arr.map(v => [\n        _dfinity_principal__WEBPACK_IMPORTED_MODULE_4__.Principal.fromUint8Array(v[0]),\n        _dfinity_principal__WEBPACK_IMPORTED_MODULE_4__.Principal.fromUint8Array(v[1]),\n    ]);\n    const canisterInRange = ranges.some(r => r[0].ltEq(canisterId) && r[1].gtEq(canisterId));\n    return canisterInRange;\n}\n//# sourceMappingURL=certificate.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2NlcnRpZmljYXRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUErQjtBQUNPO0FBQ0Y7QUFDK0I7QUFDcEI7QUFDWjtBQUNNO0FBQ3pDO0FBQ0E7QUFDQTtBQUNPLDJDQUEyQywrQ0FBVTtBQUM1RDtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGFBQWE7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0JBQWtCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxhQUFhLGtCQUFrQixjQUFjO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxjQUFjLFdBQVcsWUFBWTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsb0JBQW9CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsb0RBQUssMEJBQTBCO0FBQzVEO0FBQ0E7QUFDQSw4QkFBOEIsd0JBQXdCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUNBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEJBQTBCLFNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksNkJBQTZCO0FBQ3pDO0FBQ0E7QUFDQSxxRUFBcUUsU0FBUztBQUM5RTtBQUNBLHVCQUF1Qix5Q0FBVztBQUNsQztBQUNBLFFBQVEseURBQVM7QUFDakIsUUFBUSx5REFBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2NlcnRpZmljYXRlLmpzP2ZjYTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY2JvciBmcm9tICcuL2Nib3InO1xuaW1wb3J0IHsgQWdlbnRFcnJvciB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB7IGhhc2ggfSBmcm9tICcuL3JlcXVlc3RfaWQnO1xuaW1wb3J0IHsgYnVmRXF1YWxzLCBjb25jYXQsIGZyb21IZXgsIHRvSGV4IH0gZnJvbSAnLi91dGlscy9idWZmZXInO1xuaW1wb3J0IHsgUHJpbmNpcGFsIH0gZnJvbSAnQGRmaW5pdHkvcHJpbmNpcGFsJztcbmltcG9ydCAqIGFzIGJscyBmcm9tICcuL3V0aWxzL2Jscyc7XG5pbXBvcnQgeyBkZWNvZGVUaW1lIH0gZnJvbSAnLi91dGlscy9sZWInO1xuLyoqXG4gKiBBIGNlcnRpZmljYXRlIG1heSBmYWlsIHZlcmlmaWNhdGlvbiB3aXRoIHJlc3BlY3QgdG8gdGhlIHByb3ZpZGVkIHB1YmxpYyBrZXlcbiAqL1xuZXhwb3J0IGNsYXNzIENlcnRpZmljYXRlVmVyaWZpY2F0aW9uRXJyb3IgZXh0ZW5kcyBBZ2VudEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihyZWFzb24pIHtcbiAgICAgICAgc3VwZXIoYEludmFsaWQgY2VydGlmaWNhdGU6ICR7cmVhc29ufWApO1xuICAgIH1cbn1cbmV4cG9ydCB2YXIgTm9kZVR5cGU7XG4oZnVuY3Rpb24gKE5vZGVUeXBlKSB7XG4gICAgTm9kZVR5cGVbTm9kZVR5cGVbXCJFbXB0eVwiXSA9IDBdID0gXCJFbXB0eVwiO1xuICAgIE5vZGVUeXBlW05vZGVUeXBlW1wiRm9ya1wiXSA9IDFdID0gXCJGb3JrXCI7XG4gICAgTm9kZVR5cGVbTm9kZVR5cGVbXCJMYWJlbGVkXCJdID0gMl0gPSBcIkxhYmVsZWRcIjtcbiAgICBOb2RlVHlwZVtOb2RlVHlwZVtcIkxlYWZcIl0gPSAzXSA9IFwiTGVhZlwiO1xuICAgIE5vZGVUeXBlW05vZGVUeXBlW1wiUHJ1bmVkXCJdID0gNF0gPSBcIlBydW5lZFwiO1xufSkoTm9kZVR5cGUgfHwgKE5vZGVUeXBlID0ge30pKTtcbi8qKlxuICogTWFrZSBhIGh1bWFuIHJlYWRhYmxlIHN0cmluZyBvdXQgb2YgYSBoYXNoIHRyZWUuXG4gKiBAcGFyYW0gdHJlZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaFRyZWVUb1N0cmluZyh0cmVlKSB7XG4gICAgY29uc3QgaW5kZW50ID0gKHMpID0+IHNcbiAgICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgICAubWFwKHggPT4gJyAgJyArIHgpXG4gICAgICAgIC5qb2luKCdcXG4nKTtcbiAgICBmdW5jdGlvbiBsYWJlbFRvU3RyaW5nKGxhYmVsKSB7XG4gICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIodW5kZWZpbmVkLCB7IGZhdGFsOiB0cnVlIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRlY29kZXIuZGVjb2RlKGxhYmVsKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBgZGF0YSguLi4ke2xhYmVsLmJ5dGVMZW5ndGh9IGJ5dGVzKWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoICh0cmVlWzBdKSB7XG4gICAgICAgIGNhc2UgTm9kZVR5cGUuRW1wdHk6XG4gICAgICAgICAgICByZXR1cm4gJygpJztcbiAgICAgICAgY2FzZSBOb2RlVHlwZS5Gb3JrOiB7XG4gICAgICAgICAgICBpZiAodHJlZVsxXSBpbnN0YW5jZW9mIEFycmF5ICYmIHRyZWVbMl0gaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBoYXNoVHJlZVRvU3RyaW5nKHRyZWVbMV0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gaGFzaFRyZWVUb1N0cmluZyh0cmVlWzJdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYHN1YihcXG4gbGVmdDpcXG4ke2luZGVudChsZWZ0KX1cXG4tLS1cXG4gcmlnaHQ6XFxuJHtpbmRlbnQocmlnaHQpfVxcbilgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRyZWUgc3RydWN0dXJlIGZvciBmb3JrJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBOb2RlVHlwZS5MYWJlbGVkOiB7XG4gICAgICAgICAgICBpZiAodHJlZVsxXSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyICYmIHRyZWVbMl0gaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gbGFiZWxUb1N0cmluZyh0cmVlWzFdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWIgPSBoYXNoVHJlZVRvU3RyaW5nKHRyZWVbMl0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBgbGFiZWwoXFxuIGxhYmVsOlxcbiR7aW5kZW50KGxhYmVsKX1cXG4gc3ViOlxcbiR7aW5kZW50KHN1Yil9XFxuKWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHJlZSBzdHJ1Y3R1cmUgZm9yIGxhYmVsZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXNlIE5vZGVUeXBlLkxlYWY6IHtcbiAgICAgICAgICAgIGlmICghdHJlZVsxXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0cmVlIHN0cnVjdHVyZSBmb3IgbGVhZicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0cmVlWzFdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0cmVlWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBgbGVhZiguLi4ke3RyZWVbMV0uYnl0ZUxlbmd0aH0gYnl0ZXMpYDtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIE5vZGVUeXBlLlBydW5lZDoge1xuICAgICAgICAgICAgaWYgKCF0cmVlWzFdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRyZWUgc3RydWN0dXJlIGZvciBwcnVuZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodHJlZVsxXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodHJlZVsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYHBydW5lZCgke3RvSGV4KG5ldyBVaW50OEFycmF5KHRyZWVbMV0pKX1gO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIHJldHVybiBgdW5rbm93bigke0pTT04uc3RyaW5naWZ5KHRyZWVbMF0pfSlgO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaXNCdWZmZXJHcmVhdGVyVGhhbihhLCBiKSB7XG4gICAgY29uc3QgYTggPSBuZXcgVWludDhBcnJheShhKTtcbiAgICBjb25zdCBiOCA9IG5ldyBVaW50OEFycmF5KGIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYTgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGE4W2ldID4gYjhbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydCBjbGFzcyBDZXJ0aWZpY2F0ZSB7XG4gICAgY29uc3RydWN0b3IoY2VydGlmaWNhdGUsIF9yb290S2V5LCBfY2FuaXN0ZXJJZCwgX2Jsc1ZlcmlmeSwgXG4gICAgLy8gRGVmYXVsdCB0byA1IG1pbnV0ZXNcbiAgICBfbWF4QWdlSW5NaW51dGVzID0gNSkge1xuICAgICAgICB0aGlzLl9yb290S2V5ID0gX3Jvb3RLZXk7XG4gICAgICAgIHRoaXMuX2NhbmlzdGVySWQgPSBfY2FuaXN0ZXJJZDtcbiAgICAgICAgdGhpcy5fYmxzVmVyaWZ5ID0gX2Jsc1ZlcmlmeTtcbiAgICAgICAgdGhpcy5fbWF4QWdlSW5NaW51dGVzID0gX21heEFnZUluTWludXRlcztcbiAgICAgICAgdGhpcy5jZXJ0ID0gY2Jvci5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoY2VydGlmaWNhdGUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIGEgY2VydGlmaWNhdGUsIGF1dG9tYXRpY2FsbHkgdmVyaWZ5aW5nIGl0LiBUaHJvd3MgYVxuICAgICAqIENlcnRpZmljYXRlVmVyaWZpY2F0aW9uRXJyb3IgaWYgdGhlIGNlcnRpZmljYXRlIGNhbm5vdCBiZSB2ZXJpZmllZC5cbiAgICAgKiBAY29uc3RydWN0cyAgQ2VydGlmaWNhdGVcbiAgICAgKiBAcGFyYW0ge0NyZWF0ZUNlcnRpZmljYXRlT3B0aW9uc30gb3B0aW9ucyB7QGxpbmsgQ3JlYXRlQ2VydGlmaWNhdGVPcHRpb25zfVxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IG9wdGlvbnMuY2VydGlmaWNhdGUgVGhlIGJ5dGVzIG9mIHRoZSBjZXJ0aWZpY2F0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IG9wdGlvbnMucm9vdEtleSBUaGUgcm9vdCBrZXkgdG8gdmVyaWZ5IGFnYWluc3RcbiAgICAgKiBAcGFyYW0ge1ByaW5jaXBhbH0gb3B0aW9ucy5jYW5pc3RlcklkIFRoZSBlZmZlY3RpdmUgb3Igc2lnbmluZyBjYW5pc3RlciBJRFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLm1heEFnZUluTWludXRlcyBUaGUgbWF4aW11bSBhZ2Ugb2YgdGhlIGNlcnRpZmljYXRlIGluIG1pbnV0ZXMuIERlZmF1bHQgaXMgNSBtaW51dGVzLlxuICAgICAqIEB0aHJvd3Mge0NlcnRpZmljYXRlVmVyaWZpY2F0aW9uRXJyb3J9XG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGNyZWF0ZShvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNlcnQgPSBDZXJ0aWZpY2F0ZS5jcmVhdGVVbnZlcmlmaWVkKG9wdGlvbnMpO1xuICAgICAgICBhd2FpdCBjZXJ0LnZlcmlmeSgpO1xuICAgICAgICByZXR1cm4gY2VydDtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZVVudmVyaWZpZWQob3B0aW9ucykge1xuICAgICAgICBsZXQgYmxzVmVyaWZ5ID0gb3B0aW9ucy5ibHNWZXJpZnk7XG4gICAgICAgIGlmICghYmxzVmVyaWZ5KSB7XG4gICAgICAgICAgICBibHNWZXJpZnkgPSBibHMuYmxzVmVyaWZ5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ2VydGlmaWNhdGUob3B0aW9ucy5jZXJ0aWZpY2F0ZSwgb3B0aW9ucy5yb290S2V5LCBvcHRpb25zLmNhbmlzdGVySWQsIGJsc1ZlcmlmeSwgb3B0aW9ucy5tYXhBZ2VJbk1pbnV0ZXMpO1xuICAgIH1cbiAgICBsb29rdXAocGF0aCkge1xuICAgICAgICAvLyBjb25zdHJhaW4gdGhlIHR5cGUgb2YgdGhlIHJlc3VsdCwgc28gdGhhdCBlbXB0eSBIYXNoVHJlZSBpcyB1bmRlZmluZWRcbiAgICAgICAgcmV0dXJuIGxvb2t1cF9wYXRoKHBhdGgsIHRoaXMuY2VydC50cmVlKTtcbiAgICB9XG4gICAgbG9va3VwX2xhYmVsKGxhYmVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvb2t1cChbbGFiZWxdKTtcbiAgICB9XG4gICAgYXN5bmMgdmVyaWZ5KCkge1xuICAgICAgICBjb25zdCByb290SGFzaCA9IGF3YWl0IHJlY29uc3RydWN0KHRoaXMuY2VydC50cmVlKTtcbiAgICAgICAgY29uc3QgZGVyS2V5ID0gYXdhaXQgdGhpcy5fY2hlY2tEZWxlZ2F0aW9uQW5kR2V0S2V5KHRoaXMuY2VydC5kZWxlZ2F0aW9uKTtcbiAgICAgICAgY29uc3Qgc2lnID0gdGhpcy5jZXJ0LnNpZ25hdHVyZTtcbiAgICAgICAgY29uc3Qga2V5ID0gZXh0cmFjdERFUihkZXJLZXkpO1xuICAgICAgICBjb25zdCBtc2cgPSBjb25jYXQoZG9tYWluX3NlcCgnaWMtc3RhdGUtcm9vdCcpLCByb290SGFzaCk7XG4gICAgICAgIGxldCBzaWdWZXIgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgbG9va3VwVGltZSA9IGxvb2t1cFJlc3VsdFRvQnVmZmVyKHRoaXMubG9va3VwKFsndGltZSddKSk7XG4gICAgICAgIGlmICghbG9va3VwVGltZSkge1xuICAgICAgICAgICAgLy8gU2hvdWxkIG5ldmVyIGhhcHBlbiAtIHRpbWUgaXMgYWx3YXlzIHByZXNlbnQgaW4gSUMgY2VydGlmaWNhdGVzXG4gICAgICAgICAgICB0aHJvdyBuZXcgQ2VydGlmaWNhdGVWZXJpZmljYXRpb25FcnJvcignQ2VydGlmaWNhdGUgZG9lcyBub3QgY29udGFpbiBhIHRpbWUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBGSVZFX01JTlVURVNfSU5fTVNFQyA9IDUgKiA2MCAqIDEwMDA7XG4gICAgICAgIGNvbnN0IE1BWF9BR0VfSU5fTVNFQyA9IHRoaXMuX21heEFnZUluTWludXRlcyAqIDYwICogMTAwMDtcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgZWFybGllc3RDZXJ0aWZpY2F0ZVRpbWUgPSBub3cgLSBNQVhfQUdFX0lOX01TRUM7XG4gICAgICAgIGNvbnN0IGZpdmVNaW51dGVzRnJvbU5vdyA9IG5vdyArIEZJVkVfTUlOVVRFU19JTl9NU0VDO1xuICAgICAgICBjb25zdCBjZXJ0VGltZSA9IGRlY29kZVRpbWUobG9va3VwVGltZSk7XG4gICAgICAgIGlmIChjZXJ0VGltZS5nZXRUaW1lKCkgPCBlYXJsaWVzdENlcnRpZmljYXRlVGltZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENlcnRpZmljYXRlVmVyaWZpY2F0aW9uRXJyb3IoYENlcnRpZmljYXRlIGlzIHNpZ25lZCBtb3JlIHRoYW4gJHt0aGlzLl9tYXhBZ2VJbk1pbnV0ZXN9IG1pbnV0ZXMgaW4gdGhlIHBhc3QuIENlcnRpZmljYXRlIHRpbWU6IGAgK1xuICAgICAgICAgICAgICAgIGNlcnRUaW1lLnRvSVNPU3RyaW5nKCkgK1xuICAgICAgICAgICAgICAgICcgQ3VycmVudCB0aW1lOiAnICtcbiAgICAgICAgICAgICAgICBuZXcgRGF0ZShub3cpLnRvSVNPU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNlcnRUaW1lLmdldFRpbWUoKSA+IGZpdmVNaW51dGVzRnJvbU5vdykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENlcnRpZmljYXRlVmVyaWZpY2F0aW9uRXJyb3IoJ0NlcnRpZmljYXRlIGlzIHNpZ25lZCBtb3JlIHRoYW4gNSBtaW51dGVzIGluIHRoZSBmdXR1cmUuIENlcnRpZmljYXRlIHRpbWU6ICcgK1xuICAgICAgICAgICAgICAgIGNlcnRUaW1lLnRvSVNPU3RyaW5nKCkgK1xuICAgICAgICAgICAgICAgICcgQ3VycmVudCB0aW1lOiAnICtcbiAgICAgICAgICAgICAgICBuZXcgRGF0ZShub3cpLnRvSVNPU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzaWdWZXIgPSBhd2FpdCB0aGlzLl9ibHNWZXJpZnkobmV3IFVpbnQ4QXJyYXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoc2lnKSwgbmV3IFVpbnQ4QXJyYXkobXNnKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgc2lnVmVyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzaWdWZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDZXJ0aWZpY2F0ZVZlcmlmaWNhdGlvbkVycm9yKCdTaWduYXR1cmUgdmVyaWZpY2F0aW9uIGZhaWxlZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9jaGVja0RlbGVnYXRpb25BbmRHZXRLZXkoZCkge1xuICAgICAgICBpZiAoIWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb290S2V5O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNlcnQgPSBhd2FpdCBDZXJ0aWZpY2F0ZS5jcmVhdGVVbnZlcmlmaWVkKHtcbiAgICAgICAgICAgIGNlcnRpZmljYXRlOiBkLmNlcnRpZmljYXRlLFxuICAgICAgICAgICAgcm9vdEtleTogdGhpcy5fcm9vdEtleSxcbiAgICAgICAgICAgIGNhbmlzdGVySWQ6IHRoaXMuX2NhbmlzdGVySWQsXG4gICAgICAgICAgICBibHNWZXJpZnk6IHRoaXMuX2Jsc1ZlcmlmeSxcbiAgICAgICAgICAgIC8vIERvIG5vdCBjaGVjayBtYXggYWdlIGZvciBkZWxlZ2F0aW9uIGNlcnRpZmljYXRlc1xuICAgICAgICAgICAgbWF4QWdlSW5NaW51dGVzOiBJbmZpbml0eSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjZXJ0LmNlcnQuZGVsZWdhdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENlcnRpZmljYXRlVmVyaWZpY2F0aW9uRXJyb3IoJ0RlbGVnYXRpb24gY2VydGlmaWNhdGVzIGNhbm5vdCBiZSBuZXN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBjZXJ0LnZlcmlmeSgpO1xuICAgICAgICBjb25zdCBjYW5pc3RlckluUmFuZ2UgPSBjaGVja19jYW5pc3Rlcl9yYW5nZXMoe1xuICAgICAgICAgICAgY2FuaXN0ZXJJZDogdGhpcy5fY2FuaXN0ZXJJZCxcbiAgICAgICAgICAgIHN1Ym5ldElkOiBQcmluY2lwYWwuZnJvbVVpbnQ4QXJyYXkobmV3IFVpbnQ4QXJyYXkoZC5zdWJuZXRfaWQpKSxcbiAgICAgICAgICAgIHRyZWU6IGNlcnQuY2VydC50cmVlLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFjYW5pc3RlckluUmFuZ2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDZXJ0aWZpY2F0ZVZlcmlmaWNhdGlvbkVycm9yKGBDYW5pc3RlciAke3RoaXMuX2NhbmlzdGVySWR9IG5vdCBpbiByYW5nZSBvZiBkZWxlZ2F0aW9ucyBmb3Igc3VibmV0IDB4JHt0b0hleChkLnN1Ym5ldF9pZCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHVibGljS2V5TG9va3VwID0gbG9va3VwUmVzdWx0VG9CdWZmZXIoY2VydC5sb29rdXAoWydzdWJuZXQnLCBkLnN1Ym5ldF9pZCwgJ3B1YmxpY19rZXknXSkpO1xuICAgICAgICBpZiAoIXB1YmxpY0tleUxvb2t1cCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBzdWJuZXQga2V5IGZvciBzdWJuZXQgMHgke3RvSGV4KGQuc3VibmV0X2lkKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHVibGljS2V5TG9va3VwO1xuICAgIH1cbn1cbmNvbnN0IERFUl9QUkVGSVggPSBmcm9tSGV4KCczMDgxODIzMDFkMDYwZDJiMDYwMTA0MDE4MmRjN2MwNTAzMDEwMjAxMDYwYzJiMDYwMTA0MDE4MmRjN2MwNTAzMDIwMTAzNjEwMCcpO1xuY29uc3QgS0VZX0xFTkdUSCA9IDk2O1xuZnVuY3Rpb24gZXh0cmFjdERFUihidWYpIHtcbiAgICBjb25zdCBleHBlY3RlZExlbmd0aCA9IERFUl9QUkVGSVguYnl0ZUxlbmd0aCArIEtFWV9MRU5HVEg7XG4gICAgaWYgKGJ1Zi5ieXRlTGVuZ3RoICE9PSBleHBlY3RlZExlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBCTFMgREVSLWVuY29kZWQgcHVibGljIGtleSBtdXN0IGJlICR7ZXhwZWN0ZWRMZW5ndGh9IGJ5dGVzIGxvbmdgKTtcbiAgICB9XG4gICAgY29uc3QgcHJlZml4ID0gYnVmLnNsaWNlKDAsIERFUl9QUkVGSVguYnl0ZUxlbmd0aCk7XG4gICAgaWYgKCFidWZFcXVhbHMocHJlZml4LCBERVJfUFJFRklYKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBCTFMgREVSLWVuY29kZWQgcHVibGljIGtleSBpcyBpbnZhbGlkLiBFeHBlY3QgdGhlIGZvbGxvd2luZyBwcmVmaXg6ICR7REVSX1BSRUZJWH0sIGJ1dCBnZXQgJHtwcmVmaXh9YCk7XG4gICAgfVxuICAgIHJldHVybiBidWYuc2xpY2UoREVSX1BSRUZJWC5ieXRlTGVuZ3RoKTtcbn1cbi8qKlxuICogdXRpbGl0eSBmdW5jdGlvbiB0byBjb25zdHJhaW4gdGhlIHR5cGUgb2YgYSBwYXRoXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyIHwgSGFzaFRyZWUgfCB1bmRlZmluZWR9IHJlc3VsdCAtIHRoZSByZXN1bHQgb2YgYSBsb29rdXBcbiAqIEByZXR1cm5zIEFycmF5QnVmZmVyIG9yIFVuZGVmaW5lZFxuICovXG5leHBvcnQgZnVuY3Rpb24gbG9va3VwUmVzdWx0VG9CdWZmZXIocmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdC5zdGF0dXMgIT09IExvb2t1cFN0YXR1cy5Gb3VuZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAocmVzdWx0LnZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC52YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZS5idWZmZXI7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vKipcbiAqIEBwYXJhbSB0XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWNvbnN0cnVjdCh0KSB7XG4gICAgc3dpdGNoICh0WzBdKSB7XG4gICAgICAgIGNhc2UgTm9kZVR5cGUuRW1wdHk6XG4gICAgICAgICAgICByZXR1cm4gaGFzaChkb21haW5fc2VwKCdpYy1oYXNodHJlZS1lbXB0eScpKTtcbiAgICAgICAgY2FzZSBOb2RlVHlwZS5QcnVuZWQ6XG4gICAgICAgICAgICByZXR1cm4gdFsxXTtcbiAgICAgICAgY2FzZSBOb2RlVHlwZS5MZWFmOlxuICAgICAgICAgICAgcmV0dXJuIGhhc2goY29uY2F0KGRvbWFpbl9zZXAoJ2ljLWhhc2h0cmVlLWxlYWYnKSwgdFsxXSkpO1xuICAgICAgICBjYXNlIE5vZGVUeXBlLkxhYmVsZWQ6XG4gICAgICAgICAgICByZXR1cm4gaGFzaChjb25jYXQoZG9tYWluX3NlcCgnaWMtaGFzaHRyZWUtbGFiZWxlZCcpLCB0WzFdLCBhd2FpdCByZWNvbnN0cnVjdCh0WzJdKSkpO1xuICAgICAgICBjYXNlIE5vZGVUeXBlLkZvcms6XG4gICAgICAgICAgICByZXR1cm4gaGFzaChjb25jYXQoZG9tYWluX3NlcCgnaWMtaGFzaHRyZWUtZm9yaycpLCBhd2FpdCByZWNvbnN0cnVjdCh0WzFdKSwgYXdhaXQgcmVjb25zdHJ1Y3QodFsyXSkpKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWFjaGFibGUnKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkb21haW5fc2VwKHMpIHtcbiAgICBjb25zdCBsZW4gPSBuZXcgVWludDhBcnJheShbcy5sZW5ndGhdKTtcbiAgICBjb25zdCBzdHIgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUocyk7XG4gICAgcmV0dXJuIGNvbmNhdChsZW4sIHN0cik7XG59XG5leHBvcnQgdmFyIExvb2t1cFN0YXR1cztcbihmdW5jdGlvbiAoTG9va3VwU3RhdHVzKSB7XG4gICAgTG9va3VwU3RhdHVzW1wiVW5rbm93blwiXSA9IFwidW5rbm93blwiO1xuICAgIExvb2t1cFN0YXR1c1tcIkFic2VudFwiXSA9IFwiYWJzZW50XCI7XG4gICAgTG9va3VwU3RhdHVzW1wiRm91bmRcIl0gPSBcImZvdW5kXCI7XG59KShMb29rdXBTdGF0dXMgfHwgKExvb2t1cFN0YXR1cyA9IHt9KSk7XG52YXIgTGFiZWxMb29rdXBTdGF0dXM7XG4oZnVuY3Rpb24gKExhYmVsTG9va3VwU3RhdHVzKSB7XG4gICAgTGFiZWxMb29rdXBTdGF0dXNbXCJMZXNzXCJdID0gXCJsZXNzXCI7XG4gICAgTGFiZWxMb29rdXBTdGF0dXNbXCJHcmVhdGVyXCJdID0gXCJncmVhdGVyXCI7XG59KShMYWJlbExvb2t1cFN0YXR1cyB8fCAoTGFiZWxMb29rdXBTdGF0dXMgPSB7fSkpO1xuZXhwb3J0IGZ1bmN0aW9uIGxvb2t1cF9wYXRoKHBhdGgsIHRyZWUpIHtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc3dpdGNoICh0cmVlWzBdKSB7XG4gICAgICAgICAgICBjYXNlIE5vZGVUeXBlLkxlYWY6IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRyZWVbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRyZWUgc3RydWN0dXJlIGZvciBsZWFmJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0cmVlWzFdIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogTG9va3VwU3RhdHVzLkZvdW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRyZWVbMV0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0cmVlWzFdIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBMb29rdXBTdGF0dXMuRm91bmQsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdHJlZVsxXS5idWZmZXIsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogTG9va3VwU3RhdHVzLkZvdW5kLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdHJlZVsxXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogTG9va3VwU3RhdHVzLkZvdW5kLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdHJlZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGxhYmVsID0gdHlwZW9mIHBhdGhbMF0gPT09ICdzdHJpbmcnID8gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHBhdGhbMF0pIDogcGF0aFswXTtcbiAgICBjb25zdCBsb29rdXBSZXN1bHQgPSBmaW5kX2xhYmVsKGxhYmVsLCB0cmVlKTtcbiAgICBzd2l0Y2ggKGxvb2t1cFJlc3VsdC5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSBMb29rdXBTdGF0dXMuRm91bmQ6IHtcbiAgICAgICAgICAgIHJldHVybiBsb29rdXBfcGF0aChwYXRoLnNsaWNlKDEpLCBsb29rdXBSZXN1bHQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgTGFiZWxMb29rdXBTdGF0dXMuR3JlYXRlcjpcbiAgICAgICAgY2FzZSBMYWJlbExvb2t1cFN0YXR1cy5MZXNzOiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXR1czogTG9va3VwU3RhdHVzLkFic2VudCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgcmV0dXJuIGxvb2t1cFJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogSWYgdGhlIHRyZWUgaXMgYSBmb3JrLCBmbGF0dGVuIGl0IGludG8gYW4gYXJyYXkgb2YgdHJlZXNcbiAqIEBwYXJhbSB0IC0gdGhlIHRyZWUgdG8gZmxhdHRlblxuICogQHJldHVybnMgSGFzaFRyZWVbXSAtIHRoZSBmbGF0dGVuZWQgdHJlZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmxhdHRlbl9mb3Jrcyh0KSB7XG4gICAgc3dpdGNoICh0WzBdKSB7XG4gICAgICAgIGNhc2UgTm9kZVR5cGUuRW1wdHk6XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGNhc2UgTm9kZVR5cGUuRm9yazpcbiAgICAgICAgICAgIHJldHVybiBmbGF0dGVuX2ZvcmtzKHRbMV0pLmNvbmNhdChmbGF0dGVuX2ZvcmtzKHRbMl0pKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBbdF07XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRfbGFiZWwobGFiZWwsIHRyZWUpIHtcbiAgICBzd2l0Y2ggKHRyZWVbMF0pIHtcbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIGxhYmVsbGVkIG5vZGUsIGNvbXBhcmUgdGhlIG5vZGUncyBsYWJlbCB0byB0aGUgb25lIHdlIGFyZVxuICAgICAgICAvLyBsb29raW5nIGZvclxuICAgICAgICBjYXNlIE5vZGVUeXBlLkxhYmVsZWQ6XG4gICAgICAgICAgICAvLyBpZiB0aGUgbGFiZWwgd2UncmUgc2VhcmNoaW5nIGZvciBpcyBncmVhdGVyIHRoYW4gdGhpcyBub2RlJ3MgbGFiZWwsXG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGtlZXAgc2VhcmNoaW5nXG4gICAgICAgICAgICBpZiAoaXNCdWZmZXJHcmVhdGVyVGhhbihsYWJlbCwgdHJlZVsxXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IExhYmVsTG9va3VwU3RhdHVzLkdyZWF0ZXIsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIHRoZSBsYWJlbCB3ZSdyZSBzZWFyY2hpbmcgZm9yIGlzIGVxdWFsIHRoaXMgbm9kZSdzIGxhYmVsLCB3ZSBjYW5cbiAgICAgICAgICAgIC8vIHN0b3Agc2VhcmNoaW5nIGFuZCByZXR1cm4gdGhlIGZvdW5kIG5vZGVcbiAgICAgICAgICAgIGlmIChidWZFcXVhbHMobGFiZWwsIHRyZWVbMV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBMb29rdXBTdGF0dXMuRm91bmQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0cmVlWzJdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiB0aGUgbGFiZWwgd2UncmUgc2VhcmNoaW5nIGZvciBpcyBub3QgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoaXNcbiAgICAgICAgICAgIC8vIG5vZGUncyBsYWJlbCwgdGhlbiBpdCdzIGxlc3MgdGhhbiB0aGlzIG5vZGUncyBsYWJlbCwgYW5kIHdlIGNhbiBzdG9wXG4gICAgICAgICAgICAvLyBzZWFyY2hpbmcgYmVjYXVzZSB3ZSd2ZSBsb29rZWQgdG9vIGZhclxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IExhYmVsTG9va3VwU3RhdHVzLkxlc3MsXG4gICAgICAgICAgICB9O1xuICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgZm9yayBub2RlLCB3ZSBuZWVkIHRvIHNlYXJjaCBib3RoIHNpZGVzLCBzdGFydGluZyB3aXRoIHRoZSBsZWZ0XG4gICAgICAgIGNhc2UgTm9kZVR5cGUuRm9yazpcbiAgICAgICAgICAgIC8vIHNlYXJjaCBpbiB0aGUgbGVmdCBub2RlXG4gICAgICAgICAgICBjb25zdCBsZWZ0TG9va3VwUmVzdWx0ID0gZmluZF9sYWJlbChsYWJlbCwgdHJlZVsxXSk7XG4gICAgICAgICAgICBzd2l0Y2ggKGxlZnRMb29rdXBSZXN1bHQuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGxhYmVsIHdlJ3JlIHNlYXJjaGluZyBmb3IgaXMgZ3JlYXRlciB0aGFuIHRoZSBsZWZ0IG5vZGUgbG9va3VwLFxuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gc2VhcmNoIHRoZSByaWdodCBub2RlXG4gICAgICAgICAgICAgICAgY2FzZSBMYWJlbExvb2t1cFN0YXR1cy5HcmVhdGVyOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0TG9va3VwUmVzdWx0ID0gZmluZF9sYWJlbChsYWJlbCwgdHJlZVsyXSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBsYWJlbCB3ZSdyZSBzZWFyY2hpbmcgZm9yIGlzIGxlc3MgdGhhbiB0aGUgcmlnaHQgbm9kZSBsb29rdXAsXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZW4gd2UgY2FuIHN0b3Agc2VhcmNoaW5nIGFuZCBzYXkgdGhhdCB0aGUgbGFiZWwgaXMgcHJvdmFibHkgQWJzZW50XG4gICAgICAgICAgICAgICAgICAgIGlmIChyaWdodExvb2t1cFJlc3VsdC5zdGF0dXMgPT09IExhYmVsTG9va3VwU3RhdHVzLkxlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBMb29rdXBTdGF0dXMuQWJzZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgbGFiZWwgd2UncmUgc2VhcmNoaW5nIGZvciBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vZGUgbG9va3VwLCB0aGVuIHdlIGxldCB0aGUgY2FsbGVyIGhhbmRsZSBpdFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmlnaHRMb29rdXBSZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBsZWZ0IG5vZGUgcmV0dXJucyBhbiB1bmNlcnRhaW4gcmVzdWx0LCB3ZSBuZWVkIHRvIHNlYXJjaCB0aGVcbiAgICAgICAgICAgICAgICAvLyByaWdodCBub2RlXG4gICAgICAgICAgICAgICAgY2FzZSBMb29rdXBTdGF0dXMuVW5rbm93bjoge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmlnaHRMb29rdXBSZXN1bHQgPSBmaW5kX2xhYmVsKGxhYmVsLCB0cmVlWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGxhYmVsIHdlJ3JlIHNlYXJjaGluZyBmb3IgaXMgbGVzcyB0aGFuIHRoZSByaWdodCBub2RlIGxvb2t1cCxcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlbiB3ZSBhbHNvIG5lZWQgdG8gcmV0dXJuIGFuIHVuY2VydGFpbiByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJpZ2h0TG9va3VwUmVzdWx0LnN0YXR1cyA9PT0gTGFiZWxMb29rdXBTdGF0dXMuTGVzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IExvb2t1cFN0YXR1cy5Vbmtub3duLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgbGFiZWwgd2UncmUgc2VhcmNoaW5nIGZvciBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vZGUgbG9va3VwLCB0aGVuIHdlIGxldCB0aGUgY2FsbGVyIGhhbmRsZSBpdFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmlnaHRMb29rdXBSZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBsYWJlbCB3ZSdyZSBzZWFyY2hpbmcgZm9yIGlzIG5vdCBncmVhdGVyIHRoYW4gdGhlIGxlZnQgbm9kZVxuICAgICAgICAgICAgICAgIC8vIGxvb2t1cCwgb3IgdGhlIHJlc3VsdCBpcyBub3QgdW5jZXJ0YWluLCB3ZSBzdG9wIHNlYXJjaGluZyBhbmQgcmV0dXJuXG4gICAgICAgICAgICAgICAgLy8gd2hhdGV2ZXIgdGhlIHJlc3VsdCBvZiB0aGUgbGVmdCBub2RlIGxvb2t1cCB3YXMsIHdoaWNoIGNhbiBiZSBlaXRoZXJcbiAgICAgICAgICAgICAgICAvLyBGb3VuZCBvciBBYnNlbnRcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0TG9va3VwUmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UgZW5jb3VudGVyIGEgUHJ1bmVkIG5vZGUsIHdlIGNhbid0IGtub3cgZm9yIGNlcnRhaW4gaWYgdGhlIGxhYmVsXG4gICAgICAgIC8vIHdlJ3JlIHNlYXJjaGluZyBmb3IgaXMgcHJlc2VudCBvciBub3RcbiAgICAgICAgY2FzZSBOb2RlVHlwZS5QcnVuZWQ6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXR1czogTG9va3VwU3RhdHVzLlVua25vd24sXG4gICAgICAgICAgICB9O1xuICAgICAgICAvLyBpZiB0aGUgY3VycmVudCBub2RlIGlzIEVtcHR5LCBvciBhIExlYWYsIHdlIGNhbiBzdG9wIHNlYXJjaGluZyBiZWNhdXNlXG4gICAgICAgIC8vIHdlIGtub3cgZm9yIHN1cmUgdGhhdCB0aGUgbGFiZWwgd2UncmUgc2VhcmNoaW5nIGZvciBpcyBub3QgcHJlc2VudFxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IExvb2t1cFN0YXR1cy5BYnNlbnQsXG4gICAgICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuICogQ2hlY2sgaWYgYSBjYW5pc3RlciBmYWxscyB3aXRoaW4gYSByYW5nZSBvZiBjYW5pc3RlcnNcbiAqIEBwYXJhbSBjYW5pc3RlcklkIFByaW5jaXBhbFxuICogQHBhcmFtIHJhbmdlcyBbUHJpbmNpcGFsLCBQcmluY2lwYWxdW11cbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGVja19jYW5pc3Rlcl9yYW5nZXMocGFyYW1zKSB7XG4gICAgY29uc3QgeyBjYW5pc3RlcklkLCBzdWJuZXRJZCwgdHJlZSB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJhbmdlTG9va3VwID0gbG9va3VwX3BhdGgoWydzdWJuZXQnLCBzdWJuZXRJZC50b1VpbnQ4QXJyYXkoKSwgJ2NhbmlzdGVyX3JhbmdlcyddLCB0cmVlKTtcbiAgICBpZiAocmFuZ2VMb29rdXAuc3RhdHVzICE9PSBMb29rdXBTdGF0dXMuRm91bmQgfHwgIShyYW5nZUxvb2t1cC52YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIGNhbmlzdGVyIHJhbmdlcyBmb3Igc3VibmV0ICR7c3VibmV0SWR9YCk7XG4gICAgfVxuICAgIGNvbnN0IHJhbmdlc19hcnIgPSBjYm9yLmRlY29kZShyYW5nZUxvb2t1cC52YWx1ZSk7XG4gICAgY29uc3QgcmFuZ2VzID0gcmFuZ2VzX2Fyci5tYXAodiA9PiBbXG4gICAgICAgIFByaW5jaXBhbC5mcm9tVWludDhBcnJheSh2WzBdKSxcbiAgICAgICAgUHJpbmNpcGFsLmZyb21VaW50OEFycmF5KHZbMV0pLFxuICAgIF0pO1xuICAgIGNvbnN0IGNhbmlzdGVySW5SYW5nZSA9IHJhbmdlcy5zb21lKHIgPT4gclswXS5sdEVxKGNhbmlzdGVySWQpICYmIHJbMV0uZ3RFcShjYW5pc3RlcklkKSk7XG4gICAgcmV0dXJuIGNhbmlzdGVySW5SYW5nZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNlcnRpZmljYXRlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/certificate.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/der.js":
/*!****************************************************!*\
  !*** ./node_modules/@dfinity/agent/lib/esm/der.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DER_COSE_OID: function() { return /* binding */ DER_COSE_OID; },\n/* harmony export */   ED25519_OID: function() { return /* binding */ ED25519_OID; },\n/* harmony export */   SECP256K1_OID: function() { return /* binding */ SECP256K1_OID; },\n/* harmony export */   decodeLen: function() { return /* binding */ decodeLen; },\n/* harmony export */   decodeLenBytes: function() { return /* binding */ decodeLenBytes; },\n/* harmony export */   encodeLen: function() { return /* binding */ encodeLen; },\n/* harmony export */   encodeLenBytes: function() { return /* binding */ encodeLenBytes; },\n/* harmony export */   unwrapDER: function() { return /* binding */ unwrapDER; },\n/* harmony export */   wrapDER: function() { return /* binding */ wrapDER; }\n/* harmony export */ });\n/* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/buffer */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/utils/buffer.js\");\n\nconst encodeLenBytes = (len) => {\n    if (len <= 0x7f) {\n        return 1;\n    }\n    else if (len <= 0xff) {\n        return 2;\n    }\n    else if (len <= 0xffff) {\n        return 3;\n    }\n    else if (len <= 0xffffff) {\n        return 4;\n    }\n    else {\n        throw new Error('Length too long (> 4 bytes)');\n    }\n};\nconst encodeLen = (buf, offset, len) => {\n    if (len <= 0x7f) {\n        buf[offset] = len;\n        return 1;\n    }\n    else if (len <= 0xff) {\n        buf[offset] = 0x81;\n        buf[offset + 1] = len;\n        return 2;\n    }\n    else if (len <= 0xffff) {\n        buf[offset] = 0x82;\n        buf[offset + 1] = len >> 8;\n        buf[offset + 2] = len;\n        return 3;\n    }\n    else if (len <= 0xffffff) {\n        buf[offset] = 0x83;\n        buf[offset + 1] = len >> 16;\n        buf[offset + 2] = len >> 8;\n        buf[offset + 3] = len;\n        return 4;\n    }\n    else {\n        throw new Error('Length too long (> 4 bytes)');\n    }\n};\nconst decodeLenBytes = (buf, offset) => {\n    if (buf[offset] < 0x80)\n        return 1;\n    if (buf[offset] === 0x80)\n        throw new Error('Invalid length 0');\n    if (buf[offset] === 0x81)\n        return 2;\n    if (buf[offset] === 0x82)\n        return 3;\n    if (buf[offset] === 0x83)\n        return 4;\n    throw new Error('Length too long (> 4 bytes)');\n};\nconst decodeLen = (buf, offset) => {\n    const lenBytes = decodeLenBytes(buf, offset);\n    if (lenBytes === 1)\n        return buf[offset];\n    else if (lenBytes === 2)\n        return buf[offset + 1];\n    else if (lenBytes === 3)\n        return (buf[offset + 1] << 8) + buf[offset + 2];\n    else if (lenBytes === 4)\n        return (buf[offset + 1] << 16) + (buf[offset + 2] << 8) + buf[offset + 3];\n    throw new Error('Length too long (> 4 bytes)');\n};\n/**\n * A DER encoded `SEQUENCE(OID)` for DER-encoded-COSE\n */\nconst DER_COSE_OID = Uint8Array.from([\n    ...[0x30, 0x0c],\n    ...[0x06, 0x0a],\n    ...[0x2b, 0x06, 0x01, 0x04, 0x01, 0x83, 0xb8, 0x43, 0x01, 0x01], // DER encoded COSE\n]);\n/**\n * A DER encoded `SEQUENCE(OID)` for the Ed25519 algorithm\n */\nconst ED25519_OID = Uint8Array.from([\n    ...[0x30, 0x05],\n    ...[0x06, 0x03],\n    ...[0x2b, 0x65, 0x70], // id-Ed25519 OID\n]);\n/**\n * A DER encoded `SEQUENCE(OID)` for secp256k1 with the ECDSA algorithm\n */\nconst SECP256K1_OID = Uint8Array.from([\n    ...[0x30, 0x10],\n    ...[0x06, 0x07],\n    ...[0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01],\n    ...[0x06, 0x05],\n    ...[0x2b, 0x81, 0x04, 0x00, 0x0a], // OID secp256k1\n]);\n/**\n * Wraps the given `payload` in a DER encoding tagged with the given encoded `oid` like so:\n * `SEQUENCE(oid, BITSTRING(payload))`\n *\n * @param payload The payload to encode as the bit string\n * @param oid The DER encoded (and SEQUENCE wrapped!) OID to tag the payload with\n */\nfunction wrapDER(payload, oid) {\n    // The Bit String header needs to include the unused bit count byte in its length\n    const bitStringHeaderLength = 2 + encodeLenBytes(payload.byteLength + 1);\n    const len = oid.byteLength + bitStringHeaderLength + payload.byteLength;\n    let offset = 0;\n    const buf = new Uint8Array(1 + encodeLenBytes(len) + len);\n    // Sequence\n    buf[offset++] = 0x30;\n    // Sequence Length\n    offset += encodeLen(buf, offset, len);\n    // OID\n    buf.set(oid, offset);\n    offset += oid.byteLength;\n    // Bit String Header\n    buf[offset++] = 0x03;\n    offset += encodeLen(buf, offset, payload.byteLength + 1);\n    // 0 padding\n    buf[offset++] = 0x00;\n    buf.set(new Uint8Array(payload), offset);\n    return buf;\n}\n/**\n * Extracts a payload from the given `derEncoded` data, and checks that it was tagged with the given `oid`.\n *\n * `derEncoded = SEQUENCE(oid, BITSTRING(payload))`\n *\n * @param derEncoded The DER encoded and tagged data\n * @param oid The DER encoded (and SEQUENCE wrapped!) expected OID\n * @returns The unwrapped payload\n */\nconst unwrapDER = (derEncoded, oid) => {\n    let offset = 0;\n    const expect = (n, msg) => {\n        if (buf[offset++] !== n) {\n            throw new Error('Expected: ' + msg);\n        }\n    };\n    const buf = new Uint8Array(derEncoded);\n    expect(0x30, 'sequence');\n    offset += decodeLenBytes(buf, offset);\n    if (!(0,_utils_buffer__WEBPACK_IMPORTED_MODULE_0__.bufEquals)(buf.slice(offset, offset + oid.byteLength), oid)) {\n        throw new Error('Not the expected OID.');\n    }\n    offset += oid.byteLength;\n    expect(0x03, 'bit string');\n    const payloadLen = decodeLen(buf, offset) - 1; // Subtracting 1 to account for the 0 padding\n    offset += decodeLenBytes(buf, offset);\n    expect(0x00, '0 padding');\n    const result = buf.slice(offset);\n    if (payloadLen !== result.length) {\n        throw new Error(`DER payload mismatch: Expected length ${payloadLen} actual length ${result.length}`);\n    }\n    return result;\n};\n//# sourceMappingURL=der.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2Rlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQTJDO0FBQ3BDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx3REFBUztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxZQUFZLGdCQUFnQixjQUFjO0FBQzNHO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2Rlci5qcz8zZGRhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGJ1ZkVxdWFscyB9IGZyb20gJy4vdXRpbHMvYnVmZmVyJztcbmV4cG9ydCBjb25zdCBlbmNvZGVMZW5CeXRlcyA9IChsZW4pID0+IHtcbiAgICBpZiAobGVuIDw9IDB4N2YpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlbiA8PSAweGZmKSB7XG4gICAgICAgIHJldHVybiAyO1xuICAgIH1cbiAgICBlbHNlIGlmIChsZW4gPD0gMHhmZmZmKSB7XG4gICAgICAgIHJldHVybiAzO1xuICAgIH1cbiAgICBlbHNlIGlmIChsZW4gPD0gMHhmZmZmZmYpIHtcbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xlbmd0aCB0b28gbG9uZyAoPiA0IGJ5dGVzKScpO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgZW5jb2RlTGVuID0gKGJ1Ziwgb2Zmc2V0LCBsZW4pID0+IHtcbiAgICBpZiAobGVuIDw9IDB4N2YpIHtcbiAgICAgICAgYnVmW29mZnNldF0gPSBsZW47XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBlbHNlIGlmIChsZW4gPD0gMHhmZikge1xuICAgICAgICBidWZbb2Zmc2V0XSA9IDB4ODE7XG4gICAgICAgIGJ1ZltvZmZzZXQgKyAxXSA9IGxlbjtcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlbiA8PSAweGZmZmYpIHtcbiAgICAgICAgYnVmW29mZnNldF0gPSAweDgyO1xuICAgICAgICBidWZbb2Zmc2V0ICsgMV0gPSBsZW4gPj4gODtcbiAgICAgICAgYnVmW29mZnNldCArIDJdID0gbGVuO1xuICAgICAgICByZXR1cm4gMztcbiAgICB9XG4gICAgZWxzZSBpZiAobGVuIDw9IDB4ZmZmZmZmKSB7XG4gICAgICAgIGJ1ZltvZmZzZXRdID0gMHg4MztcbiAgICAgICAgYnVmW29mZnNldCArIDFdID0gbGVuID4+IDE2O1xuICAgICAgICBidWZbb2Zmc2V0ICsgMl0gPSBsZW4gPj4gODtcbiAgICAgICAgYnVmW29mZnNldCArIDNdID0gbGVuO1xuICAgICAgICByZXR1cm4gNDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTGVuZ3RoIHRvbyBsb25nICg+IDQgYnl0ZXMpJyk7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBkZWNvZGVMZW5CeXRlcyA9IChidWYsIG9mZnNldCkgPT4ge1xuICAgIGlmIChidWZbb2Zmc2V0XSA8IDB4ODApXG4gICAgICAgIHJldHVybiAxO1xuICAgIGlmIChidWZbb2Zmc2V0XSA9PT0gMHg4MClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxlbmd0aCAwJyk7XG4gICAgaWYgKGJ1ZltvZmZzZXRdID09PSAweDgxKVxuICAgICAgICByZXR1cm4gMjtcbiAgICBpZiAoYnVmW29mZnNldF0gPT09IDB4ODIpXG4gICAgICAgIHJldHVybiAzO1xuICAgIGlmIChidWZbb2Zmc2V0XSA9PT0gMHg4MylcbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdMZW5ndGggdG9vIGxvbmcgKD4gNCBieXRlcyknKTtcbn07XG5leHBvcnQgY29uc3QgZGVjb2RlTGVuID0gKGJ1Ziwgb2Zmc2V0KSA9PiB7XG4gICAgY29uc3QgbGVuQnl0ZXMgPSBkZWNvZGVMZW5CeXRlcyhidWYsIG9mZnNldCk7XG4gICAgaWYgKGxlbkJ5dGVzID09PSAxKVxuICAgICAgICByZXR1cm4gYnVmW29mZnNldF07XG4gICAgZWxzZSBpZiAobGVuQnl0ZXMgPT09IDIpXG4gICAgICAgIHJldHVybiBidWZbb2Zmc2V0ICsgMV07XG4gICAgZWxzZSBpZiAobGVuQnl0ZXMgPT09IDMpXG4gICAgICAgIHJldHVybiAoYnVmW29mZnNldCArIDFdIDw8IDgpICsgYnVmW29mZnNldCArIDJdO1xuICAgIGVsc2UgaWYgKGxlbkJ5dGVzID09PSA0KVxuICAgICAgICByZXR1cm4gKGJ1ZltvZmZzZXQgKyAxXSA8PCAxNikgKyAoYnVmW29mZnNldCArIDJdIDw8IDgpICsgYnVmW29mZnNldCArIDNdO1xuICAgIHRocm93IG5ldyBFcnJvcignTGVuZ3RoIHRvbyBsb25nICg+IDQgYnl0ZXMpJyk7XG59O1xuLyoqXG4gKiBBIERFUiBlbmNvZGVkIGBTRVFVRU5DRShPSUQpYCBmb3IgREVSLWVuY29kZWQtQ09TRVxuICovXG5leHBvcnQgY29uc3QgREVSX0NPU0VfT0lEID0gVWludDhBcnJheS5mcm9tKFtcbiAgICAuLi5bMHgzMCwgMHgwY10sXG4gICAgLi4uWzB4MDYsIDB4MGFdLFxuICAgIC4uLlsweDJiLCAweDA2LCAweDAxLCAweDA0LCAweDAxLCAweDgzLCAweGI4LCAweDQzLCAweDAxLCAweDAxXSwgLy8gREVSIGVuY29kZWQgQ09TRVxuXSk7XG4vKipcbiAqIEEgREVSIGVuY29kZWQgYFNFUVVFTkNFKE9JRClgIGZvciB0aGUgRWQyNTUxOSBhbGdvcml0aG1cbiAqL1xuZXhwb3J0IGNvbnN0IEVEMjU1MTlfT0lEID0gVWludDhBcnJheS5mcm9tKFtcbiAgICAuLi5bMHgzMCwgMHgwNV0sXG4gICAgLi4uWzB4MDYsIDB4MDNdLFxuICAgIC4uLlsweDJiLCAweDY1LCAweDcwXSwgLy8gaWQtRWQyNTUxOSBPSURcbl0pO1xuLyoqXG4gKiBBIERFUiBlbmNvZGVkIGBTRVFVRU5DRShPSUQpYCBmb3Igc2VjcDI1NmsxIHdpdGggdGhlIEVDRFNBIGFsZ29yaXRobVxuICovXG5leHBvcnQgY29uc3QgU0VDUDI1NksxX09JRCA9IFVpbnQ4QXJyYXkuZnJvbShbXG4gICAgLi4uWzB4MzAsIDB4MTBdLFxuICAgIC4uLlsweDA2LCAweDA3XSxcbiAgICAuLi5bMHgyYSwgMHg4NiwgMHg0OCwgMHhjZSwgMHgzZCwgMHgwMiwgMHgwMV0sXG4gICAgLi4uWzB4MDYsIDB4MDVdLFxuICAgIC4uLlsweDJiLCAweDgxLCAweDA0LCAweDAwLCAweDBhXSwgLy8gT0lEIHNlY3AyNTZrMVxuXSk7XG4vKipcbiAqIFdyYXBzIHRoZSBnaXZlbiBgcGF5bG9hZGAgaW4gYSBERVIgZW5jb2RpbmcgdGFnZ2VkIHdpdGggdGhlIGdpdmVuIGVuY29kZWQgYG9pZGAgbGlrZSBzbzpcbiAqIGBTRVFVRU5DRShvaWQsIEJJVFNUUklORyhwYXlsb2FkKSlgXG4gKlxuICogQHBhcmFtIHBheWxvYWQgVGhlIHBheWxvYWQgdG8gZW5jb2RlIGFzIHRoZSBiaXQgc3RyaW5nXG4gKiBAcGFyYW0gb2lkIFRoZSBERVIgZW5jb2RlZCAoYW5kIFNFUVVFTkNFIHdyYXBwZWQhKSBPSUQgdG8gdGFnIHRoZSBwYXlsb2FkIHdpdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXBERVIocGF5bG9hZCwgb2lkKSB7XG4gICAgLy8gVGhlIEJpdCBTdHJpbmcgaGVhZGVyIG5lZWRzIHRvIGluY2x1ZGUgdGhlIHVudXNlZCBiaXQgY291bnQgYnl0ZSBpbiBpdHMgbGVuZ3RoXG4gICAgY29uc3QgYml0U3RyaW5nSGVhZGVyTGVuZ3RoID0gMiArIGVuY29kZUxlbkJ5dGVzKHBheWxvYWQuYnl0ZUxlbmd0aCArIDEpO1xuICAgIGNvbnN0IGxlbiA9IG9pZC5ieXRlTGVuZ3RoICsgYml0U3RyaW5nSGVhZGVyTGVuZ3RoICsgcGF5bG9hZC5ieXRlTGVuZ3RoO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KDEgKyBlbmNvZGVMZW5CeXRlcyhsZW4pICsgbGVuKTtcbiAgICAvLyBTZXF1ZW5jZVxuICAgIGJ1ZltvZmZzZXQrK10gPSAweDMwO1xuICAgIC8vIFNlcXVlbmNlIExlbmd0aFxuICAgIG9mZnNldCArPSBlbmNvZGVMZW4oYnVmLCBvZmZzZXQsIGxlbik7XG4gICAgLy8gT0lEXG4gICAgYnVmLnNldChvaWQsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IG9pZC5ieXRlTGVuZ3RoO1xuICAgIC8vIEJpdCBTdHJpbmcgSGVhZGVyXG4gICAgYnVmW29mZnNldCsrXSA9IDB4MDM7XG4gICAgb2Zmc2V0ICs9IGVuY29kZUxlbihidWYsIG9mZnNldCwgcGF5bG9hZC5ieXRlTGVuZ3RoICsgMSk7XG4gICAgLy8gMCBwYWRkaW5nXG4gICAgYnVmW29mZnNldCsrXSA9IDB4MDA7XG4gICAgYnVmLnNldChuZXcgVWludDhBcnJheShwYXlsb2FkKSwgb2Zmc2V0KTtcbiAgICByZXR1cm4gYnVmO1xufVxuLyoqXG4gKiBFeHRyYWN0cyBhIHBheWxvYWQgZnJvbSB0aGUgZ2l2ZW4gYGRlckVuY29kZWRgIGRhdGEsIGFuZCBjaGVja3MgdGhhdCBpdCB3YXMgdGFnZ2VkIHdpdGggdGhlIGdpdmVuIGBvaWRgLlxuICpcbiAqIGBkZXJFbmNvZGVkID0gU0VRVUVOQ0Uob2lkLCBCSVRTVFJJTkcocGF5bG9hZCkpYFxuICpcbiAqIEBwYXJhbSBkZXJFbmNvZGVkIFRoZSBERVIgZW5jb2RlZCBhbmQgdGFnZ2VkIGRhdGFcbiAqIEBwYXJhbSBvaWQgVGhlIERFUiBlbmNvZGVkIChhbmQgU0VRVUVOQ0Ugd3JhcHBlZCEpIGV4cGVjdGVkIE9JRFxuICogQHJldHVybnMgVGhlIHVud3JhcHBlZCBwYXlsb2FkXG4gKi9cbmV4cG9ydCBjb25zdCB1bndyYXBERVIgPSAoZGVyRW5jb2RlZCwgb2lkKSA9PiB7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgY29uc3QgZXhwZWN0ID0gKG4sIG1zZykgPT4ge1xuICAgICAgICBpZiAoYnVmW29mZnNldCsrXSAhPT0gbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZDogJyArIG1zZyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KGRlckVuY29kZWQpO1xuICAgIGV4cGVjdCgweDMwLCAnc2VxdWVuY2UnKTtcbiAgICBvZmZzZXQgKz0gZGVjb2RlTGVuQnl0ZXMoYnVmLCBvZmZzZXQpO1xuICAgIGlmICghYnVmRXF1YWxzKGJ1Zi5zbGljZShvZmZzZXQsIG9mZnNldCArIG9pZC5ieXRlTGVuZ3RoKSwgb2lkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCB0aGUgZXhwZWN0ZWQgT0lELicpO1xuICAgIH1cbiAgICBvZmZzZXQgKz0gb2lkLmJ5dGVMZW5ndGg7XG4gICAgZXhwZWN0KDB4MDMsICdiaXQgc3RyaW5nJyk7XG4gICAgY29uc3QgcGF5bG9hZExlbiA9IGRlY29kZUxlbihidWYsIG9mZnNldCkgLSAxOyAvLyBTdWJ0cmFjdGluZyAxIHRvIGFjY291bnQgZm9yIHRoZSAwIHBhZGRpbmdcbiAgICBvZmZzZXQgKz0gZGVjb2RlTGVuQnl0ZXMoYnVmLCBvZmZzZXQpO1xuICAgIGV4cGVjdCgweDAwLCAnMCBwYWRkaW5nJyk7XG4gICAgY29uc3QgcmVzdWx0ID0gYnVmLnNsaWNlKG9mZnNldCk7XG4gICAgaWYgKHBheWxvYWRMZW4gIT09IHJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBERVIgcGF5bG9hZCBtaXNtYXRjaDogRXhwZWN0ZWQgbGVuZ3RoICR7cGF5bG9hZExlbn0gYWN0dWFsIGxlbmd0aCAke3Jlc3VsdC5sZW5ndGh9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/der.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/errors.js":
/*!*******************************************************!*\
  !*** ./node_modules/@dfinity/agent/lib/esm/errors.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AgentError: function() { return /* binding */ AgentError; }\n/* harmony export */ });\n/**\n * An error that happens in the Agent. This is the root of all errors and should be used\n * everywhere in the Agent code (this package).\n *\n * @todo https://github.com/dfinity/agent-js/issues/420\n */\nclass AgentError extends Error {\n    constructor(message) {\n        super(message);\n        this.message = message;\n        Object.setPrototypeOf(this, AgentError.prototype);\n    }\n}\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGRmaW5pdHkvYWdlbnQvbGliL2VzbS9lcnJvcnMuanM/OWEzYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEFuIGVycm9yIHRoYXQgaGFwcGVucyBpbiB0aGUgQWdlbnQuIFRoaXMgaXMgdGhlIHJvb3Qgb2YgYWxsIGVycm9ycyBhbmQgc2hvdWxkIGJlIHVzZWRcbiAqIGV2ZXJ5d2hlcmUgaW4gdGhlIEFnZW50IGNvZGUgKHRoaXMgcGFja2FnZSkuXG4gKlxuICogQHRvZG8gaHR0cHM6Ly9naXRodWIuY29tL2RmaW5pdHkvYWdlbnQtanMvaXNzdWVzLzQyMFxuICovXG5leHBvcnQgY2xhc3MgQWdlbnRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgQWdlbnRFcnJvci5wcm90b3R5cGUpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/errors.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/fetch_candid.js":
/*!*************************************************************!*\
  !*** ./node_modules/@dfinity/agent/lib/esm/fetch_candid.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchCandid: function() { return /* binding */ fetchCandid; }\n/* harmony export */ });\n/* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/principal */ \"(app-pages-browser)/./node_modules/@dfinity/principal/lib/esm/index.js\");\n/* harmony import */ var _canisterStatus_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./canisterStatus/index */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/canisterStatus/index.js\");\n/* harmony import */ var _agent_http__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./agent/http */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/agent/http/index.js\");\n/* harmony import */ var _actor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./actor */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/actor.js\");\n\n\n\n\n/**\n * Retrieves the Candid interface for the specified canister.\n *\n * @param agent The agent to use for the request (usually an `HttpAgent`)\n * @param canisterId A string corresponding to the canister ID\n * @returns Candid source code\n */\nasync function fetchCandid(canisterId, agent) {\n    if (!agent) {\n        // Create an anonymous `HttpAgent` (adapted from Candid UI)\n        agent = await _agent_http__WEBPACK_IMPORTED_MODULE_2__.HttpAgent.create();\n    }\n    // Attempt to use canister metadata\n    const status = await _canisterStatus_index__WEBPACK_IMPORTED_MODULE_1__.request({\n        agent,\n        canisterId: _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.fromText(canisterId),\n        paths: ['candid'],\n    });\n    const candid = status.get('candid');\n    if (candid) {\n        return candid;\n    }\n    // Use `__get_candid_interface_tmp_hack` for canisters without Candid metadata\n    const tmpHackInterface = ({ IDL }) => IDL.Service({\n        __get_candid_interface_tmp_hack: IDL.Func([], [IDL.Text], ['query']),\n    });\n    const actor = _actor__WEBPACK_IMPORTED_MODULE_3__.Actor.createActor(tmpHackInterface, { agent, canisterId });\n    return (await actor.__get_candid_interface_tmp_hack());\n}\n//# sourceMappingURL=fetch_candid.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2ZldGNoX2NhbmRpZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUErQztBQUNVO0FBQ2hCO0FBQ1Q7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxzQkFBc0Isa0RBQVM7QUFDL0I7QUFDQTtBQUNBLHlCQUF5QiwwREFBc0I7QUFDL0M7QUFDQSxvQkFBb0IseURBQVM7QUFDN0I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxLQUFLO0FBQ3JDO0FBQ0EsS0FBSztBQUNMLGtCQUFrQix5Q0FBSyxpQ0FBaUMsbUJBQW1CO0FBQzNFO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGRmaW5pdHkvYWdlbnQvbGliL2VzbS9mZXRjaF9jYW5kaWQuanM/NjdiYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQcmluY2lwYWwgfSBmcm9tICdAZGZpbml0eS9wcmluY2lwYWwnO1xuaW1wb3J0ICogYXMgQ2FuaXN0ZXJTdGF0dXMgZnJvbSAnLi9jYW5pc3RlclN0YXR1cy9pbmRleCc7XG5pbXBvcnQgeyBIdHRwQWdlbnQgfSBmcm9tICcuL2FnZW50L2h0dHAnO1xuaW1wb3J0IHsgQWN0b3IgfSBmcm9tICcuL2FjdG9yJztcbi8qKlxuICogUmV0cmlldmVzIHRoZSBDYW5kaWQgaW50ZXJmYWNlIGZvciB0aGUgc3BlY2lmaWVkIGNhbmlzdGVyLlxuICpcbiAqIEBwYXJhbSBhZ2VudCBUaGUgYWdlbnQgdG8gdXNlIGZvciB0aGUgcmVxdWVzdCAodXN1YWxseSBhbiBgSHR0cEFnZW50YClcbiAqIEBwYXJhbSBjYW5pc3RlcklkIEEgc3RyaW5nIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGNhbmlzdGVyIElEXG4gKiBAcmV0dXJucyBDYW5kaWQgc291cmNlIGNvZGVcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoQ2FuZGlkKGNhbmlzdGVySWQsIGFnZW50KSB7XG4gICAgaWYgKCFhZ2VudCkge1xuICAgICAgICAvLyBDcmVhdGUgYW4gYW5vbnltb3VzIGBIdHRwQWdlbnRgIChhZGFwdGVkIGZyb20gQ2FuZGlkIFVJKVxuICAgICAgICBhZ2VudCA9IGF3YWl0IEh0dHBBZ2VudC5jcmVhdGUoKTtcbiAgICB9XG4gICAgLy8gQXR0ZW1wdCB0byB1c2UgY2FuaXN0ZXIgbWV0YWRhdGFcbiAgICBjb25zdCBzdGF0dXMgPSBhd2FpdCBDYW5pc3RlclN0YXR1cy5yZXF1ZXN0KHtcbiAgICAgICAgYWdlbnQsXG4gICAgICAgIGNhbmlzdGVySWQ6IFByaW5jaXBhbC5mcm9tVGV4dChjYW5pc3RlcklkKSxcbiAgICAgICAgcGF0aHM6IFsnY2FuZGlkJ10sXG4gICAgfSk7XG4gICAgY29uc3QgY2FuZGlkID0gc3RhdHVzLmdldCgnY2FuZGlkJyk7XG4gICAgaWYgKGNhbmRpZCkge1xuICAgICAgICByZXR1cm4gY2FuZGlkO1xuICAgIH1cbiAgICAvLyBVc2UgYF9fZ2V0X2NhbmRpZF9pbnRlcmZhY2VfdG1wX2hhY2tgIGZvciBjYW5pc3RlcnMgd2l0aG91dCBDYW5kaWQgbWV0YWRhdGFcbiAgICBjb25zdCB0bXBIYWNrSW50ZXJmYWNlID0gKHsgSURMIH0pID0+IElETC5TZXJ2aWNlKHtcbiAgICAgICAgX19nZXRfY2FuZGlkX2ludGVyZmFjZV90bXBfaGFjazogSURMLkZ1bmMoW10sIFtJREwuVGV4dF0sIFsncXVlcnknXSksXG4gICAgfSk7XG4gICAgY29uc3QgYWN0b3IgPSBBY3Rvci5jcmVhdGVBY3Rvcih0bXBIYWNrSW50ZXJmYWNlLCB7IGFnZW50LCBjYW5pc3RlcklkIH0pO1xuICAgIHJldHVybiAoYXdhaXQgYWN0b3IuX19nZXRfY2FuZGlkX2ludGVyZmFjZV90bXBfaGFjaygpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZldGNoX2NhbmRpZC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/fetch_candid.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@dfinity/agent/lib/esm/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ACTOR_METHOD_WITH_CERTIFICATE: function() { return /* reexport safe */ _actor__WEBPACK_IMPORTED_MODULE_0__.ACTOR_METHOD_WITH_CERTIFICATE; },\n/* harmony export */   ACTOR_METHOD_WITH_HTTP_DETAILS: function() { return /* reexport safe */ _actor__WEBPACK_IMPORTED_MODULE_0__.ACTOR_METHOD_WITH_HTTP_DETAILS; },\n/* harmony export */   Actor: function() { return /* reexport safe */ _actor__WEBPACK_IMPORTED_MODULE_0__.Actor; },\n/* harmony export */   ActorCallError: function() { return /* reexport safe */ _actor__WEBPACK_IMPORTED_MODULE_0__.ActorCallError; },\n/* harmony export */   AdvancedActor: function() { return /* reexport safe */ _actor__WEBPACK_IMPORTED_MODULE_0__.AdvancedActor; },\n/* harmony export */   AgentHTTPResponseError: function() { return /* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.AgentHTTPResponseError; },\n/* harmony export */   AnonymousIdentity: function() { return /* reexport safe */ _auth__WEBPACK_IMPORTED_MODULE_4__.AnonymousIdentity; },\n/* harmony export */   CanisterStatus: function() { return /* reexport module object */ _canisterStatus__WEBPACK_IMPORTED_MODULE_15__; },\n/* harmony export */   Cbor: function() { return /* reexport module object */ _cbor__WEBPACK_IMPORTED_MODULE_16__; },\n/* harmony export */   Certificate: function() { return /* reexport safe */ _certificate__WEBPACK_IMPORTED_MODULE_6__.Certificate; },\n/* harmony export */   CertificateVerificationError: function() { return /* reexport safe */ _certificate__WEBPACK_IMPORTED_MODULE_6__.CertificateVerificationError; },\n/* harmony export */   DER_COSE_OID: function() { return /* reexport safe */ _der__WEBPACK_IMPORTED_MODULE_7__.DER_COSE_OID; },\n/* harmony export */   ED25519_OID: function() { return /* reexport safe */ _der__WEBPACK_IMPORTED_MODULE_7__.ED25519_OID; },\n/* harmony export */   Ed25519PublicKey: function() { return /* reexport safe */ _public_key__WEBPACK_IMPORTED_MODULE_9__.Ed25519PublicKey; },\n/* harmony export */   Expiry: function() { return /* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.Expiry; },\n/* harmony export */   HttpAgent: function() { return /* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.HttpAgent; },\n/* harmony export */   IC_ROOT_KEY: function() { return /* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.IC_ROOT_KEY; },\n/* harmony export */   IdentityInvalidError: function() { return /* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.IdentityInvalidError; },\n/* harmony export */   LookupStatus: function() { return /* reexport safe */ _certificate__WEBPACK_IMPORTED_MODULE_6__.LookupStatus; },\n/* harmony export */   MANAGEMENT_CANISTER_ID: function() { return /* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.MANAGEMENT_CANISTER_ID; },\n/* harmony export */   NodeType: function() { return /* reexport safe */ _certificate__WEBPACK_IMPORTED_MODULE_6__.NodeType; },\n/* harmony export */   ProxyAgent: function() { return /* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.ProxyAgent; },\n/* harmony export */   ProxyMessageKind: function() { return /* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.ProxyMessageKind; },\n/* harmony export */   ProxyStubAgent: function() { return /* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.ProxyStubAgent; },\n/* harmony export */   QueryCallRejectedError: function() { return /* reexport safe */ _actor__WEBPACK_IMPORTED_MODULE_0__.QueryCallRejectedError; },\n/* harmony export */   ReplicaRejectCode: function() { return /* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.ReplicaRejectCode; },\n/* harmony export */   RequestStatusResponseStatus: function() { return /* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.RequestStatusResponseStatus; },\n/* harmony export */   SECP256K1_OID: function() { return /* reexport safe */ _der__WEBPACK_IMPORTED_MODULE_7__.SECP256K1_OID; },\n/* harmony export */   SignIdentity: function() { return /* reexport safe */ _auth__WEBPACK_IMPORTED_MODULE_4__.SignIdentity; },\n/* harmony export */   SubmitRequestType: function() { return /* reexport safe */ _agent_http_types__WEBPACK_IMPORTED_MODULE_3__.SubmitRequestType; },\n/* harmony export */   UpdateCallRejectedError: function() { return /* reexport safe */ _actor__WEBPACK_IMPORTED_MODULE_0__.UpdateCallRejectedError; },\n/* harmony export */   blsVerify: function() { return /* reexport safe */ _utils_bls__WEBPACK_IMPORTED_MODULE_11__.blsVerify; },\n/* harmony export */   bufEquals: function() { return /* reexport safe */ _utils_buffer__WEBPACK_IMPORTED_MODULE_12__.bufEquals; },\n/* harmony export */   bufFromBufLike: function() { return /* reexport safe */ _utils_buffer__WEBPACK_IMPORTED_MODULE_12__.bufFromBufLike; },\n/* harmony export */   check_canister_ranges: function() { return /* reexport safe */ _certificate__WEBPACK_IMPORTED_MODULE_6__.check_canister_ranges; },\n/* harmony export */   compare: function() { return /* reexport safe */ _utils_buffer__WEBPACK_IMPORTED_MODULE_12__.compare; },\n/* harmony export */   concat: function() { return /* reexport safe */ _utils_buffer__WEBPACK_IMPORTED_MODULE_12__.concat; },\n/* harmony export */   createAssetCanisterActor: function() { return /* reexport safe */ _canisters_asset__WEBPACK_IMPORTED_MODULE_5__.createAssetCanisterActor; },\n/* harmony export */   createIdentityDescriptor: function() { return /* reexport safe */ _auth__WEBPACK_IMPORTED_MODULE_4__.createIdentityDescriptor; },\n/* harmony export */   decodeLen: function() { return /* reexport safe */ _der__WEBPACK_IMPORTED_MODULE_7__.decodeLen; },\n/* harmony export */   decodeLenBytes: function() { return /* reexport safe */ _der__WEBPACK_IMPORTED_MODULE_7__.decodeLenBytes; },\n/* harmony export */   defaultStrategy: function() { return /* reexport safe */ _polling__WEBPACK_IMPORTED_MODULE_14__.defaultStrategy; },\n/* harmony export */   encodeLen: function() { return /* reexport safe */ _der__WEBPACK_IMPORTED_MODULE_7__.encodeLen; },\n/* harmony export */   encodeLenBytes: function() { return /* reexport safe */ _der__WEBPACK_IMPORTED_MODULE_7__.encodeLenBytes; },\n/* harmony export */   fetchCandid: function() { return /* reexport safe */ _fetch_candid__WEBPACK_IMPORTED_MODULE_8__.fetchCandid; },\n/* harmony export */   find_label: function() { return /* reexport safe */ _certificate__WEBPACK_IMPORTED_MODULE_6__.find_label; },\n/* harmony export */   flatten_forks: function() { return /* reexport safe */ _certificate__WEBPACK_IMPORTED_MODULE_6__.flatten_forks; },\n/* harmony export */   fromHex: function() { return /* reexport safe */ _utils_buffer__WEBPACK_IMPORTED_MODULE_12__.fromHex; },\n/* harmony export */   getDefaultAgent: function() { return /* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.getDefaultAgent; },\n/* harmony export */   getManagementCanister: function() { return /* reexport safe */ _actor__WEBPACK_IMPORTED_MODULE_0__.getManagementCanister; },\n/* harmony export */   hash: function() { return /* reexport safe */ _request_id__WEBPACK_IMPORTED_MODULE_10__.hash; },\n/* harmony export */   hashOfMap: function() { return /* reexport safe */ _request_id__WEBPACK_IMPORTED_MODULE_10__.hashOfMap; },\n/* harmony export */   hashTreeToString: function() { return /* reexport safe */ _certificate__WEBPACK_IMPORTED_MODULE_6__.hashTreeToString; },\n/* harmony export */   hashValue: function() { return /* reexport safe */ _request_id__WEBPACK_IMPORTED_MODULE_10__.hashValue; },\n/* harmony export */   httpHeadersTransform: function() { return /* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.httpHeadersTransform; },\n/* harmony export */   lookupResultToBuffer: function() { return /* reexport safe */ _certificate__WEBPACK_IMPORTED_MODULE_6__.lookupResultToBuffer; },\n/* harmony export */   lookup_path: function() { return /* reexport safe */ _certificate__WEBPACK_IMPORTED_MODULE_6__.lookup_path; },\n/* harmony export */   makeExpiryTransform: function() { return /* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.makeExpiryTransform; },\n/* harmony export */   makeNonce: function() { return /* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.makeNonce; },\n/* harmony export */   makeNonceTransform: function() { return /* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.makeNonceTransform; },\n/* harmony export */   pollForResponse: function() { return /* reexport safe */ _polling__WEBPACK_IMPORTED_MODULE_14__.pollForResponse; },\n/* harmony export */   polling: function() { return /* reexport module object */ _polling__WEBPACK_IMPORTED_MODULE_14__; },\n/* harmony export */   randomNumber: function() { return /* reexport safe */ _utils_random__WEBPACK_IMPORTED_MODULE_13__.randomNumber; },\n/* harmony export */   reconstruct: function() { return /* reexport safe */ _certificate__WEBPACK_IMPORTED_MODULE_6__.reconstruct; },\n/* harmony export */   requestIdOf: function() { return /* reexport safe */ _request_id__WEBPACK_IMPORTED_MODULE_10__.requestIdOf; },\n/* harmony export */   strategy: function() { return /* reexport safe */ _polling__WEBPACK_IMPORTED_MODULE_14__.strategy; },\n/* harmony export */   toHex: function() { return /* reexport safe */ _utils_buffer__WEBPACK_IMPORTED_MODULE_12__.toHex; },\n/* harmony export */   uint8ToBuf: function() { return /* reexport safe */ _utils_buffer__WEBPACK_IMPORTED_MODULE_12__.uint8ToBuf; },\n/* harmony export */   unwrapDER: function() { return /* reexport safe */ _der__WEBPACK_IMPORTED_MODULE_7__.unwrapDER; },\n/* harmony export */   verify: function() { return /* reexport safe */ _utils_bls__WEBPACK_IMPORTED_MODULE_11__.verify; },\n/* harmony export */   wrapDER: function() { return /* reexport safe */ _der__WEBPACK_IMPORTED_MODULE_7__.wrapDER; }\n/* harmony export */ });\n/* harmony import */ var _actor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./actor */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/actor.js\");\n/* harmony import */ var _agent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./agent */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/agent/index.js\");\n/* harmony import */ var _agent_http_transforms__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./agent/http/transforms */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/agent/http/transforms.js\");\n/* harmony import */ var _agent_http_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./agent/http/types */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/agent/http/types.js\");\n/* harmony import */ var _auth__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./auth */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/auth.js\");\n/* harmony import */ var _canisters_asset__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./canisters/asset */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/canisters/asset.js\");\n/* harmony import */ var _certificate__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./certificate */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/certificate.js\");\n/* harmony import */ var _der__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./der */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/der.js\");\n/* harmony import */ var _fetch_candid__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./fetch_candid */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/fetch_candid.js\");\n/* harmony import */ var _public_key__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./public_key */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/public_key.js\");\n/* harmony import */ var _request_id__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./request_id */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/request_id.js\");\n/* harmony import */ var _utils_bls__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils/bls */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/utils/bls.js\");\n/* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./utils/buffer */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/utils/buffer.js\");\n/* harmony import */ var _utils_random__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./utils/random */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/utils/random.js\");\n/* harmony import */ var _polling__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./polling */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/polling/index.js\");\n/* harmony import */ var _canisterStatus__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./canisterStatus */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/canisterStatus/index.js\");\n/* harmony import */ var _cbor__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./cbor */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/cbor.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0I7QUFDQTtBQUNnQjtBQUNMO0FBQ1o7QUFDVztBQUNKO0FBQ1I7QUFDUztBQUNGO0FBQ0E7QUFDRDtBQUNHO0FBQ0E7QUFDTTtBQUNjO0FBQ3BCO0FBQ0w7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vaW5kZXguanM/ODQwMyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL2FjdG9yJztcbmV4cG9ydCAqIGZyb20gJy4vYWdlbnQnO1xuZXhwb3J0ICogZnJvbSAnLi9hZ2VudC9odHRwL3RyYW5zZm9ybXMnO1xuZXhwb3J0ICogZnJvbSAnLi9hZ2VudC9odHRwL3R5cGVzJztcbmV4cG9ydCAqIGZyb20gJy4vYXV0aCc7XG5leHBvcnQgKiBmcm9tICcuL2NhbmlzdGVycy9hc3NldCc7XG5leHBvcnQgKiBmcm9tICcuL2NlcnRpZmljYXRlJztcbmV4cG9ydCAqIGZyb20gJy4vZGVyJztcbmV4cG9ydCAqIGZyb20gJy4vZmV0Y2hfY2FuZGlkJztcbmV4cG9ydCAqIGZyb20gJy4vcHVibGljX2tleSc7XG5leHBvcnQgKiBmcm9tICcuL3JlcXVlc3RfaWQnO1xuZXhwb3J0ICogZnJvbSAnLi91dGlscy9ibHMnO1xuZXhwb3J0ICogZnJvbSAnLi91dGlscy9idWZmZXInO1xuZXhwb3J0ICogZnJvbSAnLi91dGlscy9yYW5kb20nO1xuZXhwb3J0ICogYXMgcG9sbGluZyBmcm9tICcuL3BvbGxpbmcnO1xuZXhwb3J0ICogYXMgQ2FuaXN0ZXJTdGF0dXMgZnJvbSAnLi9jYW5pc3RlclN0YXR1cyc7XG5leHBvcnQgKiBhcyBDYm9yIGZyb20gJy4vY2Jvcic7XG5leHBvcnQgKiBmcm9tICcuL3BvbGxpbmcnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/observable.js":
/*!***********************************************************!*\
  !*** ./node_modules/@dfinity/agent/lib/esm/observable.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Observable: function() { return /* binding */ Observable; },\n/* harmony export */   ObservableLog: function() { return /* binding */ ObservableLog; }\n/* harmony export */ });\nclass Observable {\n    constructor() {\n        this.observers = [];\n    }\n    subscribe(func) {\n        this.observers.push(func);\n    }\n    unsubscribe(func) {\n        this.observers = this.observers.filter(observer => observer !== func);\n    }\n    notify(data, ...rest) {\n        this.observers.forEach(observer => observer(data, ...rest));\n    }\n}\nclass ObservableLog extends Observable {\n    constructor() {\n        super();\n    }\n    print(message, ...rest) {\n        this.notify({ message, level: 'info' }, ...rest);\n    }\n    warn(message, ...rest) {\n        this.notify({ message, level: 'warn' }, ...rest);\n    }\n    error(message, error, ...rest) {\n        this.notify({ message, level: 'error', error }, ...rest);\n    }\n}\n//# sourceMappingURL=observable.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL29ic2VydmFibGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBLHNCQUFzQixnQ0FBZ0M7QUFDdEQ7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL29ic2VydmFibGUuanM/YjY4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY2xhc3MgT2JzZXJ2YWJsZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gW107XG4gICAgfVxuICAgIHN1YnNjcmliZShmdW5jKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLnB1c2goZnVuYyk7XG4gICAgfVxuICAgIHVuc3Vic2NyaWJlKGZ1bmMpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVycy5maWx0ZXIob2JzZXJ2ZXIgPT4gb2JzZXJ2ZXIgIT09IGZ1bmMpO1xuICAgIH1cbiAgICBub3RpZnkoZGF0YSwgLi4ucmVzdCkge1xuICAgICAgICB0aGlzLm9ic2VydmVycy5mb3JFYWNoKG9ic2VydmVyID0+IG9ic2VydmVyKGRhdGEsIC4uLnJlc3QpKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgT2JzZXJ2YWJsZUxvZyBleHRlbmRzIE9ic2VydmFibGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cbiAgICBwcmludChtZXNzYWdlLCAuLi5yZXN0KSB7XG4gICAgICAgIHRoaXMubm90aWZ5KHsgbWVzc2FnZSwgbGV2ZWw6ICdpbmZvJyB9LCAuLi5yZXN0KTtcbiAgICB9XG4gICAgd2FybihtZXNzYWdlLCAuLi5yZXN0KSB7XG4gICAgICAgIHRoaXMubm90aWZ5KHsgbWVzc2FnZSwgbGV2ZWw6ICd3YXJuJyB9LCAuLi5yZXN0KTtcbiAgICB9XG4gICAgZXJyb3IobWVzc2FnZSwgZXJyb3IsIC4uLnJlc3QpIHtcbiAgICAgICAgdGhpcy5ub3RpZnkoeyBtZXNzYWdlLCBsZXZlbDogJ2Vycm9yJywgZXJyb3IgfSwgLi4ucmVzdCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JzZXJ2YWJsZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/observable.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/polling/backoff.js":
/*!****************************************************************!*\
  !*** ./node_modules/@dfinity/agent/lib/esm/polling/backoff.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ExponentialBackoff: function() { return /* binding */ ExponentialBackoff; },\n/* harmony export */   exponentialBackoff: function() { return /* binding */ exponentialBackoff; }\n/* harmony export */ });\nvar __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _ExponentialBackoff_currentInterval, _ExponentialBackoff_randomizationFactor, _ExponentialBackoff_multiplier, _ExponentialBackoff_maxInterval, _ExponentialBackoff_startTime, _ExponentialBackoff_maxElapsedTime, _ExponentialBackoff_maxIterations, _ExponentialBackoff_date, _ExponentialBackoff_count;\nconst RANDOMIZATION_FACTOR = 0.5;\nconst MULTIPLIER = 1.5;\nconst INITIAL_INTERVAL_MSEC = 500;\nconst MAX_INTERVAL_MSEC = 60000;\nconst MAX_ELAPSED_TIME_MSEC = 900000;\nconst MAX_ITERATIONS = 10;\n/**\n * Exponential backoff strategy.\n */\nclass ExponentialBackoff {\n    constructor(options = ExponentialBackoff.default) {\n        _ExponentialBackoff_currentInterval.set(this, void 0);\n        _ExponentialBackoff_randomizationFactor.set(this, void 0);\n        _ExponentialBackoff_multiplier.set(this, void 0);\n        _ExponentialBackoff_maxInterval.set(this, void 0);\n        _ExponentialBackoff_startTime.set(this, void 0);\n        _ExponentialBackoff_maxElapsedTime.set(this, void 0);\n        _ExponentialBackoff_maxIterations.set(this, void 0);\n        _ExponentialBackoff_date.set(this, void 0);\n        _ExponentialBackoff_count.set(this, 0);\n        const { initialInterval = INITIAL_INTERVAL_MSEC, randomizationFactor = RANDOMIZATION_FACTOR, multiplier = MULTIPLIER, maxInterval = MAX_INTERVAL_MSEC, maxElapsedTime = MAX_ELAPSED_TIME_MSEC, maxIterations = MAX_ITERATIONS, date = Date, } = options;\n        __classPrivateFieldSet(this, _ExponentialBackoff_currentInterval, initialInterval, \"f\");\n        __classPrivateFieldSet(this, _ExponentialBackoff_randomizationFactor, randomizationFactor, \"f\");\n        __classPrivateFieldSet(this, _ExponentialBackoff_multiplier, multiplier, \"f\");\n        __classPrivateFieldSet(this, _ExponentialBackoff_maxInterval, maxInterval, \"f\");\n        __classPrivateFieldSet(this, _ExponentialBackoff_date, date, \"f\");\n        __classPrivateFieldSet(this, _ExponentialBackoff_startTime, date.now(), \"f\");\n        __classPrivateFieldSet(this, _ExponentialBackoff_maxElapsedTime, maxElapsedTime, \"f\");\n        __classPrivateFieldSet(this, _ExponentialBackoff_maxIterations, maxIterations, \"f\");\n    }\n    get ellapsedTimeInMsec() {\n        return __classPrivateFieldGet(this, _ExponentialBackoff_date, \"f\").now() - __classPrivateFieldGet(this, _ExponentialBackoff_startTime, \"f\");\n    }\n    get currentInterval() {\n        return __classPrivateFieldGet(this, _ExponentialBackoff_currentInterval, \"f\");\n    }\n    get count() {\n        return __classPrivateFieldGet(this, _ExponentialBackoff_count, \"f\");\n    }\n    get randomValueFromInterval() {\n        const delta = __classPrivateFieldGet(this, _ExponentialBackoff_randomizationFactor, \"f\") * __classPrivateFieldGet(this, _ExponentialBackoff_currentInterval, \"f\");\n        const min = __classPrivateFieldGet(this, _ExponentialBackoff_currentInterval, \"f\") - delta;\n        const max = __classPrivateFieldGet(this, _ExponentialBackoff_currentInterval, \"f\") + delta;\n        return Math.random() * (max - min) + min;\n    }\n    incrementCurrentInterval() {\n        var _a;\n        __classPrivateFieldSet(this, _ExponentialBackoff_currentInterval, Math.min(__classPrivateFieldGet(this, _ExponentialBackoff_currentInterval, \"f\") * __classPrivateFieldGet(this, _ExponentialBackoff_multiplier, \"f\"), __classPrivateFieldGet(this, _ExponentialBackoff_maxInterval, \"f\")), \"f\");\n        __classPrivateFieldSet(this, _ExponentialBackoff_count, (_a = __classPrivateFieldGet(this, _ExponentialBackoff_count, \"f\"), _a++, _a), \"f\");\n        return __classPrivateFieldGet(this, _ExponentialBackoff_currentInterval, \"f\");\n    }\n    next() {\n        if (this.ellapsedTimeInMsec >= __classPrivateFieldGet(this, _ExponentialBackoff_maxElapsedTime, \"f\") || __classPrivateFieldGet(this, _ExponentialBackoff_count, \"f\") >= __classPrivateFieldGet(this, _ExponentialBackoff_maxIterations, \"f\")) {\n            return null;\n        }\n        else {\n            this.incrementCurrentInterval();\n            return this.randomValueFromInterval;\n        }\n    }\n}\n_ExponentialBackoff_currentInterval = new WeakMap(), _ExponentialBackoff_randomizationFactor = new WeakMap(), _ExponentialBackoff_multiplier = new WeakMap(), _ExponentialBackoff_maxInterval = new WeakMap(), _ExponentialBackoff_startTime = new WeakMap(), _ExponentialBackoff_maxElapsedTime = new WeakMap(), _ExponentialBackoff_maxIterations = new WeakMap(), _ExponentialBackoff_date = new WeakMap(), _ExponentialBackoff_count = new WeakMap();\nExponentialBackoff.default = {\n    initialInterval: INITIAL_INTERVAL_MSEC,\n    randomizationFactor: RANDOMIZATION_FACTOR,\n    multiplier: MULTIPLIER,\n    maxInterval: MAX_INTERVAL_MSEC,\n    // 1 minute\n    maxElapsedTime: MAX_ELAPSED_TIME_MSEC,\n    maxIterations: MAX_ITERATIONS,\n    date: Date,\n};\n/**\n * Utility function to create an exponential backoff iterator.\n * @param options - for the exponential backoff\n * @returns an iterator that yields the next delay in the exponential backoff\n * @yields the next delay in the exponential backoff\n */\nfunction* exponentialBackoff(options = ExponentialBackoff.default) {\n    const backoff = new ExponentialBackoff(options);\n    let next = backoff.next();\n    while (next) {\n        yield next;\n        next = backoff.next();\n    }\n}\n//# sourceMappingURL=backoff.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3BvbGxpbmcvYmFja29mZi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLDhCQUE4QixTQUFJLElBQUksU0FBSTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFNBQUksSUFBSSxTQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNPQUFzTztBQUN0UDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vcG9sbGluZy9iYWNrb2ZmLmpzP2YwYzMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRTZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59O1xudmFyIF9FeHBvbmVudGlhbEJhY2tvZmZfY3VycmVudEludGVydmFsLCBfRXhwb25lbnRpYWxCYWNrb2ZmX3JhbmRvbWl6YXRpb25GYWN0b3IsIF9FeHBvbmVudGlhbEJhY2tvZmZfbXVsdGlwbGllciwgX0V4cG9uZW50aWFsQmFja29mZl9tYXhJbnRlcnZhbCwgX0V4cG9uZW50aWFsQmFja29mZl9zdGFydFRpbWUsIF9FeHBvbmVudGlhbEJhY2tvZmZfbWF4RWxhcHNlZFRpbWUsIF9FeHBvbmVudGlhbEJhY2tvZmZfbWF4SXRlcmF0aW9ucywgX0V4cG9uZW50aWFsQmFja29mZl9kYXRlLCBfRXhwb25lbnRpYWxCYWNrb2ZmX2NvdW50O1xuY29uc3QgUkFORE9NSVpBVElPTl9GQUNUT1IgPSAwLjU7XG5jb25zdCBNVUxUSVBMSUVSID0gMS41O1xuY29uc3QgSU5JVElBTF9JTlRFUlZBTF9NU0VDID0gNTAwO1xuY29uc3QgTUFYX0lOVEVSVkFMX01TRUMgPSA2MDAwMDtcbmNvbnN0IE1BWF9FTEFQU0VEX1RJTUVfTVNFQyA9IDkwMDAwMDtcbmNvbnN0IE1BWF9JVEVSQVRJT05TID0gMTA7XG4vKipcbiAqIEV4cG9uZW50aWFsIGJhY2tvZmYgc3RyYXRlZ3kuXG4gKi9cbmV4cG9ydCBjbGFzcyBFeHBvbmVudGlhbEJhY2tvZmYge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSBFeHBvbmVudGlhbEJhY2tvZmYuZGVmYXVsdCkge1xuICAgICAgICBfRXhwb25lbnRpYWxCYWNrb2ZmX2N1cnJlbnRJbnRlcnZhbC5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0V4cG9uZW50aWFsQmFja29mZl9yYW5kb21pemF0aW9uRmFjdG9yLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfRXhwb25lbnRpYWxCYWNrb2ZmX211bHRpcGxpZXIuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9FeHBvbmVudGlhbEJhY2tvZmZfbWF4SW50ZXJ2YWwuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9FeHBvbmVudGlhbEJhY2tvZmZfc3RhcnRUaW1lLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfRXhwb25lbnRpYWxCYWNrb2ZmX21heEVsYXBzZWRUaW1lLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfRXhwb25lbnRpYWxCYWNrb2ZmX21heEl0ZXJhdGlvbnMuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9FeHBvbmVudGlhbEJhY2tvZmZfZGF0ZS5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0V4cG9uZW50aWFsQmFja29mZl9jb3VudC5zZXQodGhpcywgMCk7XG4gICAgICAgIGNvbnN0IHsgaW5pdGlhbEludGVydmFsID0gSU5JVElBTF9JTlRFUlZBTF9NU0VDLCByYW5kb21pemF0aW9uRmFjdG9yID0gUkFORE9NSVpBVElPTl9GQUNUT1IsIG11bHRpcGxpZXIgPSBNVUxUSVBMSUVSLCBtYXhJbnRlcnZhbCA9IE1BWF9JTlRFUlZBTF9NU0VDLCBtYXhFbGFwc2VkVGltZSA9IE1BWF9FTEFQU0VEX1RJTUVfTVNFQywgbWF4SXRlcmF0aW9ucyA9IE1BWF9JVEVSQVRJT05TLCBkYXRlID0gRGF0ZSwgfSA9IG9wdGlvbnM7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0V4cG9uZW50aWFsQmFja29mZl9jdXJyZW50SW50ZXJ2YWwsIGluaXRpYWxJbnRlcnZhbCwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9FeHBvbmVudGlhbEJhY2tvZmZfcmFuZG9taXphdGlvbkZhY3RvciwgcmFuZG9taXphdGlvbkZhY3RvciwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9FeHBvbmVudGlhbEJhY2tvZmZfbXVsdGlwbGllciwgbXVsdGlwbGllciwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9FeHBvbmVudGlhbEJhY2tvZmZfbWF4SW50ZXJ2YWwsIG1heEludGVydmFsLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0V4cG9uZW50aWFsQmFja29mZl9kYXRlLCBkYXRlLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0V4cG9uZW50aWFsQmFja29mZl9zdGFydFRpbWUsIGRhdGUubm93KCksIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfRXhwb25lbnRpYWxCYWNrb2ZmX21heEVsYXBzZWRUaW1lLCBtYXhFbGFwc2VkVGltZSwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9FeHBvbmVudGlhbEJhY2tvZmZfbWF4SXRlcmF0aW9ucywgbWF4SXRlcmF0aW9ucywgXCJmXCIpO1xuICAgIH1cbiAgICBnZXQgZWxsYXBzZWRUaW1lSW5Nc2VjKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXhwb25lbnRpYWxCYWNrb2ZmX2RhdGUsIFwiZlwiKS5ub3coKSAtIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V4cG9uZW50aWFsQmFja29mZl9zdGFydFRpbWUsIFwiZlwiKTtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRJbnRlcnZhbCgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V4cG9uZW50aWFsQmFja29mZl9jdXJyZW50SW50ZXJ2YWwsIFwiZlwiKTtcbiAgICB9XG4gICAgZ2V0IGNvdW50KCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXhwb25lbnRpYWxCYWNrb2ZmX2NvdW50LCBcImZcIik7XG4gICAgfVxuICAgIGdldCByYW5kb21WYWx1ZUZyb21JbnRlcnZhbCgpIHtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FeHBvbmVudGlhbEJhY2tvZmZfcmFuZG9taXphdGlvbkZhY3RvciwgXCJmXCIpICogX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXhwb25lbnRpYWxCYWNrb2ZmX2N1cnJlbnRJbnRlcnZhbCwgXCJmXCIpO1xuICAgICAgICBjb25zdCBtaW4gPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FeHBvbmVudGlhbEJhY2tvZmZfY3VycmVudEludGVydmFsLCBcImZcIikgLSBkZWx0YTtcbiAgICAgICAgY29uc3QgbWF4ID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXhwb25lbnRpYWxCYWNrb2ZmX2N1cnJlbnRJbnRlcnZhbCwgXCJmXCIpICsgZGVsdGE7XG4gICAgICAgIHJldHVybiBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikgKyBtaW47XG4gICAgfVxuICAgIGluY3JlbWVudEN1cnJlbnRJbnRlcnZhbCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9FeHBvbmVudGlhbEJhY2tvZmZfY3VycmVudEludGVydmFsLCBNYXRoLm1pbihfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FeHBvbmVudGlhbEJhY2tvZmZfY3VycmVudEludGVydmFsLCBcImZcIikgKiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FeHBvbmVudGlhbEJhY2tvZmZfbXVsdGlwbGllciwgXCJmXCIpLCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FeHBvbmVudGlhbEJhY2tvZmZfbWF4SW50ZXJ2YWwsIFwiZlwiKSksIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfRXhwb25lbnRpYWxCYWNrb2ZmX2NvdW50LCAoX2EgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FeHBvbmVudGlhbEJhY2tvZmZfY291bnQsIFwiZlwiKSwgX2ErKywgX2EpLCBcImZcIik7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FeHBvbmVudGlhbEJhY2tvZmZfY3VycmVudEludGVydmFsLCBcImZcIik7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIGlmICh0aGlzLmVsbGFwc2VkVGltZUluTXNlYyA+PSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FeHBvbmVudGlhbEJhY2tvZmZfbWF4RWxhcHNlZFRpbWUsIFwiZlwiKSB8fCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FeHBvbmVudGlhbEJhY2tvZmZfY291bnQsIFwiZlwiKSA+PSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FeHBvbmVudGlhbEJhY2tvZmZfbWF4SXRlcmF0aW9ucywgXCJmXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5jcmVtZW50Q3VycmVudEludGVydmFsKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yYW5kb21WYWx1ZUZyb21JbnRlcnZhbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbl9FeHBvbmVudGlhbEJhY2tvZmZfY3VycmVudEludGVydmFsID0gbmV3IFdlYWtNYXAoKSwgX0V4cG9uZW50aWFsQmFja29mZl9yYW5kb21pemF0aW9uRmFjdG9yID0gbmV3IFdlYWtNYXAoKSwgX0V4cG9uZW50aWFsQmFja29mZl9tdWx0aXBsaWVyID0gbmV3IFdlYWtNYXAoKSwgX0V4cG9uZW50aWFsQmFja29mZl9tYXhJbnRlcnZhbCA9IG5ldyBXZWFrTWFwKCksIF9FeHBvbmVudGlhbEJhY2tvZmZfc3RhcnRUaW1lID0gbmV3IFdlYWtNYXAoKSwgX0V4cG9uZW50aWFsQmFja29mZl9tYXhFbGFwc2VkVGltZSA9IG5ldyBXZWFrTWFwKCksIF9FeHBvbmVudGlhbEJhY2tvZmZfbWF4SXRlcmF0aW9ucyA9IG5ldyBXZWFrTWFwKCksIF9FeHBvbmVudGlhbEJhY2tvZmZfZGF0ZSA9IG5ldyBXZWFrTWFwKCksIF9FeHBvbmVudGlhbEJhY2tvZmZfY291bnQgPSBuZXcgV2Vha01hcCgpO1xuRXhwb25lbnRpYWxCYWNrb2ZmLmRlZmF1bHQgPSB7XG4gICAgaW5pdGlhbEludGVydmFsOiBJTklUSUFMX0lOVEVSVkFMX01TRUMsXG4gICAgcmFuZG9taXphdGlvbkZhY3RvcjogUkFORE9NSVpBVElPTl9GQUNUT1IsXG4gICAgbXVsdGlwbGllcjogTVVMVElQTElFUixcbiAgICBtYXhJbnRlcnZhbDogTUFYX0lOVEVSVkFMX01TRUMsXG4gICAgLy8gMSBtaW51dGVcbiAgICBtYXhFbGFwc2VkVGltZTogTUFYX0VMQVBTRURfVElNRV9NU0VDLFxuICAgIG1heEl0ZXJhdGlvbnM6IE1BWF9JVEVSQVRJT05TLFxuICAgIGRhdGU6IERhdGUsXG59O1xuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGNyZWF0ZSBhbiBleHBvbmVudGlhbCBiYWNrb2ZmIGl0ZXJhdG9yLlxuICogQHBhcmFtIG9wdGlvbnMgLSBmb3IgdGhlIGV4cG9uZW50aWFsIGJhY2tvZmZcbiAqIEByZXR1cm5zIGFuIGl0ZXJhdG9yIHRoYXQgeWllbGRzIHRoZSBuZXh0IGRlbGF5IGluIHRoZSBleHBvbmVudGlhbCBiYWNrb2ZmXG4gKiBAeWllbGRzIHRoZSBuZXh0IGRlbGF5IGluIHRoZSBleHBvbmVudGlhbCBiYWNrb2ZmXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiogZXhwb25lbnRpYWxCYWNrb2ZmKG9wdGlvbnMgPSBFeHBvbmVudGlhbEJhY2tvZmYuZGVmYXVsdCkge1xuICAgIGNvbnN0IGJhY2tvZmYgPSBuZXcgRXhwb25lbnRpYWxCYWNrb2ZmKG9wdGlvbnMpO1xuICAgIGxldCBuZXh0ID0gYmFja29mZi5uZXh0KCk7XG4gICAgd2hpbGUgKG5leHQpIHtcbiAgICAgICAgeWllbGQgbmV4dDtcbiAgICAgICAgbmV4dCA9IGJhY2tvZmYubmV4dCgpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhY2tvZmYuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/polling/backoff.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/polling/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@dfinity/agent/lib/esm/polling/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultStrategy: function() { return /* reexport safe */ _strategy__WEBPACK_IMPORTED_MODULE_3__.defaultStrategy; },\n/* harmony export */   pollForResponse: function() { return /* binding */ pollForResponse; },\n/* harmony export */   strategy: function() { return /* reexport module object */ _strategy__WEBPACK_IMPORTED_MODULE_3__; }\n/* harmony export */ });\n/* harmony import */ var _agent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../agent */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/agent/index.js\");\n/* harmony import */ var _certificate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../certificate */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/certificate.js\");\n/* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/buffer */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/utils/buffer.js\");\n/* harmony import */ var _strategy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./strategy */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/polling/strategy.js\");\n\n\n\n\n\n\n/**\n * Polls the IC to check the status of the given request then\n * returns the response bytes once the request has been processed.\n * @param agent The agent to use to poll read_state.\n * @param canisterId The effective canister ID.\n * @param requestId The Request ID to poll status for.\n * @param strategy A polling strategy.\n * @param request Request for the readState call.\n * @param blsVerify - optional replacement function that verifies the BLS signature of a certificate.\n */\nasync function pollForResponse(agent, canisterId, requestId, strategy = (0,_strategy__WEBPACK_IMPORTED_MODULE_3__.defaultStrategy)(), \n// eslint-disable-next-line\nrequest, blsVerify) {\n    var _a;\n    const path = [new TextEncoder().encode('request_status'), requestId];\n    const currentRequest = request !== null && request !== void 0 ? request : (await ((_a = agent.createReadStateRequest) === null || _a === void 0 ? void 0 : _a.call(agent, { paths: [path] })));\n    const state = await agent.readState(canisterId, { paths: [path] }, undefined, currentRequest);\n    if (agent.rootKey == null)\n        throw new Error('Agent root key not initialized before polling');\n    const cert = await _certificate__WEBPACK_IMPORTED_MODULE_1__.Certificate.create({\n        certificate: state.certificate,\n        rootKey: agent.rootKey,\n        canisterId: canisterId,\n        blsVerify,\n    });\n    const maybeBuf = (0,_certificate__WEBPACK_IMPORTED_MODULE_1__.lookupResultToBuffer)(cert.lookup([...path, new TextEncoder().encode('status')]));\n    let status;\n    if (typeof maybeBuf === 'undefined') {\n        // Missing requestId means we need to wait\n        status = _agent__WEBPACK_IMPORTED_MODULE_0__.RequestStatusResponseStatus.Unknown;\n    }\n    else {\n        status = new TextDecoder().decode(maybeBuf);\n    }\n    switch (status) {\n        case _agent__WEBPACK_IMPORTED_MODULE_0__.RequestStatusResponseStatus.Replied: {\n            return {\n                reply: (0,_certificate__WEBPACK_IMPORTED_MODULE_1__.lookupResultToBuffer)(cert.lookup([...path, 'reply'])),\n                certificate: cert,\n            };\n        }\n        case _agent__WEBPACK_IMPORTED_MODULE_0__.RequestStatusResponseStatus.Received:\n        case _agent__WEBPACK_IMPORTED_MODULE_0__.RequestStatusResponseStatus.Unknown:\n        case _agent__WEBPACK_IMPORTED_MODULE_0__.RequestStatusResponseStatus.Processing:\n            // Execute the polling strategy, then retry.\n            await strategy(canisterId, requestId, status);\n            return pollForResponse(agent, canisterId, requestId, strategy, currentRequest, blsVerify);\n        case _agent__WEBPACK_IMPORTED_MODULE_0__.RequestStatusResponseStatus.Rejected: {\n            const rejectCode = new Uint8Array((0,_certificate__WEBPACK_IMPORTED_MODULE_1__.lookupResultToBuffer)(cert.lookup([...path, 'reject_code'])))[0];\n            const rejectMessage = new TextDecoder().decode((0,_certificate__WEBPACK_IMPORTED_MODULE_1__.lookupResultToBuffer)(cert.lookup([...path, 'reject_message'])));\n            throw new Error(`Call was rejected:\\n` +\n                `  Request ID: ${(0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.toHex)(requestId)}\\n` +\n                `  Reject code: ${rejectCode}\\n` +\n                `  Reject text: ${rejectMessage}\\n`);\n        }\n        case _agent__WEBPACK_IMPORTED_MODULE_0__.RequestStatusResponseStatus.Done:\n            // This is _technically_ not an error, but we still didn't see the `Replied` status so\n            // we don't know the result and cannot decode it.\n            throw new Error(`Call was marked as done but we never saw the reply:\\n` +\n                `  Request ID: ${(0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.toHex)(requestId)}\\n`);\n    }\n    throw new Error('unreachable');\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3BvbGxpbmcvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUF1RDtBQUNZO0FBQzNCO0FBQ0Q7QUFDTTtBQUNBO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sd0VBQXdFLDBEQUFlO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0xBQWdMLGVBQWU7QUFDL0wsc0RBQXNELGVBQWU7QUFDckU7QUFDQTtBQUNBLHVCQUF1QixxREFBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxxQkFBcUIsa0VBQW9CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwrREFBMkI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsK0RBQTJCO0FBQ3hDO0FBQ0EsdUJBQXVCLGtFQUFvQjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxhQUFhLCtEQUEyQjtBQUN4QyxhQUFhLCtEQUEyQjtBQUN4QyxhQUFhLCtEQUEyQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxhQUFhLCtEQUEyQjtBQUN4Qyw4Q0FBOEMsa0VBQW9CO0FBQ2xFLDJEQUEyRCxrRUFBb0I7QUFDL0U7QUFDQSxpQ0FBaUMsb0RBQUssWUFBWTtBQUNsRCxrQ0FBa0MsV0FBVztBQUM3QyxrQ0FBa0MsY0FBYztBQUNoRDtBQUNBLGFBQWEsK0RBQTJCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxvREFBSyxZQUFZO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3BvbGxpbmcvaW5kZXguanM/ZWUwNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSZXF1ZXN0U3RhdHVzUmVzcG9uc2VTdGF0dXMgfSBmcm9tICcuLi9hZ2VudCc7XG5pbXBvcnQgeyBDZXJ0aWZpY2F0ZSwgbG9va3VwUmVzdWx0VG9CdWZmZXIgfSBmcm9tICcuLi9jZXJ0aWZpY2F0ZSc7XG5pbXBvcnQgeyB0b0hleCB9IGZyb20gJy4uL3V0aWxzL2J1ZmZlcic7XG5leHBvcnQgKiBhcyBzdHJhdGVneSBmcm9tICcuL3N0cmF0ZWd5JztcbmltcG9ydCB7IGRlZmF1bHRTdHJhdGVneSB9IGZyb20gJy4vc3RyYXRlZ3knO1xuZXhwb3J0IHsgZGVmYXVsdFN0cmF0ZWd5IH0gZnJvbSAnLi9zdHJhdGVneSc7XG4vKipcbiAqIFBvbGxzIHRoZSBJQyB0byBjaGVjayB0aGUgc3RhdHVzIG9mIHRoZSBnaXZlbiByZXF1ZXN0IHRoZW5cbiAqIHJldHVybnMgdGhlIHJlc3BvbnNlIGJ5dGVzIG9uY2UgdGhlIHJlcXVlc3QgaGFzIGJlZW4gcHJvY2Vzc2VkLlxuICogQHBhcmFtIGFnZW50IFRoZSBhZ2VudCB0byB1c2UgdG8gcG9sbCByZWFkX3N0YXRlLlxuICogQHBhcmFtIGNhbmlzdGVySWQgVGhlIGVmZmVjdGl2ZSBjYW5pc3RlciBJRC5cbiAqIEBwYXJhbSByZXF1ZXN0SWQgVGhlIFJlcXVlc3QgSUQgdG8gcG9sbCBzdGF0dXMgZm9yLlxuICogQHBhcmFtIHN0cmF0ZWd5IEEgcG9sbGluZyBzdHJhdGVneS5cbiAqIEBwYXJhbSByZXF1ZXN0IFJlcXVlc3QgZm9yIHRoZSByZWFkU3RhdGUgY2FsbC5cbiAqIEBwYXJhbSBibHNWZXJpZnkgLSBvcHRpb25hbCByZXBsYWNlbWVudCBmdW5jdGlvbiB0aGF0IHZlcmlmaWVzIHRoZSBCTFMgc2lnbmF0dXJlIG9mIGEgY2VydGlmaWNhdGUuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwb2xsRm9yUmVzcG9uc2UoYWdlbnQsIGNhbmlzdGVySWQsIHJlcXVlc3RJZCwgc3RyYXRlZ3kgPSBkZWZhdWx0U3RyYXRlZ3koKSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbnJlcXVlc3QsIGJsc1ZlcmlmeSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBwYXRoID0gW25ldyBUZXh0RW5jb2RlcigpLmVuY29kZSgncmVxdWVzdF9zdGF0dXMnKSwgcmVxdWVzdElkXTtcbiAgICBjb25zdCBjdXJyZW50UmVxdWVzdCA9IHJlcXVlc3QgIT09IG51bGwgJiYgcmVxdWVzdCAhPT0gdm9pZCAwID8gcmVxdWVzdCA6IChhd2FpdCAoKF9hID0gYWdlbnQuY3JlYXRlUmVhZFN0YXRlUmVxdWVzdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoYWdlbnQsIHsgcGF0aHM6IFtwYXRoXSB9KSkpO1xuICAgIGNvbnN0IHN0YXRlID0gYXdhaXQgYWdlbnQucmVhZFN0YXRlKGNhbmlzdGVySWQsIHsgcGF0aHM6IFtwYXRoXSB9LCB1bmRlZmluZWQsIGN1cnJlbnRSZXF1ZXN0KTtcbiAgICBpZiAoYWdlbnQucm9vdEtleSA9PSBudWxsKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FnZW50IHJvb3Qga2V5IG5vdCBpbml0aWFsaXplZCBiZWZvcmUgcG9sbGluZycpO1xuICAgIGNvbnN0IGNlcnQgPSBhd2FpdCBDZXJ0aWZpY2F0ZS5jcmVhdGUoe1xuICAgICAgICBjZXJ0aWZpY2F0ZTogc3RhdGUuY2VydGlmaWNhdGUsXG4gICAgICAgIHJvb3RLZXk6IGFnZW50LnJvb3RLZXksXG4gICAgICAgIGNhbmlzdGVySWQ6IGNhbmlzdGVySWQsXG4gICAgICAgIGJsc1ZlcmlmeSxcbiAgICB9KTtcbiAgICBjb25zdCBtYXliZUJ1ZiA9IGxvb2t1cFJlc3VsdFRvQnVmZmVyKGNlcnQubG9va3VwKFsuLi5wYXRoLCBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoJ3N0YXR1cycpXSkpO1xuICAgIGxldCBzdGF0dXM7XG4gICAgaWYgKHR5cGVvZiBtYXliZUJ1ZiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gTWlzc2luZyByZXF1ZXN0SWQgbWVhbnMgd2UgbmVlZCB0byB3YWl0XG4gICAgICAgIHN0YXR1cyA9IFJlcXVlc3RTdGF0dXNSZXNwb25zZVN0YXR1cy5Vbmtub3duO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3RhdHVzID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKG1heWJlQnVmKTtcbiAgICB9XG4gICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgICAgY2FzZSBSZXF1ZXN0U3RhdHVzUmVzcG9uc2VTdGF0dXMuUmVwbGllZDoge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByZXBseTogbG9va3VwUmVzdWx0VG9CdWZmZXIoY2VydC5sb29rdXAoWy4uLnBhdGgsICdyZXBseSddKSksXG4gICAgICAgICAgICAgICAgY2VydGlmaWNhdGU6IGNlcnQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgUmVxdWVzdFN0YXR1c1Jlc3BvbnNlU3RhdHVzLlJlY2VpdmVkOlxuICAgICAgICBjYXNlIFJlcXVlc3RTdGF0dXNSZXNwb25zZVN0YXR1cy5Vbmtub3duOlxuICAgICAgICBjYXNlIFJlcXVlc3RTdGF0dXNSZXNwb25zZVN0YXR1cy5Qcm9jZXNzaW5nOlxuICAgICAgICAgICAgLy8gRXhlY3V0ZSB0aGUgcG9sbGluZyBzdHJhdGVneSwgdGhlbiByZXRyeS5cbiAgICAgICAgICAgIGF3YWl0IHN0cmF0ZWd5KGNhbmlzdGVySWQsIHJlcXVlc3RJZCwgc3RhdHVzKTtcbiAgICAgICAgICAgIHJldHVybiBwb2xsRm9yUmVzcG9uc2UoYWdlbnQsIGNhbmlzdGVySWQsIHJlcXVlc3RJZCwgc3RyYXRlZ3ksIGN1cnJlbnRSZXF1ZXN0LCBibHNWZXJpZnkpO1xuICAgICAgICBjYXNlIFJlcXVlc3RTdGF0dXNSZXNwb25zZVN0YXR1cy5SZWplY3RlZDoge1xuICAgICAgICAgICAgY29uc3QgcmVqZWN0Q29kZSA9IG5ldyBVaW50OEFycmF5KGxvb2t1cFJlc3VsdFRvQnVmZmVyKGNlcnQubG9va3VwKFsuLi5wYXRoLCAncmVqZWN0X2NvZGUnXSkpKVswXTtcbiAgICAgICAgICAgIGNvbnN0IHJlamVjdE1lc3NhZ2UgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUobG9va3VwUmVzdWx0VG9CdWZmZXIoY2VydC5sb29rdXAoWy4uLnBhdGgsICdyZWplY3RfbWVzc2FnZSddKSkpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYWxsIHdhcyByZWplY3RlZDpcXG5gICtcbiAgICAgICAgICAgICAgICBgICBSZXF1ZXN0IElEOiAke3RvSGV4KHJlcXVlc3RJZCl9XFxuYCArXG4gICAgICAgICAgICAgICAgYCAgUmVqZWN0IGNvZGU6ICR7cmVqZWN0Q29kZX1cXG5gICtcbiAgICAgICAgICAgICAgICBgICBSZWplY3QgdGV4dDogJHtyZWplY3RNZXNzYWdlfVxcbmApO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgUmVxdWVzdFN0YXR1c1Jlc3BvbnNlU3RhdHVzLkRvbmU6XG4gICAgICAgICAgICAvLyBUaGlzIGlzIF90ZWNobmljYWxseV8gbm90IGFuIGVycm9yLCBidXQgd2Ugc3RpbGwgZGlkbid0IHNlZSB0aGUgYFJlcGxpZWRgIHN0YXR1cyBzb1xuICAgICAgICAgICAgLy8gd2UgZG9uJ3Qga25vdyB0aGUgcmVzdWx0IGFuZCBjYW5ub3QgZGVjb2RlIGl0LlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYWxsIHdhcyBtYXJrZWQgYXMgZG9uZSBidXQgd2UgbmV2ZXIgc2F3IHRoZSByZXBseTpcXG5gICtcbiAgICAgICAgICAgICAgICBgICBSZXF1ZXN0IElEOiAke3RvSGV4KHJlcXVlc3RJZCl9XFxuYCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcigndW5yZWFjaGFibGUnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/polling/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/polling/strategy.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@dfinity/agent/lib/esm/polling/strategy.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   backoff: function() { return /* binding */ backoff; },\n/* harmony export */   chain: function() { return /* binding */ chain; },\n/* harmony export */   conditionalDelay: function() { return /* binding */ conditionalDelay; },\n/* harmony export */   defaultStrategy: function() { return /* binding */ defaultStrategy; },\n/* harmony export */   maxAttempts: function() { return /* binding */ maxAttempts; },\n/* harmony export */   once: function() { return /* binding */ once; },\n/* harmony export */   throttle: function() { return /* binding */ throttle; },\n/* harmony export */   timeout: function() { return /* binding */ timeout; }\n/* harmony export */ });\n/* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/buffer */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/utils/buffer.js\");\n\nconst FIVE_MINUTES_IN_MSEC = 5 * 60 * 1000;\n/**\n * A best practices polling strategy: wait 2 seconds before the first poll, then 1 second\n * with an exponential backoff factor of 1.2. Timeout after 5 minutes.\n */\nfunction defaultStrategy() {\n    return chain(conditionalDelay(once(), 1000), backoff(1000, 1.2), timeout(FIVE_MINUTES_IN_MSEC));\n}\n/**\n * Predicate that returns true once.\n */\nfunction once() {\n    let first = true;\n    return async () => {\n        if (first) {\n            first = false;\n            return true;\n        }\n        return false;\n    };\n}\n/**\n * Delay the polling once.\n * @param condition A predicate that indicates when to delay.\n * @param timeInMsec The amount of time to delay.\n */\nfunction conditionalDelay(condition, timeInMsec) {\n    return async (canisterId, requestId, status) => {\n        if (await condition(canisterId, requestId, status)) {\n            return new Promise(resolve => setTimeout(resolve, timeInMsec));\n        }\n    };\n}\n/**\n * Error out after a maximum number of polling has been done.\n * @param count The maximum attempts to poll.\n */\nfunction maxAttempts(count) {\n    let attempts = count;\n    return async (canisterId, requestId, status) => {\n        if (--attempts <= 0) {\n            throw new Error(`Failed to retrieve a reply for request after ${count} attempts:\\n` +\n                `  Request ID: ${(0,_utils_buffer__WEBPACK_IMPORTED_MODULE_0__.toHex)(requestId)}\\n` +\n                `  Request status: ${status}\\n`);\n        }\n    };\n}\n/**\n * Throttle polling.\n * @param throttleInMsec Amount in millisecond to wait between each polling.\n */\nfunction throttle(throttleInMsec) {\n    return () => new Promise(resolve => setTimeout(resolve, throttleInMsec));\n}\n/**\n * Reject a call after a certain amount of time.\n * @param timeInMsec Time in milliseconds before the polling should be rejected.\n */\nfunction timeout(timeInMsec) {\n    const end = Date.now() + timeInMsec;\n    return async (canisterId, requestId, status) => {\n        if (Date.now() > end) {\n            throw new Error(`Request timed out after ${timeInMsec} msec:\\n` +\n                `  Request ID: ${(0,_utils_buffer__WEBPACK_IMPORTED_MODULE_0__.toHex)(requestId)}\\n` +\n                `  Request status: ${status}\\n`);\n        }\n    };\n}\n/**\n * A strategy that throttle, but using an exponential backoff strategy.\n * @param startingThrottleInMsec The throttle in milliseconds to start with.\n * @param backoffFactor The factor to multiple the throttle time between every poll. For\n *   example if using 2, the throttle will double between every run.\n */\nfunction backoff(startingThrottleInMsec, backoffFactor) {\n    let currentThrottling = startingThrottleInMsec;\n    return () => new Promise(resolve => setTimeout(() => {\n        currentThrottling *= backoffFactor;\n        resolve();\n    }, currentThrottling));\n}\n/**\n * Chain multiple polling strategy. This _chains_ the strategies, so if you pass in,\n * say, two throttling strategy of 1 second, it will result in a throttle of 2 seconds.\n * @param strategies A strategy list to chain.\n */\nfunction chain(...strategies) {\n    return async (canisterId, requestId, status) => {\n        for (const a of strategies) {\n            await a(canisterId, requestId, status);\n        }\n    };\n}\n//# sourceMappingURL=strategy.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3BvbGxpbmcvc3RyYXRlZ3kuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsT0FBTztBQUNuRixpQ0FBaUMsb0RBQUssWUFBWTtBQUNsRCxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsWUFBWTtBQUNuRSxpQ0FBaUMsb0RBQUssWUFBWTtBQUNsRCxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vcG9sbGluZy9zdHJhdGVneS5qcz9jMzNmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHRvSGV4IH0gZnJvbSAnLi4vdXRpbHMvYnVmZmVyJztcbmNvbnN0IEZJVkVfTUlOVVRFU19JTl9NU0VDID0gNSAqIDYwICogMTAwMDtcbi8qKlxuICogQSBiZXN0IHByYWN0aWNlcyBwb2xsaW5nIHN0cmF0ZWd5OiB3YWl0IDIgc2Vjb25kcyBiZWZvcmUgdGhlIGZpcnN0IHBvbGwsIHRoZW4gMSBzZWNvbmRcbiAqIHdpdGggYW4gZXhwb25lbnRpYWwgYmFja29mZiBmYWN0b3Igb2YgMS4yLiBUaW1lb3V0IGFmdGVyIDUgbWludXRlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRTdHJhdGVneSgpIHtcbiAgICByZXR1cm4gY2hhaW4oY29uZGl0aW9uYWxEZWxheShvbmNlKCksIDEwMDApLCBiYWNrb2ZmKDEwMDAsIDEuMiksIHRpbWVvdXQoRklWRV9NSU5VVEVTX0lOX01TRUMpKTtcbn1cbi8qKlxuICogUHJlZGljYXRlIHRoYXQgcmV0dXJucyB0cnVlIG9uY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbmNlKCkge1xuICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgcmV0dXJuIGFzeW5jICgpID0+IHtcbiAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG59XG4vKipcbiAqIERlbGF5IHRoZSBwb2xsaW5nIG9uY2UuXG4gKiBAcGFyYW0gY29uZGl0aW9uIEEgcHJlZGljYXRlIHRoYXQgaW5kaWNhdGVzIHdoZW4gdG8gZGVsYXkuXG4gKiBAcGFyYW0gdGltZUluTXNlYyBUaGUgYW1vdW50IG9mIHRpbWUgdG8gZGVsYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25kaXRpb25hbERlbGF5KGNvbmRpdGlvbiwgdGltZUluTXNlYykge1xuICAgIHJldHVybiBhc3luYyAoY2FuaXN0ZXJJZCwgcmVxdWVzdElkLCBzdGF0dXMpID0+IHtcbiAgICAgICAgaWYgKGF3YWl0IGNvbmRpdGlvbihjYW5pc3RlcklkLCByZXF1ZXN0SWQsIHN0YXR1cykpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZUluTXNlYykpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuICogRXJyb3Igb3V0IGFmdGVyIGEgbWF4aW11bSBudW1iZXIgb2YgcG9sbGluZyBoYXMgYmVlbiBkb25lLlxuICogQHBhcmFtIGNvdW50IFRoZSBtYXhpbXVtIGF0dGVtcHRzIHRvIHBvbGwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXhBdHRlbXB0cyhjb3VudCkge1xuICAgIGxldCBhdHRlbXB0cyA9IGNvdW50O1xuICAgIHJldHVybiBhc3luYyAoY2FuaXN0ZXJJZCwgcmVxdWVzdElkLCBzdGF0dXMpID0+IHtcbiAgICAgICAgaWYgKC0tYXR0ZW1wdHMgPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcmV0cmlldmUgYSByZXBseSBmb3IgcmVxdWVzdCBhZnRlciAke2NvdW50fSBhdHRlbXB0czpcXG5gICtcbiAgICAgICAgICAgICAgICBgICBSZXF1ZXN0IElEOiAke3RvSGV4KHJlcXVlc3RJZCl9XFxuYCArXG4gICAgICAgICAgICAgICAgYCAgUmVxdWVzdCBzdGF0dXM6ICR7c3RhdHVzfVxcbmApO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuICogVGhyb3R0bGUgcG9sbGluZy5cbiAqIEBwYXJhbSB0aHJvdHRsZUluTXNlYyBBbW91bnQgaW4gbWlsbGlzZWNvbmQgdG8gd2FpdCBiZXR3ZWVuIGVhY2ggcG9sbGluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRocm90dGxlKHRocm90dGxlSW5Nc2VjKSB7XG4gICAgcmV0dXJuICgpID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCB0aHJvdHRsZUluTXNlYykpO1xufVxuLyoqXG4gKiBSZWplY3QgYSBjYWxsIGFmdGVyIGEgY2VydGFpbiBhbW91bnQgb2YgdGltZS5cbiAqIEBwYXJhbSB0aW1lSW5Nc2VjIFRpbWUgaW4gbWlsbGlzZWNvbmRzIGJlZm9yZSB0aGUgcG9sbGluZyBzaG91bGQgYmUgcmVqZWN0ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aW1lb3V0KHRpbWVJbk1zZWMpIHtcbiAgICBjb25zdCBlbmQgPSBEYXRlLm5vdygpICsgdGltZUluTXNlYztcbiAgICByZXR1cm4gYXN5bmMgKGNhbmlzdGVySWQsIHJlcXVlc3RJZCwgc3RhdHVzKSA9PiB7XG4gICAgICAgIGlmIChEYXRlLm5vdygpID4gZW5kKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlcXVlc3QgdGltZWQgb3V0IGFmdGVyICR7dGltZUluTXNlY30gbXNlYzpcXG5gICtcbiAgICAgICAgICAgICAgICBgICBSZXF1ZXN0IElEOiAke3RvSGV4KHJlcXVlc3RJZCl9XFxuYCArXG4gICAgICAgICAgICAgICAgYCAgUmVxdWVzdCBzdGF0dXM6ICR7c3RhdHVzfVxcbmApO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuICogQSBzdHJhdGVneSB0aGF0IHRocm90dGxlLCBidXQgdXNpbmcgYW4gZXhwb25lbnRpYWwgYmFja29mZiBzdHJhdGVneS5cbiAqIEBwYXJhbSBzdGFydGluZ1Rocm90dGxlSW5Nc2VjIFRoZSB0aHJvdHRsZSBpbiBtaWxsaXNlY29uZHMgdG8gc3RhcnQgd2l0aC5cbiAqIEBwYXJhbSBiYWNrb2ZmRmFjdG9yIFRoZSBmYWN0b3IgdG8gbXVsdGlwbGUgdGhlIHRocm90dGxlIHRpbWUgYmV0d2VlbiBldmVyeSBwb2xsLiBGb3JcbiAqICAgZXhhbXBsZSBpZiB1c2luZyAyLCB0aGUgdGhyb3R0bGUgd2lsbCBkb3VibGUgYmV0d2VlbiBldmVyeSBydW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiYWNrb2ZmKHN0YXJ0aW5nVGhyb3R0bGVJbk1zZWMsIGJhY2tvZmZGYWN0b3IpIHtcbiAgICBsZXQgY3VycmVudFRocm90dGxpbmcgPSBzdGFydGluZ1Rocm90dGxlSW5Nc2VjO1xuICAgIHJldHVybiAoKSA9PiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjdXJyZW50VGhyb3R0bGluZyAqPSBiYWNrb2ZmRmFjdG9yO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgfSwgY3VycmVudFRocm90dGxpbmcpKTtcbn1cbi8qKlxuICogQ2hhaW4gbXVsdGlwbGUgcG9sbGluZyBzdHJhdGVneS4gVGhpcyBfY2hhaW5zXyB0aGUgc3RyYXRlZ2llcywgc28gaWYgeW91IHBhc3MgaW4sXG4gKiBzYXksIHR3byB0aHJvdHRsaW5nIHN0cmF0ZWd5IG9mIDEgc2Vjb25kLCBpdCB3aWxsIHJlc3VsdCBpbiBhIHRocm90dGxlIG9mIDIgc2Vjb25kcy5cbiAqIEBwYXJhbSBzdHJhdGVnaWVzIEEgc3RyYXRlZ3kgbGlzdCB0byBjaGFpbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoYWluKC4uLnN0cmF0ZWdpZXMpIHtcbiAgICByZXR1cm4gYXN5bmMgKGNhbmlzdGVySWQsIHJlcXVlc3RJZCwgc3RhdHVzKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgYSBvZiBzdHJhdGVnaWVzKSB7XG4gICAgICAgICAgICBhd2FpdCBhKGNhbmlzdGVySWQsIHJlcXVlc3RJZCwgc3RhdHVzKTtcbiAgICAgICAgfVxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJhdGVneS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/polling/strategy.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/public_key.js":
/*!***********************************************************!*\
  !*** ./node_modules/@dfinity/agent/lib/esm/public_key.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ed25519PublicKey: function() { return /* binding */ Ed25519PublicKey; }\n/* harmony export */ });\n/* harmony import */ var _der__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./der */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/der.js\");\nvar __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _Ed25519PublicKey_rawKey, _Ed25519PublicKey_derKey;\n\nclass Ed25519PublicKey {\n    // `fromRaw` and `fromDer` should be used for instantiation, not this constructor.\n    constructor(key) {\n        _Ed25519PublicKey_rawKey.set(this, void 0);\n        _Ed25519PublicKey_derKey.set(this, void 0);\n        if (key.byteLength !== Ed25519PublicKey.RAW_KEY_LENGTH) {\n            throw new Error('An Ed25519 public key must be exactly 32bytes long');\n        }\n        __classPrivateFieldSet(this, _Ed25519PublicKey_rawKey, key, \"f\");\n        __classPrivateFieldSet(this, _Ed25519PublicKey_derKey, Ed25519PublicKey.derEncode(key), \"f\");\n    }\n    static from(key) {\n        return this.fromDer(key.toDer());\n    }\n    static fromRaw(rawKey) {\n        return new Ed25519PublicKey(rawKey);\n    }\n    static fromDer(derKey) {\n        return new Ed25519PublicKey(this.derDecode(derKey));\n    }\n    static derEncode(publicKey) {\n        return (0,_der__WEBPACK_IMPORTED_MODULE_0__.wrapDER)(publicKey, _der__WEBPACK_IMPORTED_MODULE_0__.ED25519_OID).buffer;\n    }\n    static derDecode(key) {\n        const unwrapped = (0,_der__WEBPACK_IMPORTED_MODULE_0__.unwrapDER)(key, _der__WEBPACK_IMPORTED_MODULE_0__.ED25519_OID);\n        if (unwrapped.length !== this.RAW_KEY_LENGTH) {\n            throw new Error('An Ed25519 public key must be exactly 32bytes long');\n        }\n        return unwrapped;\n    }\n    get rawKey() {\n        return __classPrivateFieldGet(this, _Ed25519PublicKey_rawKey, \"f\");\n    }\n    get derKey() {\n        return __classPrivateFieldGet(this, _Ed25519PublicKey_derKey, \"f\");\n    }\n    toDer() {\n        return this.derKey;\n    }\n    toRaw() {\n        return this.rawKey;\n    }\n}\n_Ed25519PublicKey_rawKey = new WeakMap(), _Ed25519PublicKey_derKey = new WeakMap();\n// The length of Ed25519 public keys is always 32 bytes.\nEd25519PublicKey.RAW_KEY_LENGTH = 32;\n//# sourceMappingURL=public_key.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3B1YmxpY19rZXkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSw4QkFBOEIsU0FBSSxJQUFJLFNBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixTQUFJLElBQUksU0FBSTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3dEO0FBQ2pEO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNkNBQU8sWUFBWSw2Q0FBVztBQUM3QztBQUNBO0FBQ0EsMEJBQTBCLCtDQUFTLE1BQU0sNkNBQVc7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vcHVibGljX2tleS5qcz9jMmVhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfRWQyNTUxOVB1YmxpY0tleV9yYXdLZXksIF9FZDI1NTE5UHVibGljS2V5X2RlcktleTtcbmltcG9ydCB7IEVEMjU1MTlfT0lELCB1bndyYXBERVIsIHdyYXBERVIgfSBmcm9tICcuL2Rlcic7XG5leHBvcnQgY2xhc3MgRWQyNTUxOVB1YmxpY0tleSB7XG4gICAgLy8gYGZyb21SYXdgIGFuZCBgZnJvbURlcmAgc2hvdWxkIGJlIHVzZWQgZm9yIGluc3RhbnRpYXRpb24sIG5vdCB0aGlzIGNvbnN0cnVjdG9yLlxuICAgIGNvbnN0cnVjdG9yKGtleSkge1xuICAgICAgICBfRWQyNTUxOVB1YmxpY0tleV9yYXdLZXkuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9FZDI1NTE5UHVibGljS2V5X2RlcktleS5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgaWYgKGtleS5ieXRlTGVuZ3RoICE9PSBFZDI1NTE5UHVibGljS2V5LlJBV19LRVlfTEVOR1RIKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuIEVkMjU1MTkgcHVibGljIGtleSBtdXN0IGJlIGV4YWN0bHkgMzJieXRlcyBsb25nJyk7XG4gICAgICAgIH1cbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfRWQyNTUxOVB1YmxpY0tleV9yYXdLZXksIGtleSwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9FZDI1NTE5UHVibGljS2V5X2RlcktleSwgRWQyNTUxOVB1YmxpY0tleS5kZXJFbmNvZGUoa2V5KSwgXCJmXCIpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbURlcihrZXkudG9EZXIoKSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tUmF3KHJhd0tleSkge1xuICAgICAgICByZXR1cm4gbmV3IEVkMjU1MTlQdWJsaWNLZXkocmF3S2V5KTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21EZXIoZGVyS2V5KSB7XG4gICAgICAgIHJldHVybiBuZXcgRWQyNTUxOVB1YmxpY0tleSh0aGlzLmRlckRlY29kZShkZXJLZXkpKTtcbiAgICB9XG4gICAgc3RhdGljIGRlckVuY29kZShwdWJsaWNLZXkpIHtcbiAgICAgICAgcmV0dXJuIHdyYXBERVIocHVibGljS2V5LCBFRDI1NTE5X09JRCkuYnVmZmVyO1xuICAgIH1cbiAgICBzdGF0aWMgZGVyRGVjb2RlKGtleSkge1xuICAgICAgICBjb25zdCB1bndyYXBwZWQgPSB1bndyYXBERVIoa2V5LCBFRDI1NTE5X09JRCk7XG4gICAgICAgIGlmICh1bndyYXBwZWQubGVuZ3RoICE9PSB0aGlzLlJBV19LRVlfTEVOR1RIKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuIEVkMjU1MTkgcHVibGljIGtleSBtdXN0IGJlIGV4YWN0bHkgMzJieXRlcyBsb25nJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVud3JhcHBlZDtcbiAgICB9XG4gICAgZ2V0IHJhd0tleSgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0VkMjU1MTlQdWJsaWNLZXlfcmF3S2V5LCBcImZcIik7XG4gICAgfVxuICAgIGdldCBkZXJLZXkoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FZDI1NTE5UHVibGljS2V5X2RlcktleSwgXCJmXCIpO1xuICAgIH1cbiAgICB0b0RlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVyS2V5O1xuICAgIH1cbiAgICB0b1JhdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3S2V5O1xuICAgIH1cbn1cbl9FZDI1NTE5UHVibGljS2V5X3Jhd0tleSA9IG5ldyBXZWFrTWFwKCksIF9FZDI1NTE5UHVibGljS2V5X2RlcktleSA9IG5ldyBXZWFrTWFwKCk7XG4vLyBUaGUgbGVuZ3RoIG9mIEVkMjU1MTkgcHVibGljIGtleXMgaXMgYWx3YXlzIDMyIGJ5dGVzLlxuRWQyNTUxOVB1YmxpY0tleS5SQVdfS0VZX0xFTkdUSCA9IDMyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHVibGljX2tleS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/public_key.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/request_id.js":
/*!***********************************************************!*\
  !*** ./node_modules/@dfinity/agent/lib/esm/request_id.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hash: function() { return /* binding */ hash; },\n/* harmony export */   hashOfMap: function() { return /* binding */ hashOfMap; },\n/* harmony export */   hashValue: function() { return /* binding */ hashValue; },\n/* harmony export */   requestIdOf: function() { return /* binding */ requestIdOf; }\n/* harmony export */ });\n/* harmony import */ var _dfinity_candid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/candid */ \"(app-pages-browser)/./node_modules/@dfinity/candid/lib/esm/index.js\");\n/* harmony import */ var borc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! borc */ \"(app-pages-browser)/../../node_modules/borc/src/index.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(app-pages-browser)/../../node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/buffer */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/utils/buffer.js\");\n\n\n\n\n/**\n * sha256 hash the provided Buffer\n * @param data - input to hash function\n */\nfunction hash(data) {\n    return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.uint8ToBuf)(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_3__.sha256.create().update(new Uint8Array(data)).digest());\n}\n/**\n *\n * @param value unknown value\n * @returns ArrayBuffer\n */\nfunction hashValue(value) {\n    if (value instanceof borc__WEBPACK_IMPORTED_MODULE_1__.Tagged) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return hashValue(value.value);\n    }\n    else if (typeof value === 'string') {\n        return hashString(value);\n    }\n    else if (typeof value === 'number') {\n        return hash((0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_0__.lebEncode)(value));\n    }\n    else if (value instanceof ArrayBuffer || ArrayBuffer.isView(value)) {\n        return hash(value);\n    }\n    else if (Array.isArray(value)) {\n        const vals = value.map(hashValue);\n        return hash((0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.concat)(...vals));\n    }\n    else if (value && typeof value === 'object' && value._isPrincipal) {\n        return hash(value.toUint8Array());\n    }\n    else if (typeof value === 'object' &&\n        value !== null &&\n        typeof value.toHash === 'function') {\n        return hashValue(value.toHash());\n        // TODO This should be move to a specific async method as the webauthn flow required\n        // the flow to be synchronous to ensure Safari touch id works.\n        // } else if (value instanceof Promise) {\n        //   return value.then(x => hashValue(x));\n    }\n    else if (typeof value === 'object') {\n        return hashOfMap(value);\n    }\n    else if (typeof value === 'bigint') {\n        // Do this check much later than the other bigint check because this one is much less\n        // type-safe.\n        // So we want to try all the high-assurance type guards before this 'probable' one.\n        return hash((0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_0__.lebEncode)(value));\n    }\n    throw Object.assign(new Error(`Attempt to hash a value of unsupported type: ${value}`), {\n        // include so logs/callers can understand the confusing value.\n        // (when stringified in error message, prototype info is lost)\n        value,\n    });\n}\nconst hashString = (value) => {\n    const encoded = new TextEncoder().encode(value);\n    return hash(encoded);\n};\n/**\n * Get the RequestId of the provided ic-ref request.\n * RequestId is the result of the representation-independent-hash function.\n * https://sdk.dfinity.org/docs/interface-spec/index.html#hash-of-map\n * @param request - ic-ref request to hash into RequestId\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction requestIdOf(request) {\n    return hashOfMap(request);\n}\n/**\n * Hash a map into an ArrayBuffer using the representation-independent-hash function.\n * https://sdk.dfinity.org/docs/interface-spec/index.html#hash-of-map\n * @param map - Any non-nested object\n * @returns ArrayBuffer\n */\nfunction hashOfMap(map) {\n    const hashed = Object.entries(map)\n        .filter(([, value]) => value !== undefined)\n        .map(([key, value]) => {\n        const hashedKey = hashString(key);\n        const hashedValue = hashValue(value);\n        return [hashedKey, hashedValue];\n    });\n    const traversed = hashed;\n    const sorted = traversed.sort(([k1], [k2]) => {\n        return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.compare)(k1, k2);\n    });\n    const concatenated = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.concat)(...sorted.map(x => (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.concat)(...x)));\n    const result = hash(concatenated);\n    return result;\n}\n//# sourceMappingURL=request_id.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3JlcXVlc3RfaWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBNEM7QUFDcEI7QUFDc0I7QUFDZTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyx5REFBVSxDQUFDLHdEQUFNO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AseUJBQXlCLHdDQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBEQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxREFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMERBQVM7QUFDN0I7QUFDQSxrRkFBa0YsTUFBTTtBQUN4RjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGVBQWUsc0RBQU87QUFDdEIsS0FBSztBQUNMLHlCQUF5QixxREFBTSxvQkFBb0IscURBQU07QUFDekQ7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vcmVxdWVzdF9pZC5qcz9mNzkwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGxlYkVuY29kZSB9IGZyb20gJ0BkZmluaXR5L2NhbmRpZCc7XG5pbXBvcnQgYm9yYyBmcm9tICdib3JjJztcbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMjU2JztcbmltcG9ydCB7IGNvbXBhcmUsIGNvbmNhdCwgdWludDhUb0J1ZiB9IGZyb20gJy4vdXRpbHMvYnVmZmVyJztcbi8qKlxuICogc2hhMjU2IGhhc2ggdGhlIHByb3ZpZGVkIEJ1ZmZlclxuICogQHBhcmFtIGRhdGEgLSBpbnB1dCB0byBoYXNoIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoKGRhdGEpIHtcbiAgICByZXR1cm4gdWludDhUb0J1ZihzaGEyNTYuY3JlYXRlKCkudXBkYXRlKG5ldyBVaW50OEFycmF5KGRhdGEpKS5kaWdlc3QoKSk7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gdmFsdWUgdW5rbm93biB2YWx1ZVxuICogQHJldHVybnMgQXJyYXlCdWZmZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2hWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIGJvcmMuVGFnZ2VkKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHJldHVybiBoYXNoVmFsdWUodmFsdWUudmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBoYXNoU3RyaW5nKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gaGFzaChsZWJFbmNvZGUodmFsdWUpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBoYXNoKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgdmFscyA9IHZhbHVlLm1hcChoYXNoVmFsdWUpO1xuICAgICAgICByZXR1cm4gaGFzaChjb25jYXQoLi4udmFscykpO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlLl9pc1ByaW5jaXBhbCkge1xuICAgICAgICByZXR1cm4gaGFzaCh2YWx1ZS50b1VpbnQ4QXJyYXkoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgdmFsdWUgIT09IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlLnRvSGFzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gaGFzaFZhbHVlKHZhbHVlLnRvSGFzaCgpKTtcbiAgICAgICAgLy8gVE9ETyBUaGlzIHNob3VsZCBiZSBtb3ZlIHRvIGEgc3BlY2lmaWMgYXN5bmMgbWV0aG9kIGFzIHRoZSB3ZWJhdXRobiBmbG93IHJlcXVpcmVkXG4gICAgICAgIC8vIHRoZSBmbG93IHRvIGJlIHN5bmNocm9ub3VzIHRvIGVuc3VyZSBTYWZhcmkgdG91Y2ggaWQgd29ya3MuXG4gICAgICAgIC8vIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIC8vICAgcmV0dXJuIHZhbHVlLnRoZW4oeCA9PiBoYXNoVmFsdWUoeCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBoYXNoT2ZNYXAodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgIC8vIERvIHRoaXMgY2hlY2sgbXVjaCBsYXRlciB0aGFuIHRoZSBvdGhlciBiaWdpbnQgY2hlY2sgYmVjYXVzZSB0aGlzIG9uZSBpcyBtdWNoIGxlc3NcbiAgICAgICAgLy8gdHlwZS1zYWZlLlxuICAgICAgICAvLyBTbyB3ZSB3YW50IHRvIHRyeSBhbGwgdGhlIGhpZ2gtYXNzdXJhbmNlIHR5cGUgZ3VhcmRzIGJlZm9yZSB0aGlzICdwcm9iYWJsZScgb25lLlxuICAgICAgICByZXR1cm4gaGFzaChsZWJFbmNvZGUodmFsdWUpKTtcbiAgICB9XG4gICAgdGhyb3cgT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoYEF0dGVtcHQgdG8gaGFzaCBhIHZhbHVlIG9mIHVuc3VwcG9ydGVkIHR5cGU6ICR7dmFsdWV9YCksIHtcbiAgICAgICAgLy8gaW5jbHVkZSBzbyBsb2dzL2NhbGxlcnMgY2FuIHVuZGVyc3RhbmQgdGhlIGNvbmZ1c2luZyB2YWx1ZS5cbiAgICAgICAgLy8gKHdoZW4gc3RyaW5naWZpZWQgaW4gZXJyb3IgbWVzc2FnZSwgcHJvdG90eXBlIGluZm8gaXMgbG9zdClcbiAgICAgICAgdmFsdWUsXG4gICAgfSk7XG59XG5jb25zdCBoYXNoU3RyaW5nID0gKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgZW5jb2RlZCA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh2YWx1ZSk7XG4gICAgcmV0dXJuIGhhc2goZW5jb2RlZCk7XG59O1xuLyoqXG4gKiBHZXQgdGhlIFJlcXVlc3RJZCBvZiB0aGUgcHJvdmlkZWQgaWMtcmVmIHJlcXVlc3QuXG4gKiBSZXF1ZXN0SWQgaXMgdGhlIHJlc3VsdCBvZiB0aGUgcmVwcmVzZW50YXRpb24taW5kZXBlbmRlbnQtaGFzaCBmdW5jdGlvbi5cbiAqIGh0dHBzOi8vc2RrLmRmaW5pdHkub3JnL2RvY3MvaW50ZXJmYWNlLXNwZWMvaW5kZXguaHRtbCNoYXNoLW9mLW1hcFxuICogQHBhcmFtIHJlcXVlc3QgLSBpYy1yZWYgcmVxdWVzdCB0byBoYXNoIGludG8gUmVxdWVzdElkXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5leHBvcnQgZnVuY3Rpb24gcmVxdWVzdElkT2YocmVxdWVzdCkge1xuICAgIHJldHVybiBoYXNoT2ZNYXAocmVxdWVzdCk7XG59XG4vKipcbiAqIEhhc2ggYSBtYXAgaW50byBhbiBBcnJheUJ1ZmZlciB1c2luZyB0aGUgcmVwcmVzZW50YXRpb24taW5kZXBlbmRlbnQtaGFzaCBmdW5jdGlvbi5cbiAqIGh0dHBzOi8vc2RrLmRmaW5pdHkub3JnL2RvY3MvaW50ZXJmYWNlLXNwZWMvaW5kZXguaHRtbCNoYXNoLW9mLW1hcFxuICogQHBhcmFtIG1hcCAtIEFueSBub24tbmVzdGVkIG9iamVjdFxuICogQHJldHVybnMgQXJyYXlCdWZmZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2hPZk1hcChtYXApIHtcbiAgICBjb25zdCBoYXNoZWQgPSBPYmplY3QuZW50cmllcyhtYXApXG4gICAgICAgIC5maWx0ZXIoKFssIHZhbHVlXSkgPT4gdmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgLm1hcCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGNvbnN0IGhhc2hlZEtleSA9IGhhc2hTdHJpbmcoa2V5KTtcbiAgICAgICAgY29uc3QgaGFzaGVkVmFsdWUgPSBoYXNoVmFsdWUodmFsdWUpO1xuICAgICAgICByZXR1cm4gW2hhc2hlZEtleSwgaGFzaGVkVmFsdWVdO1xuICAgIH0pO1xuICAgIGNvbnN0IHRyYXZlcnNlZCA9IGhhc2hlZDtcbiAgICBjb25zdCBzb3J0ZWQgPSB0cmF2ZXJzZWQuc29ydCgoW2sxXSwgW2syXSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tcGFyZShrMSwgazIpO1xuICAgIH0pO1xuICAgIGNvbnN0IGNvbmNhdGVuYXRlZCA9IGNvbmNhdCguLi5zb3J0ZWQubWFwKHggPT4gY29uY2F0KC4uLngpKSk7XG4gICAgY29uc3QgcmVzdWx0ID0gaGFzaChjb25jYXRlbmF0ZWQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXF1ZXN0X2lkLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/request_id.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/utils/bls.js":
/*!**********************************************************!*\
  !*** ./node_modules/@dfinity/agent/lib/esm/utils/bls.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   blsVerify: function() { return /* binding */ blsVerify; },\n/* harmony export */   verify: function() { return /* binding */ verify; }\n/* harmony export */ });\n/* harmony import */ var _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/curves/bls12-381 */ \"(app-pages-browser)/../../node_modules/@noble/curves/esm/bls12-381.js\");\n/* harmony import */ var _buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buffer */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/utils/buffer.js\");\n\n\nlet verify;\n/**\n *\n * @param pk primary key: Uint8Array\n * @param sig signature: Uint8Array\n * @param msg message: Uint8Array\n * @returns boolean\n */\nfunction blsVerify(pk, sig, msg) {\n    const primaryKey = typeof pk === 'string' ? pk : (0,_buffer__WEBPACK_IMPORTED_MODULE_0__.toHex)(pk);\n    const signature = typeof sig === 'string' ? sig : (0,_buffer__WEBPACK_IMPORTED_MODULE_0__.toHex)(sig);\n    const message = typeof msg === 'string' ? msg : (0,_buffer__WEBPACK_IMPORTED_MODULE_0__.toHex)(msg);\n    return _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_1__.bls12_381.verifyShortSignature(signature, message, primaryKey);\n}\n//# sourceMappingURL=bls.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3V0aWxzL2Jscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQW9EO0FBQ25CO0FBQzFCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHFEQUFxRCw4Q0FBSztBQUMxRCxzREFBc0QsOENBQUs7QUFDM0Qsb0RBQW9ELDhDQUFLO0FBQ3pELFdBQVcsOERBQVM7QUFDcEI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGRmaW5pdHkvYWdlbnQvbGliL2VzbS91dGlscy9ibHMuanM/OGExOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBibHMxMl8zODEgfSBmcm9tICdAbm9ibGUvY3VydmVzL2JsczEyLTM4MSc7XG5pbXBvcnQgeyB0b0hleCB9IGZyb20gJy4vYnVmZmVyJztcbmV4cG9ydCBsZXQgdmVyaWZ5O1xuLyoqXG4gKlxuICogQHBhcmFtIHBrIHByaW1hcnkga2V5OiBVaW50OEFycmF5XG4gKiBAcGFyYW0gc2lnIHNpZ25hdHVyZTogVWludDhBcnJheVxuICogQHBhcmFtIG1zZyBtZXNzYWdlOiBVaW50OEFycmF5XG4gKiBAcmV0dXJucyBib29sZWFuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBibHNWZXJpZnkocGssIHNpZywgbXNnKSB7XG4gICAgY29uc3QgcHJpbWFyeUtleSA9IHR5cGVvZiBwayA9PT0gJ3N0cmluZycgPyBwayA6IHRvSGV4KHBrKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSB0eXBlb2Ygc2lnID09PSAnc3RyaW5nJyA/IHNpZyA6IHRvSGV4KHNpZyk7XG4gICAgY29uc3QgbWVzc2FnZSA9IHR5cGVvZiBtc2cgPT09ICdzdHJpbmcnID8gbXNnIDogdG9IZXgobXNnKTtcbiAgICByZXR1cm4gYmxzMTJfMzgxLnZlcmlmeVNob3J0U2lnbmF0dXJlKHNpZ25hdHVyZSwgbWVzc2FnZSwgcHJpbWFyeUtleSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ibHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/utils/bls.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/utils/buffer.js":
/*!*************************************************************!*\
  !*** ./node_modules/@dfinity/agent/lib/esm/utils/buffer.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bufEquals: function() { return /* binding */ bufEquals; },\n/* harmony export */   bufFromBufLike: function() { return /* binding */ bufFromBufLike; },\n/* harmony export */   compare: function() { return /* binding */ compare; },\n/* harmony export */   concat: function() { return /* binding */ concat; },\n/* harmony export */   fromHex: function() { return /* binding */ fromHex; },\n/* harmony export */   toHex: function() { return /* binding */ toHex; },\n/* harmony export */   uint8ToBuf: function() { return /* binding */ uint8ToBuf; }\n/* harmony export */ });\n/**\n * Concatenate multiple array buffers.\n * @param buffers The buffers to concatenate.\n */\nfunction concat(...buffers) {\n    const result = new Uint8Array(buffers.reduce((acc, curr) => acc + curr.byteLength, 0));\n    let index = 0;\n    for (const b of buffers) {\n        result.set(new Uint8Array(b), index);\n        index += b.byteLength;\n    }\n    return result.buffer;\n}\n/**\n * Transforms a buffer to an hexadecimal string. This will use the buffer as an Uint8Array.\n * @param buffer The buffer to return the hexadecimal string of.\n */\nfunction toHex(buffer) {\n    return [...new Uint8Array(buffer)].map(x => x.toString(16).padStart(2, '0')).join('');\n}\nconst hexRe = new RegExp(/^[0-9a-fA-F]+$/);\n/**\n * Transforms a hexadecimal string into an array buffer.\n * @param hex The hexadecimal string to use.\n */\nfunction fromHex(hex) {\n    if (!hexRe.test(hex)) {\n        throw new Error('Invalid hexadecimal string.');\n    }\n    const buffer = [...hex]\n        .reduce((acc, curr, i) => {\n        acc[(i / 2) | 0] = (acc[(i / 2) | 0] || '') + curr;\n        return acc;\n    }, [])\n        .map(x => Number.parseInt(x, 16));\n    return new Uint8Array(buffer).buffer;\n}\n/**\n *\n * @param b1 array buffer 1\n * @param b2 array buffer 2\n * @returns number - negative if b1 < b2, positive if b1 > b2, 0 if b1 === b2\n */\nfunction compare(b1, b2) {\n    if (b1.byteLength !== b2.byteLength) {\n        return b1.byteLength - b2.byteLength;\n    }\n    const u1 = new Uint8Array(b1);\n    const u2 = new Uint8Array(b2);\n    for (let i = 0; i < u1.length; i++) {\n        if (u1[i] !== u2[i]) {\n            return u1[i] - u2[i];\n        }\n    }\n    return 0;\n}\n/**\n * Checks two array buffers for equality.\n * @param b1 array buffer 1\n * @param b2 array buffer 2\n * @returns boolean\n */\nfunction bufEquals(b1, b2) {\n    return compare(b1, b2) === 0;\n}\n/**\n * Returns a true ArrayBuffer from a Uint8Array, as Uint8Array.buffer is unsafe.\n * @param {Uint8Array} arr Uint8Array to convert\n * @returns ArrayBuffer\n */\nfunction uint8ToBuf(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength).buffer;\n}\n/**\n * Returns a true ArrayBuffer from an ArrayBufferLike object.\n * @param bufLike a buffer-like object\n * @returns ArrayBuffer\n */\nfunction bufFromBufLike(bufLike) {\n    if (bufLike instanceof Uint8Array) {\n        return uint8ToBuf(bufLike);\n    }\n    if (bufLike instanceof ArrayBuffer) {\n        return bufLike;\n    }\n    if (Array.isArray(bufLike)) {\n        return uint8ToBuf(new Uint8Array(bufLike));\n    }\n    if ('buffer' in bufLike) {\n        return bufFromBufLike(bufLike.buffer);\n    }\n    return uint8ToBuf(new Uint8Array(bufLike));\n}\n//# sourceMappingURL=buffer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3V0aWxzL2J1ZmZlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGRmaW5pdHkvYWdlbnQvbGliL2VzbS91dGlscy9idWZmZXIuanM/NWExNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvbmNhdGVuYXRlIG11bHRpcGxlIGFycmF5IGJ1ZmZlcnMuXG4gKiBAcGFyYW0gYnVmZmVycyBUaGUgYnVmZmVycyB0byBjb25jYXRlbmF0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdCguLi5idWZmZXJzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVycy5yZWR1Y2UoKGFjYywgY3VycikgPT4gYWNjICsgY3Vyci5ieXRlTGVuZ3RoLCAwKSk7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBmb3IgKGNvbnN0IGIgb2YgYnVmZmVycykge1xuICAgICAgICByZXN1bHQuc2V0KG5ldyBVaW50OEFycmF5KGIpLCBpbmRleCk7XG4gICAgICAgIGluZGV4ICs9IGIuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5idWZmZXI7XG59XG4vKipcbiAqIFRyYW5zZm9ybXMgYSBidWZmZXIgdG8gYW4gaGV4YWRlY2ltYWwgc3RyaW5nLiBUaGlzIHdpbGwgdXNlIHRoZSBidWZmZXIgYXMgYW4gVWludDhBcnJheS5cbiAqIEBwYXJhbSBidWZmZXIgVGhlIGJ1ZmZlciB0byByZXR1cm4gdGhlIGhleGFkZWNpbWFsIHN0cmluZyBvZi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSGV4KGJ1ZmZlcikge1xuICAgIHJldHVybiBbLi4ubmV3IFVpbnQ4QXJyYXkoYnVmZmVyKV0ubWFwKHggPT4geC50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbignJyk7XG59XG5jb25zdCBoZXhSZSA9IG5ldyBSZWdFeHAoL15bMC05YS1mQS1GXSskLyk7XG4vKipcbiAqIFRyYW5zZm9ybXMgYSBoZXhhZGVjaW1hbCBzdHJpbmcgaW50byBhbiBhcnJheSBidWZmZXIuXG4gKiBAcGFyYW0gaGV4IFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gdXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUhleChoZXgpIHtcbiAgICBpZiAoIWhleFJlLnRlc3QoaGV4KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4YWRlY2ltYWwgc3RyaW5nLicpO1xuICAgIH1cbiAgICBjb25zdCBidWZmZXIgPSBbLi4uaGV4XVxuICAgICAgICAucmVkdWNlKChhY2MsIGN1cnIsIGkpID0+IHtcbiAgICAgICAgYWNjWyhpIC8gMikgfCAwXSA9IChhY2NbKGkgLyAyKSB8IDBdIHx8ICcnKSArIGN1cnI7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgW10pXG4gICAgICAgIC5tYXAoeCA9PiBOdW1iZXIucGFyc2VJbnQoeCwgMTYpKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKS5idWZmZXI7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gYjEgYXJyYXkgYnVmZmVyIDFcbiAqIEBwYXJhbSBiMiBhcnJheSBidWZmZXIgMlxuICogQHJldHVybnMgbnVtYmVyIC0gbmVnYXRpdmUgaWYgYjEgPCBiMiwgcG9zaXRpdmUgaWYgYjEgPiBiMiwgMCBpZiBiMSA9PT0gYjJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmUoYjEsIGIyKSB7XG4gICAgaWYgKGIxLmJ5dGVMZW5ndGggIT09IGIyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGIxLmJ5dGVMZW5ndGggLSBiMi5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCB1MSA9IG5ldyBVaW50OEFycmF5KGIxKTtcbiAgICBjb25zdCB1MiA9IG5ldyBVaW50OEFycmF5KGIyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHUxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh1MVtpXSAhPT0gdTJbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiB1MVtpXSAtIHUyW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuLyoqXG4gKiBDaGVja3MgdHdvIGFycmF5IGJ1ZmZlcnMgZm9yIGVxdWFsaXR5LlxuICogQHBhcmFtIGIxIGFycmF5IGJ1ZmZlciAxXG4gKiBAcGFyYW0gYjIgYXJyYXkgYnVmZmVyIDJcbiAqIEByZXR1cm5zIGJvb2xlYW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1ZkVxdWFscyhiMSwgYjIpIHtcbiAgICByZXR1cm4gY29tcGFyZShiMSwgYjIpID09PSAwO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgdHJ1ZSBBcnJheUJ1ZmZlciBmcm9tIGEgVWludDhBcnJheSwgYXMgVWludDhBcnJheS5idWZmZXIgaXMgdW5zYWZlLlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBhcnIgVWludDhBcnJheSB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyBBcnJheUJ1ZmZlclxuICovXG5leHBvcnQgZnVuY3Rpb24gdWludDhUb0J1ZihhcnIpIHtcbiAgICByZXR1cm4gbmV3IERhdGFWaWV3KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCkuYnVmZmVyO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgdHJ1ZSBBcnJheUJ1ZmZlciBmcm9tIGFuIEFycmF5QnVmZmVyTGlrZSBvYmplY3QuXG4gKiBAcGFyYW0gYnVmTGlrZSBhIGJ1ZmZlci1saWtlIG9iamVjdFxuICogQHJldHVybnMgQXJyYXlCdWZmZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1ZkZyb21CdWZMaWtlKGJ1Zkxpa2UpIHtcbiAgICBpZiAoYnVmTGlrZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHVpbnQ4VG9CdWYoYnVmTGlrZSk7XG4gICAgfVxuICAgIGlmIChidWZMaWtlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGJ1Zkxpa2U7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGJ1Zkxpa2UpKSB7XG4gICAgICAgIHJldHVybiB1aW50OFRvQnVmKG5ldyBVaW50OEFycmF5KGJ1Zkxpa2UpKTtcbiAgICB9XG4gICAgaWYgKCdidWZmZXInIGluIGJ1Zkxpa2UpIHtcbiAgICAgICAgcmV0dXJuIGJ1ZkZyb21CdWZMaWtlKGJ1Zkxpa2UuYnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHVpbnQ4VG9CdWYobmV3IFVpbnQ4QXJyYXkoYnVmTGlrZSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVmZmVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/utils/buffer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/utils/expirableMap.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@dfinity/agent/lib/esm/utils/expirableMap.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ExpirableMap: function() { return /* binding */ ExpirableMap; }\n/* harmony export */ });\nvar __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _ExpirableMap_inner, _ExpirableMap_expirationTime, _a, _b;\n/**\n * A map that expires entries after a given time.\n * Defaults to 10 minutes.\n */\nclass ExpirableMap {\n    /**\n     * Create a new ExpirableMap.\n     * @param {ExpirableMapOptions<any, any>} options - options for the map.\n     * @param {Iterable<[any, any]>} options.source - an optional source of entries to initialize the map with.\n     * @param {number} options.expirationTime - the time in milliseconds after which entries will expire.\n     */\n    constructor(options = {}) {\n        // Internals\n        _ExpirableMap_inner.set(this, void 0);\n        _ExpirableMap_expirationTime.set(this, void 0);\n        this[_a] = this.entries.bind(this);\n        this[_b] = 'ExpirableMap';\n        const { source = [], expirationTime = 10 * 60 * 1000 } = options;\n        const currentTime = Date.now();\n        __classPrivateFieldSet(this, _ExpirableMap_inner, new Map([...source].map(([key, value]) => [key, { value, timestamp: currentTime }])), \"f\");\n        __classPrivateFieldSet(this, _ExpirableMap_expirationTime, expirationTime, \"f\");\n    }\n    /**\n     * Prune removes all expired entries.\n     */\n    prune() {\n        const currentTime = Date.now();\n        for (const [key, entry] of __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").entries()) {\n            if (currentTime - entry.timestamp > __classPrivateFieldGet(this, _ExpirableMap_expirationTime, \"f\")) {\n                __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").delete(key);\n            }\n        }\n        return this;\n    }\n    // Implementing the Map interface\n    /**\n     * Set the value for the given key. Prunes expired entries.\n     * @param key for the entry\n     * @param value of the entry\n     * @returns this\n     */\n    set(key, value) {\n        this.prune();\n        const entry = {\n            value,\n            timestamp: Date.now(),\n        };\n        __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").set(key, entry);\n        return this;\n    }\n    /**\n     * Get the value associated with the key, if it exists and has not expired.\n     * @param key K\n     * @returns the value associated with the key, or undefined if the key is not present or has expired.\n     */\n    get(key) {\n        const entry = __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").get(key);\n        if (entry === undefined) {\n            return undefined;\n        }\n        if (Date.now() - entry.timestamp > __classPrivateFieldGet(this, _ExpirableMap_expirationTime, \"f\")) {\n            __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").delete(key);\n            return undefined;\n        }\n        return entry.value;\n    }\n    /**\n     * Clear all entries.\n     */\n    clear() {\n        __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").clear();\n    }\n    /**\n     * Entries returns the entries of the map, without the expiration time.\n     * @returns an iterator over the entries of the map.\n     */\n    entries() {\n        const iterator = __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").entries();\n        const generator = function* () {\n            for (const [key, value] of iterator) {\n                yield [key, value.value];\n            }\n        };\n        return generator();\n    }\n    /**\n     * Values returns the values of the map, without the expiration time.\n     * @returns an iterator over the values of the map.\n     */\n    values() {\n        const iterator = __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").values();\n        const generator = function* () {\n            for (const value of iterator) {\n                yield value.value;\n            }\n        };\n        return generator();\n    }\n    /**\n     * Keys returns the keys of the map\n     * @returns an iterator over the keys of the map.\n     */\n    keys() {\n        return __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").keys();\n    }\n    /**\n     * forEach calls the callbackfn on each entry of the map.\n     * @param callbackfn to call on each entry\n     * @param thisArg to use as this when calling the callbackfn\n     */\n    forEach(callbackfn, thisArg) {\n        for (const [key, value] of __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").entries()) {\n            callbackfn.call(thisArg, value.value, key, this);\n        }\n    }\n    /**\n     * has returns true if the key exists and has not expired.\n     * @param key K\n     * @returns true if the key exists and has not expired.\n     */\n    has(key) {\n        return __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").has(key);\n    }\n    /**\n     * delete the entry for the given key.\n     * @param key K\n     * @returns true if the key existed and has been deleted.\n     */\n    delete(key) {\n        return __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").delete(key);\n    }\n    /**\n     * get size of the map.\n     * @returns the size of the map.\n     */\n    get size() {\n        return __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").size;\n    }\n}\n_ExpirableMap_inner = new WeakMap(), _ExpirableMap_expirationTime = new WeakMap(), _a = Symbol.iterator, _b = Symbol.toStringTag;\n//# sourceMappingURL=expirableMap.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3V0aWxzL2V4cGlyYWJsZU1hcC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsOEJBQThCLFNBQUksSUFBSSxTQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsU0FBSSxJQUFJLFNBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsZUFBZSwrQkFBK0I7QUFDOUMsZUFBZSxzQkFBc0I7QUFDckMsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0NBQStDO0FBQy9EO0FBQ0EsNEdBQTRHLCtCQUErQjtBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGRmaW5pdHkvYWdlbnQvbGliL2VzbS91dGlscy9leHBpcmFibGVNYXAuanM/MjlmNiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX0V4cGlyYWJsZU1hcF9pbm5lciwgX0V4cGlyYWJsZU1hcF9leHBpcmF0aW9uVGltZSwgX2EsIF9iO1xuLyoqXG4gKiBBIG1hcCB0aGF0IGV4cGlyZXMgZW50cmllcyBhZnRlciBhIGdpdmVuIHRpbWUuXG4gKiBEZWZhdWx0cyB0byAxMCBtaW51dGVzLlxuICovXG5leHBvcnQgY2xhc3MgRXhwaXJhYmxlTWFwIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgRXhwaXJhYmxlTWFwLlxuICAgICAqIEBwYXJhbSB7RXhwaXJhYmxlTWFwT3B0aW9uczxhbnksIGFueT59IG9wdGlvbnMgLSBvcHRpb25zIGZvciB0aGUgbWFwLlxuICAgICAqIEBwYXJhbSB7SXRlcmFibGU8W2FueSwgYW55XT59IG9wdGlvbnMuc291cmNlIC0gYW4gb3B0aW9uYWwgc291cmNlIG9mIGVudHJpZXMgdG8gaW5pdGlhbGl6ZSB0aGUgbWFwIHdpdGguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuZXhwaXJhdGlvblRpbWUgLSB0aGUgdGltZSBpbiBtaWxsaXNlY29uZHMgYWZ0ZXIgd2hpY2ggZW50cmllcyB3aWxsIGV4cGlyZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgLy8gSW50ZXJuYWxzXG4gICAgICAgIF9FeHBpcmFibGVNYXBfaW5uZXIuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9FeHBpcmFibGVNYXBfZXhwaXJhdGlvblRpbWUuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIHRoaXNbX2FdID0gdGhpcy5lbnRyaWVzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXNbX2JdID0gJ0V4cGlyYWJsZU1hcCc7XG4gICAgICAgIGNvbnN0IHsgc291cmNlID0gW10sIGV4cGlyYXRpb25UaW1lID0gMTAgKiA2MCAqIDEwMDAgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfRXhwaXJhYmxlTWFwX2lubmVyLCBuZXcgTWFwKFsuLi5zb3VyY2VdLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBba2V5LCB7IHZhbHVlLCB0aW1lc3RhbXA6IGN1cnJlbnRUaW1lIH1dKSksIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfRXhwaXJhYmxlTWFwX2V4cGlyYXRpb25UaW1lLCBleHBpcmF0aW9uVGltZSwgXCJmXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcnVuZSByZW1vdmVzIGFsbCBleHBpcmVkIGVudHJpZXMuXG4gICAgICovXG4gICAgcHJ1bmUoKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBlbnRyeV0gb2YgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXhwaXJhYmxlTWFwX2lubmVyLCBcImZcIikuZW50cmllcygpKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFRpbWUgLSBlbnRyeS50aW1lc3RhbXAgPiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FeHBpcmFibGVNYXBfZXhwaXJhdGlvblRpbWUsIFwiZlwiKSkge1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V4cGlyYWJsZU1hcF9pbm5lciwgXCJmXCIpLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBJbXBsZW1lbnRpbmcgdGhlIE1hcCBpbnRlcmZhY2VcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHZhbHVlIGZvciB0aGUgZ2l2ZW4ga2V5LiBQcnVuZXMgZXhwaXJlZCBlbnRyaWVzLlxuICAgICAqIEBwYXJhbSBrZXkgZm9yIHRoZSBlbnRyeVxuICAgICAqIEBwYXJhbSB2YWx1ZSBvZiB0aGUgZW50cnlcbiAgICAgKiBAcmV0dXJucyB0aGlzXG4gICAgICovXG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5wcnVuZSgpO1xuICAgICAgICBjb25zdCBlbnRyeSA9IHtcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICB9O1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FeHBpcmFibGVNYXBfaW5uZXIsIFwiZlwiKS5zZXQoa2V5LCBlbnRyeSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5LCBpZiBpdCBleGlzdHMgYW5kIGhhcyBub3QgZXhwaXJlZC5cbiAgICAgKiBAcGFyYW0ga2V5IEtcbiAgICAgKiBAcmV0dXJucyB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBrZXksIG9yIHVuZGVmaW5lZCBpZiB0aGUga2V5IGlzIG5vdCBwcmVzZW50IG9yIGhhcyBleHBpcmVkLlxuICAgICAqL1xuICAgIGdldChrZXkpIHtcbiAgICAgICAgY29uc3QgZW50cnkgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FeHBpcmFibGVNYXBfaW5uZXIsIFwiZlwiKS5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGVudHJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKERhdGUubm93KCkgLSBlbnRyeS50aW1lc3RhbXAgPiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FeHBpcmFibGVNYXBfZXhwaXJhdGlvblRpbWUsIFwiZlwiKSkge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXhwaXJhYmxlTWFwX2lubmVyLCBcImZcIikuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnRyeS52YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXIgYWxsIGVudHJpZXMuXG4gICAgICovXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V4cGlyYWJsZU1hcF9pbm5lciwgXCJmXCIpLmNsZWFyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVudHJpZXMgcmV0dXJucyB0aGUgZW50cmllcyBvZiB0aGUgbWFwLCB3aXRob3V0IHRoZSBleHBpcmF0aW9uIHRpbWUuXG4gICAgICogQHJldHVybnMgYW4gaXRlcmF0b3Igb3ZlciB0aGUgZW50cmllcyBvZiB0aGUgbWFwLlxuICAgICAqL1xuICAgIGVudHJpZXMoKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXhwaXJhYmxlTWFwX2lubmVyLCBcImZcIikuZW50cmllcygpO1xuICAgICAgICBjb25zdCBnZW5lcmF0b3IgPSBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgaXRlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBba2V5LCB2YWx1ZS52YWx1ZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBnZW5lcmF0b3IoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsdWVzIHJldHVybnMgdGhlIHZhbHVlcyBvZiB0aGUgbWFwLCB3aXRob3V0IHRoZSBleHBpcmF0aW9uIHRpbWUuXG4gICAgICogQHJldHVybnMgYW4gaXRlcmF0b3Igb3ZlciB0aGUgdmFsdWVzIG9mIHRoZSBtYXAuXG4gICAgICovXG4gICAgdmFsdWVzKCkge1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V4cGlyYWJsZU1hcF9pbm5lciwgXCJmXCIpLnZhbHVlcygpO1xuICAgICAgICBjb25zdCBnZW5lcmF0b3IgPSBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBpdGVyYXRvcikge1xuICAgICAgICAgICAgICAgIHlpZWxkIHZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZ2VuZXJhdG9yKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEtleXMgcmV0dXJucyB0aGUga2V5cyBvZiB0aGUgbWFwXG4gICAgICogQHJldHVybnMgYW4gaXRlcmF0b3Igb3ZlciB0aGUga2V5cyBvZiB0aGUgbWFwLlxuICAgICAqL1xuICAgIGtleXMoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FeHBpcmFibGVNYXBfaW5uZXIsIFwiZlwiKS5rZXlzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGZvckVhY2ggY2FsbHMgdGhlIGNhbGxiYWNrZm4gb24gZWFjaCBlbnRyeSBvZiB0aGUgbWFwLlxuICAgICAqIEBwYXJhbSBjYWxsYmFja2ZuIHRvIGNhbGwgb24gZWFjaCBlbnRyeVxuICAgICAqIEBwYXJhbSB0aGlzQXJnIHRvIHVzZSBhcyB0aGlzIHdoZW4gY2FsbGluZyB0aGUgY2FsbGJhY2tmblxuICAgICAqL1xuICAgIGZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZykge1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FeHBpcmFibGVNYXBfaW5uZXIsIFwiZlwiKS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrZm4uY2FsbCh0aGlzQXJnLCB2YWx1ZS52YWx1ZSwga2V5LCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBoYXMgcmV0dXJucyB0cnVlIGlmIHRoZSBrZXkgZXhpc3RzIGFuZCBoYXMgbm90IGV4cGlyZWQuXG4gICAgICogQHBhcmFtIGtleSBLXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUga2V5IGV4aXN0cyBhbmQgaGFzIG5vdCBleHBpcmVkLlxuICAgICAqL1xuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V4cGlyYWJsZU1hcF9pbm5lciwgXCJmXCIpLmhhcyhrZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBkZWxldGUgdGhlIGVudHJ5IGZvciB0aGUgZ2l2ZW4ga2V5LlxuICAgICAqIEBwYXJhbSBrZXkgS1xuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGtleSBleGlzdGVkIGFuZCBoYXMgYmVlbiBkZWxldGVkLlxuICAgICAqL1xuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V4cGlyYWJsZU1hcF9pbm5lciwgXCJmXCIpLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXQgc2l6ZSBvZiB0aGUgbWFwLlxuICAgICAqIEByZXR1cm5zIHRoZSBzaXplIG9mIHRoZSBtYXAuXG4gICAgICovXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FeHBpcmFibGVNYXBfaW5uZXIsIFwiZlwiKS5zaXplO1xuICAgIH1cbn1cbl9FeHBpcmFibGVNYXBfaW5uZXIgPSBuZXcgV2Vha01hcCgpLCBfRXhwaXJhYmxlTWFwX2V4cGlyYXRpb25UaW1lID0gbmV3IFdlYWtNYXAoKSwgX2EgPSBTeW1ib2wuaXRlcmF0b3IsIF9iID0gU3ltYm9sLnRvU3RyaW5nVGFnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhwaXJhYmxlTWFwLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/utils/expirableMap.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/utils/leb.js":
/*!**********************************************************!*\
  !*** ./node_modules/@dfinity/agent/lib/esm/utils/leb.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeLeb128: function() { return /* binding */ decodeLeb128; },\n/* harmony export */   decodeTime: function() { return /* binding */ decodeTime; }\n/* harmony export */ });\n/* harmony import */ var _dfinity_candid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/candid */ \"(app-pages-browser)/./node_modules/@dfinity/candid/lib/esm/index.js\");\n\nconst decodeLeb128 = (buf) => {\n    return (0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_0__.lebDecode)(new _dfinity_candid__WEBPACK_IMPORTED_MODULE_0__.PipeArrayBuffer(buf));\n};\n// time is a LEB128-encoded Nat\nconst decodeTime = (buf) => {\n    const decoded = decodeLeb128(buf);\n    // nanoseconds to milliseconds\n    return new Date(Number(decoded) / 1000000);\n};\n//# sourceMappingURL=leb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3V0aWxzL2xlYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNkQ7QUFDdEQ7QUFDUCxXQUFXLDBEQUFTLEtBQUssNERBQWU7QUFDeEM7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGRmaW5pdHkvYWdlbnQvbGliL2VzbS91dGlscy9sZWIuanM/OTgzZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQaXBlQXJyYXlCdWZmZXIsIGxlYkRlY29kZSB9IGZyb20gJ0BkZmluaXR5L2NhbmRpZCc7XG5leHBvcnQgY29uc3QgZGVjb2RlTGViMTI4ID0gKGJ1ZikgPT4ge1xuICAgIHJldHVybiBsZWJEZWNvZGUobmV3IFBpcGVBcnJheUJ1ZmZlcihidWYpKTtcbn07XG4vLyB0aW1lIGlzIGEgTEVCMTI4LWVuY29kZWQgTmF0XG5leHBvcnQgY29uc3QgZGVjb2RlVGltZSA9IChidWYpID0+IHtcbiAgICBjb25zdCBkZWNvZGVkID0gZGVjb2RlTGViMTI4KGJ1Zik7XG4gICAgLy8gbmFub3NlY29uZHMgdG8gbWlsbGlzZWNvbmRzXG4gICAgcmV0dXJuIG5ldyBEYXRlKE51bWJlcihkZWNvZGVkKSAvIDEwMDAwMDApO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxlYi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/utils/leb.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/utils/random.js":
/*!*************************************************************!*\
  !*** ./node_modules/@dfinity/agent/lib/esm/utils/random.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   randomNumber: function() { return /* binding */ randomNumber; }\n/* harmony export */ });\n/**\n * Generates a random unsigned 32-bit integer between 0 and 0xffffffff\n * @returns {number} a random number\n */\nconst randomNumber = () => {\n    // determine whether browser crypto is available\n    if (typeof window !== 'undefined' && !!window.crypto && !!window.crypto.getRandomValues) {\n        const array = new Uint32Array(1);\n        window.crypto.getRandomValues(array);\n        return array[0];\n    }\n    // A second check for webcrypto, in case it is loaded under global instead of window\n    if (typeof crypto !== 'undefined' && crypto.getRandomValues) {\n        const array = new Uint32Array(1);\n        crypto.getRandomValues(array);\n        return array[0];\n    }\n    // determine whether node crypto is available\n    if (typeof crypto !== 'undefined' && crypto.randomInt) {\n        return crypto.randomInt(0, 0xffffffff);\n    }\n    // fall back to Math.random\n    return Math.floor(Math.random() * 0xffffffff);\n};\n//# sourceMappingURL=random.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3V0aWxzL3JhbmRvbS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGRmaW5pdHkvYWdlbnQvbGliL2VzbS91dGlscy9yYW5kb20uanM/NzZhZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB1bnNpZ25lZCAzMi1iaXQgaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDB4ZmZmZmZmZmZcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGEgcmFuZG9tIG51bWJlclxuICovXG5leHBvcnQgY29uc3QgcmFuZG9tTnVtYmVyID0gKCkgPT4ge1xuICAgIC8vIGRldGVybWluZSB3aGV0aGVyIGJyb3dzZXIgY3J5cHRvIGlzIGF2YWlsYWJsZVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhIXdpbmRvdy5jcnlwdG8gJiYgISF3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgICAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50MzJBcnJheSgxKTtcbiAgICAgICAgd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyYXkpO1xuICAgICAgICByZXR1cm4gYXJyYXlbMF07XG4gICAgfVxuICAgIC8vIEEgc2Vjb25kIGNoZWNrIGZvciB3ZWJjcnlwdG8sIGluIGNhc2UgaXQgaXMgbG9hZGVkIHVuZGVyIGdsb2JhbCBpbnN0ZWFkIG9mIHdpbmRvd1xuICAgIGlmICh0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQzMkFycmF5KDEpO1xuICAgICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycmF5KTtcbiAgICAgICAgcmV0dXJuIGFycmF5WzBdO1xuICAgIH1cbiAgICAvLyBkZXRlcm1pbmUgd2hldGhlciBub2RlIGNyeXB0byBpcyBhdmFpbGFibGVcbiAgICBpZiAodHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLnJhbmRvbUludCkge1xuICAgICAgICByZXR1cm4gY3J5cHRvLnJhbmRvbUludCgwLCAweGZmZmZmZmZmKTtcbiAgICB9XG4gICAgLy8gZmFsbCBiYWNrIHRvIE1hdGgucmFuZG9tXG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJhbmRvbS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/utils/random.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dfinity/candid/lib/esm/candid-core.js":
/*!*************************************************************!*\
  !*** ./node_modules/@dfinity/candid/lib/esm/candid-core.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InputBox: function() { return /* binding */ InputBox; },\n/* harmony export */   InputForm: function() { return /* binding */ InputForm; },\n/* harmony export */   OptionForm: function() { return /* binding */ OptionForm; },\n/* harmony export */   RecordForm: function() { return /* binding */ RecordForm; },\n/* harmony export */   TupleForm: function() { return /* binding */ TupleForm; },\n/* harmony export */   VariantForm: function() { return /* binding */ VariantForm; },\n/* harmony export */   VecForm: function() { return /* binding */ VecForm; }\n/* harmony export */ });\nclass InputBox {\n    constructor(idl, ui) {\n        this.idl = idl;\n        this.ui = ui;\n        this.label = null;\n        this.value = undefined;\n        const status = document.createElement('span');\n        status.className = 'status';\n        this.status = status;\n        if (ui.input) {\n            ui.input.addEventListener('blur', () => {\n                if (ui.input.value === '') {\n                    return;\n                }\n                this.parse();\n            });\n            ui.input.addEventListener('input', () => {\n                status.style.display = 'none';\n                ui.input.classList.remove('reject');\n            });\n        }\n    }\n    isRejected() {\n        return this.value === undefined;\n    }\n    parse(config = {}) {\n        if (this.ui.form) {\n            const value = this.ui.form.parse(config);\n            this.value = value;\n            return value;\n        }\n        if (this.ui.input) {\n            const input = this.ui.input;\n            try {\n                const value = this.ui.parse(this.idl, config, input.value);\n                if (!this.idl.covariant(value)) {\n                    throw new Error(`${input.value} is not of type ${this.idl.display()}`);\n                }\n                this.status.style.display = 'none';\n                this.value = value;\n                return value;\n            }\n            catch (err) {\n                input.classList.add('reject');\n                this.status.style.display = 'block';\n                this.status.innerHTML = 'InputError: ' + err.message;\n                this.value = undefined;\n                return undefined;\n            }\n        }\n        return null;\n    }\n    render(dom) {\n        const container = document.createElement('span');\n        if (this.label) {\n            const label = document.createElement('label');\n            label.innerText = this.label;\n            container.appendChild(label);\n        }\n        if (this.ui.input) {\n            container.appendChild(this.ui.input);\n            container.appendChild(this.status);\n        }\n        if (this.ui.form) {\n            this.ui.form.render(container);\n        }\n        dom.appendChild(container);\n    }\n}\nclass InputForm {\n    constructor(ui) {\n        this.ui = ui;\n        this.form = [];\n    }\n    renderForm(dom) {\n        if (this.ui.container) {\n            this.form.forEach(e => e.render(this.ui.container));\n            dom.appendChild(this.ui.container);\n        }\n        else {\n            this.form.forEach(e => e.render(dom));\n        }\n    }\n    render(dom) {\n        if (this.ui.open && this.ui.event) {\n            dom.appendChild(this.ui.open);\n            const form = this;\n            // eslint-disable-next-line\n            form.ui.open.addEventListener(form.ui.event, () => {\n                // Remove old form\n                if (form.ui.container) {\n                    form.ui.container.innerHTML = '';\n                }\n                else {\n                    const oldContainer = form.ui.open.nextElementSibling;\n                    if (oldContainer) {\n                        oldContainer.parentNode.removeChild(oldContainer);\n                    }\n                }\n                // Render form\n                form.generateForm();\n                form.renderForm(dom);\n            });\n        }\n        else {\n            this.generateForm();\n            this.renderForm(dom);\n        }\n    }\n}\nclass RecordForm extends InputForm {\n    constructor(fields, ui) {\n        super(ui);\n        this.fields = fields;\n        this.ui = ui;\n    }\n    generateForm() {\n        this.form = this.fields.map(([key, type]) => {\n            const input = this.ui.render(type);\n            // eslint-disable-next-line\n            if (this.ui.labelMap && this.ui.labelMap.hasOwnProperty(key)) {\n                input.label = this.ui.labelMap[key] + ' ';\n            }\n            else {\n                input.label = key + ' ';\n            }\n            return input;\n        });\n    }\n    parse(config) {\n        const v = {};\n        this.fields.forEach(([key, _], i) => {\n            const value = this.form[i].parse(config);\n            v[key] = value;\n        });\n        if (this.form.some(input => input.isRejected())) {\n            return undefined;\n        }\n        return v;\n    }\n}\nclass TupleForm extends InputForm {\n    constructor(components, ui) {\n        super(ui);\n        this.components = components;\n        this.ui = ui;\n    }\n    generateForm() {\n        this.form = this.components.map(type => {\n            const input = this.ui.render(type);\n            return input;\n        });\n    }\n    parse(config) {\n        const v = [];\n        this.components.forEach((_, i) => {\n            const value = this.form[i].parse(config);\n            v.push(value);\n        });\n        if (this.form.some(input => input.isRejected())) {\n            return undefined;\n        }\n        return v;\n    }\n}\nclass VariantForm extends InputForm {\n    constructor(fields, ui) {\n        super(ui);\n        this.fields = fields;\n        this.ui = ui;\n    }\n    generateForm() {\n        const index = this.ui.open.selectedIndex;\n        const [_, type] = this.fields[index];\n        const variant = this.ui.render(type);\n        this.form = [variant];\n    }\n    parse(config) {\n        const select = this.ui.open;\n        const selected = select.options[select.selectedIndex].value;\n        const value = this.form[0].parse(config);\n        if (value === undefined) {\n            return undefined;\n        }\n        const v = {};\n        v[selected] = value;\n        return v;\n    }\n}\nclass OptionForm extends InputForm {\n    constructor(ty, ui) {\n        super(ui);\n        this.ty = ty;\n        this.ui = ui;\n    }\n    generateForm() {\n        if (this.ui.open.checked) {\n            const opt = this.ui.render(this.ty);\n            this.form = [opt];\n        }\n        else {\n            this.form = [];\n        }\n    }\n    parse(config) {\n        if (this.form.length === 0) {\n            return [];\n        }\n        else {\n            const value = this.form[0].parse(config);\n            if (value === undefined) {\n                return undefined;\n            }\n            return [value];\n        }\n    }\n}\nclass VecForm extends InputForm {\n    constructor(ty, ui) {\n        super(ui);\n        this.ty = ty;\n        this.ui = ui;\n    }\n    generateForm() {\n        const len = +this.ui.open.value;\n        this.form = [];\n        for (let i = 0; i < len; i++) {\n            const t = this.ui.render(this.ty);\n            this.form.push(t);\n        }\n    }\n    parse(config) {\n        const value = this.form.map(input => {\n            return input.parse(config);\n        });\n        if (this.form.some(input => input.isRejected())) {\n            return undefined;\n        }\n        return value;\n    }\n}\n//# sourceMappingURL=candid-core.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9jYW5kaWQvbGliL2VzbS9jYW5kaWQtY29yZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGFBQWEsaUJBQWlCLG1CQUFtQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2NhbmRpZC9saWIvZXNtL2NhbmRpZC1jb3JlLmpzPzIwOGEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIElucHV0Qm94IHtcbiAgICBjb25zdHJ1Y3RvcihpZGwsIHVpKSB7XG4gICAgICAgIHRoaXMuaWRsID0gaWRsO1xuICAgICAgICB0aGlzLnVpID0gdWk7XG4gICAgICAgIHRoaXMubGFiZWwgPSBudWxsO1xuICAgICAgICB0aGlzLnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBzdGF0dXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIHN0YXR1cy5jbGFzc05hbWUgPSAnc3RhdHVzJztcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIGlmICh1aS5pbnB1dCkge1xuICAgICAgICAgICAgdWkuaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodWkuaW5wdXQudmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB1aS5pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBzdGF0dXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICB1aS5pbnB1dC5jbGFzc0xpc3QucmVtb3ZlKCdyZWplY3QnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzUmVqZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlID09PSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHBhcnNlKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIGlmICh0aGlzLnVpLmZvcm0pIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy51aS5mb3JtLnBhcnNlKGNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudWkuaW5wdXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gdGhpcy51aS5pbnB1dDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnVpLnBhcnNlKHRoaXMuaWRsLCBjb25maWcsIGlucHV0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaWRsLmNvdmFyaWFudCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2lucHV0LnZhbHVlfSBpcyBub3Qgb2YgdHlwZSAke3RoaXMuaWRsLmRpc3BsYXkoKX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlucHV0LmNsYXNzTGlzdC5hZGQoJ3JlamVjdCcpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzLmlubmVySFRNTCA9ICdJbnB1dEVycm9yOiAnICsgZXJyLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZW5kZXIoZG9tKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgaWYgKHRoaXMubGFiZWwpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICAgICAgICAgIGxhYmVsLmlubmVyVGV4dCA9IHRoaXMubGFiZWw7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQobGFiZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnVpLmlucHV0KSB7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy51aS5pbnB1dCk7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5zdGF0dXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnVpLmZvcm0pIHtcbiAgICAgICAgICAgIHRoaXMudWkuZm9ybS5yZW5kZXIoY29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBkb20uYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgSW5wdXRGb3JtIHtcbiAgICBjb25zdHJ1Y3Rvcih1aSkge1xuICAgICAgICB0aGlzLnVpID0gdWk7XG4gICAgICAgIHRoaXMuZm9ybSA9IFtdO1xuICAgIH1cbiAgICByZW5kZXJGb3JtKGRvbSkge1xuICAgICAgICBpZiAodGhpcy51aS5jb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybS5mb3JFYWNoKGUgPT4gZS5yZW5kZXIodGhpcy51aS5jb250YWluZXIpKTtcbiAgICAgICAgICAgIGRvbS5hcHBlbmRDaGlsZCh0aGlzLnVpLmNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZvcm0uZm9yRWFjaChlID0+IGUucmVuZGVyKGRvbSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmRlcihkb20pIHtcbiAgICAgICAgaWYgKHRoaXMudWkub3BlbiAmJiB0aGlzLnVpLmV2ZW50KSB7XG4gICAgICAgICAgICBkb20uYXBwZW5kQ2hpbGQodGhpcy51aS5vcGVuKTtcbiAgICAgICAgICAgIGNvbnN0IGZvcm0gPSB0aGlzO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICBmb3JtLnVpLm9wZW4uYWRkRXZlbnRMaXN0ZW5lcihmb3JtLnVpLmV2ZW50LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIG9sZCBmb3JtXG4gICAgICAgICAgICAgICAgaWYgKGZvcm0udWkuY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm0udWkuY29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2xkQ29udGFpbmVyID0gZm9ybS51aS5vcGVuLm5leHRFbGVtZW50U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZENvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2xkQ29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQob2xkQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZW5kZXIgZm9ybVxuICAgICAgICAgICAgICAgIGZvcm0uZ2VuZXJhdGVGb3JtKCk7XG4gICAgICAgICAgICAgICAgZm9ybS5yZW5kZXJGb3JtKGRvbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVGb3JtKCk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckZvcm0oZG9tKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBSZWNvcmRGb3JtIGV4dGVuZHMgSW5wdXRGb3JtIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIHVpKSB7XG4gICAgICAgIHN1cGVyKHVpKTtcbiAgICAgICAgdGhpcy5maWVsZHMgPSBmaWVsZHM7XG4gICAgICAgIHRoaXMudWkgPSB1aTtcbiAgICB9XG4gICAgZ2VuZXJhdGVGb3JtKCkge1xuICAgICAgICB0aGlzLmZvcm0gPSB0aGlzLmZpZWxkcy5tYXAoKFtrZXksIHR5cGVdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IHRoaXMudWkucmVuZGVyKHR5cGUpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICBpZiAodGhpcy51aS5sYWJlbE1hcCAmJiB0aGlzLnVpLmxhYmVsTWFwLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBpbnB1dC5sYWJlbCA9IHRoaXMudWkubGFiZWxNYXBba2V5XSArICcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlucHV0LmxhYmVsID0ga2V5ICsgJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGFyc2UoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IHYgPSB7fTtcbiAgICAgICAgdGhpcy5maWVsZHMuZm9yRWFjaCgoW2tleSwgX10sIGkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5mb3JtW2ldLnBhcnNlKGNvbmZpZyk7XG4gICAgICAgICAgICB2W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmZvcm0uc29tZShpbnB1dCA9PiBpbnB1dC5pc1JlamVjdGVkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBUdXBsZUZvcm0gZXh0ZW5kcyBJbnB1dEZvcm0ge1xuICAgIGNvbnN0cnVjdG9yKGNvbXBvbmVudHMsIHVpKSB7XG4gICAgICAgIHN1cGVyKHVpKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzID0gY29tcG9uZW50cztcbiAgICAgICAgdGhpcy51aSA9IHVpO1xuICAgIH1cbiAgICBnZW5lcmF0ZUZvcm0oKSB7XG4gICAgICAgIHRoaXMuZm9ybSA9IHRoaXMuY29tcG9uZW50cy5tYXAodHlwZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IHRoaXMudWkucmVuZGVyKHR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGFyc2UoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IHYgPSBbXTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzLmZvckVhY2goKF8sIGkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5mb3JtW2ldLnBhcnNlKGNvbmZpZyk7XG4gICAgICAgICAgICB2LnB1c2godmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuZm9ybS5zb21lKGlucHV0ID0+IGlucHV0LmlzUmVqZWN0ZWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFZhcmlhbnRGb3JtIGV4dGVuZHMgSW5wdXRGb3JtIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIHVpKSB7XG4gICAgICAgIHN1cGVyKHVpKTtcbiAgICAgICAgdGhpcy5maWVsZHMgPSBmaWVsZHM7XG4gICAgICAgIHRoaXMudWkgPSB1aTtcbiAgICB9XG4gICAgZ2VuZXJhdGVGb3JtKCkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMudWkub3Blbi5zZWxlY3RlZEluZGV4O1xuICAgICAgICBjb25zdCBbXywgdHlwZV0gPSB0aGlzLmZpZWxkc1tpbmRleF07XG4gICAgICAgIGNvbnN0IHZhcmlhbnQgPSB0aGlzLnVpLnJlbmRlcih0eXBlKTtcbiAgICAgICAgdGhpcy5mb3JtID0gW3ZhcmlhbnRdO1xuICAgIH1cbiAgICBwYXJzZShjb25maWcpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0ID0gdGhpcy51aS5vcGVuO1xuICAgICAgICBjb25zdCBzZWxlY3RlZCA9IHNlbGVjdC5vcHRpb25zW3NlbGVjdC5zZWxlY3RlZEluZGV4XS52YWx1ZTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmZvcm1bMF0ucGFyc2UoY29uZmlnKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdiA9IHt9O1xuICAgICAgICB2W3NlbGVjdGVkXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgT3B0aW9uRm9ybSBleHRlbmRzIElucHV0Rm9ybSB7XG4gICAgY29uc3RydWN0b3IodHksIHVpKSB7XG4gICAgICAgIHN1cGVyKHVpKTtcbiAgICAgICAgdGhpcy50eSA9IHR5O1xuICAgICAgICB0aGlzLnVpID0gdWk7XG4gICAgfVxuICAgIGdlbmVyYXRlRm9ybSgpIHtcbiAgICAgICAgaWYgKHRoaXMudWkub3Blbi5jaGVja2VkKSB7XG4gICAgICAgICAgICBjb25zdCBvcHQgPSB0aGlzLnVpLnJlbmRlcih0aGlzLnR5KTtcbiAgICAgICAgICAgIHRoaXMuZm9ybSA9IFtvcHRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mb3JtID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFyc2UoY29uZmlnKSB7XG4gICAgICAgIGlmICh0aGlzLmZvcm0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZm9ybVswXS5wYXJzZShjb25maWcpO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFt2YWx1ZV07XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVmVjRm9ybSBleHRlbmRzIElucHV0Rm9ybSB7XG4gICAgY29uc3RydWN0b3IodHksIHVpKSB7XG4gICAgICAgIHN1cGVyKHVpKTtcbiAgICAgICAgdGhpcy50eSA9IHR5O1xuICAgICAgICB0aGlzLnVpID0gdWk7XG4gICAgfVxuICAgIGdlbmVyYXRlRm9ybSgpIHtcbiAgICAgICAgY29uc3QgbGVuID0gK3RoaXMudWkub3Blbi52YWx1ZTtcbiAgICAgICAgdGhpcy5mb3JtID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHQgPSB0aGlzLnVpLnJlbmRlcih0aGlzLnR5KTtcbiAgICAgICAgICAgIHRoaXMuZm9ybS5wdXNoKHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhcnNlKGNvbmZpZykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZm9ybS5tYXAoaW5wdXQgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnBhcnNlKGNvbmZpZyk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5mb3JtLnNvbWUoaW5wdXQgPT4gaW5wdXQuaXNSZWplY3RlZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FuZGlkLWNvcmUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/candid/lib/esm/candid-core.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dfinity/candid/lib/esm/candid-ui.js":
/*!***********************************************************!*\
  !*** ./node_modules/@dfinity/candid/lib/esm/candid-ui.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Render: function() { return /* binding */ Render; },\n/* harmony export */   inputBox: function() { return /* binding */ inputBox; },\n/* harmony export */   optForm: function() { return /* binding */ optForm; },\n/* harmony export */   recordForm: function() { return /* binding */ recordForm; },\n/* harmony export */   renderInput: function() { return /* binding */ renderInput; },\n/* harmony export */   renderValue: function() { return /* binding */ renderValue; },\n/* harmony export */   tupleForm: function() { return /* binding */ tupleForm; },\n/* harmony export */   variantForm: function() { return /* binding */ variantForm; },\n/* harmony export */   vecForm: function() { return /* binding */ vecForm; }\n/* harmony export */ });\n/* harmony import */ var _idl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./idl */ \"(app-pages-browser)/./node_modules/@dfinity/candid/lib/esm/idl.js\");\n/* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @dfinity/principal */ \"(app-pages-browser)/./node_modules/@dfinity/principal/lib/esm/index.js\");\n/* harmony import */ var _candid_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./candid-core */ \"(app-pages-browser)/./node_modules/@dfinity/candid/lib/esm/candid-core.js\");\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n\n\nconst InputConfig = { parse: parsePrimitive };\nconst FormConfig = { render: renderInput };\nconst inputBox = (t, config) => {\n    return new _candid_core__WEBPACK_IMPORTED_MODULE_2__.InputBox(t, Object.assign(Object.assign({}, InputConfig), config));\n};\nconst recordForm = (fields, config) => {\n    return new _candid_core__WEBPACK_IMPORTED_MODULE_2__.RecordForm(fields, Object.assign(Object.assign({}, FormConfig), config));\n};\nconst tupleForm = (components, config) => {\n    return new _candid_core__WEBPACK_IMPORTED_MODULE_2__.TupleForm(components, Object.assign(Object.assign({}, FormConfig), config));\n};\nconst variantForm = (fields, config) => {\n    return new _candid_core__WEBPACK_IMPORTED_MODULE_2__.VariantForm(fields, Object.assign(Object.assign({}, FormConfig), config));\n};\nconst optForm = (ty, config) => {\n    return new _candid_core__WEBPACK_IMPORTED_MODULE_2__.OptionForm(ty, Object.assign(Object.assign({}, FormConfig), config));\n};\nconst vecForm = (ty, config) => {\n    return new _candid_core__WEBPACK_IMPORTED_MODULE_2__.VecForm(ty, Object.assign(Object.assign({}, FormConfig), config));\n};\nclass Render extends _idl__WEBPACK_IMPORTED_MODULE_0__.Visitor {\n    visitType(t, d) {\n        const input = document.createElement('input');\n        input.classList.add('argument');\n        input.placeholder = t.display();\n        return inputBox(t, { input });\n    }\n    visitNull(t, d) {\n        return inputBox(t, {});\n    }\n    visitRecord(t, fields, d) {\n        let config = {};\n        if (fields.length > 1) {\n            const container = document.createElement('div');\n            container.classList.add('popup-form');\n            config = { container };\n        }\n        const form = recordForm(fields, config);\n        return inputBox(t, { form });\n    }\n    visitTuple(t, components, d) {\n        let config = {};\n        if (components.length > 1) {\n            const container = document.createElement('div');\n            container.classList.add('popup-form');\n            config = { container };\n        }\n        const form = tupleForm(components, config);\n        return inputBox(t, { form });\n    }\n    visitVariant(t, fields, d) {\n        const select = document.createElement('select');\n        for (const [key, type] of fields) {\n            const option = new Option(key);\n            select.add(option);\n        }\n        select.selectedIndex = -1;\n        select.classList.add('open');\n        const config = { open: select, event: 'change' };\n        const form = variantForm(fields, config);\n        return inputBox(t, { form });\n    }\n    visitOpt(t, ty, d) {\n        const checkbox = document.createElement('input');\n        checkbox.type = 'checkbox';\n        checkbox.classList.add('open');\n        const form = optForm(ty, { open: checkbox, event: 'change' });\n        return inputBox(t, { form });\n    }\n    visitVec(t, ty, d) {\n        const len = document.createElement('input');\n        len.type = 'number';\n        len.min = '0';\n        len.max = '100';\n        len.style.width = '8rem';\n        len.placeholder = 'len';\n        len.classList.add('open');\n        const container = document.createElement('div');\n        container.classList.add('popup-form');\n        const form = vecForm(ty, { open: len, event: 'change', container });\n        return inputBox(t, { form });\n    }\n    visitRec(t, ty, d) {\n        return renderInput(ty);\n    }\n}\nclass Parse extends _idl__WEBPACK_IMPORTED_MODULE_0__.Visitor {\n    visitNull(t, v) {\n        return null;\n    }\n    visitBool(t, v) {\n        if (v === 'true') {\n            return true;\n        }\n        if (v === 'false') {\n            return false;\n        }\n        throw new Error(`Cannot parse ${v} as boolean`);\n    }\n    visitText(t, v) {\n        return v;\n    }\n    visitFloat(t, v) {\n        return parseFloat(v);\n    }\n    visitFixedInt(t, v) {\n        if (t._bits <= 32) {\n            return parseInt(v, 10);\n        }\n        else {\n            return BigInt(v);\n        }\n    }\n    visitFixedNat(t, v) {\n        if (t._bits <= 32) {\n            return parseInt(v, 10);\n        }\n        else {\n            return BigInt(v);\n        }\n    }\n    visitNumber(t, v) {\n        return BigInt(v);\n    }\n    visitPrincipal(t, v) {\n        return _dfinity_principal__WEBPACK_IMPORTED_MODULE_1__.Principal.fromText(v);\n    }\n    visitService(t, v) {\n        return _dfinity_principal__WEBPACK_IMPORTED_MODULE_1__.Principal.fromText(v);\n    }\n    visitFunc(t, v) {\n        const x = v.split('.', 2);\n        return [_dfinity_principal__WEBPACK_IMPORTED_MODULE_1__.Principal.fromText(x[0]), x[1]];\n    }\n}\nclass Random extends _idl__WEBPACK_IMPORTED_MODULE_0__.Visitor {\n    visitNull(t, v) {\n        return null;\n    }\n    visitBool(t, v) {\n        return Math.random() < 0.5;\n    }\n    visitText(t, v) {\n        return Math.random().toString(36).substring(6);\n    }\n    visitFloat(t, v) {\n        return Math.random();\n    }\n    visitInt(t, v) {\n        return BigInt(this.generateNumber(true));\n    }\n    visitNat(t, v) {\n        return BigInt(this.generateNumber(false));\n    }\n    visitFixedInt(t, v) {\n        const x = this.generateNumber(true);\n        if (t._bits <= 32) {\n            return x;\n        }\n        else {\n            return BigInt(v);\n        }\n    }\n    visitFixedNat(t, v) {\n        const x = this.generateNumber(false);\n        if (t._bits <= 32) {\n            return x;\n        }\n        else {\n            return BigInt(v);\n        }\n    }\n    generateNumber(signed) {\n        const num = Math.floor(Math.random() * 100);\n        if (signed && Math.random() < 0.5) {\n            return -num;\n        }\n        else {\n            return num;\n        }\n    }\n}\nfunction parsePrimitive(t, config, d) {\n    if (config.random && d === '') {\n        return t.accept(new Random(), d);\n    }\n    else {\n        return t.accept(new Parse(), d);\n    }\n}\n/**\n *\n * @param t an IDL type\n * @returns an input for that type\n */\nfunction renderInput(t) {\n    return t.accept(new Render(), null);\n}\n/**\n *\n * @param t an IDL Type\n * @param input an InputBox\n * @param value any\n * @returns rendering that value to the provided input\n */\nfunction renderValue(t, input, value) {\n    return t.accept(new RenderValue(), { input, value });\n}\nclass RenderValue extends _idl__WEBPACK_IMPORTED_MODULE_0__.Visitor {\n    visitType(t, d) {\n        d.input.ui.input.value = t.valueToString(d.value);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    visitNull(t, d) { }\n    visitText(t, d) {\n        d.input.ui.input.value = d.value;\n    }\n    visitRec(t, ty, d) {\n        renderValue(ty, d.input, d.value);\n    }\n    visitOpt(t, ty, d) {\n        if (d.value.length === 0) {\n            return;\n        }\n        else {\n            const form = d.input.ui.form;\n            const open = form.ui.open;\n            open.checked = true;\n            open.dispatchEvent(new Event(form.ui.event));\n            renderValue(ty, form.form[0], d.value[0]);\n        }\n    }\n    visitRecord(t, fields, d) {\n        const form = d.input.ui.form;\n        fields.forEach(([key, type], i) => {\n            renderValue(type, form.form[i], d.value[key]);\n        });\n    }\n    visitTuple(t, components, d) {\n        const form = d.input.ui.form;\n        components.forEach((type, i) => {\n            renderValue(type, form.form[i], d.value[i]);\n        });\n    }\n    visitVariant(t, fields, d) {\n        const form = d.input.ui.form;\n        const selected = Object.entries(d.value)[0];\n        fields.forEach(([key, type], i) => {\n            if (key === selected[0]) {\n                const open = form.ui.open;\n                open.selectedIndex = i;\n                open.dispatchEvent(new Event(form.ui.event));\n                renderValue(type, form.form[0], selected[1]);\n            }\n        });\n    }\n    visitVec(t, ty, d) {\n        const form = d.input.ui.form;\n        const len = d.value.length;\n        const open = form.ui.open;\n        open.value = len;\n        open.dispatchEvent(new Event(form.ui.event));\n        d.value.forEach((v, i) => {\n            renderValue(ty, form.form[i], v);\n        });\n    }\n}\n//# sourceMappingURL=candid-ui.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9jYW5kaWQvbGliL2VzbS9jYW5kaWQtdWkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUM2QjtBQUNrQjtBQUNYO0FBQ3BDLHNCQUFzQjtBQUN0QixxQkFBcUI7QUFDZDtBQUNQLGVBQWUsa0RBQVcsa0NBQWtDO0FBQzVEO0FBQ087QUFDUCxlQUFlLG9EQUFhLHVDQUF1QztBQUNuRTtBQUNPO0FBQ1AsZUFBZSxtREFBWSwyQ0FBMkM7QUFDdEU7QUFDTztBQUNQLGVBQWUscURBQWMsdUNBQXVDO0FBQ3BFO0FBQ087QUFDUCxlQUFlLG9EQUFhLG1DQUFtQztBQUMvRDtBQUNPO0FBQ1AsZUFBZSxpREFBVSxtQ0FBbUM7QUFDNUQ7QUFDTyxxQkFBcUIseUNBQVc7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsT0FBTztBQUNwQztBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsNkJBQTZCLE1BQU07QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSw2QkFBNkIsTUFBTTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSw2QkFBNkIsTUFBTTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGlDQUFpQztBQUNwRSw2QkFBNkIsTUFBTTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHVDQUF1QztBQUMxRSw2QkFBNkIsTUFBTTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlDQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLEdBQUc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5REFBUztBQUN4QjtBQUNBO0FBQ0EsZUFBZSx5REFBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseURBQVM7QUFDekI7QUFDQTtBQUNBLHFCQUFxQix5Q0FBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHlDQUF5QyxjQUFjO0FBQ3ZEO0FBQ0EsMEJBQTBCLHlDQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGRmaW5pdHkvY2FuZGlkL2xpYi9lc20vY2FuZGlkLXVpLmpzPzUyNmQiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG5pbXBvcnQgKiBhcyBJREwgZnJvbSAnLi9pZGwnO1xuaW1wb3J0IHsgUHJpbmNpcGFsIH0gZnJvbSAnQGRmaW5pdHkvcHJpbmNpcGFsJztcbmltcG9ydCAqIGFzIFVJIGZyb20gJy4vY2FuZGlkLWNvcmUnO1xuY29uc3QgSW5wdXRDb25maWcgPSB7IHBhcnNlOiBwYXJzZVByaW1pdGl2ZSB9O1xuY29uc3QgRm9ybUNvbmZpZyA9IHsgcmVuZGVyOiByZW5kZXJJbnB1dCB9O1xuZXhwb3J0IGNvbnN0IGlucHV0Qm94ID0gKHQsIGNvbmZpZykgPT4ge1xuICAgIHJldHVybiBuZXcgVUkuSW5wdXRCb3godCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBJbnB1dENvbmZpZyksIGNvbmZpZykpO1xufTtcbmV4cG9ydCBjb25zdCByZWNvcmRGb3JtID0gKGZpZWxkcywgY29uZmlnKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBVSS5SZWNvcmRGb3JtKGZpZWxkcywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBGb3JtQ29uZmlnKSwgY29uZmlnKSk7XG59O1xuZXhwb3J0IGNvbnN0IHR1cGxlRm9ybSA9IChjb21wb25lbnRzLCBjb25maWcpID0+IHtcbiAgICByZXR1cm4gbmV3IFVJLlR1cGxlRm9ybShjb21wb25lbnRzLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIEZvcm1Db25maWcpLCBjb25maWcpKTtcbn07XG5leHBvcnQgY29uc3QgdmFyaWFudEZvcm0gPSAoZmllbGRzLCBjb25maWcpID0+IHtcbiAgICByZXR1cm4gbmV3IFVJLlZhcmlhbnRGb3JtKGZpZWxkcywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBGb3JtQ29uZmlnKSwgY29uZmlnKSk7XG59O1xuZXhwb3J0IGNvbnN0IG9wdEZvcm0gPSAodHksIGNvbmZpZykgPT4ge1xuICAgIHJldHVybiBuZXcgVUkuT3B0aW9uRm9ybSh0eSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBGb3JtQ29uZmlnKSwgY29uZmlnKSk7XG59O1xuZXhwb3J0IGNvbnN0IHZlY0Zvcm0gPSAodHksIGNvbmZpZykgPT4ge1xuICAgIHJldHVybiBuZXcgVUkuVmVjRm9ybSh0eSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBGb3JtQ29uZmlnKSwgY29uZmlnKSk7XG59O1xuZXhwb3J0IGNsYXNzIFJlbmRlciBleHRlbmRzIElETC5WaXNpdG9yIHtcbiAgICB2aXNpdFR5cGUodCwgZCkge1xuICAgICAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIGlucHV0LmNsYXNzTGlzdC5hZGQoJ2FyZ3VtZW50Jyk7XG4gICAgICAgIGlucHV0LnBsYWNlaG9sZGVyID0gdC5kaXNwbGF5KCk7XG4gICAgICAgIHJldHVybiBpbnB1dEJveCh0LCB7IGlucHV0IH0pO1xuICAgIH1cbiAgICB2aXNpdE51bGwodCwgZCkge1xuICAgICAgICByZXR1cm4gaW5wdXRCb3godCwge30pO1xuICAgIH1cbiAgICB2aXNpdFJlY29yZCh0LCBmaWVsZHMsIGQpIHtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHt9O1xuICAgICAgICBpZiAoZmllbGRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3BvcHVwLWZvcm0nKTtcbiAgICAgICAgICAgIGNvbmZpZyA9IHsgY29udGFpbmVyIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm9ybSA9IHJlY29yZEZvcm0oZmllbGRzLCBjb25maWcpO1xuICAgICAgICByZXR1cm4gaW5wdXRCb3godCwgeyBmb3JtIH0pO1xuICAgIH1cbiAgICB2aXNpdFR1cGxlKHQsIGNvbXBvbmVudHMsIGQpIHtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHt9O1xuICAgICAgICBpZiAoY29tcG9uZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdwb3B1cC1mb3JtJyk7XG4gICAgICAgICAgICBjb25maWcgPSB7IGNvbnRhaW5lciB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvcm0gPSB0dXBsZUZvcm0oY29tcG9uZW50cywgY29uZmlnKTtcbiAgICAgICAgcmV0dXJuIGlucHV0Qm94KHQsIHsgZm9ybSB9KTtcbiAgICB9XG4gICAgdmlzaXRWYXJpYW50KHQsIGZpZWxkcywgZCkge1xuICAgICAgICBjb25zdCBzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB0eXBlXSBvZiBmaWVsZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbiA9IG5ldyBPcHRpb24oa2V5KTtcbiAgICAgICAgICAgIHNlbGVjdC5hZGQob3B0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxlY3Quc2VsZWN0ZWRJbmRleCA9IC0xO1xuICAgICAgICBzZWxlY3QuY2xhc3NMaXN0LmFkZCgnb3BlbicpO1xuICAgICAgICBjb25zdCBjb25maWcgPSB7IG9wZW46IHNlbGVjdCwgZXZlbnQ6ICdjaGFuZ2UnIH07XG4gICAgICAgIGNvbnN0IGZvcm0gPSB2YXJpYW50Rm9ybShmaWVsZHMsIGNvbmZpZyk7XG4gICAgICAgIHJldHVybiBpbnB1dEJveCh0LCB7IGZvcm0gfSk7XG4gICAgfVxuICAgIHZpc2l0T3B0KHQsIHR5LCBkKSB7XG4gICAgICAgIGNvbnN0IGNoZWNrYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgY2hlY2tib3gudHlwZSA9ICdjaGVja2JveCc7XG4gICAgICAgIGNoZWNrYm94LmNsYXNzTGlzdC5hZGQoJ29wZW4nKTtcbiAgICAgICAgY29uc3QgZm9ybSA9IG9wdEZvcm0odHksIHsgb3BlbjogY2hlY2tib3gsIGV2ZW50OiAnY2hhbmdlJyB9KTtcbiAgICAgICAgcmV0dXJuIGlucHV0Qm94KHQsIHsgZm9ybSB9KTtcbiAgICB9XG4gICAgdmlzaXRWZWModCwgdHksIGQpIHtcbiAgICAgICAgY29uc3QgbGVuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgbGVuLnR5cGUgPSAnbnVtYmVyJztcbiAgICAgICAgbGVuLm1pbiA9ICcwJztcbiAgICAgICAgbGVuLm1heCA9ICcxMDAnO1xuICAgICAgICBsZW4uc3R5bGUud2lkdGggPSAnOHJlbSc7XG4gICAgICAgIGxlbi5wbGFjZWhvbGRlciA9ICdsZW4nO1xuICAgICAgICBsZW4uY2xhc3NMaXN0LmFkZCgnb3BlbicpO1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3BvcHVwLWZvcm0nKTtcbiAgICAgICAgY29uc3QgZm9ybSA9IHZlY0Zvcm0odHksIHsgb3BlbjogbGVuLCBldmVudDogJ2NoYW5nZScsIGNvbnRhaW5lciB9KTtcbiAgICAgICAgcmV0dXJuIGlucHV0Qm94KHQsIHsgZm9ybSB9KTtcbiAgICB9XG4gICAgdmlzaXRSZWModCwgdHksIGQpIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlcklucHV0KHR5KTtcbiAgICB9XG59XG5jbGFzcyBQYXJzZSBleHRlbmRzIElETC5WaXNpdG9yIHtcbiAgICB2aXNpdE51bGwodCwgdikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmlzaXRCb29sKHQsIHYpIHtcbiAgICAgICAgaWYgKHYgPT09ICd0cnVlJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHYgPT09ICdmYWxzZScpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBwYXJzZSAke3Z9IGFzIGJvb2xlYW5gKTtcbiAgICB9XG4gICAgdmlzaXRUZXh0KHQsIHYpIHtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHZpc2l0RmxvYXQodCwgdikge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2KTtcbiAgICB9XG4gICAgdmlzaXRGaXhlZEludCh0LCB2KSB7XG4gICAgICAgIGlmICh0Ll9iaXRzIDw9IDMyKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodiwgMTApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aXNpdEZpeGVkTmF0KHQsIHYpIHtcbiAgICAgICAgaWYgKHQuX2JpdHMgPD0gMzIpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh2LCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KHYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpc2l0TnVtYmVyKHQsIHYpIHtcbiAgICAgICAgcmV0dXJuIEJpZ0ludCh2KTtcbiAgICB9XG4gICAgdmlzaXRQcmluY2lwYWwodCwgdikge1xuICAgICAgICByZXR1cm4gUHJpbmNpcGFsLmZyb21UZXh0KHYpO1xuICAgIH1cbiAgICB2aXNpdFNlcnZpY2UodCwgdikge1xuICAgICAgICByZXR1cm4gUHJpbmNpcGFsLmZyb21UZXh0KHYpO1xuICAgIH1cbiAgICB2aXNpdEZ1bmModCwgdikge1xuICAgICAgICBjb25zdCB4ID0gdi5zcGxpdCgnLicsIDIpO1xuICAgICAgICByZXR1cm4gW1ByaW5jaXBhbC5mcm9tVGV4dCh4WzBdKSwgeFsxXV07XG4gICAgfVxufVxuY2xhc3MgUmFuZG9tIGV4dGVuZHMgSURMLlZpc2l0b3Ige1xuICAgIHZpc2l0TnVsbCh0LCB2KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdEJvb2wodCwgdikge1xuICAgICAgICByZXR1cm4gTWF0aC5yYW5kb20oKSA8IDAuNTtcbiAgICB9XG4gICAgdmlzaXRUZXh0KHQsIHYpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg2KTtcbiAgICB9XG4gICAgdmlzaXRGbG9hdCh0LCB2KSB7XG4gICAgICAgIHJldHVybiBNYXRoLnJhbmRvbSgpO1xuICAgIH1cbiAgICB2aXNpdEludCh0LCB2KSB7XG4gICAgICAgIHJldHVybiBCaWdJbnQodGhpcy5nZW5lcmF0ZU51bWJlcih0cnVlKSk7XG4gICAgfVxuICAgIHZpc2l0TmF0KHQsIHYpIHtcbiAgICAgICAgcmV0dXJuIEJpZ0ludCh0aGlzLmdlbmVyYXRlTnVtYmVyKGZhbHNlKSk7XG4gICAgfVxuICAgIHZpc2l0Rml4ZWRJbnQodCwgdikge1xuICAgICAgICBjb25zdCB4ID0gdGhpcy5nZW5lcmF0ZU51bWJlcih0cnVlKTtcbiAgICAgICAgaWYgKHQuX2JpdHMgPD0gMzIpIHtcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aXNpdEZpeGVkTmF0KHQsIHYpIHtcbiAgICAgICAgY29uc3QgeCA9IHRoaXMuZ2VuZXJhdGVOdW1iZXIoZmFsc2UpO1xuICAgICAgICBpZiAodC5fYml0cyA8PSAzMikge1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KHYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdlbmVyYXRlTnVtYmVyKHNpZ25lZCkge1xuICAgICAgICBjb25zdCBudW0gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDApO1xuICAgICAgICBpZiAoc2lnbmVkICYmIE1hdGgucmFuZG9tKCkgPCAwLjUpIHtcbiAgICAgICAgICAgIHJldHVybiAtbnVtO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlUHJpbWl0aXZlKHQsIGNvbmZpZywgZCkge1xuICAgIGlmIChjb25maWcucmFuZG9tICYmIGQgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiB0LmFjY2VwdChuZXcgUmFuZG9tKCksIGQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHQuYWNjZXB0KG5ldyBQYXJzZSgpLCBkKTtcbiAgICB9XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gdCBhbiBJREwgdHlwZVxuICogQHJldHVybnMgYW4gaW5wdXQgZm9yIHRoYXQgdHlwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVySW5wdXQodCkge1xuICAgIHJldHVybiB0LmFjY2VwdChuZXcgUmVuZGVyKCksIG51bGwpO1xufVxuLyoqXG4gKlxuICogQHBhcmFtIHQgYW4gSURMIFR5cGVcbiAqIEBwYXJhbSBpbnB1dCBhbiBJbnB1dEJveFxuICogQHBhcmFtIHZhbHVlIGFueVxuICogQHJldHVybnMgcmVuZGVyaW5nIHRoYXQgdmFsdWUgdG8gdGhlIHByb3ZpZGVkIGlucHV0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJWYWx1ZSh0LCBpbnB1dCwgdmFsdWUpIHtcbiAgICByZXR1cm4gdC5hY2NlcHQobmV3IFJlbmRlclZhbHVlKCksIHsgaW5wdXQsIHZhbHVlIH0pO1xufVxuY2xhc3MgUmVuZGVyVmFsdWUgZXh0ZW5kcyBJREwuVmlzaXRvciB7XG4gICAgdmlzaXRUeXBlKHQsIGQpIHtcbiAgICAgICAgZC5pbnB1dC51aS5pbnB1dC52YWx1ZSA9IHQudmFsdWVUb1N0cmluZyhkLnZhbHVlKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuICAgIHZpc2l0TnVsbCh0LCBkKSB7IH1cbiAgICB2aXNpdFRleHQodCwgZCkge1xuICAgICAgICBkLmlucHV0LnVpLmlucHV0LnZhbHVlID0gZC52YWx1ZTtcbiAgICB9XG4gICAgdmlzaXRSZWModCwgdHksIGQpIHtcbiAgICAgICAgcmVuZGVyVmFsdWUodHksIGQuaW5wdXQsIGQudmFsdWUpO1xuICAgIH1cbiAgICB2aXNpdE9wdCh0LCB0eSwgZCkge1xuICAgICAgICBpZiAoZC52YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm0gPSBkLmlucHV0LnVpLmZvcm07XG4gICAgICAgICAgICBjb25zdCBvcGVuID0gZm9ybS51aS5vcGVuO1xuICAgICAgICAgICAgb3Blbi5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIG9wZW4uZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoZm9ybS51aS5ldmVudCkpO1xuICAgICAgICAgICAgcmVuZGVyVmFsdWUodHksIGZvcm0uZm9ybVswXSwgZC52YWx1ZVswXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlzaXRSZWNvcmQodCwgZmllbGRzLCBkKSB7XG4gICAgICAgIGNvbnN0IGZvcm0gPSBkLmlucHV0LnVpLmZvcm07XG4gICAgICAgIGZpZWxkcy5mb3JFYWNoKChba2V5LCB0eXBlXSwgaSkgPT4ge1xuICAgICAgICAgICAgcmVuZGVyVmFsdWUodHlwZSwgZm9ybS5mb3JtW2ldLCBkLnZhbHVlW2tleV0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmlzaXRUdXBsZSh0LCBjb21wb25lbnRzLCBkKSB7XG4gICAgICAgIGNvbnN0IGZvcm0gPSBkLmlucHV0LnVpLmZvcm07XG4gICAgICAgIGNvbXBvbmVudHMuZm9yRWFjaCgodHlwZSwgaSkgPT4ge1xuICAgICAgICAgICAgcmVuZGVyVmFsdWUodHlwZSwgZm9ybS5mb3JtW2ldLCBkLnZhbHVlW2ldKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZpc2l0VmFyaWFudCh0LCBmaWVsZHMsIGQpIHtcbiAgICAgICAgY29uc3QgZm9ybSA9IGQuaW5wdXQudWkuZm9ybTtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWQgPSBPYmplY3QuZW50cmllcyhkLnZhbHVlKVswXTtcbiAgICAgICAgZmllbGRzLmZvckVhY2goKFtrZXksIHR5cGVdLCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBzZWxlY3RlZFswXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wZW4gPSBmb3JtLnVpLm9wZW47XG4gICAgICAgICAgICAgICAgb3Blbi5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBvcGVuLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KGZvcm0udWkuZXZlbnQpKTtcbiAgICAgICAgICAgICAgICByZW5kZXJWYWx1ZSh0eXBlLCBmb3JtLmZvcm1bMF0sIHNlbGVjdGVkWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZpc2l0VmVjKHQsIHR5LCBkKSB7XG4gICAgICAgIGNvbnN0IGZvcm0gPSBkLmlucHV0LnVpLmZvcm07XG4gICAgICAgIGNvbnN0IGxlbiA9IGQudmFsdWUubGVuZ3RoO1xuICAgICAgICBjb25zdCBvcGVuID0gZm9ybS51aS5vcGVuO1xuICAgICAgICBvcGVuLnZhbHVlID0gbGVuO1xuICAgICAgICBvcGVuLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KGZvcm0udWkuZXZlbnQpKTtcbiAgICAgICAgZC52YWx1ZS5mb3JFYWNoKCh2LCBpKSA9PiB7XG4gICAgICAgICAgICByZW5kZXJWYWx1ZSh0eSwgZm9ybS5mb3JtW2ldLCB2KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FuZGlkLXVpLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/candid/lib/esm/candid-ui.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dfinity/candid/lib/esm/idl.js":
/*!*****************************************************!*\
  !*** ./node_modules/@dfinity/candid/lib/esm/idl.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Bool: function() { return /* binding */ Bool; },\n/* harmony export */   BoolClass: function() { return /* binding */ BoolClass; },\n/* harmony export */   ConstructType: function() { return /* binding */ ConstructType; },\n/* harmony export */   Empty: function() { return /* binding */ Empty; },\n/* harmony export */   EmptyClass: function() { return /* binding */ EmptyClass; },\n/* harmony export */   FixedIntClass: function() { return /* binding */ FixedIntClass; },\n/* harmony export */   FixedNatClass: function() { return /* binding */ FixedNatClass; },\n/* harmony export */   Float32: function() { return /* binding */ Float32; },\n/* harmony export */   Float64: function() { return /* binding */ Float64; },\n/* harmony export */   FloatClass: function() { return /* binding */ FloatClass; },\n/* harmony export */   Func: function() { return /* binding */ Func; },\n/* harmony export */   FuncClass: function() { return /* binding */ FuncClass; },\n/* harmony export */   Int: function() { return /* binding */ Int; },\n/* harmony export */   Int16: function() { return /* binding */ Int16; },\n/* harmony export */   Int32: function() { return /* binding */ Int32; },\n/* harmony export */   Int64: function() { return /* binding */ Int64; },\n/* harmony export */   Int8: function() { return /* binding */ Int8; },\n/* harmony export */   IntClass: function() { return /* binding */ IntClass; },\n/* harmony export */   Nat: function() { return /* binding */ Nat; },\n/* harmony export */   Nat16: function() { return /* binding */ Nat16; },\n/* harmony export */   Nat32: function() { return /* binding */ Nat32; },\n/* harmony export */   Nat64: function() { return /* binding */ Nat64; },\n/* harmony export */   Nat8: function() { return /* binding */ Nat8; },\n/* harmony export */   NatClass: function() { return /* binding */ NatClass; },\n/* harmony export */   Null: function() { return /* binding */ Null; },\n/* harmony export */   NullClass: function() { return /* binding */ NullClass; },\n/* harmony export */   Opt: function() { return /* binding */ Opt; },\n/* harmony export */   OptClass: function() { return /* binding */ OptClass; },\n/* harmony export */   PrimitiveType: function() { return /* binding */ PrimitiveType; },\n/* harmony export */   Principal: function() { return /* binding */ Principal; },\n/* harmony export */   PrincipalClass: function() { return /* binding */ PrincipalClass; },\n/* harmony export */   Rec: function() { return /* binding */ Rec; },\n/* harmony export */   RecClass: function() { return /* binding */ RecClass; },\n/* harmony export */   Record: function() { return /* binding */ Record; },\n/* harmony export */   RecordClass: function() { return /* binding */ RecordClass; },\n/* harmony export */   Reserved: function() { return /* binding */ Reserved; },\n/* harmony export */   ReservedClass: function() { return /* binding */ ReservedClass; },\n/* harmony export */   Service: function() { return /* binding */ Service; },\n/* harmony export */   ServiceClass: function() { return /* binding */ ServiceClass; },\n/* harmony export */   Text: function() { return /* binding */ Text; },\n/* harmony export */   TextClass: function() { return /* binding */ TextClass; },\n/* harmony export */   Tuple: function() { return /* binding */ Tuple; },\n/* harmony export */   TupleClass: function() { return /* binding */ TupleClass; },\n/* harmony export */   Type: function() { return /* binding */ Type; },\n/* harmony export */   Unknown: function() { return /* binding */ Unknown; },\n/* harmony export */   UnknownClass: function() { return /* binding */ UnknownClass; },\n/* harmony export */   Variant: function() { return /* binding */ Variant; },\n/* harmony export */   VariantClass: function() { return /* binding */ VariantClass; },\n/* harmony export */   Vec: function() { return /* binding */ Vec; },\n/* harmony export */   VecClass: function() { return /* binding */ VecClass; },\n/* harmony export */   Visitor: function() { return /* binding */ Visitor; },\n/* harmony export */   decode: function() { return /* binding */ decode; },\n/* harmony export */   encode: function() { return /* binding */ encode; }\n/* harmony export */ });\n/* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/principal */ \"(app-pages-browser)/./node_modules/@dfinity/principal/lib/esm/index.js\");\n/* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/buffer */ \"(app-pages-browser)/./node_modules/@dfinity/candid/lib/esm/utils/buffer.js\");\n/* harmony import */ var _utils_hash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/hash */ \"(app-pages-browser)/./node_modules/@dfinity/candid/lib/esm/utils/hash.js\");\n/* harmony import */ var _utils_leb128__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/leb128 */ \"(app-pages-browser)/./node_modules/@dfinity/candid/lib/esm/utils/leb128.js\");\n/* harmony import */ var _utils_bigint_math__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/bigint-math */ \"(app-pages-browser)/./node_modules/@dfinity/candid/lib/esm/utils/bigint-math.js\");\n/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n\n\n\n\nconst magicNumber = 'DIDL';\nconst toReadableString_max = 400; // will not display arguments after 400chars. Makes sure 2mb blobs don't get inside the error\nfunction zipWith(xs, ys, f) {\n    return xs.map((x, i) => f(x, ys[i]));\n}\n/**\n * An IDL Type Table, which precedes the data in the stream.\n */\nclass TypeTable {\n    constructor() {\n        // List of types. Needs to be an array as the index needs to be stable.\n        this._typs = [];\n        this._idx = new Map();\n    }\n    has(obj) {\n        return this._idx.has(obj.name);\n    }\n    add(type, buf) {\n        const idx = this._typs.length;\n        this._idx.set(type.name, idx);\n        this._typs.push(buf);\n    }\n    merge(obj, knot) {\n        const idx = this._idx.get(obj.name);\n        const knotIdx = this._idx.get(knot);\n        if (idx === undefined) {\n            throw new Error('Missing type index for ' + obj);\n        }\n        if (knotIdx === undefined) {\n            throw new Error('Missing type index for ' + knot);\n        }\n        this._typs[idx] = this._typs[knotIdx];\n        // Delete the type.\n        this._typs.splice(knotIdx, 1);\n        this._idx.delete(knot);\n    }\n    encode() {\n        const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(this._typs.length);\n        const buf = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(...this._typs);\n        return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(len, buf);\n    }\n    indexOf(typeName) {\n        if (!this._idx.has(typeName)) {\n            throw new Error('Missing type index for ' + typeName);\n        }\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(this._idx.get(typeName) || 0);\n    }\n}\nclass Visitor {\n    visitType(t, data) {\n        throw new Error('Not implemented');\n    }\n    visitPrimitive(t, data) {\n        return this.visitType(t, data);\n    }\n    visitEmpty(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitBool(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitNull(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitReserved(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitText(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitNumber(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitInt(t, data) {\n        return this.visitNumber(t, data);\n    }\n    visitNat(t, data) {\n        return this.visitNumber(t, data);\n    }\n    visitFloat(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitFixedInt(t, data) {\n        return this.visitNumber(t, data);\n    }\n    visitFixedNat(t, data) {\n        return this.visitNumber(t, data);\n    }\n    visitPrincipal(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitConstruct(t, data) {\n        return this.visitType(t, data);\n    }\n    visitVec(t, ty, data) {\n        return this.visitConstruct(t, data);\n    }\n    visitOpt(t, ty, data) {\n        return this.visitConstruct(t, data);\n    }\n    visitRecord(t, fields, data) {\n        return this.visitConstruct(t, data);\n    }\n    visitTuple(t, components, data) {\n        const fields = components.map((ty, i) => [`_${i}_`, ty]);\n        return this.visitRecord(t, fields, data);\n    }\n    visitVariant(t, fields, data) {\n        return this.visitConstruct(t, data);\n    }\n    visitRec(t, ty, data) {\n        return this.visitConstruct(ty, data);\n    }\n    visitFunc(t, data) {\n        return this.visitConstruct(t, data);\n    }\n    visitService(t, data) {\n        return this.visitConstruct(t, data);\n    }\n}\n/**\n * Represents an IDL type.\n */\nclass Type {\n    /* Display type name */\n    display() {\n        return this.name;\n    }\n    valueToString(x) {\n        return toReadableString(x);\n    }\n    /* Implement `T` in the IDL spec, only needed for non-primitive types */\n    buildTypeTable(typeTable) {\n        if (!typeTable.has(this)) {\n            this._buildTypeTableImpl(typeTable);\n        }\n    }\n}\nclass PrimitiveType extends Type {\n    checkType(t) {\n        if (this.name !== t.name) {\n            throw new Error(`type mismatch: type on the wire ${t.name}, expect type ${this.name}`);\n        }\n        return t;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _buildTypeTableImpl(typeTable) {\n        // No type table encoding for Primitive types.\n        return;\n    }\n}\nclass ConstructType extends Type {\n    checkType(t) {\n        if (t instanceof RecClass) {\n            const ty = t.getType();\n            if (typeof ty === 'undefined') {\n                throw new Error('type mismatch with uninitialized type');\n            }\n            return ty;\n        }\n        throw new Error(`type mismatch: type on the wire ${t.name}, expect type ${this.name}`);\n    }\n    encodeType(typeTable) {\n        return typeTable.indexOf(this.name);\n    }\n}\n/**\n * Represents an IDL Empty, a type which has no inhabitants.\n * Since no values exist for this type, it cannot be serialised or deserialised.\n * Result types like `Result<Text, Empty>` should always succeed.\n */\nclass EmptyClass extends PrimitiveType {\n    accept(v, d) {\n        return v.visitEmpty(this, d);\n    }\n    covariant(x) {\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue() {\n        throw new Error('Empty cannot appear as a function argument');\n    }\n    valueToString() {\n        throw new Error('Empty cannot appear as a value');\n    }\n    encodeType() {\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-17 /* IDLTypeIds.Empty */);\n    }\n    decodeValue() {\n        throw new Error('Empty cannot appear as an output');\n    }\n    get name() {\n        return 'empty';\n    }\n}\n/**\n * Represents an IDL Unknown, a placeholder type for deserialization only.\n * When decoding a value as Unknown, all fields will be retained but the names are only available in\n * hashed form.\n * A deserialized unknown will offer it's actual type by calling the `type()` function.\n * Unknown cannot be serialized and attempting to do so will throw an error.\n */\nclass UnknownClass extends Type {\n    checkType(t) {\n        throw new Error('Method not implemented for unknown.');\n    }\n    accept(v, d) {\n        throw v.visitType(this, d);\n    }\n    covariant(x) {\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue() {\n        throw new Error('Unknown cannot appear as a function argument');\n    }\n    valueToString() {\n        throw new Error('Unknown cannot appear as a value');\n    }\n    encodeType() {\n        throw new Error('Unknown cannot be serialized');\n    }\n    decodeValue(b, t) {\n        let decodedValue = t.decodeValue(b, t);\n        if (Object(decodedValue) !== decodedValue) {\n            // decodedValue is primitive. Box it, otherwise we cannot add the type() function.\n            // The type() function is important for primitives because otherwise we cannot tell apart the\n            // different number types.\n            decodedValue = Object(decodedValue);\n        }\n        let typeFunc;\n        if (t instanceof RecClass) {\n            typeFunc = () => t.getType();\n        }\n        else {\n            typeFunc = () => t;\n        }\n        // Do not use 'decodedValue.type = typeFunc' because this would lead to an enumerable property\n        // 'type' which means it would be serialized if the value would be candid encoded again.\n        // This in turn leads to problems if the decoded value is a variant because these values are\n        // only allowed to have a single property.\n        Object.defineProperty(decodedValue, 'type', {\n            value: typeFunc,\n            writable: true,\n            enumerable: false,\n            configurable: true,\n        });\n        return decodedValue;\n    }\n    _buildTypeTableImpl() {\n        throw new Error('Unknown cannot be serialized');\n    }\n    get name() {\n        return 'Unknown';\n    }\n}\n/**\n * Represents an IDL Bool\n */\nclass BoolClass extends PrimitiveType {\n    accept(v, d) {\n        return v.visitBool(this, d);\n    }\n    covariant(x) {\n        if (typeof x === 'boolean')\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        return new Uint8Array([x ? 1 : 0]);\n    }\n    encodeType() {\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-2 /* IDLTypeIds.Bool */);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        switch ((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.safeReadUint8)(b)) {\n            case 0:\n                return false;\n            case 1:\n                return true;\n            default:\n                throw new Error('Boolean value out of range');\n        }\n    }\n    get name() {\n        return 'bool';\n    }\n}\n/**\n * Represents an IDL Null\n */\nclass NullClass extends PrimitiveType {\n    accept(v, d) {\n        return v.visitNull(this, d);\n    }\n    covariant(x) {\n        if (x === null)\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue() {\n        return new ArrayBuffer(0);\n    }\n    encodeType() {\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-1 /* IDLTypeIds.Null */);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        return null;\n    }\n    get name() {\n        return 'null';\n    }\n}\n/**\n * Represents an IDL Reserved\n */\nclass ReservedClass extends PrimitiveType {\n    accept(v, d) {\n        return v.visitReserved(this, d);\n    }\n    covariant(x) {\n        return true;\n    }\n    encodeValue() {\n        return new ArrayBuffer(0);\n    }\n    encodeType() {\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-16 /* IDLTypeIds.Reserved */);\n    }\n    decodeValue(b, t) {\n        if (t.name !== this.name) {\n            t.decodeValue(b, t);\n        }\n        return null;\n    }\n    get name() {\n        return 'reserved';\n    }\n}\n/**\n * Represents an IDL Text\n */\nclass TextClass extends PrimitiveType {\n    accept(v, d) {\n        return v.visitText(this, d);\n    }\n    covariant(x) {\n        if (typeof x === 'string')\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        const buf = new TextEncoder().encode(x);\n        const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(buf.byteLength);\n        return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(len, buf);\n    }\n    encodeType() {\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-15 /* IDLTypeIds.Text */);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(b);\n        const buf = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.safeRead)(b, Number(len));\n        const decoder = new TextDecoder('utf8', { fatal: true });\n        return decoder.decode(buf);\n    }\n    get name() {\n        return 'text';\n    }\n    valueToString(x) {\n        return '\"' + x + '\"';\n    }\n}\n/**\n * Represents an IDL Int\n */\nclass IntClass extends PrimitiveType {\n    accept(v, d) {\n        return v.visitInt(this, d);\n    }\n    covariant(x) {\n        // We allow encoding of JavaScript plain numbers.\n        // But we will always decode to bigint.\n        if (typeof x === 'bigint' || Number.isInteger(x))\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(x);\n    }\n    encodeType() {\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-4 /* IDLTypeIds.Int */);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebDecode)(b);\n    }\n    get name() {\n        return 'int';\n    }\n    valueToString(x) {\n        return x.toString();\n    }\n}\n/**\n * Represents an IDL Nat\n */\nclass NatClass extends PrimitiveType {\n    accept(v, d) {\n        return v.visitNat(this, d);\n    }\n    covariant(x) {\n        // We allow encoding of JavaScript plain numbers.\n        // But we will always decode to bigint.\n        if ((typeof x === 'bigint' && x >= BigInt(0)) || (Number.isInteger(x) && x >= 0))\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(x);\n    }\n    encodeType() {\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-3 /* IDLTypeIds.Nat */);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(b);\n    }\n    get name() {\n        return 'nat';\n    }\n    valueToString(x) {\n        return x.toString();\n    }\n}\n/**\n * Represents an IDL Float\n */\nclass FloatClass extends PrimitiveType {\n    constructor(_bits) {\n        super();\n        this._bits = _bits;\n        if (_bits !== 32 && _bits !== 64) {\n            throw new Error('not a valid float type');\n        }\n    }\n    accept(v, d) {\n        return v.visitFloat(this, d);\n    }\n    covariant(x) {\n        if (typeof x === 'number' || x instanceof Number)\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        const buf = new ArrayBuffer(this._bits / 8);\n        const view = new DataView(buf);\n        if (this._bits === 32) {\n            view.setFloat32(0, x, true);\n        }\n        else {\n            view.setFloat64(0, x, true);\n        }\n        return buf;\n    }\n    encodeType() {\n        const opcode = this._bits === 32 ? -13 /* IDLTypeIds.Float32 */ : -14 /* IDLTypeIds.Float64 */;\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(opcode);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        const bytes = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.safeRead)(b, this._bits / 8);\n        const view = new DataView(bytes);\n        if (this._bits === 32) {\n            return view.getFloat32(0, true);\n        }\n        else {\n            return view.getFloat64(0, true);\n        }\n    }\n    get name() {\n        return 'float' + this._bits;\n    }\n    valueToString(x) {\n        return x.toString();\n    }\n}\n/**\n * Represents an IDL fixed-width Int(n)\n */\nclass FixedIntClass extends PrimitiveType {\n    constructor(_bits) {\n        super();\n        this._bits = _bits;\n    }\n    accept(v, d) {\n        return v.visitFixedInt(this, d);\n    }\n    covariant(x) {\n        const min = (0,_utils_bigint_math__WEBPACK_IMPORTED_MODULE_4__.iexp2)(this._bits - 1) * BigInt(-1);\n        const max = (0,_utils_bigint_math__WEBPACK_IMPORTED_MODULE_4__.iexp2)(this._bits - 1) - BigInt(1);\n        let ok = false;\n        if (typeof x === 'bigint') {\n            ok = x >= min && x <= max;\n        }\n        else if (Number.isInteger(x)) {\n            const v = BigInt(x);\n            ok = v >= min && v <= max;\n        }\n        else {\n            ok = false;\n        }\n        if (ok)\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.writeIntLE)(x, this._bits / 8);\n    }\n    encodeType() {\n        const offset = Math.log2(this._bits) - 3;\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-9 - offset);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        const num = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.readIntLE)(b, this._bits / 8);\n        if (this._bits <= 32) {\n            return Number(num);\n        }\n        else {\n            return num;\n        }\n    }\n    get name() {\n        return `int${this._bits}`;\n    }\n    valueToString(x) {\n        return x.toString();\n    }\n}\n/**\n * Represents an IDL fixed-width Nat(n)\n */\nclass FixedNatClass extends PrimitiveType {\n    constructor(_bits) {\n        super();\n        this._bits = _bits;\n    }\n    accept(v, d) {\n        return v.visitFixedNat(this, d);\n    }\n    covariant(x) {\n        const max = (0,_utils_bigint_math__WEBPACK_IMPORTED_MODULE_4__.iexp2)(this._bits);\n        let ok = false;\n        if (typeof x === 'bigint' && x >= BigInt(0)) {\n            ok = x < max;\n        }\n        else if (Number.isInteger(x) && x >= 0) {\n            const v = BigInt(x);\n            ok = v < max;\n        }\n        else {\n            ok = false;\n        }\n        if (ok)\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.writeUIntLE)(x, this._bits / 8);\n    }\n    encodeType() {\n        const offset = Math.log2(this._bits) - 3;\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-5 - offset);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        const num = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.readUIntLE)(b, this._bits / 8);\n        if (this._bits <= 32) {\n            return Number(num);\n        }\n        else {\n            return num;\n        }\n    }\n    get name() {\n        return `nat${this._bits}`;\n    }\n    valueToString(x) {\n        return x.toString();\n    }\n}\n/**\n * Represents an IDL Array\n *\n * Arrays of fixed-sized nat/int type (e.g. nat8), are encoded from and decoded to TypedArrays (e.g. Uint8Array).\n * Arrays of float or other non-primitive types are encoded/decoded as untyped array in Javascript.\n * @param {Type} t\n */\nclass VecClass extends ConstructType {\n    constructor(_type) {\n        super();\n        this._type = _type;\n        // If true, this vector is really a blob and we can just use memcpy.\n        //\n        // NOTE:\n        // With support of encoding/dencoding of TypedArrays, this optimization is\n        // only used when plain array of bytes are passed as encoding input in order\n        // to be backward compatible.\n        this._blobOptimization = false;\n        if (_type instanceof FixedNatClass && _type._bits === 8) {\n            this._blobOptimization = true;\n        }\n    }\n    accept(v, d) {\n        return v.visitVec(this, this._type, d);\n    }\n    covariant(x) {\n        // Special case for ArrayBuffer\n        const bits = this._type instanceof FixedNatClass\n            ? this._type._bits\n            : this._type instanceof FixedIntClass\n                ? this._type._bits\n                : 0;\n        if ((ArrayBuffer.isView(x) && bits == x.BYTES_PER_ELEMENT * 8) ||\n            (Array.isArray(x) &&\n                x.every((v, idx) => {\n                    try {\n                        return this._type.covariant(v);\n                    }\n                    catch (e) {\n                        throw new Error(`Invalid ${this.display()} argument: \\n\\nindex ${idx} -> ${e.message}`);\n                    }\n                })))\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(x.length);\n        if (this._blobOptimization) {\n            return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(len, new Uint8Array(x));\n        }\n        if (ArrayBuffer.isView(x)) {\n            return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(len, new Uint8Array(x.buffer));\n        }\n        const buf = new _utils_buffer__WEBPACK_IMPORTED_MODULE_1__.PipeArrayBuffer(new ArrayBuffer(len.byteLength + x.length), 0);\n        buf.write(len);\n        for (const d of x) {\n            const encoded = this._type.encodeValue(d);\n            buf.write(new Uint8Array(encoded));\n        }\n        return buf.buffer;\n    }\n    _buildTypeTableImpl(typeTable) {\n        this._type.buildTypeTable(typeTable);\n        const opCode = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-19 /* IDLTypeIds.Vector */);\n        const buffer = this._type.encodeType(typeTable);\n        typeTable.add(this, (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(opCode, buffer));\n    }\n    decodeValue(b, t) {\n        const vec = this.checkType(t);\n        if (!(vec instanceof VecClass)) {\n            throw new Error('Not a vector type');\n        }\n        const len = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(b));\n        if (this._type instanceof FixedNatClass) {\n            if (this._type._bits == 8) {\n                return new Uint8Array(b.read(len));\n            }\n            if (this._type._bits == 16) {\n                return new Uint16Array(b.read(len * 2));\n            }\n            if (this._type._bits == 32) {\n                return new Uint32Array(b.read(len * 4));\n            }\n            if (this._type._bits == 64) {\n                return new BigUint64Array(b.read(len * 8));\n            }\n        }\n        if (this._type instanceof FixedIntClass) {\n            if (this._type._bits == 8) {\n                return new Int8Array(b.read(len));\n            }\n            if (this._type._bits == 16) {\n                return new Int16Array(b.read(len * 2));\n            }\n            if (this._type._bits == 32) {\n                return new Int32Array(b.read(len * 4));\n            }\n            if (this._type._bits == 64) {\n                return new BigInt64Array(b.read(len * 8));\n            }\n        }\n        const rets = [];\n        for (let i = 0; i < len; i++) {\n            rets.push(this._type.decodeValue(b, vec._type));\n        }\n        return rets;\n    }\n    get name() {\n        return `vec ${this._type.name}`;\n    }\n    display() {\n        return `vec ${this._type.display()}`;\n    }\n    valueToString(x) {\n        const elements = x.map(e => this._type.valueToString(e));\n        return 'vec {' + elements.join('; ') + '}';\n    }\n}\n/**\n * Represents an IDL Option\n * @param {Type} t\n */\nclass OptClass extends ConstructType {\n    constructor(_type) {\n        super();\n        this._type = _type;\n    }\n    accept(v, d) {\n        return v.visitOpt(this, this._type, d);\n    }\n    covariant(x) {\n        try {\n            if (Array.isArray(x) && (x.length === 0 || (x.length === 1 && this._type.covariant(x[0]))))\n                return true;\n        }\n        catch (e) {\n            throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)} \\n\\n-> ${e.message}`);\n        }\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        if (x.length === 0) {\n            return new Uint8Array([0]);\n        }\n        else {\n            return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(new Uint8Array([1]), this._type.encodeValue(x[0]));\n        }\n    }\n    _buildTypeTableImpl(typeTable) {\n        this._type.buildTypeTable(typeTable);\n        const opCode = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-18 /* IDLTypeIds.Opt */);\n        const buffer = this._type.encodeType(typeTable);\n        typeTable.add(this, (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(opCode, buffer));\n    }\n    decodeValue(b, t) {\n        const opt = this.checkType(t);\n        if (!(opt instanceof OptClass)) {\n            throw new Error('Not an option type');\n        }\n        switch ((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.safeReadUint8)(b)) {\n            case 0:\n                return [];\n            case 1:\n                return [this._type.decodeValue(b, opt._type)];\n            default:\n                throw new Error('Not an option value');\n        }\n    }\n    get name() {\n        return `opt ${this._type.name}`;\n    }\n    display() {\n        return `opt ${this._type.display()}`;\n    }\n    valueToString(x) {\n        if (x.length === 0) {\n            return 'null';\n        }\n        else {\n            return `opt ${this._type.valueToString(x[0])}`;\n        }\n    }\n}\n/**\n * Represents an IDL Record\n * @param {object} [fields] - mapping of function name to Type\n */\nclass RecordClass extends ConstructType {\n    constructor(fields = {}) {\n        super();\n        this._fields = Object.entries(fields).sort((a, b) => (0,_utils_hash__WEBPACK_IMPORTED_MODULE_2__.idlLabelToId)(a[0]) - (0,_utils_hash__WEBPACK_IMPORTED_MODULE_2__.idlLabelToId)(b[0]));\n    }\n    accept(v, d) {\n        return v.visitRecord(this, this._fields, d);\n    }\n    tryAsTuple() {\n        const res = [];\n        for (let i = 0; i < this._fields.length; i++) {\n            const [key, type] = this._fields[i];\n            if (key !== `_${i}_`) {\n                return null;\n            }\n            res.push(type);\n        }\n        return res;\n    }\n    covariant(x) {\n        if (typeof x === 'object' &&\n            this._fields.every(([k, t]) => {\n                // eslint-disable-next-line\n                if (!x.hasOwnProperty(k)) {\n                    throw new Error(`Record is missing key \"${k}\".`);\n                }\n                try {\n                    return t.covariant(x[k]);\n                }\n                catch (e) {\n                    throw new Error(`Invalid ${this.display()} argument: \\n\\nfield ${k} -> ${e.message}`);\n                }\n            }))\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        const values = this._fields.map(([key]) => x[key]);\n        const bufs = zipWith(this._fields, values, ([, c], d) => c.encodeValue(d));\n        return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(...bufs);\n    }\n    _buildTypeTableImpl(T) {\n        this._fields.forEach(([_, value]) => value.buildTypeTable(T));\n        const opCode = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-20 /* IDLTypeIds.Record */);\n        const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(this._fields.length);\n        const fields = this._fields.map(([key, value]) => (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)((0,_utils_hash__WEBPACK_IMPORTED_MODULE_2__.idlLabelToId)(key)), value.encodeType(T)));\n        T.add(this, (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(opCode, len, (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(...fields)));\n    }\n    decodeValue(b, t) {\n        const record = this.checkType(t);\n        if (!(record instanceof RecordClass)) {\n            throw new Error('Not a record type');\n        }\n        const x = {};\n        let expectedRecordIdx = 0;\n        let actualRecordIdx = 0;\n        while (actualRecordIdx < record._fields.length) {\n            const [hash, type] = record._fields[actualRecordIdx];\n            if (expectedRecordIdx >= this._fields.length) {\n                // skip unexpected left over fields present on the wire\n                type.decodeValue(b, type);\n                actualRecordIdx++;\n                continue;\n            }\n            const [expectKey, expectType] = this._fields[expectedRecordIdx];\n            const expectedId = (0,_utils_hash__WEBPACK_IMPORTED_MODULE_2__.idlLabelToId)(this._fields[expectedRecordIdx][0]);\n            const actualId = (0,_utils_hash__WEBPACK_IMPORTED_MODULE_2__.idlLabelToId)(hash);\n            if (expectedId === actualId) {\n                // the current field on the wire matches the expected field\n                x[expectKey] = expectType.decodeValue(b, type);\n                expectedRecordIdx++;\n                actualRecordIdx++;\n            }\n            else if (actualId > expectedId) {\n                // The expected field does not exist on the wire\n                if (expectType instanceof OptClass || expectType instanceof ReservedClass) {\n                    x[expectKey] = [];\n                    expectedRecordIdx++;\n                }\n                else {\n                    throw new Error('Cannot find required field ' + expectKey);\n                }\n            }\n            else {\n                // The field on the wire does not exist in the output type, so we can skip it\n                type.decodeValue(b, type);\n                actualRecordIdx++;\n            }\n        }\n        // initialize left over expected optional fields\n        for (const [expectKey, expectType] of this._fields.slice(expectedRecordIdx)) {\n            if (expectType instanceof OptClass || expectType instanceof ReservedClass) {\n                // TODO this assumes null value in opt is represented as []\n                x[expectKey] = [];\n            }\n            else {\n                throw new Error('Cannot find required field ' + expectKey);\n            }\n        }\n        return x;\n    }\n    get name() {\n        const fields = this._fields.map(([key, value]) => key + ':' + value.name);\n        return `record {${fields.join('; ')}}`;\n    }\n    display() {\n        const fields = this._fields.map(([key, value]) => key + ':' + value.display());\n        return `record {${fields.join('; ')}}`;\n    }\n    valueToString(x) {\n        const values = this._fields.map(([key]) => x[key]);\n        const fields = zipWith(this._fields, values, ([k, c], d) => k + '=' + c.valueToString(d));\n        return `record {${fields.join('; ')}}`;\n    }\n}\n/**\n * Represents Tuple, a syntactic sugar for Record.\n * @param {Type} components\n */\nclass TupleClass extends RecordClass {\n    constructor(_components) {\n        const x = {};\n        _components.forEach((e, i) => (x['_' + i + '_'] = e));\n        super(x);\n        this._components = _components;\n    }\n    accept(v, d) {\n        return v.visitTuple(this, this._components, d);\n    }\n    covariant(x) {\n        // `>=` because tuples can be covariant when encoded.\n        if (Array.isArray(x) &&\n            x.length >= this._fields.length &&\n            this._components.every((t, i) => {\n                try {\n                    return t.covariant(x[i]);\n                }\n                catch (e) {\n                    throw new Error(`Invalid ${this.display()} argument: \\n\\nindex ${i} -> ${e.message}`);\n                }\n            }))\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        const bufs = zipWith(this._components, x, (c, d) => c.encodeValue(d));\n        return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(...bufs);\n    }\n    decodeValue(b, t) {\n        const tuple = this.checkType(t);\n        if (!(tuple instanceof TupleClass)) {\n            throw new Error('not a tuple type');\n        }\n        if (tuple._components.length < this._components.length) {\n            throw new Error('tuple mismatch');\n        }\n        const res = [];\n        for (const [i, wireType] of tuple._components.entries()) {\n            if (i >= this._components.length) {\n                // skip value\n                wireType.decodeValue(b, wireType);\n            }\n            else {\n                res.push(this._components[i].decodeValue(b, wireType));\n            }\n        }\n        return res;\n    }\n    display() {\n        const fields = this._components.map(value => value.display());\n        return `record {${fields.join('; ')}}`;\n    }\n    valueToString(values) {\n        const fields = zipWith(this._components, values, (c, d) => c.valueToString(d));\n        return `record {${fields.join('; ')}}`;\n    }\n}\n/**\n * Represents an IDL Variant\n * @param {object} [fields] - mapping of function name to Type\n */\nclass VariantClass extends ConstructType {\n    constructor(fields = {}) {\n        super();\n        this._fields = Object.entries(fields).sort((a, b) => (0,_utils_hash__WEBPACK_IMPORTED_MODULE_2__.idlLabelToId)(a[0]) - (0,_utils_hash__WEBPACK_IMPORTED_MODULE_2__.idlLabelToId)(b[0]));\n    }\n    accept(v, d) {\n        return v.visitVariant(this, this._fields, d);\n    }\n    covariant(x) {\n        if (typeof x === 'object' &&\n            Object.entries(x).length === 1 &&\n            this._fields.every(([k, v]) => {\n                try {\n                    // eslint-disable-next-line\n                    return !x.hasOwnProperty(k) || v.covariant(x[k]);\n                }\n                catch (e) {\n                    throw new Error(`Invalid ${this.display()} argument: \\n\\nvariant ${k} -> ${e.message}`);\n                }\n            }))\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        for (let i = 0; i < this._fields.length; i++) {\n            const [name, type] = this._fields[i];\n            // eslint-disable-next-line\n            if (x.hasOwnProperty(name)) {\n                const idx = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(i);\n                const buf = type.encodeValue(x[name]);\n                return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(idx, buf);\n            }\n        }\n        throw Error('Variant has no data: ' + x);\n    }\n    _buildTypeTableImpl(typeTable) {\n        this._fields.forEach(([, type]) => {\n            type.buildTypeTable(typeTable);\n        });\n        const opCode = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-21 /* IDLTypeIds.Variant */);\n        const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(this._fields.length);\n        const fields = this._fields.map(([key, value]) => (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)((0,_utils_hash__WEBPACK_IMPORTED_MODULE_2__.idlLabelToId)(key)), value.encodeType(typeTable)));\n        typeTable.add(this, (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(opCode, len, ...fields));\n    }\n    decodeValue(b, t) {\n        const variant = this.checkType(t);\n        if (!(variant instanceof VariantClass)) {\n            throw new Error('Not a variant type');\n        }\n        const idx = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(b));\n        if (idx >= variant._fields.length) {\n            throw Error('Invalid variant index: ' + idx);\n        }\n        const [wireHash, wireType] = variant._fields[idx];\n        for (const [key, expectType] of this._fields) {\n            if ((0,_utils_hash__WEBPACK_IMPORTED_MODULE_2__.idlLabelToId)(wireHash) === (0,_utils_hash__WEBPACK_IMPORTED_MODULE_2__.idlLabelToId)(key)) {\n                const value = expectType.decodeValue(b, wireType);\n                return { [key]: value };\n            }\n        }\n        throw new Error('Cannot find field hash ' + wireHash);\n    }\n    get name() {\n        const fields = this._fields.map(([key, type]) => key + ':' + type.name);\n        return `variant {${fields.join('; ')}}`;\n    }\n    display() {\n        const fields = this._fields.map(([key, type]) => key + (type.name === 'null' ? '' : `:${type.display()}`));\n        return `variant {${fields.join('; ')}}`;\n    }\n    valueToString(x) {\n        for (const [name, type] of this._fields) {\n            // eslint-disable-next-line\n            if (x.hasOwnProperty(name)) {\n                const value = type.valueToString(x[name]);\n                if (value === 'null') {\n                    return `variant {${name}}`;\n                }\n                else {\n                    return `variant {${name}=${value}}`;\n                }\n            }\n        }\n        throw new Error('Variant has no data: ' + x);\n    }\n}\n/**\n * Represents a reference to an IDL type, used for defining recursive data\n * types.\n */\nclass RecClass extends ConstructType {\n    constructor() {\n        super(...arguments);\n        this._id = RecClass._counter++;\n        this._type = undefined;\n    }\n    accept(v, d) {\n        if (!this._type) {\n            throw Error('Recursive type uninitialized.');\n        }\n        return v.visitRec(this, this._type, d);\n    }\n    fill(t) {\n        this._type = t;\n    }\n    getType() {\n        return this._type;\n    }\n    covariant(x) {\n        if (this._type ? this._type.covariant(x) : false)\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        if (!this._type) {\n            throw Error('Recursive type uninitialized.');\n        }\n        return this._type.encodeValue(x);\n    }\n    _buildTypeTableImpl(typeTable) {\n        if (!this._type) {\n            throw Error('Recursive type uninitialized.');\n        }\n        typeTable.add(this, new Uint8Array([]));\n        this._type.buildTypeTable(typeTable);\n        typeTable.merge(this, this._type.name);\n    }\n    decodeValue(b, t) {\n        if (!this._type) {\n            throw Error('Recursive type uninitialized.');\n        }\n        return this._type.decodeValue(b, t);\n    }\n    get name() {\n        return `rec_${this._id}`;\n    }\n    display() {\n        if (!this._type) {\n            throw Error('Recursive type uninitialized.');\n        }\n        return `${this.name}.${this._type.name}`;\n    }\n    valueToString(x) {\n        if (!this._type) {\n            throw Error('Recursive type uninitialized.');\n        }\n        return this._type.valueToString(x);\n    }\n}\nRecClass._counter = 0;\nfunction decodePrincipalId(b) {\n    const x = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.safeReadUint8)(b);\n    if (x !== 1) {\n        throw new Error('Cannot decode principal');\n    }\n    const len = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(b));\n    return _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.fromUint8Array(new Uint8Array((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.safeRead)(b, len)));\n}\n/**\n * Represents an IDL principal reference\n */\nclass PrincipalClass extends PrimitiveType {\n    accept(v, d) {\n        return v.visitPrincipal(this, d);\n    }\n    covariant(x) {\n        if (x && x._isPrincipal)\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        const buf = x.toUint8Array();\n        const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(buf.byteLength);\n        return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(new Uint8Array([1]), len, buf);\n    }\n    encodeType() {\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-24 /* IDLTypeIds.Principal */);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        return decodePrincipalId(b);\n    }\n    get name() {\n        return 'principal';\n    }\n    valueToString(x) {\n        return `${this.name} \"${x.toText()}\"`;\n    }\n}\n/**\n * Represents an IDL function reference.\n * @param argTypes Argument types.\n * @param retTypes Return types.\n * @param annotations Function annotations.\n */\nclass FuncClass extends ConstructType {\n    constructor(argTypes, retTypes, annotations = []) {\n        super();\n        this.argTypes = argTypes;\n        this.retTypes = retTypes;\n        this.annotations = annotations;\n    }\n    static argsToString(types, v) {\n        if (types.length !== v.length) {\n            throw new Error('arity mismatch');\n        }\n        return '(' + types.map((t, i) => t.valueToString(v[i])).join(', ') + ')';\n    }\n    accept(v, d) {\n        return v.visitFunc(this, d);\n    }\n    covariant(x) {\n        if (Array.isArray(x) && x.length === 2 && x[0] && x[0]._isPrincipal && typeof x[1] === 'string')\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue([principal, methodName]) {\n        const buf = principal.toUint8Array();\n        const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(buf.byteLength);\n        const canister = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(new Uint8Array([1]), len, buf);\n        const method = new TextEncoder().encode(methodName);\n        const methodLen = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(method.byteLength);\n        return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(new Uint8Array([1]), canister, methodLen, method);\n    }\n    _buildTypeTableImpl(T) {\n        this.argTypes.forEach(arg => arg.buildTypeTable(T));\n        this.retTypes.forEach(arg => arg.buildTypeTable(T));\n        const opCode = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-22 /* IDLTypeIds.Func */);\n        const argLen = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(this.argTypes.length);\n        const args = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(...this.argTypes.map(arg => arg.encodeType(T)));\n        const retLen = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(this.retTypes.length);\n        const rets = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(...this.retTypes.map(arg => arg.encodeType(T)));\n        const annLen = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(this.annotations.length);\n        const anns = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(...this.annotations.map(a => this.encodeAnnotation(a)));\n        T.add(this, (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(opCode, argLen, args, retLen, rets, annLen, anns));\n    }\n    decodeValue(b) {\n        const x = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.safeReadUint8)(b);\n        if (x !== 1) {\n            throw new Error('Cannot decode function reference');\n        }\n        const canister = decodePrincipalId(b);\n        const mLen = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(b));\n        const buf = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.safeRead)(b, mLen);\n        const decoder = new TextDecoder('utf8', { fatal: true });\n        const method = decoder.decode(buf);\n        return [canister, method];\n    }\n    get name() {\n        const args = this.argTypes.map(arg => arg.name).join(', ');\n        const rets = this.retTypes.map(arg => arg.name).join(', ');\n        const annon = ' ' + this.annotations.join(' ');\n        return `(${args}) -> (${rets})${annon}`;\n    }\n    valueToString([principal, str]) {\n        return `func \"${principal.toText()}\".${str}`;\n    }\n    display() {\n        const args = this.argTypes.map(arg => arg.display()).join(', ');\n        const rets = this.retTypes.map(arg => arg.display()).join(', ');\n        const annon = ' ' + this.annotations.join(' ');\n        return `(${args})  (${rets})${annon}`;\n    }\n    encodeAnnotation(ann) {\n        if (ann === 'query') {\n            return new Uint8Array([1]);\n        }\n        else if (ann === 'oneway') {\n            return new Uint8Array([2]);\n        }\n        else if (ann === 'composite_query') {\n            return new Uint8Array([3]);\n        }\n        else {\n            throw new Error('Illegal function annotation');\n        }\n    }\n}\nclass ServiceClass extends ConstructType {\n    constructor(fields) {\n        super();\n        this._fields = Object.entries(fields).sort((a, b) => {\n            if (a[0] < b[0]) {\n                return -1;\n            }\n            if (a[0] > b[0]) {\n                return 1;\n            }\n            return 0;\n        });\n    }\n    accept(v, d) {\n        return v.visitService(this, d);\n    }\n    covariant(x) {\n        if (x && x._isPrincipal)\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        const buf = x.toUint8Array();\n        const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(buf.length);\n        return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(new Uint8Array([1]), len, buf);\n    }\n    _buildTypeTableImpl(T) {\n        this._fields.forEach(([_, func]) => func.buildTypeTable(T));\n        const opCode = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-23 /* IDLTypeIds.Service */);\n        const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(this._fields.length);\n        const meths = this._fields.map(([label, func]) => {\n            const labelBuf = new TextEncoder().encode(label);\n            const labelLen = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(labelBuf.length);\n            return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(labelLen, labelBuf, func.encodeType(T));\n        });\n        T.add(this, (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(opCode, len, ...meths));\n    }\n    decodeValue(b) {\n        return decodePrincipalId(b);\n    }\n    get name() {\n        const fields = this._fields.map(([key, value]) => key + ':' + value.name);\n        return `service {${fields.join('; ')}}`;\n    }\n    valueToString(x) {\n        return `service \"${x.toText()}\"`;\n    }\n}\n/**\n * Takes an unknown value and returns a string representation of it.\n * @param x - unknown value\n * @returns {string} string representation of the value\n */\nfunction toReadableString(x) {\n    const str = JSON.stringify(x, (_key, value) => typeof value === 'bigint' ? `BigInt(${value})` : value);\n    return str && str.length > toReadableString_max\n        ? str.substring(0, toReadableString_max - 3) + '...'\n        : str;\n}\n/**\n * Encode a array of values\n * @param argTypes - array of Types\n * @param args - array of values\n * @returns {ArrayBuffer} serialised value\n */\nfunction encode(argTypes, args) {\n    if (args.length < argTypes.length) {\n        throw Error('Wrong number of message arguments');\n    }\n    const typeTable = new TypeTable();\n    argTypes.forEach(t => t.buildTypeTable(typeTable));\n    const magic = new TextEncoder().encode(magicNumber);\n    const table = typeTable.encode();\n    const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(args.length);\n    const typs = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(...argTypes.map(t => t.encodeType(typeTable)));\n    const vals = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(...zipWith(argTypes, args, (t, x) => {\n        try {\n            t.covariant(x);\n        }\n        catch (e) {\n            const err = new Error(e.message + '\\n\\n');\n            throw err;\n        }\n        return t.encodeValue(x);\n    }));\n    return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(magic, table, len, typs, vals);\n}\n/**\n * Decode a binary value\n * @param retTypes - Types expected in the buffer.\n * @param bytes - hex-encoded string, or buffer.\n * @returns Value deserialised to JS type\n */\nfunction decode(retTypes, bytes) {\n    const b = new _utils_buffer__WEBPACK_IMPORTED_MODULE_1__.PipeArrayBuffer(bytes);\n    if (bytes.byteLength < magicNumber.length) {\n        throw new Error('Message length smaller than magic number');\n    }\n    const magicBuffer = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.safeRead)(b, magicNumber.length);\n    const magic = new TextDecoder().decode(magicBuffer);\n    if (magic !== magicNumber) {\n        throw new Error('Wrong magic number: ' + JSON.stringify(magic));\n    }\n    function readTypeTable(pipe) {\n        const typeTable = [];\n        const len = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(pipe));\n        for (let i = 0; i < len; i++) {\n            const ty = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebDecode)(pipe));\n            switch (ty) {\n                case -18 /* IDLTypeIds.Opt */:\n                case -19 /* IDLTypeIds.Vector */: {\n                    const t = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebDecode)(pipe));\n                    typeTable.push([ty, t]);\n                    break;\n                }\n                case -20 /* IDLTypeIds.Record */:\n                case -21 /* IDLTypeIds.Variant */: {\n                    const fields = [];\n                    let objectLength = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(pipe));\n                    let prevHash;\n                    while (objectLength--) {\n                        const hash = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(pipe));\n                        if (hash >= Math.pow(2, 32)) {\n                            throw new Error('field id out of 32-bit range');\n                        }\n                        if (typeof prevHash === 'number' && prevHash >= hash) {\n                            throw new Error('field id collision or not sorted');\n                        }\n                        prevHash = hash;\n                        const t = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebDecode)(pipe));\n                        fields.push([hash, t]);\n                    }\n                    typeTable.push([ty, fields]);\n                    break;\n                }\n                case -22 /* IDLTypeIds.Func */: {\n                    const args = [];\n                    let argLength = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(pipe));\n                    while (argLength--) {\n                        args.push(Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebDecode)(pipe)));\n                    }\n                    const returnValues = [];\n                    let returnValuesLength = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(pipe));\n                    while (returnValuesLength--) {\n                        returnValues.push(Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebDecode)(pipe)));\n                    }\n                    const annotations = [];\n                    let annotationLength = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(pipe));\n                    while (annotationLength--) {\n                        const annotation = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(pipe));\n                        switch (annotation) {\n                            case 1: {\n                                annotations.push('query');\n                                break;\n                            }\n                            case 2: {\n                                annotations.push('oneway');\n                                break;\n                            }\n                            case 3: {\n                                annotations.push('composite_query');\n                                break;\n                            }\n                            default:\n                                throw new Error('unknown annotation');\n                        }\n                    }\n                    typeTable.push([ty, [args, returnValues, annotations]]);\n                    break;\n                }\n                case -23 /* IDLTypeIds.Service */: {\n                    let servLength = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(pipe));\n                    const methods = [];\n                    while (servLength--) {\n                        const nameLength = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(pipe));\n                        const funcName = new TextDecoder().decode((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.safeRead)(pipe, nameLength));\n                        const funcType = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebDecode)(pipe);\n                        methods.push([funcName, funcType]);\n                    }\n                    typeTable.push([ty, methods]);\n                    break;\n                }\n                default:\n                    throw new Error('Illegal op_code: ' + ty);\n            }\n        }\n        const rawList = [];\n        const length = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(pipe));\n        for (let i = 0; i < length; i++) {\n            rawList.push(Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebDecode)(pipe)));\n        }\n        return [typeTable, rawList];\n    }\n    const [rawTable, rawTypes] = readTypeTable(b);\n    if (rawTypes.length < retTypes.length) {\n        throw new Error('Wrong number of return values');\n    }\n    const table = rawTable.map(_ => Rec());\n    function getType(t) {\n        if (t < -24) {\n            throw new Error('future value not supported');\n        }\n        if (t < 0) {\n            switch (t) {\n                case -1:\n                    return Null;\n                case -2:\n                    return Bool;\n                case -3:\n                    return Nat;\n                case -4:\n                    return Int;\n                case -5:\n                    return Nat8;\n                case -6:\n                    return Nat16;\n                case -7:\n                    return Nat32;\n                case -8:\n                    return Nat64;\n                case -9:\n                    return Int8;\n                case -10:\n                    return Int16;\n                case -11:\n                    return Int32;\n                case -12:\n                    return Int64;\n                case -13:\n                    return Float32;\n                case -14:\n                    return Float64;\n                case -15:\n                    return Text;\n                case -16:\n                    return Reserved;\n                case -17:\n                    return Empty;\n                case -24:\n                    return Principal;\n                default:\n                    throw new Error('Illegal op_code: ' + t);\n            }\n        }\n        if (t >= rawTable.length) {\n            throw new Error('type index out of range');\n        }\n        return table[t];\n    }\n    function buildType(entry) {\n        switch (entry[0]) {\n            case -19 /* IDLTypeIds.Vector */: {\n                const ty = getType(entry[1]);\n                return Vec(ty);\n            }\n            case -18 /* IDLTypeIds.Opt */: {\n                const ty = getType(entry[1]);\n                return Opt(ty);\n            }\n            case -20 /* IDLTypeIds.Record */: {\n                const fields = {};\n                for (const [hash, ty] of entry[1]) {\n                    const name = `_${hash}_`;\n                    fields[name] = getType(ty);\n                }\n                const record = Record(fields);\n                const tuple = record.tryAsTuple();\n                if (Array.isArray(tuple)) {\n                    return Tuple(...tuple);\n                }\n                else {\n                    return record;\n                }\n            }\n            case -21 /* IDLTypeIds.Variant */: {\n                const fields = {};\n                for (const [hash, ty] of entry[1]) {\n                    const name = `_${hash}_`;\n                    fields[name] = getType(ty);\n                }\n                return Variant(fields);\n            }\n            case -22 /* IDLTypeIds.Func */: {\n                const [args, returnValues, annotations] = entry[1];\n                return Func(args.map((t) => getType(t)), returnValues.map((t) => getType(t)), annotations);\n            }\n            case -23 /* IDLTypeIds.Service */: {\n                const rec = {};\n                const methods = entry[1];\n                for (const [name, typeRef] of methods) {\n                    let type = getType(typeRef);\n                    if (type instanceof RecClass) {\n                        // unpack reference type\n                        type = type.getType();\n                    }\n                    if (!(type instanceof FuncClass)) {\n                        throw new Error('Illegal service definition: services can only contain functions');\n                    }\n                    rec[name] = type;\n                }\n                return Service(rec);\n            }\n            default:\n                throw new Error('Illegal op_code: ' + entry[0]);\n        }\n    }\n    rawTable.forEach((entry, i) => {\n        // Process function type first, so that we can construct the correct service type\n        if (entry[0] === -22 /* IDLTypeIds.Func */) {\n            const t = buildType(entry);\n            table[i].fill(t);\n        }\n    });\n    rawTable.forEach((entry, i) => {\n        if (entry[0] !== -22 /* IDLTypeIds.Func */) {\n            const t = buildType(entry);\n            table[i].fill(t);\n        }\n    });\n    const types = rawTypes.map(t => getType(t));\n    const output = retTypes.map((t, i) => {\n        return t.decodeValue(b, types[i]);\n    });\n    // skip unused values\n    for (let ind = retTypes.length; ind < types.length; ind++) {\n        types[ind].decodeValue(b, types[ind]);\n    }\n    if (b.byteLength > 0) {\n        throw new Error('decode: Left-over bytes');\n    }\n    return output;\n}\n// Export Types instances.\nconst Empty = new EmptyClass();\nconst Reserved = new ReservedClass();\n/**\n * Client-only type for deserializing unknown data. Not supported by Candid, and its use is discouraged.\n */\nconst Unknown = new UnknownClass();\nconst Bool = new BoolClass();\nconst Null = new NullClass();\nconst Text = new TextClass();\nconst Int = new IntClass();\nconst Nat = new NatClass();\nconst Float32 = new FloatClass(32);\nconst Float64 = new FloatClass(64);\nconst Int8 = new FixedIntClass(8);\nconst Int16 = new FixedIntClass(16);\nconst Int32 = new FixedIntClass(32);\nconst Int64 = new FixedIntClass(64);\nconst Nat8 = new FixedNatClass(8);\nconst Nat16 = new FixedNatClass(16);\nconst Nat32 = new FixedNatClass(32);\nconst Nat64 = new FixedNatClass(64);\nconst Principal = new PrincipalClass();\n/**\n *\n * @param types array of any types\n * @returns TupleClass from those types\n */\nfunction Tuple(...types) {\n    return new TupleClass(types);\n}\n/**\n *\n * @param t IDL Type\n * @returns VecClass from that type\n */\nfunction Vec(t) {\n    return new VecClass(t);\n}\n/**\n *\n * @param t IDL Type\n * @returns OptClass of Type\n */\nfunction Opt(t) {\n    return new OptClass(t);\n}\n/**\n *\n * @param t Record of string and IDL Type\n * @returns RecordClass of string and Type\n */\nfunction Record(t) {\n    return new RecordClass(t);\n}\n/**\n *\n * @param fields Record of string and IDL Type\n * @returns VariantClass\n */\nfunction Variant(fields) {\n    return new VariantClass(fields);\n}\n/**\n *\n * @returns new RecClass\n */\nfunction Rec() {\n    return new RecClass();\n}\n/**\n *\n * @param args array of IDL Types\n * @param ret array of IDL Types\n * @param annotations array of strings, [] by default\n * @returns new FuncClass\n */\nfunction Func(args, ret, annotations = []) {\n    return new FuncClass(args, ret, annotations);\n}\n/**\n *\n * @param t Record of string and FuncClass\n * @returns ServiceClass\n */\nfunction Service(t) {\n    return new ServiceClass(t);\n}\n//# sourceMappingURL=idl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9jYW5kaWQvbGliL2VzbS9pZGwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDOEQ7QUFDRztBQUNyQjtBQUM0RztBQUM1RztBQUM1QztBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdEQUFTO0FBQzdCLG9CQUFvQixxREFBTTtBQUMxQixlQUFlLHFEQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlEQUFVO0FBQ3pCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELEVBQUU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxLQUFLO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsS0FBSztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG9DQUFvQyxvQkFBb0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9jYW5kaWQvbGliL2VzbS9pZGwuanM/MTZiOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi9cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmltcG9ydCB7IFByaW5jaXBhbCBhcyBQcmluY2lwYWxJZCB9IGZyb20gJ0BkZmluaXR5L3ByaW5jaXBhbCc7XG5pbXBvcnQgeyBjb25jYXQsIFBpcGVBcnJheUJ1ZmZlciBhcyBQaXBlIH0gZnJvbSAnLi91dGlscy9idWZmZXInO1xuaW1wb3J0IHsgaWRsTGFiZWxUb0lkIH0gZnJvbSAnLi91dGlscy9oYXNoJztcbmltcG9ydCB7IGxlYkRlY29kZSwgbGViRW5jb2RlLCByZWFkSW50TEUsIHJlYWRVSW50TEUsIHNhZmVSZWFkLCBzYWZlUmVhZFVpbnQ4LCBzbGViRGVjb2RlLCBzbGViRW5jb2RlLCB3cml0ZUludExFLCB3cml0ZVVJbnRMRSwgfSBmcm9tICcuL3V0aWxzL2xlYjEyOCc7XG5pbXBvcnQgeyBpZXhwMiB9IGZyb20gJy4vdXRpbHMvYmlnaW50LW1hdGgnO1xuY29uc3QgbWFnaWNOdW1iZXIgPSAnRElETCc7XG5jb25zdCB0b1JlYWRhYmxlU3RyaW5nX21heCA9IDQwMDsgLy8gd2lsbCBub3QgZGlzcGxheSBhcmd1bWVudHMgYWZ0ZXIgNDAwY2hhcnMuIE1ha2VzIHN1cmUgMm1iIGJsb2JzIGRvbid0IGdldCBpbnNpZGUgdGhlIGVycm9yXG5mdW5jdGlvbiB6aXBXaXRoKHhzLCB5cywgZikge1xuICAgIHJldHVybiB4cy5tYXAoKHgsIGkpID0+IGYoeCwgeXNbaV0pKTtcbn1cbi8qKlxuICogQW4gSURMIFR5cGUgVGFibGUsIHdoaWNoIHByZWNlZGVzIHRoZSBkYXRhIGluIHRoZSBzdHJlYW0uXG4gKi9cbmNsYXNzIFR5cGVUYWJsZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIExpc3Qgb2YgdHlwZXMuIE5lZWRzIHRvIGJlIGFuIGFycmF5IGFzIHRoZSBpbmRleCBuZWVkcyB0byBiZSBzdGFibGUuXG4gICAgICAgIHRoaXMuX3R5cHMgPSBbXTtcbiAgICAgICAgdGhpcy5faWR4ID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBoYXMob2JqKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pZHguaGFzKG9iai5uYW1lKTtcbiAgICB9XG4gICAgYWRkKHR5cGUsIGJ1Zikge1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLl90eXBzLmxlbmd0aDtcbiAgICAgICAgdGhpcy5faWR4LnNldCh0eXBlLm5hbWUsIGlkeCk7XG4gICAgICAgIHRoaXMuX3R5cHMucHVzaChidWYpO1xuICAgIH1cbiAgICBtZXJnZShvYmosIGtub3QpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5faWR4LmdldChvYmoubmFtZSk7XG4gICAgICAgIGNvbnN0IGtub3RJZHggPSB0aGlzLl9pZHguZ2V0KGtub3QpO1xuICAgICAgICBpZiAoaWR4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyB0eXBlIGluZGV4IGZvciAnICsgb2JqKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa25vdElkeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgdHlwZSBpbmRleCBmb3IgJyArIGtub3QpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3R5cHNbaWR4XSA9IHRoaXMuX3R5cHNba25vdElkeF07XG4gICAgICAgIC8vIERlbGV0ZSB0aGUgdHlwZS5cbiAgICAgICAgdGhpcy5fdHlwcy5zcGxpY2Uoa25vdElkeCwgMSk7XG4gICAgICAgIHRoaXMuX2lkeC5kZWxldGUoa25vdCk7XG4gICAgfVxuICAgIGVuY29kZSgpIHtcbiAgICAgICAgY29uc3QgbGVuID0gbGViRW5jb2RlKHRoaXMuX3R5cHMubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgYnVmID0gY29uY2F0KC4uLnRoaXMuX3R5cHMpO1xuICAgICAgICByZXR1cm4gY29uY2F0KGxlbiwgYnVmKTtcbiAgICB9XG4gICAgaW5kZXhPZih0eXBlTmFtZSkge1xuICAgICAgICBpZiAoIXRoaXMuX2lkeC5oYXModHlwZU5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgdHlwZSBpbmRleCBmb3IgJyArIHR5cGVOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2xlYkVuY29kZSh0aGlzLl9pZHguZ2V0KHR5cGVOYW1lKSB8fCAwKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVmlzaXRvciB7XG4gICAgdmlzaXRUeXBlKHQsIGRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gICAgdmlzaXRQcmltaXRpdmUodCwgZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdFR5cGUodCwgZGF0YSk7XG4gICAgfVxuICAgIHZpc2l0RW1wdHkodCwgZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdFByaW1pdGl2ZSh0LCBkYXRhKTtcbiAgICB9XG4gICAgdmlzaXRCb29sKHQsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRQcmltaXRpdmUodCwgZGF0YSk7XG4gICAgfVxuICAgIHZpc2l0TnVsbCh0LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0UHJpbWl0aXZlKHQsIGRhdGEpO1xuICAgIH1cbiAgICB2aXNpdFJlc2VydmVkKHQsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRQcmltaXRpdmUodCwgZGF0YSk7XG4gICAgfVxuICAgIHZpc2l0VGV4dCh0LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0UHJpbWl0aXZlKHQsIGRhdGEpO1xuICAgIH1cbiAgICB2aXNpdE51bWJlcih0LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0UHJpbWl0aXZlKHQsIGRhdGEpO1xuICAgIH1cbiAgICB2aXNpdEludCh0LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0TnVtYmVyKHQsIGRhdGEpO1xuICAgIH1cbiAgICB2aXNpdE5hdCh0LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0TnVtYmVyKHQsIGRhdGEpO1xuICAgIH1cbiAgICB2aXNpdEZsb2F0KHQsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRQcmltaXRpdmUodCwgZGF0YSk7XG4gICAgfVxuICAgIHZpc2l0Rml4ZWRJbnQodCwgZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdE51bWJlcih0LCBkYXRhKTtcbiAgICB9XG4gICAgdmlzaXRGaXhlZE5hdCh0LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0TnVtYmVyKHQsIGRhdGEpO1xuICAgIH1cbiAgICB2aXNpdFByaW5jaXBhbCh0LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0UHJpbWl0aXZlKHQsIGRhdGEpO1xuICAgIH1cbiAgICB2aXNpdENvbnN0cnVjdCh0LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0VHlwZSh0LCBkYXRhKTtcbiAgICB9XG4gICAgdmlzaXRWZWModCwgdHksIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRDb25zdHJ1Y3QodCwgZGF0YSk7XG4gICAgfVxuICAgIHZpc2l0T3B0KHQsIHR5LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0Q29uc3RydWN0KHQsIGRhdGEpO1xuICAgIH1cbiAgICB2aXNpdFJlY29yZCh0LCBmaWVsZHMsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRDb25zdHJ1Y3QodCwgZGF0YSk7XG4gICAgfVxuICAgIHZpc2l0VHVwbGUodCwgY29tcG9uZW50cywgZGF0YSkge1xuICAgICAgICBjb25zdCBmaWVsZHMgPSBjb21wb25lbnRzLm1hcCgodHksIGkpID0+IFtgXyR7aX1fYCwgdHldKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRSZWNvcmQodCwgZmllbGRzLCBkYXRhKTtcbiAgICB9XG4gICAgdmlzaXRWYXJpYW50KHQsIGZpZWxkcywgZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdENvbnN0cnVjdCh0LCBkYXRhKTtcbiAgICB9XG4gICAgdmlzaXRSZWModCwgdHksIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRDb25zdHJ1Y3QodHksIGRhdGEpO1xuICAgIH1cbiAgICB2aXNpdEZ1bmModCwgZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdENvbnN0cnVjdCh0LCBkYXRhKTtcbiAgICB9XG4gICAgdmlzaXRTZXJ2aWNlKHQsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRDb25zdHJ1Y3QodCwgZGF0YSk7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIElETCB0eXBlLlxuICovXG5leHBvcnQgY2xhc3MgVHlwZSB7XG4gICAgLyogRGlzcGxheSB0eXBlIG5hbWUgKi9cbiAgICBkaXNwbGF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgIH1cbiAgICB2YWx1ZVRvU3RyaW5nKHgpIHtcbiAgICAgICAgcmV0dXJuIHRvUmVhZGFibGVTdHJpbmcoeCk7XG4gICAgfVxuICAgIC8qIEltcGxlbWVudCBgVGAgaW4gdGhlIElETCBzcGVjLCBvbmx5IG5lZWRlZCBmb3Igbm9uLXByaW1pdGl2ZSB0eXBlcyAqL1xuICAgIGJ1aWxkVHlwZVRhYmxlKHR5cGVUYWJsZSkge1xuICAgICAgICBpZiAoIXR5cGVUYWJsZS5oYXModGhpcykpIHtcbiAgICAgICAgICAgIHRoaXMuX2J1aWxkVHlwZVRhYmxlSW1wbCh0eXBlVGFibGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFByaW1pdGl2ZVR5cGUgZXh0ZW5kcyBUeXBlIHtcbiAgICBjaGVja1R5cGUodCkge1xuICAgICAgICBpZiAodGhpcy5uYW1lICE9PSB0Lm5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdHlwZSBtaXNtYXRjaDogdHlwZSBvbiB0aGUgd2lyZSAke3QubmFtZX0sIGV4cGVjdCB0eXBlICR7dGhpcy5uYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgX2J1aWxkVHlwZVRhYmxlSW1wbCh0eXBlVGFibGUpIHtcbiAgICAgICAgLy8gTm8gdHlwZSB0YWJsZSBlbmNvZGluZyBmb3IgUHJpbWl0aXZlIHR5cGVzLlxuICAgICAgICByZXR1cm47XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIENvbnN0cnVjdFR5cGUgZXh0ZW5kcyBUeXBlIHtcbiAgICBjaGVja1R5cGUodCkge1xuICAgICAgICBpZiAodCBpbnN0YW5jZW9mIFJlY0NsYXNzKSB7XG4gICAgICAgICAgICBjb25zdCB0eSA9IHQuZ2V0VHlwZSgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0eSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3R5cGUgbWlzbWF0Y2ggd2l0aCB1bmluaXRpYWxpemVkIHR5cGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHR5cGUgbWlzbWF0Y2g6IHR5cGUgb24gdGhlIHdpcmUgJHt0Lm5hbWV9LCBleHBlY3QgdHlwZSAke3RoaXMubmFtZX1gKTtcbiAgICB9XG4gICAgZW5jb2RlVHlwZSh0eXBlVGFibGUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVUYWJsZS5pbmRleE9mKHRoaXMubmFtZSk7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIElETCBFbXB0eSwgYSB0eXBlIHdoaWNoIGhhcyBubyBpbmhhYml0YW50cy5cbiAqIFNpbmNlIG5vIHZhbHVlcyBleGlzdCBmb3IgdGhpcyB0eXBlLCBpdCBjYW5ub3QgYmUgc2VyaWFsaXNlZCBvciBkZXNlcmlhbGlzZWQuXG4gKiBSZXN1bHQgdHlwZXMgbGlrZSBgUmVzdWx0PFRleHQsIEVtcHR5PmAgc2hvdWxkIGFsd2F5cyBzdWNjZWVkLlxuICovXG5leHBvcnQgY2xhc3MgRW1wdHlDbGFzcyBleHRlbmRzIFByaW1pdGl2ZVR5cGUge1xuICAgIGFjY2VwdCh2LCBkKSB7XG4gICAgICAgIHJldHVybiB2LnZpc2l0RW1wdHkodGhpcywgZCk7XG4gICAgfVxuICAgIGNvdmFyaWFudCh4KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCAke3RoaXMuZGlzcGxheSgpfSBhcmd1bWVudDogJHt0b1JlYWRhYmxlU3RyaW5nKHgpfWApO1xuICAgIH1cbiAgICBlbmNvZGVWYWx1ZSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbXB0eSBjYW5ub3QgYXBwZWFyIGFzIGEgZnVuY3Rpb24gYXJndW1lbnQnKTtcbiAgICB9XG4gICAgdmFsdWVUb1N0cmluZygpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbXB0eSBjYW5ub3QgYXBwZWFyIGFzIGEgdmFsdWUnKTtcbiAgICB9XG4gICAgZW5jb2RlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHNsZWJFbmNvZGUoLTE3IC8qIElETFR5cGVJZHMuRW1wdHkgKi8pO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbXB0eSBjYW5ub3QgYXBwZWFyIGFzIGFuIG91dHB1dCcpO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdlbXB0eSc7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIElETCBVbmtub3duLCBhIHBsYWNlaG9sZGVyIHR5cGUgZm9yIGRlc2VyaWFsaXphdGlvbiBvbmx5LlxuICogV2hlbiBkZWNvZGluZyBhIHZhbHVlIGFzIFVua25vd24sIGFsbCBmaWVsZHMgd2lsbCBiZSByZXRhaW5lZCBidXQgdGhlIG5hbWVzIGFyZSBvbmx5IGF2YWlsYWJsZSBpblxuICogaGFzaGVkIGZvcm0uXG4gKiBBIGRlc2VyaWFsaXplZCB1bmtub3duIHdpbGwgb2ZmZXIgaXQncyBhY3R1YWwgdHlwZSBieSBjYWxsaW5nIHRoZSBgdHlwZSgpYCBmdW5jdGlvbi5cbiAqIFVua25vd24gY2Fubm90IGJlIHNlcmlhbGl6ZWQgYW5kIGF0dGVtcHRpbmcgdG8gZG8gc28gd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAqL1xuZXhwb3J0IGNsYXNzIFVua25vd25DbGFzcyBleHRlbmRzIFR5cGUge1xuICAgIGNoZWNrVHlwZSh0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZCBmb3IgdW5rbm93bi4nKTtcbiAgICB9XG4gICAgYWNjZXB0KHYsIGQpIHtcbiAgICAgICAgdGhyb3cgdi52aXNpdFR5cGUodGhpcywgZCk7XG4gICAgfVxuICAgIGNvdmFyaWFudCh4KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCAke3RoaXMuZGlzcGxheSgpfSBhcmd1bWVudDogJHt0b1JlYWRhYmxlU3RyaW5nKHgpfWApO1xuICAgIH1cbiAgICBlbmNvZGVWYWx1ZSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGNhbm5vdCBhcHBlYXIgYXMgYSBmdW5jdGlvbiBhcmd1bWVudCcpO1xuICAgIH1cbiAgICB2YWx1ZVRvU3RyaW5nKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gY2Fubm90IGFwcGVhciBhcyBhIHZhbHVlJyk7XG4gICAgfVxuICAgIGVuY29kZVR5cGUoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBjYW5ub3QgYmUgc2VyaWFsaXplZCcpO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZShiLCB0KSB7XG4gICAgICAgIGxldCBkZWNvZGVkVmFsdWUgPSB0LmRlY29kZVZhbHVlKGIsIHQpO1xuICAgICAgICBpZiAoT2JqZWN0KGRlY29kZWRWYWx1ZSkgIT09IGRlY29kZWRWYWx1ZSkge1xuICAgICAgICAgICAgLy8gZGVjb2RlZFZhbHVlIGlzIHByaW1pdGl2ZS4gQm94IGl0LCBvdGhlcndpc2Ugd2UgY2Fubm90IGFkZCB0aGUgdHlwZSgpIGZ1bmN0aW9uLlxuICAgICAgICAgICAgLy8gVGhlIHR5cGUoKSBmdW5jdGlvbiBpcyBpbXBvcnRhbnQgZm9yIHByaW1pdGl2ZXMgYmVjYXVzZSBvdGhlcndpc2Ugd2UgY2Fubm90IHRlbGwgYXBhcnQgdGhlXG4gICAgICAgICAgICAvLyBkaWZmZXJlbnQgbnVtYmVyIHR5cGVzLlxuICAgICAgICAgICAgZGVjb2RlZFZhbHVlID0gT2JqZWN0KGRlY29kZWRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHR5cGVGdW5jO1xuICAgICAgICBpZiAodCBpbnN0YW5jZW9mIFJlY0NsYXNzKSB7XG4gICAgICAgICAgICB0eXBlRnVuYyA9ICgpID0+IHQuZ2V0VHlwZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHlwZUZ1bmMgPSAoKSA9PiB0O1xuICAgICAgICB9XG4gICAgICAgIC8vIERvIG5vdCB1c2UgJ2RlY29kZWRWYWx1ZS50eXBlID0gdHlwZUZ1bmMnIGJlY2F1c2UgdGhpcyB3b3VsZCBsZWFkIHRvIGFuIGVudW1lcmFibGUgcHJvcGVydHlcbiAgICAgICAgLy8gJ3R5cGUnIHdoaWNoIG1lYW5zIGl0IHdvdWxkIGJlIHNlcmlhbGl6ZWQgaWYgdGhlIHZhbHVlIHdvdWxkIGJlIGNhbmRpZCBlbmNvZGVkIGFnYWluLlxuICAgICAgICAvLyBUaGlzIGluIHR1cm4gbGVhZHMgdG8gcHJvYmxlbXMgaWYgdGhlIGRlY29kZWQgdmFsdWUgaXMgYSB2YXJpYW50IGJlY2F1c2UgdGhlc2UgdmFsdWVzIGFyZVxuICAgICAgICAvLyBvbmx5IGFsbG93ZWQgdG8gaGF2ZSBhIHNpbmdsZSBwcm9wZXJ0eS5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlY29kZWRWYWx1ZSwgJ3R5cGUnLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHlwZUZ1bmMsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRlY29kZWRWYWx1ZTtcbiAgICB9XG4gICAgX2J1aWxkVHlwZVRhYmxlSW1wbCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGNhbm5vdCBiZSBzZXJpYWxpemVkJyk7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gJ1Vua25vd24nO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhbiBJREwgQm9vbFxuICovXG5leHBvcnQgY2xhc3MgQm9vbENsYXNzIGV4dGVuZHMgUHJpbWl0aXZlVHlwZSB7XG4gICAgYWNjZXB0KHYsIGQpIHtcbiAgICAgICAgcmV0dXJuIHYudmlzaXRCb29sKHRoaXMsIGQpO1xuICAgIH1cbiAgICBjb3ZhcmlhbnQoeCkge1xuICAgICAgICBpZiAodHlwZW9mIHggPT09ICdib29sZWFuJylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHt0aGlzLmRpc3BsYXkoKX0gYXJndW1lbnQ6ICR7dG9SZWFkYWJsZVN0cmluZyh4KX1gKTtcbiAgICB9XG4gICAgZW5jb2RlVmFsdWUoeCkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoW3ggPyAxIDogMF0pO1xuICAgIH1cbiAgICBlbmNvZGVUeXBlKCkge1xuICAgICAgICByZXR1cm4gc2xlYkVuY29kZSgtMiAvKiBJRExUeXBlSWRzLkJvb2wgKi8pO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZShiLCB0KSB7XG4gICAgICAgIHRoaXMuY2hlY2tUeXBlKHQpO1xuICAgICAgICBzd2l0Y2ggKHNhZmVSZWFkVWludDgoYikpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQm9vbGVhbiB2YWx1ZSBvdXQgb2YgcmFuZ2UnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdib29sJztcbiAgICB9XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYW4gSURMIE51bGxcbiAqL1xuZXhwb3J0IGNsYXNzIE51bGxDbGFzcyBleHRlbmRzIFByaW1pdGl2ZVR5cGUge1xuICAgIGFjY2VwdCh2LCBkKSB7XG4gICAgICAgIHJldHVybiB2LnZpc2l0TnVsbCh0aGlzLCBkKTtcbiAgICB9XG4gICAgY292YXJpYW50KHgpIHtcbiAgICAgICAgaWYgKHggPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkICR7dGhpcy5kaXNwbGF5KCl9IGFyZ3VtZW50OiAke3RvUmVhZGFibGVTdHJpbmcoeCl9YCk7XG4gICAgfVxuICAgIGVuY29kZVZhbHVlKCkge1xuICAgICAgICByZXR1cm4gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgIH1cbiAgICBlbmNvZGVUeXBlKCkge1xuICAgICAgICByZXR1cm4gc2xlYkVuY29kZSgtMSAvKiBJRExUeXBlSWRzLk51bGwgKi8pO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZShiLCB0KSB7XG4gICAgICAgIHRoaXMuY2hlY2tUeXBlKHQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIElETCBSZXNlcnZlZFxuICovXG5leHBvcnQgY2xhc3MgUmVzZXJ2ZWRDbGFzcyBleHRlbmRzIFByaW1pdGl2ZVR5cGUge1xuICAgIGFjY2VwdCh2LCBkKSB7XG4gICAgICAgIHJldHVybiB2LnZpc2l0UmVzZXJ2ZWQodGhpcywgZCk7XG4gICAgfVxuICAgIGNvdmFyaWFudCh4KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbmNvZGVWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICB9XG4gICAgZW5jb2RlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHNsZWJFbmNvZGUoLTE2IC8qIElETFR5cGVJZHMuUmVzZXJ2ZWQgKi8pO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZShiLCB0KSB7XG4gICAgICAgIGlmICh0Lm5hbWUgIT09IHRoaXMubmFtZSkge1xuICAgICAgICAgICAgdC5kZWNvZGVWYWx1ZShiLCB0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiAncmVzZXJ2ZWQnO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhbiBJREwgVGV4dFxuICovXG5leHBvcnQgY2xhc3MgVGV4dENsYXNzIGV4dGVuZHMgUHJpbWl0aXZlVHlwZSB7XG4gICAgYWNjZXB0KHYsIGQpIHtcbiAgICAgICAgcmV0dXJuIHYudmlzaXRUZXh0KHRoaXMsIGQpO1xuICAgIH1cbiAgICBjb3ZhcmlhbnQoeCkge1xuICAgICAgICBpZiAodHlwZW9mIHggPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCAke3RoaXMuZGlzcGxheSgpfSBhcmd1bWVudDogJHt0b1JlYWRhYmxlU3RyaW5nKHgpfWApO1xuICAgIH1cbiAgICBlbmNvZGVWYWx1ZSh4KSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh4KTtcbiAgICAgICAgY29uc3QgbGVuID0gbGViRW5jb2RlKGJ1Zi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGNvbmNhdChsZW4sIGJ1Zik7XG4gICAgfVxuICAgIGVuY29kZVR5cGUoKSB7XG4gICAgICAgIHJldHVybiBzbGViRW5jb2RlKC0xNSAvKiBJRExUeXBlSWRzLlRleHQgKi8pO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZShiLCB0KSB7XG4gICAgICAgIHRoaXMuY2hlY2tUeXBlKHQpO1xuICAgICAgICBjb25zdCBsZW4gPSBsZWJEZWNvZGUoYik7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHNhZmVSZWFkKGIsIE51bWJlcihsZW4pKTtcbiAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmOCcsIHsgZmF0YWw6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiBkZWNvZGVyLmRlY29kZShidWYpO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICd0ZXh0JztcbiAgICB9XG4gICAgdmFsdWVUb1N0cmluZyh4KSB7XG4gICAgICAgIHJldHVybiAnXCInICsgeCArICdcIic7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIElETCBJbnRcbiAqL1xuZXhwb3J0IGNsYXNzIEludENsYXNzIGV4dGVuZHMgUHJpbWl0aXZlVHlwZSB7XG4gICAgYWNjZXB0KHYsIGQpIHtcbiAgICAgICAgcmV0dXJuIHYudmlzaXRJbnQodGhpcywgZCk7XG4gICAgfVxuICAgIGNvdmFyaWFudCh4KSB7XG4gICAgICAgIC8vIFdlIGFsbG93IGVuY29kaW5nIG9mIEphdmFTY3JpcHQgcGxhaW4gbnVtYmVycy5cbiAgICAgICAgLy8gQnV0IHdlIHdpbGwgYWx3YXlzIGRlY29kZSB0byBiaWdpbnQuXG4gICAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ2JpZ2ludCcgfHwgTnVtYmVyLmlzSW50ZWdlcih4KSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHt0aGlzLmRpc3BsYXkoKX0gYXJndW1lbnQ6ICR7dG9SZWFkYWJsZVN0cmluZyh4KX1gKTtcbiAgICB9XG4gICAgZW5jb2RlVmFsdWUoeCkge1xuICAgICAgICByZXR1cm4gc2xlYkVuY29kZSh4KTtcbiAgICB9XG4gICAgZW5jb2RlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHNsZWJFbmNvZGUoLTQgLyogSURMVHlwZUlkcy5JbnQgKi8pO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZShiLCB0KSB7XG4gICAgICAgIHRoaXMuY2hlY2tUeXBlKHQpO1xuICAgICAgICByZXR1cm4gc2xlYkRlY29kZShiKTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnaW50JztcbiAgICB9XG4gICAgdmFsdWVUb1N0cmluZyh4KSB7XG4gICAgICAgIHJldHVybiB4LnRvU3RyaW5nKCk7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIElETCBOYXRcbiAqL1xuZXhwb3J0IGNsYXNzIE5hdENsYXNzIGV4dGVuZHMgUHJpbWl0aXZlVHlwZSB7XG4gICAgYWNjZXB0KHYsIGQpIHtcbiAgICAgICAgcmV0dXJuIHYudmlzaXROYXQodGhpcywgZCk7XG4gICAgfVxuICAgIGNvdmFyaWFudCh4KSB7XG4gICAgICAgIC8vIFdlIGFsbG93IGVuY29kaW5nIG9mIEphdmFTY3JpcHQgcGxhaW4gbnVtYmVycy5cbiAgICAgICAgLy8gQnV0IHdlIHdpbGwgYWx3YXlzIGRlY29kZSB0byBiaWdpbnQuXG4gICAgICAgIGlmICgodHlwZW9mIHggPT09ICdiaWdpbnQnICYmIHggPj0gQmlnSW50KDApKSB8fCAoTnVtYmVyLmlzSW50ZWdlcih4KSAmJiB4ID49IDApKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCAke3RoaXMuZGlzcGxheSgpfSBhcmd1bWVudDogJHt0b1JlYWRhYmxlU3RyaW5nKHgpfWApO1xuICAgIH1cbiAgICBlbmNvZGVWYWx1ZSh4KSB7XG4gICAgICAgIHJldHVybiBsZWJFbmNvZGUoeCk7XG4gICAgfVxuICAgIGVuY29kZVR5cGUoKSB7XG4gICAgICAgIHJldHVybiBzbGViRW5jb2RlKC0zIC8qIElETFR5cGVJZHMuTmF0ICovKTtcbiAgICB9XG4gICAgZGVjb2RlVmFsdWUoYiwgdCkge1xuICAgICAgICB0aGlzLmNoZWNrVHlwZSh0KTtcbiAgICAgICAgcmV0dXJuIGxlYkRlY29kZShiKTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnbmF0JztcbiAgICB9XG4gICAgdmFsdWVUb1N0cmluZyh4KSB7XG4gICAgICAgIHJldHVybiB4LnRvU3RyaW5nKCk7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIElETCBGbG9hdFxuICovXG5leHBvcnQgY2xhc3MgRmxvYXRDbGFzcyBleHRlbmRzIFByaW1pdGl2ZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKF9iaXRzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2JpdHMgPSBfYml0cztcbiAgICAgICAgaWYgKF9iaXRzICE9PSAzMiAmJiBfYml0cyAhPT0gNjQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGEgdmFsaWQgZmxvYXQgdHlwZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFjY2VwdCh2LCBkKSB7XG4gICAgICAgIHJldHVybiB2LnZpc2l0RmxvYXQodGhpcywgZCk7XG4gICAgfVxuICAgIGNvdmFyaWFudCh4KSB7XG4gICAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicgfHwgeCBpbnN0YW5jZW9mIE51bWJlcilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHt0aGlzLmRpc3BsYXkoKX0gYXJndW1lbnQ6ICR7dG9SZWFkYWJsZVN0cmluZyh4KX1gKTtcbiAgICB9XG4gICAgZW5jb2RlVmFsdWUoeCkge1xuICAgICAgICBjb25zdCBidWYgPSBuZXcgQXJyYXlCdWZmZXIodGhpcy5fYml0cyAvIDgpO1xuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1Zik7XG4gICAgICAgIGlmICh0aGlzLl9iaXRzID09PSAzMikge1xuICAgICAgICAgICAgdmlldy5zZXRGbG9hdDMyKDAsIHgsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmlldy5zZXRGbG9hdDY0KDAsIHgsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICAgIGVuY29kZVR5cGUoKSB7XG4gICAgICAgIGNvbnN0IG9wY29kZSA9IHRoaXMuX2JpdHMgPT09IDMyID8gLTEzIC8qIElETFR5cGVJZHMuRmxvYXQzMiAqLyA6IC0xNCAvKiBJRExUeXBlSWRzLkZsb2F0NjQgKi87XG4gICAgICAgIHJldHVybiBzbGViRW5jb2RlKG9wY29kZSk7XG4gICAgfVxuICAgIGRlY29kZVZhbHVlKGIsIHQpIHtcbiAgICAgICAgdGhpcy5jaGVja1R5cGUodCk7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gc2FmZVJlYWQoYiwgdGhpcy5fYml0cyAvIDgpO1xuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ5dGVzKTtcbiAgICAgICAgaWYgKHRoaXMuX2JpdHMgPT09IDMyKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlldy5nZXRGbG9hdDMyKDAsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHZpZXcuZ2V0RmxvYXQ2NCgwLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdmbG9hdCcgKyB0aGlzLl9iaXRzO1xuICAgIH1cbiAgICB2YWx1ZVRvU3RyaW5nKHgpIHtcbiAgICAgICAgcmV0dXJuIHgudG9TdHJpbmcoKTtcbiAgICB9XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYW4gSURMIGZpeGVkLXdpZHRoIEludChuKVxuICovXG5leHBvcnQgY2xhc3MgRml4ZWRJbnRDbGFzcyBleHRlbmRzIFByaW1pdGl2ZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKF9iaXRzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2JpdHMgPSBfYml0cztcbiAgICB9XG4gICAgYWNjZXB0KHYsIGQpIHtcbiAgICAgICAgcmV0dXJuIHYudmlzaXRGaXhlZEludCh0aGlzLCBkKTtcbiAgICB9XG4gICAgY292YXJpYW50KHgpIHtcbiAgICAgICAgY29uc3QgbWluID0gaWV4cDIodGhpcy5fYml0cyAtIDEpICogQmlnSW50KC0xKTtcbiAgICAgICAgY29uc3QgbWF4ID0gaWV4cDIodGhpcy5fYml0cyAtIDEpIC0gQmlnSW50KDEpO1xuICAgICAgICBsZXQgb2sgPSBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiB4ID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgb2sgPSB4ID49IG1pbiAmJiB4IDw9IG1heDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHgpKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gQmlnSW50KHgpO1xuICAgICAgICAgICAgb2sgPSB2ID49IG1pbiAmJiB2IDw9IG1heDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9rID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9rKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCAke3RoaXMuZGlzcGxheSgpfSBhcmd1bWVudDogJHt0b1JlYWRhYmxlU3RyaW5nKHgpfWApO1xuICAgIH1cbiAgICBlbmNvZGVWYWx1ZSh4KSB7XG4gICAgICAgIHJldHVybiB3cml0ZUludExFKHgsIHRoaXMuX2JpdHMgLyA4KTtcbiAgICB9XG4gICAgZW5jb2RlVHlwZSgpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gTWF0aC5sb2cyKHRoaXMuX2JpdHMpIC0gMztcbiAgICAgICAgcmV0dXJuIHNsZWJFbmNvZGUoLTkgLSBvZmZzZXQpO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZShiLCB0KSB7XG4gICAgICAgIHRoaXMuY2hlY2tUeXBlKHQpO1xuICAgICAgICBjb25zdCBudW0gPSByZWFkSW50TEUoYiwgdGhpcy5fYml0cyAvIDgpO1xuICAgICAgICBpZiAodGhpcy5fYml0cyA8PSAzMikge1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlcihudW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIGBpbnQke3RoaXMuX2JpdHN9YDtcbiAgICB9XG4gICAgdmFsdWVUb1N0cmluZyh4KSB7XG4gICAgICAgIHJldHVybiB4LnRvU3RyaW5nKCk7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIElETCBmaXhlZC13aWR0aCBOYXQobilcbiAqL1xuZXhwb3J0IGNsYXNzIEZpeGVkTmF0Q2xhc3MgZXh0ZW5kcyBQcmltaXRpdmVUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihfYml0cykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9iaXRzID0gX2JpdHM7XG4gICAgfVxuICAgIGFjY2VwdCh2LCBkKSB7XG4gICAgICAgIHJldHVybiB2LnZpc2l0Rml4ZWROYXQodGhpcywgZCk7XG4gICAgfVxuICAgIGNvdmFyaWFudCh4KSB7XG4gICAgICAgIGNvbnN0IG1heCA9IGlleHAyKHRoaXMuX2JpdHMpO1xuICAgICAgICBsZXQgb2sgPSBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiB4ID49IEJpZ0ludCgwKSkge1xuICAgICAgICAgICAgb2sgPSB4IDwgbWF4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKE51bWJlci5pc0ludGVnZXIoeCkgJiYgeCA+PSAwKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gQmlnSW50KHgpO1xuICAgICAgICAgICAgb2sgPSB2IDwgbWF4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2sgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2spXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkICR7dGhpcy5kaXNwbGF5KCl9IGFyZ3VtZW50OiAke3RvUmVhZGFibGVTdHJpbmcoeCl9YCk7XG4gICAgfVxuICAgIGVuY29kZVZhbHVlKHgpIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlVUludExFKHgsIHRoaXMuX2JpdHMgLyA4KTtcbiAgICB9XG4gICAgZW5jb2RlVHlwZSgpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gTWF0aC5sb2cyKHRoaXMuX2JpdHMpIC0gMztcbiAgICAgICAgcmV0dXJuIHNsZWJFbmNvZGUoLTUgLSBvZmZzZXQpO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZShiLCB0KSB7XG4gICAgICAgIHRoaXMuY2hlY2tUeXBlKHQpO1xuICAgICAgICBjb25zdCBudW0gPSByZWFkVUludExFKGIsIHRoaXMuX2JpdHMgLyA4KTtcbiAgICAgICAgaWYgKHRoaXMuX2JpdHMgPD0gMzIpIHtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIobnVtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudW07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiBgbmF0JHt0aGlzLl9iaXRzfWA7XG4gICAgfVxuICAgIHZhbHVlVG9TdHJpbmcoeCkge1xuICAgICAgICByZXR1cm4geC50b1N0cmluZygpO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhbiBJREwgQXJyYXlcbiAqXG4gKiBBcnJheXMgb2YgZml4ZWQtc2l6ZWQgbmF0L2ludCB0eXBlIChlLmcuIG5hdDgpLCBhcmUgZW5jb2RlZCBmcm9tIGFuZCBkZWNvZGVkIHRvIFR5cGVkQXJyYXlzIChlLmcuIFVpbnQ4QXJyYXkpLlxuICogQXJyYXlzIG9mIGZsb2F0IG9yIG90aGVyIG5vbi1wcmltaXRpdmUgdHlwZXMgYXJlIGVuY29kZWQvZGVjb2RlZCBhcyB1bnR5cGVkIGFycmF5IGluIEphdmFzY3JpcHQuXG4gKiBAcGFyYW0ge1R5cGV9IHRcbiAqL1xuZXhwb3J0IGNsYXNzIFZlY0NsYXNzIGV4dGVuZHMgQ29uc3RydWN0VHlwZSB7XG4gICAgY29uc3RydWN0b3IoX3R5cGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fdHlwZSA9IF90eXBlO1xuICAgICAgICAvLyBJZiB0cnVlLCB0aGlzIHZlY3RvciBpcyByZWFsbHkgYSBibG9iIGFuZCB3ZSBjYW4ganVzdCB1c2UgbWVtY3B5LlxuICAgICAgICAvL1xuICAgICAgICAvLyBOT1RFOlxuICAgICAgICAvLyBXaXRoIHN1cHBvcnQgb2YgZW5jb2RpbmcvZGVuY29kaW5nIG9mIFR5cGVkQXJyYXlzLCB0aGlzIG9wdGltaXphdGlvbiBpc1xuICAgICAgICAvLyBvbmx5IHVzZWQgd2hlbiBwbGFpbiBhcnJheSBvZiBieXRlcyBhcmUgcGFzc2VkIGFzIGVuY29kaW5nIGlucHV0IGluIG9yZGVyXG4gICAgICAgIC8vIHRvIGJlIGJhY2t3YXJkIGNvbXBhdGlibGUuXG4gICAgICAgIHRoaXMuX2Jsb2JPcHRpbWl6YXRpb24gPSBmYWxzZTtcbiAgICAgICAgaWYgKF90eXBlIGluc3RhbmNlb2YgRml4ZWROYXRDbGFzcyAmJiBfdHlwZS5fYml0cyA9PT0gOCkge1xuICAgICAgICAgICAgdGhpcy5fYmxvYk9wdGltaXphdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWNjZXB0KHYsIGQpIHtcbiAgICAgICAgcmV0dXJuIHYudmlzaXRWZWModGhpcywgdGhpcy5fdHlwZSwgZCk7XG4gICAgfVxuICAgIGNvdmFyaWFudCh4KSB7XG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgQXJyYXlCdWZmZXJcbiAgICAgICAgY29uc3QgYml0cyA9IHRoaXMuX3R5cGUgaW5zdGFuY2VvZiBGaXhlZE5hdENsYXNzXG4gICAgICAgICAgICA/IHRoaXMuX3R5cGUuX2JpdHNcbiAgICAgICAgICAgIDogdGhpcy5fdHlwZSBpbnN0YW5jZW9mIEZpeGVkSW50Q2xhc3NcbiAgICAgICAgICAgICAgICA/IHRoaXMuX3R5cGUuX2JpdHNcbiAgICAgICAgICAgICAgICA6IDA7XG4gICAgICAgIGlmICgoQXJyYXlCdWZmZXIuaXNWaWV3KHgpICYmIGJpdHMgPT0geC5CWVRFU19QRVJfRUxFTUVOVCAqIDgpIHx8XG4gICAgICAgICAgICAoQXJyYXkuaXNBcnJheSh4KSAmJlxuICAgICAgICAgICAgICAgIHguZXZlcnkoKHYsIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGUuY292YXJpYW50KHYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHt0aGlzLmRpc3BsYXkoKX0gYXJndW1lbnQ6IFxcblxcbmluZGV4ICR7aWR4fSAtPiAke2UubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHt0aGlzLmRpc3BsYXkoKX0gYXJndW1lbnQ6ICR7dG9SZWFkYWJsZVN0cmluZyh4KX1gKTtcbiAgICB9XG4gICAgZW5jb2RlVmFsdWUoeCkge1xuICAgICAgICBjb25zdCBsZW4gPSBsZWJFbmNvZGUoeC5sZW5ndGgpO1xuICAgICAgICBpZiAodGhpcy5fYmxvYk9wdGltaXphdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdChsZW4sIG5ldyBVaW50OEFycmF5KHgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHgpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uY2F0KGxlbiwgbmV3IFVpbnQ4QXJyYXkoeC5idWZmZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWYgPSBuZXcgUGlwZShuZXcgQXJyYXlCdWZmZXIobGVuLmJ5dGVMZW5ndGggKyB4Lmxlbmd0aCksIDApO1xuICAgICAgICBidWYud3JpdGUobGVuKTtcbiAgICAgICAgZm9yIChjb25zdCBkIG9mIHgpIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZWQgPSB0aGlzLl90eXBlLmVuY29kZVZhbHVlKGQpO1xuICAgICAgICAgICAgYnVmLndyaXRlKG5ldyBVaW50OEFycmF5KGVuY29kZWQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmLmJ1ZmZlcjtcbiAgICB9XG4gICAgX2J1aWxkVHlwZVRhYmxlSW1wbCh0eXBlVGFibGUpIHtcbiAgICAgICAgdGhpcy5fdHlwZS5idWlsZFR5cGVUYWJsZSh0eXBlVGFibGUpO1xuICAgICAgICBjb25zdCBvcENvZGUgPSBzbGViRW5jb2RlKC0xOSAvKiBJRExUeXBlSWRzLlZlY3RvciAqLyk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuX3R5cGUuZW5jb2RlVHlwZSh0eXBlVGFibGUpO1xuICAgICAgICB0eXBlVGFibGUuYWRkKHRoaXMsIGNvbmNhdChvcENvZGUsIGJ1ZmZlcikpO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZShiLCB0KSB7XG4gICAgICAgIGNvbnN0IHZlYyA9IHRoaXMuY2hlY2tUeXBlKHQpO1xuICAgICAgICBpZiAoISh2ZWMgaW5zdGFuY2VvZiBWZWNDbGFzcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGEgdmVjdG9yIHR5cGUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW4gPSBOdW1iZXIobGViRGVjb2RlKGIpKTtcbiAgICAgICAgaWYgKHRoaXMuX3R5cGUgaW5zdGFuY2VvZiBGaXhlZE5hdENsYXNzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdHlwZS5fYml0cyA9PSA4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGIucmVhZChsZW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl90eXBlLl9iaXRzID09IDE2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50MTZBcnJheShiLnJlYWQobGVuICogMikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3R5cGUuX2JpdHMgPT0gMzIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KGIucmVhZChsZW4gKiA0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fdHlwZS5fYml0cyA9PSA2NCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmlnVWludDY0QXJyYXkoYi5yZWFkKGxlbiAqIDgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdHlwZSBpbnN0YW5jZW9mIEZpeGVkSW50Q2xhc3MpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl90eXBlLl9iaXRzID09IDgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEludDhBcnJheShiLnJlYWQobGVuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fdHlwZS5fYml0cyA9PSAxNikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW50MTZBcnJheShiLnJlYWQobGVuICogMikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3R5cGUuX2JpdHMgPT0gMzIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoYi5yZWFkKGxlbiAqIDQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl90eXBlLl9iaXRzID09IDY0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnQ2NEFycmF5KGIucmVhZChsZW4gKiA4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICByZXRzLnB1c2godGhpcy5fdHlwZS5kZWNvZGVWYWx1ZShiLCB2ZWMuX3R5cGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0cztcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiBgdmVjICR7dGhpcy5fdHlwZS5uYW1lfWA7XG4gICAgfVxuICAgIGRpc3BsYXkoKSB7XG4gICAgICAgIHJldHVybiBgdmVjICR7dGhpcy5fdHlwZS5kaXNwbGF5KCl9YDtcbiAgICB9XG4gICAgdmFsdWVUb1N0cmluZyh4KSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0geC5tYXAoZSA9PiB0aGlzLl90eXBlLnZhbHVlVG9TdHJpbmcoZSkpO1xuICAgICAgICByZXR1cm4gJ3ZlYyB7JyArIGVsZW1lbnRzLmpvaW4oJzsgJykgKyAnfSc7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIElETCBPcHRpb25cbiAqIEBwYXJhbSB7VHlwZX0gdFxuICovXG5leHBvcnQgY2xhc3MgT3B0Q2xhc3MgZXh0ZW5kcyBDb25zdHJ1Y3RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihfdHlwZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl90eXBlID0gX3R5cGU7XG4gICAgfVxuICAgIGFjY2VwdCh2LCBkKSB7XG4gICAgICAgIHJldHVybiB2LnZpc2l0T3B0KHRoaXMsIHRoaXMuX3R5cGUsIGQpO1xuICAgIH1cbiAgICBjb3ZhcmlhbnQoeCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoeCkgJiYgKHgubGVuZ3RoID09PSAwIHx8ICh4Lmxlbmd0aCA9PT0gMSAmJiB0aGlzLl90eXBlLmNvdmFyaWFudCh4WzBdKSkpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHt0aGlzLmRpc3BsYXkoKX0gYXJndW1lbnQ6ICR7dG9SZWFkYWJsZVN0cmluZyh4KX0gXFxuXFxuLT4gJHtlLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkICR7dGhpcy5kaXNwbGF5KCl9IGFyZ3VtZW50OiAke3RvUmVhZGFibGVTdHJpbmcoeCl9YCk7XG4gICAgfVxuICAgIGVuY29kZVZhbHVlKHgpIHtcbiAgICAgICAgaWYgKHgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjb25jYXQobmV3IFVpbnQ4QXJyYXkoWzFdKSwgdGhpcy5fdHlwZS5lbmNvZGVWYWx1ZSh4WzBdKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2J1aWxkVHlwZVRhYmxlSW1wbCh0eXBlVGFibGUpIHtcbiAgICAgICAgdGhpcy5fdHlwZS5idWlsZFR5cGVUYWJsZSh0eXBlVGFibGUpO1xuICAgICAgICBjb25zdCBvcENvZGUgPSBzbGViRW5jb2RlKC0xOCAvKiBJRExUeXBlSWRzLk9wdCAqLyk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuX3R5cGUuZW5jb2RlVHlwZSh0eXBlVGFibGUpO1xuICAgICAgICB0eXBlVGFibGUuYWRkKHRoaXMsIGNvbmNhdChvcENvZGUsIGJ1ZmZlcikpO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZShiLCB0KSB7XG4gICAgICAgIGNvbnN0IG9wdCA9IHRoaXMuY2hlY2tUeXBlKHQpO1xuICAgICAgICBpZiAoIShvcHQgaW5zdGFuY2VvZiBPcHRDbGFzcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGFuIG9wdGlvbiB0eXBlJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChzYWZlUmVhZFVpbnQ4KGIpKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiBbdGhpcy5fdHlwZS5kZWNvZGVWYWx1ZShiLCBvcHQuX3R5cGUpXTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYW4gb3B0aW9uIHZhbHVlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiBgb3B0ICR7dGhpcy5fdHlwZS5uYW1lfWA7XG4gICAgfVxuICAgIGRpc3BsYXkoKSB7XG4gICAgICAgIHJldHVybiBgb3B0ICR7dGhpcy5fdHlwZS5kaXNwbGF5KCl9YDtcbiAgICB9XG4gICAgdmFsdWVUb1N0cmluZyh4KSB7XG4gICAgICAgIGlmICh4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgb3B0ICR7dGhpcy5fdHlwZS52YWx1ZVRvU3RyaW5nKHhbMF0pfWA7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYW4gSURMIFJlY29yZFxuICogQHBhcmFtIHtvYmplY3R9IFtmaWVsZHNdIC0gbWFwcGluZyBvZiBmdW5jdGlvbiBuYW1lIHRvIFR5cGVcbiAqL1xuZXhwb3J0IGNsYXNzIFJlY29yZENsYXNzIGV4dGVuZHMgQ29uc3RydWN0VHlwZSB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzID0ge30pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fZmllbGRzID0gT2JqZWN0LmVudHJpZXMoZmllbGRzKS5zb3J0KChhLCBiKSA9PiBpZGxMYWJlbFRvSWQoYVswXSkgLSBpZGxMYWJlbFRvSWQoYlswXSkpO1xuICAgIH1cbiAgICBhY2NlcHQodiwgZCkge1xuICAgICAgICByZXR1cm4gdi52aXNpdFJlY29yZCh0aGlzLCB0aGlzLl9maWVsZHMsIGQpO1xuICAgIH1cbiAgICB0cnlBc1R1cGxlKCkge1xuICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9maWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IFtrZXksIHR5cGVdID0gdGhpcy5fZmllbGRzW2ldO1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gYF8ke2l9X2ApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcy5wdXNoKHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGNvdmFyaWFudCh4KSB7XG4gICAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHRoaXMuX2ZpZWxkcy5ldmVyeSgoW2ssIHRdKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICAgICAgaWYgKCF4Lmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVjb3JkIGlzIG1pc3Npbmcga2V5IFwiJHtrfVwiLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdC5jb3ZhcmlhbnQoeFtrXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCAke3RoaXMuZGlzcGxheSgpfSBhcmd1bWVudDogXFxuXFxuZmllbGQgJHtrfSAtPiAke2UubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHt0aGlzLmRpc3BsYXkoKX0gYXJndW1lbnQ6ICR7dG9SZWFkYWJsZVN0cmluZyh4KX1gKTtcbiAgICB9XG4gICAgZW5jb2RlVmFsdWUoeCkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLl9maWVsZHMubWFwKChba2V5XSkgPT4geFtrZXldKTtcbiAgICAgICAgY29uc3QgYnVmcyA9IHppcFdpdGgodGhpcy5fZmllbGRzLCB2YWx1ZXMsIChbLCBjXSwgZCkgPT4gYy5lbmNvZGVWYWx1ZShkKSk7XG4gICAgICAgIHJldHVybiBjb25jYXQoLi4uYnVmcyk7XG4gICAgfVxuICAgIF9idWlsZFR5cGVUYWJsZUltcGwoVCkge1xuICAgICAgICB0aGlzLl9maWVsZHMuZm9yRWFjaCgoW18sIHZhbHVlXSkgPT4gdmFsdWUuYnVpbGRUeXBlVGFibGUoVCkpO1xuICAgICAgICBjb25zdCBvcENvZGUgPSBzbGViRW5jb2RlKC0yMCAvKiBJRExUeXBlSWRzLlJlY29yZCAqLyk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGxlYkVuY29kZSh0aGlzLl9maWVsZHMubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy5fZmllbGRzLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBjb25jYXQobGViRW5jb2RlKGlkbExhYmVsVG9JZChrZXkpKSwgdmFsdWUuZW5jb2RlVHlwZShUKSkpO1xuICAgICAgICBULmFkZCh0aGlzLCBjb25jYXQob3BDb2RlLCBsZW4sIGNvbmNhdCguLi5maWVsZHMpKSk7XG4gICAgfVxuICAgIGRlY29kZVZhbHVlKGIsIHQpIHtcbiAgICAgICAgY29uc3QgcmVjb3JkID0gdGhpcy5jaGVja1R5cGUodCk7XG4gICAgICAgIGlmICghKHJlY29yZCBpbnN0YW5jZW9mIFJlY29yZENsYXNzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSByZWNvcmQgdHlwZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHggPSB7fTtcbiAgICAgICAgbGV0IGV4cGVjdGVkUmVjb3JkSWR4ID0gMDtcbiAgICAgICAgbGV0IGFjdHVhbFJlY29yZElkeCA9IDA7XG4gICAgICAgIHdoaWxlIChhY3R1YWxSZWNvcmRJZHggPCByZWNvcmQuX2ZpZWxkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IFtoYXNoLCB0eXBlXSA9IHJlY29yZC5fZmllbGRzW2FjdHVhbFJlY29yZElkeF07XG4gICAgICAgICAgICBpZiAoZXhwZWN0ZWRSZWNvcmRJZHggPj0gdGhpcy5fZmllbGRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIHNraXAgdW5leHBlY3RlZCBsZWZ0IG92ZXIgZmllbGRzIHByZXNlbnQgb24gdGhlIHdpcmVcbiAgICAgICAgICAgICAgICB0eXBlLmRlY29kZVZhbHVlKGIsIHR5cGUpO1xuICAgICAgICAgICAgICAgIGFjdHVhbFJlY29yZElkeCsrO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgW2V4cGVjdEtleSwgZXhwZWN0VHlwZV0gPSB0aGlzLl9maWVsZHNbZXhwZWN0ZWRSZWNvcmRJZHhdO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRJZCA9IGlkbExhYmVsVG9JZCh0aGlzLl9maWVsZHNbZXhwZWN0ZWRSZWNvcmRJZHhdWzBdKTtcbiAgICAgICAgICAgIGNvbnN0IGFjdHVhbElkID0gaWRsTGFiZWxUb0lkKGhhc2gpO1xuICAgICAgICAgICAgaWYgKGV4cGVjdGVkSWQgPT09IGFjdHVhbElkKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgZmllbGQgb24gdGhlIHdpcmUgbWF0Y2hlcyB0aGUgZXhwZWN0ZWQgZmllbGRcbiAgICAgICAgICAgICAgICB4W2V4cGVjdEtleV0gPSBleHBlY3RUeXBlLmRlY29kZVZhbHVlKGIsIHR5cGUpO1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkUmVjb3JkSWR4Kys7XG4gICAgICAgICAgICAgICAgYWN0dWFsUmVjb3JkSWR4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY3R1YWxJZCA+IGV4cGVjdGVkSWQpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZXhwZWN0ZWQgZmllbGQgZG9lcyBub3QgZXhpc3Qgb24gdGhlIHdpcmVcbiAgICAgICAgICAgICAgICBpZiAoZXhwZWN0VHlwZSBpbnN0YW5jZW9mIE9wdENsYXNzIHx8IGV4cGVjdFR5cGUgaW5zdGFuY2VvZiBSZXNlcnZlZENsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHhbZXhwZWN0S2V5XSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZFJlY29yZElkeCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCByZXF1aXJlZCBmaWVsZCAnICsgZXhwZWN0S2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZmllbGQgb24gdGhlIHdpcmUgZG9lcyBub3QgZXhpc3QgaW4gdGhlIG91dHB1dCB0eXBlLCBzbyB3ZSBjYW4gc2tpcCBpdFxuICAgICAgICAgICAgICAgIHR5cGUuZGVjb2RlVmFsdWUoYiwgdHlwZSk7XG4gICAgICAgICAgICAgICAgYWN0dWFsUmVjb3JkSWR4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBsZWZ0IG92ZXIgZXhwZWN0ZWQgb3B0aW9uYWwgZmllbGRzXG4gICAgICAgIGZvciAoY29uc3QgW2V4cGVjdEtleSwgZXhwZWN0VHlwZV0gb2YgdGhpcy5fZmllbGRzLnNsaWNlKGV4cGVjdGVkUmVjb3JkSWR4KSkge1xuICAgICAgICAgICAgaWYgKGV4cGVjdFR5cGUgaW5zdGFuY2VvZiBPcHRDbGFzcyB8fCBleHBlY3RUeXBlIGluc3RhbmNlb2YgUmVzZXJ2ZWRDbGFzcykge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gdGhpcyBhc3N1bWVzIG51bGwgdmFsdWUgaW4gb3B0IGlzIHJlcHJlc2VudGVkIGFzIFtdXG4gICAgICAgICAgICAgICAgeFtleHBlY3RLZXldID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHJlcXVpcmVkIGZpZWxkICcgKyBleHBlY3RLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy5fZmllbGRzLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBrZXkgKyAnOicgKyB2YWx1ZS5uYW1lKTtcbiAgICAgICAgcmV0dXJuIGByZWNvcmQgeyR7ZmllbGRzLmpvaW4oJzsgJyl9fWA7XG4gICAgfVxuICAgIGRpc3BsYXkoKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMuX2ZpZWxkcy5tYXAoKFtrZXksIHZhbHVlXSkgPT4ga2V5ICsgJzonICsgdmFsdWUuZGlzcGxheSgpKTtcbiAgICAgICAgcmV0dXJuIGByZWNvcmQgeyR7ZmllbGRzLmpvaW4oJzsgJyl9fWA7XG4gICAgfVxuICAgIHZhbHVlVG9TdHJpbmcoeCkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLl9maWVsZHMubWFwKChba2V5XSkgPT4geFtrZXldKTtcbiAgICAgICAgY29uc3QgZmllbGRzID0gemlwV2l0aCh0aGlzLl9maWVsZHMsIHZhbHVlcywgKFtrLCBjXSwgZCkgPT4gayArICc9JyArIGMudmFsdWVUb1N0cmluZyhkKSk7XG4gICAgICAgIHJldHVybiBgcmVjb3JkIHske2ZpZWxkcy5qb2luKCc7ICcpfX1gO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBUdXBsZSwgYSBzeW50YWN0aWMgc3VnYXIgZm9yIFJlY29yZC5cbiAqIEBwYXJhbSB7VHlwZX0gY29tcG9uZW50c1xuICovXG5leHBvcnQgY2xhc3MgVHVwbGVDbGFzcyBleHRlbmRzIFJlY29yZENsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcihfY29tcG9uZW50cykge1xuICAgICAgICBjb25zdCB4ID0ge307XG4gICAgICAgIF9jb21wb25lbnRzLmZvckVhY2goKGUsIGkpID0+ICh4WydfJyArIGkgKyAnXyddID0gZSkpO1xuICAgICAgICBzdXBlcih4KTtcbiAgICAgICAgdGhpcy5fY29tcG9uZW50cyA9IF9jb21wb25lbnRzO1xuICAgIH1cbiAgICBhY2NlcHQodiwgZCkge1xuICAgICAgICByZXR1cm4gdi52aXNpdFR1cGxlKHRoaXMsIHRoaXMuX2NvbXBvbmVudHMsIGQpO1xuICAgIH1cbiAgICBjb3ZhcmlhbnQoeCkge1xuICAgICAgICAvLyBgPj1gIGJlY2F1c2UgdHVwbGVzIGNhbiBiZSBjb3ZhcmlhbnQgd2hlbiBlbmNvZGVkLlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh4KSAmJlxuICAgICAgICAgICAgeC5sZW5ndGggPj0gdGhpcy5fZmllbGRzLmxlbmd0aCAmJlxuICAgICAgICAgICAgdGhpcy5fY29tcG9uZW50cy5ldmVyeSgodCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0LmNvdmFyaWFudCh4W2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkICR7dGhpcy5kaXNwbGF5KCl9IGFyZ3VtZW50OiBcXG5cXG5pbmRleCAke2l9IC0+ICR7ZS5tZXNzYWdlfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCAke3RoaXMuZGlzcGxheSgpfSBhcmd1bWVudDogJHt0b1JlYWRhYmxlU3RyaW5nKHgpfWApO1xuICAgIH1cbiAgICBlbmNvZGVWYWx1ZSh4KSB7XG4gICAgICAgIGNvbnN0IGJ1ZnMgPSB6aXBXaXRoKHRoaXMuX2NvbXBvbmVudHMsIHgsIChjLCBkKSA9PiBjLmVuY29kZVZhbHVlKGQpKTtcbiAgICAgICAgcmV0dXJuIGNvbmNhdCguLi5idWZzKTtcbiAgICB9XG4gICAgZGVjb2RlVmFsdWUoYiwgdCkge1xuICAgICAgICBjb25zdCB0dXBsZSA9IHRoaXMuY2hlY2tUeXBlKHQpO1xuICAgICAgICBpZiAoISh0dXBsZSBpbnN0YW5jZW9mIFR1cGxlQ2xhc3MpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBhIHR1cGxlIHR5cGUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHVwbGUuX2NvbXBvbmVudHMubGVuZ3RoIDwgdGhpcy5fY29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndHVwbGUgbWlzbWF0Y2gnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBbaSwgd2lyZVR5cGVdIG9mIHR1cGxlLl9jb21wb25lbnRzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaWYgKGkgPj0gdGhpcy5fY29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBza2lwIHZhbHVlXG4gICAgICAgICAgICAgICAgd2lyZVR5cGUuZGVjb2RlVmFsdWUoYiwgd2lyZVR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2godGhpcy5fY29tcG9uZW50c1tpXS5kZWNvZGVWYWx1ZShiLCB3aXJlVHlwZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGRpc3BsYXkoKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMuX2NvbXBvbmVudHMubWFwKHZhbHVlID0+IHZhbHVlLmRpc3BsYXkoKSk7XG4gICAgICAgIHJldHVybiBgcmVjb3JkIHske2ZpZWxkcy5qb2luKCc7ICcpfX1gO1xuICAgIH1cbiAgICB2YWx1ZVRvU3RyaW5nKHZhbHVlcykge1xuICAgICAgICBjb25zdCBmaWVsZHMgPSB6aXBXaXRoKHRoaXMuX2NvbXBvbmVudHMsIHZhbHVlcywgKGMsIGQpID0+IGMudmFsdWVUb1N0cmluZyhkKSk7XG4gICAgICAgIHJldHVybiBgcmVjb3JkIHske2ZpZWxkcy5qb2luKCc7ICcpfX1gO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhbiBJREwgVmFyaWFudFxuICogQHBhcmFtIHtvYmplY3R9IFtmaWVsZHNdIC0gbWFwcGluZyBvZiBmdW5jdGlvbiBuYW1lIHRvIFR5cGVcbiAqL1xuZXhwb3J0IGNsYXNzIFZhcmlhbnRDbGFzcyBleHRlbmRzIENvbnN0cnVjdFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2ZpZWxkcyA9IE9iamVjdC5lbnRyaWVzKGZpZWxkcykuc29ydCgoYSwgYikgPT4gaWRsTGFiZWxUb0lkKGFbMF0pIC0gaWRsTGFiZWxUb0lkKGJbMF0pKTtcbiAgICB9XG4gICAgYWNjZXB0KHYsIGQpIHtcbiAgICAgICAgcmV0dXJuIHYudmlzaXRWYXJpYW50KHRoaXMsIHRoaXMuX2ZpZWxkcywgZCk7XG4gICAgfVxuICAgIGNvdmFyaWFudCh4KSB7XG4gICAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHgpLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgdGhpcy5fZmllbGRzLmV2ZXJ5KChbaywgdl0pID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICF4Lmhhc093blByb3BlcnR5KGspIHx8IHYuY292YXJpYW50KHhba10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHt0aGlzLmRpc3BsYXkoKX0gYXJndW1lbnQ6IFxcblxcbnZhcmlhbnQgJHtrfSAtPiAke2UubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHt0aGlzLmRpc3BsYXkoKX0gYXJndW1lbnQ6ICR7dG9SZWFkYWJsZVN0cmluZyh4KX1gKTtcbiAgICB9XG4gICAgZW5jb2RlVmFsdWUoeCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2ZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgW25hbWUsIHR5cGVdID0gdGhpcy5fZmllbGRzW2ldO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICBpZiAoeC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkeCA9IGxlYkVuY29kZShpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBidWYgPSB0eXBlLmVuY29kZVZhbHVlKHhbbmFtZV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25jYXQoaWR4LCBidWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IEVycm9yKCdWYXJpYW50IGhhcyBubyBkYXRhOiAnICsgeCk7XG4gICAgfVxuICAgIF9idWlsZFR5cGVUYWJsZUltcGwodHlwZVRhYmxlKSB7XG4gICAgICAgIHRoaXMuX2ZpZWxkcy5mb3JFYWNoKChbLCB0eXBlXSkgPT4ge1xuICAgICAgICAgICAgdHlwZS5idWlsZFR5cGVUYWJsZSh0eXBlVGFibGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgb3BDb2RlID0gc2xlYkVuY29kZSgtMjEgLyogSURMVHlwZUlkcy5WYXJpYW50ICovKTtcbiAgICAgICAgY29uc3QgbGVuID0gbGViRW5jb2RlKHRoaXMuX2ZpZWxkcy5sZW5ndGgpO1xuICAgICAgICBjb25zdCBmaWVsZHMgPSB0aGlzLl9maWVsZHMubWFwKChba2V5LCB2YWx1ZV0pID0+IGNvbmNhdChsZWJFbmNvZGUoaWRsTGFiZWxUb0lkKGtleSkpLCB2YWx1ZS5lbmNvZGVUeXBlKHR5cGVUYWJsZSkpKTtcbiAgICAgICAgdHlwZVRhYmxlLmFkZCh0aGlzLCBjb25jYXQob3BDb2RlLCBsZW4sIC4uLmZpZWxkcykpO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZShiLCB0KSB7XG4gICAgICAgIGNvbnN0IHZhcmlhbnQgPSB0aGlzLmNoZWNrVHlwZSh0KTtcbiAgICAgICAgaWYgKCEodmFyaWFudCBpbnN0YW5jZW9mIFZhcmlhbnRDbGFzcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGEgdmFyaWFudCB0eXBlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWR4ID0gTnVtYmVyKGxlYkRlY29kZShiKSk7XG4gICAgICAgIGlmIChpZHggPj0gdmFyaWFudC5fZmllbGRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgdmFyaWFudCBpbmRleDogJyArIGlkeCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW3dpcmVIYXNoLCB3aXJlVHlwZV0gPSB2YXJpYW50Ll9maWVsZHNbaWR4XTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBleHBlY3RUeXBlXSBvZiB0aGlzLl9maWVsZHMpIHtcbiAgICAgICAgICAgIGlmIChpZGxMYWJlbFRvSWQod2lyZUhhc2gpID09PSBpZGxMYWJlbFRvSWQoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZXhwZWN0VHlwZS5kZWNvZGVWYWx1ZShiLCB3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgW2tleV06IHZhbHVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBmaWVsZCBoYXNoICcgKyB3aXJlSGFzaCk7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICBjb25zdCBmaWVsZHMgPSB0aGlzLl9maWVsZHMubWFwKChba2V5LCB0eXBlXSkgPT4ga2V5ICsgJzonICsgdHlwZS5uYW1lKTtcbiAgICAgICAgcmV0dXJuIGB2YXJpYW50IHske2ZpZWxkcy5qb2luKCc7ICcpfX1gO1xuICAgIH1cbiAgICBkaXNwbGF5KCkge1xuICAgICAgICBjb25zdCBmaWVsZHMgPSB0aGlzLl9maWVsZHMubWFwKChba2V5LCB0eXBlXSkgPT4ga2V5ICsgKHR5cGUubmFtZSA9PT0gJ251bGwnID8gJycgOiBgOiR7dHlwZS5kaXNwbGF5KCl9YCkpO1xuICAgICAgICByZXR1cm4gYHZhcmlhbnQgeyR7ZmllbGRzLmpvaW4oJzsgJyl9fWA7XG4gICAgfVxuICAgIHZhbHVlVG9TdHJpbmcoeCkge1xuICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCB0eXBlXSBvZiB0aGlzLl9maWVsZHMpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgaWYgKHguaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHR5cGUudmFsdWVUb1N0cmluZyh4W25hbWVdKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09ICdudWxsJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYHZhcmlhbnQgeyR7bmFtZX19YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgdmFyaWFudCB7JHtuYW1lfT0ke3ZhbHVlfX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhcmlhbnQgaGFzIG5vIGRhdGE6ICcgKyB4KTtcbiAgICB9XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYSByZWZlcmVuY2UgdG8gYW4gSURMIHR5cGUsIHVzZWQgZm9yIGRlZmluaW5nIHJlY3Vyc2l2ZSBkYXRhXG4gKiB0eXBlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIFJlY0NsYXNzIGV4dGVuZHMgQ29uc3RydWN0VHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX2lkID0gUmVjQ2xhc3MuX2NvdW50ZXIrKztcbiAgICAgICAgdGhpcy5fdHlwZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgYWNjZXB0KHYsIGQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignUmVjdXJzaXZlIHR5cGUgdW5pbml0aWFsaXplZC4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdi52aXNpdFJlYyh0aGlzLCB0aGlzLl90eXBlLCBkKTtcbiAgICB9XG4gICAgZmlsbCh0KSB7XG4gICAgICAgIHRoaXMuX3R5cGUgPSB0O1xuICAgIH1cbiAgICBnZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHlwZTtcbiAgICB9XG4gICAgY292YXJpYW50KHgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3R5cGUgPyB0aGlzLl90eXBlLmNvdmFyaWFudCh4KSA6IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCAke3RoaXMuZGlzcGxheSgpfSBhcmd1bWVudDogJHt0b1JlYWRhYmxlU3RyaW5nKHgpfWApO1xuICAgIH1cbiAgICBlbmNvZGVWYWx1ZSh4KSB7XG4gICAgICAgIGlmICghdGhpcy5fdHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1JlY3Vyc2l2ZSB0eXBlIHVuaW5pdGlhbGl6ZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGUuZW5jb2RlVmFsdWUoeCk7XG4gICAgfVxuICAgIF9idWlsZFR5cGVUYWJsZUltcGwodHlwZVRhYmxlKSB7XG4gICAgICAgIGlmICghdGhpcy5fdHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1JlY3Vyc2l2ZSB0eXBlIHVuaW5pdGlhbGl6ZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdHlwZVRhYmxlLmFkZCh0aGlzLCBuZXcgVWludDhBcnJheShbXSkpO1xuICAgICAgICB0aGlzLl90eXBlLmJ1aWxkVHlwZVRhYmxlKHR5cGVUYWJsZSk7XG4gICAgICAgIHR5cGVUYWJsZS5tZXJnZSh0aGlzLCB0aGlzLl90eXBlLm5hbWUpO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZShiLCB0KSB7XG4gICAgICAgIGlmICghdGhpcy5fdHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1JlY3Vyc2l2ZSB0eXBlIHVuaW5pdGlhbGl6ZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGUuZGVjb2RlVmFsdWUoYiwgdCk7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gYHJlY18ke3RoaXMuX2lkfWA7XG4gICAgfVxuICAgIGRpc3BsYXkoKSB7XG4gICAgICAgIGlmICghdGhpcy5fdHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1JlY3Vyc2l2ZSB0eXBlIHVuaW5pdGlhbGl6ZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGDOvCR7dGhpcy5uYW1lfS4ke3RoaXMuX3R5cGUubmFtZX1gO1xuICAgIH1cbiAgICB2YWx1ZVRvU3RyaW5nKHgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignUmVjdXJzaXZlIHR5cGUgdW5pbml0aWFsaXplZC4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdHlwZS52YWx1ZVRvU3RyaW5nKHgpO1xuICAgIH1cbn1cblJlY0NsYXNzLl9jb3VudGVyID0gMDtcbmZ1bmN0aW9uIGRlY29kZVByaW5jaXBhbElkKGIpIHtcbiAgICBjb25zdCB4ID0gc2FmZVJlYWRVaW50OChiKTtcbiAgICBpZiAoeCAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBkZWNvZGUgcHJpbmNpcGFsJyk7XG4gICAgfVxuICAgIGNvbnN0IGxlbiA9IE51bWJlcihsZWJEZWNvZGUoYikpO1xuICAgIHJldHVybiBQcmluY2lwYWxJZC5mcm9tVWludDhBcnJheShuZXcgVWludDhBcnJheShzYWZlUmVhZChiLCBsZW4pKSk7XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYW4gSURMIHByaW5jaXBhbCByZWZlcmVuY2VcbiAqL1xuZXhwb3J0IGNsYXNzIFByaW5jaXBhbENsYXNzIGV4dGVuZHMgUHJpbWl0aXZlVHlwZSB7XG4gICAgYWNjZXB0KHYsIGQpIHtcbiAgICAgICAgcmV0dXJuIHYudmlzaXRQcmluY2lwYWwodGhpcywgZCk7XG4gICAgfVxuICAgIGNvdmFyaWFudCh4KSB7XG4gICAgICAgIGlmICh4ICYmIHguX2lzUHJpbmNpcGFsKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCAke3RoaXMuZGlzcGxheSgpfSBhcmd1bWVudDogJHt0b1JlYWRhYmxlU3RyaW5nKHgpfWApO1xuICAgIH1cbiAgICBlbmNvZGVWYWx1ZSh4KSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHgudG9VaW50OEFycmF5KCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGxlYkVuY29kZShidWYuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJldHVybiBjb25jYXQobmV3IFVpbnQ4QXJyYXkoWzFdKSwgbGVuLCBidWYpO1xuICAgIH1cbiAgICBlbmNvZGVUeXBlKCkge1xuICAgICAgICByZXR1cm4gc2xlYkVuY29kZSgtMjQgLyogSURMVHlwZUlkcy5QcmluY2lwYWwgKi8pO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZShiLCB0KSB7XG4gICAgICAgIHRoaXMuY2hlY2tUeXBlKHQpO1xuICAgICAgICByZXR1cm4gZGVjb2RlUHJpbmNpcGFsSWQoYik7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gJ3ByaW5jaXBhbCc7XG4gICAgfVxuICAgIHZhbHVlVG9TdHJpbmcoeCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5uYW1lfSBcIiR7eC50b1RleHQoKX1cImA7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIElETCBmdW5jdGlvbiByZWZlcmVuY2UuXG4gKiBAcGFyYW0gYXJnVHlwZXMgQXJndW1lbnQgdHlwZXMuXG4gKiBAcGFyYW0gcmV0VHlwZXMgUmV0dXJuIHR5cGVzLlxuICogQHBhcmFtIGFubm90YXRpb25zIEZ1bmN0aW9uIGFubm90YXRpb25zLlxuICovXG5leHBvcnQgY2xhc3MgRnVuY0NsYXNzIGV4dGVuZHMgQ29uc3RydWN0VHlwZSB7XG4gICAgY29uc3RydWN0b3IoYXJnVHlwZXMsIHJldFR5cGVzLCBhbm5vdGF0aW9ucyA9IFtdKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXJnVHlwZXMgPSBhcmdUeXBlcztcbiAgICAgICAgdGhpcy5yZXRUeXBlcyA9IHJldFR5cGVzO1xuICAgICAgICB0aGlzLmFubm90YXRpb25zID0gYW5ub3RhdGlvbnM7XG4gICAgfVxuICAgIHN0YXRpYyBhcmdzVG9TdHJpbmcodHlwZXMsIHYpIHtcbiAgICAgICAgaWYgKHR5cGVzLmxlbmd0aCAhPT0gdi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXJpdHkgbWlzbWF0Y2gnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJygnICsgdHlwZXMubWFwKCh0LCBpKSA9PiB0LnZhbHVlVG9TdHJpbmcodltpXSkpLmpvaW4oJywgJykgKyAnKSc7XG4gICAgfVxuICAgIGFjY2VwdCh2LCBkKSB7XG4gICAgICAgIHJldHVybiB2LnZpc2l0RnVuYyh0aGlzLCBkKTtcbiAgICB9XG4gICAgY292YXJpYW50KHgpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoeCkgJiYgeC5sZW5ndGggPT09IDIgJiYgeFswXSAmJiB4WzBdLl9pc1ByaW5jaXBhbCAmJiB0eXBlb2YgeFsxXSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkICR7dGhpcy5kaXNwbGF5KCl9IGFyZ3VtZW50OiAke3RvUmVhZGFibGVTdHJpbmcoeCl9YCk7XG4gICAgfVxuICAgIGVuY29kZVZhbHVlKFtwcmluY2lwYWwsIG1ldGhvZE5hbWVdKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHByaW5jaXBhbC50b1VpbnQ4QXJyYXkoKTtcbiAgICAgICAgY29uc3QgbGVuID0gbGViRW5jb2RlKGJ1Zi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgY29uc3QgY2FuaXN0ZXIgPSBjb25jYXQobmV3IFVpbnQ4QXJyYXkoWzFdKSwgbGVuLCBidWYpO1xuICAgICAgICBjb25zdCBtZXRob2QgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUobWV0aG9kTmFtZSk7XG4gICAgICAgIGNvbnN0IG1ldGhvZExlbiA9IGxlYkVuY29kZShtZXRob2QuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJldHVybiBjb25jYXQobmV3IFVpbnQ4QXJyYXkoWzFdKSwgY2FuaXN0ZXIsIG1ldGhvZExlbiwgbWV0aG9kKTtcbiAgICB9XG4gICAgX2J1aWxkVHlwZVRhYmxlSW1wbChUKSB7XG4gICAgICAgIHRoaXMuYXJnVHlwZXMuZm9yRWFjaChhcmcgPT4gYXJnLmJ1aWxkVHlwZVRhYmxlKFQpKTtcbiAgICAgICAgdGhpcy5yZXRUeXBlcy5mb3JFYWNoKGFyZyA9PiBhcmcuYnVpbGRUeXBlVGFibGUoVCkpO1xuICAgICAgICBjb25zdCBvcENvZGUgPSBzbGViRW5jb2RlKC0yMiAvKiBJRExUeXBlSWRzLkZ1bmMgKi8pO1xuICAgICAgICBjb25zdCBhcmdMZW4gPSBsZWJFbmNvZGUodGhpcy5hcmdUeXBlcy5sZW5ndGgpO1xuICAgICAgICBjb25zdCBhcmdzID0gY29uY2F0KC4uLnRoaXMuYXJnVHlwZXMubWFwKGFyZyA9PiBhcmcuZW5jb2RlVHlwZShUKSkpO1xuICAgICAgICBjb25zdCByZXRMZW4gPSBsZWJFbmNvZGUodGhpcy5yZXRUeXBlcy5sZW5ndGgpO1xuICAgICAgICBjb25zdCByZXRzID0gY29uY2F0KC4uLnRoaXMucmV0VHlwZXMubWFwKGFyZyA9PiBhcmcuZW5jb2RlVHlwZShUKSkpO1xuICAgICAgICBjb25zdCBhbm5MZW4gPSBsZWJFbmNvZGUodGhpcy5hbm5vdGF0aW9ucy5sZW5ndGgpO1xuICAgICAgICBjb25zdCBhbm5zID0gY29uY2F0KC4uLnRoaXMuYW5ub3RhdGlvbnMubWFwKGEgPT4gdGhpcy5lbmNvZGVBbm5vdGF0aW9uKGEpKSk7XG4gICAgICAgIFQuYWRkKHRoaXMsIGNvbmNhdChvcENvZGUsIGFyZ0xlbiwgYXJncywgcmV0TGVuLCByZXRzLCBhbm5MZW4sIGFubnMpKTtcbiAgICB9XG4gICAgZGVjb2RlVmFsdWUoYikge1xuICAgICAgICBjb25zdCB4ID0gc2FmZVJlYWRVaW50OChiKTtcbiAgICAgICAgaWYgKHggIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGRlY29kZSBmdW5jdGlvbiByZWZlcmVuY2UnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYW5pc3RlciA9IGRlY29kZVByaW5jaXBhbElkKGIpO1xuICAgICAgICBjb25zdCBtTGVuID0gTnVtYmVyKGxlYkRlY29kZShiKSk7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHNhZmVSZWFkKGIsIG1MZW4pO1xuICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGY4JywgeyBmYXRhbDogdHJ1ZSB9KTtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gZGVjb2Rlci5kZWNvZGUoYnVmKTtcbiAgICAgICAgcmV0dXJuIFtjYW5pc3RlciwgbWV0aG9kXTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLmFyZ1R5cGVzLm1hcChhcmcgPT4gYXJnLm5hbWUpLmpvaW4oJywgJyk7XG4gICAgICAgIGNvbnN0IHJldHMgPSB0aGlzLnJldFR5cGVzLm1hcChhcmcgPT4gYXJnLm5hbWUpLmpvaW4oJywgJyk7XG4gICAgICAgIGNvbnN0IGFubm9uID0gJyAnICsgdGhpcy5hbm5vdGF0aW9ucy5qb2luKCcgJyk7XG4gICAgICAgIHJldHVybiBgKCR7YXJnc30pIC0+ICgke3JldHN9KSR7YW5ub259YDtcbiAgICB9XG4gICAgdmFsdWVUb1N0cmluZyhbcHJpbmNpcGFsLCBzdHJdKSB7XG4gICAgICAgIHJldHVybiBgZnVuYyBcIiR7cHJpbmNpcGFsLnRvVGV4dCgpfVwiLiR7c3RyfWA7XG4gICAgfVxuICAgIGRpc3BsYXkoKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLmFyZ1R5cGVzLm1hcChhcmcgPT4gYXJnLmRpc3BsYXkoKSkuam9pbignLCAnKTtcbiAgICAgICAgY29uc3QgcmV0cyA9IHRoaXMucmV0VHlwZXMubWFwKGFyZyA9PiBhcmcuZGlzcGxheSgpKS5qb2luKCcsICcpO1xuICAgICAgICBjb25zdCBhbm5vbiA9ICcgJyArIHRoaXMuYW5ub3RhdGlvbnMuam9pbignICcpO1xuICAgICAgICByZXR1cm4gYCgke2FyZ3N9KSDihpIgKCR7cmV0c30pJHthbm5vbn1gO1xuICAgIH1cbiAgICBlbmNvZGVBbm5vdGF0aW9uKGFubikge1xuICAgICAgICBpZiAoYW5uID09PSAncXVlcnknKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhbm4gPT09ICdvbmV3YXknKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzJdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhbm4gPT09ICdjb21wb3NpdGVfcXVlcnknKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzNdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBmdW5jdGlvbiBhbm5vdGF0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY2xhc3MgU2VydmljZUNsYXNzIGV4dGVuZHMgQ29uc3RydWN0VHlwZSB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2ZpZWxkcyA9IE9iamVjdC5lbnRyaWVzKGZpZWxkcykuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgaWYgKGFbMF0gPCBiWzBdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFbMF0gPiBiWzBdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFjY2VwdCh2LCBkKSB7XG4gICAgICAgIHJldHVybiB2LnZpc2l0U2VydmljZSh0aGlzLCBkKTtcbiAgICB9XG4gICAgY292YXJpYW50KHgpIHtcbiAgICAgICAgaWYgKHggJiYgeC5faXNQcmluY2lwYWwpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkICR7dGhpcy5kaXNwbGF5KCl9IGFyZ3VtZW50OiAke3RvUmVhZGFibGVTdHJpbmcoeCl9YCk7XG4gICAgfVxuICAgIGVuY29kZVZhbHVlKHgpIHtcbiAgICAgICAgY29uc3QgYnVmID0geC50b1VpbnQ4QXJyYXkoKTtcbiAgICAgICAgY29uc3QgbGVuID0gbGViRW5jb2RlKGJ1Zi5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gY29uY2F0KG5ldyBVaW50OEFycmF5KFsxXSksIGxlbiwgYnVmKTtcbiAgICB9XG4gICAgX2J1aWxkVHlwZVRhYmxlSW1wbChUKSB7XG4gICAgICAgIHRoaXMuX2ZpZWxkcy5mb3JFYWNoKChbXywgZnVuY10pID0+IGZ1bmMuYnVpbGRUeXBlVGFibGUoVCkpO1xuICAgICAgICBjb25zdCBvcENvZGUgPSBzbGViRW5jb2RlKC0yMyAvKiBJRExUeXBlSWRzLlNlcnZpY2UgKi8pO1xuICAgICAgICBjb25zdCBsZW4gPSBsZWJFbmNvZGUodGhpcy5fZmllbGRzLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IG1ldGhzID0gdGhpcy5fZmllbGRzLm1hcCgoW2xhYmVsLCBmdW5jXSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGFiZWxCdWYgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUobGFiZWwpO1xuICAgICAgICAgICAgY29uc3QgbGFiZWxMZW4gPSBsZWJFbmNvZGUobGFiZWxCdWYubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBjb25jYXQobGFiZWxMZW4sIGxhYmVsQnVmLCBmdW5jLmVuY29kZVR5cGUoVCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgVC5hZGQodGhpcywgY29uY2F0KG9wQ29kZSwgbGVuLCAuLi5tZXRocykpO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZShiKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVQcmluY2lwYWxJZChiKTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMuX2ZpZWxkcy5tYXAoKFtrZXksIHZhbHVlXSkgPT4ga2V5ICsgJzonICsgdmFsdWUubmFtZSk7XG4gICAgICAgIHJldHVybiBgc2VydmljZSB7JHtmaWVsZHMuam9pbignOyAnKX19YDtcbiAgICB9XG4gICAgdmFsdWVUb1N0cmluZyh4KSB7XG4gICAgICAgIHJldHVybiBgc2VydmljZSBcIiR7eC50b1RleHQoKX1cImA7XG4gICAgfVxufVxuLyoqXG4gKiBUYWtlcyBhbiB1bmtub3duIHZhbHVlIGFuZCByZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGl0LlxuICogQHBhcmFtIHggLSB1bmtub3duIHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRvUmVhZGFibGVTdHJpbmcoeCkge1xuICAgIGNvbnN0IHN0ciA9IEpTT04uc3RyaW5naWZ5KHgsIChfa2V5LCB2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JyA/IGBCaWdJbnQoJHt2YWx1ZX0pYCA6IHZhbHVlKTtcbiAgICByZXR1cm4gc3RyICYmIHN0ci5sZW5ndGggPiB0b1JlYWRhYmxlU3RyaW5nX21heFxuICAgICAgICA/IHN0ci5zdWJzdHJpbmcoMCwgdG9SZWFkYWJsZVN0cmluZ19tYXggLSAzKSArICcuLi4nXG4gICAgICAgIDogc3RyO1xufVxuLyoqXG4gKiBFbmNvZGUgYSBhcnJheSBvZiB2YWx1ZXNcbiAqIEBwYXJhbSBhcmdUeXBlcyAtIGFycmF5IG9mIFR5cGVzXG4gKiBAcGFyYW0gYXJncyAtIGFycmF5IG9mIHZhbHVlc1xuICogQHJldHVybnMge0FycmF5QnVmZmVyfSBzZXJpYWxpc2VkIHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGUoYXJnVHlwZXMsIGFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPCBhcmdUeXBlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1dyb25nIG51bWJlciBvZiBtZXNzYWdlIGFyZ3VtZW50cycpO1xuICAgIH1cbiAgICBjb25zdCB0eXBlVGFibGUgPSBuZXcgVHlwZVRhYmxlKCk7XG4gICAgYXJnVHlwZXMuZm9yRWFjaCh0ID0+IHQuYnVpbGRUeXBlVGFibGUodHlwZVRhYmxlKSk7XG4gICAgY29uc3QgbWFnaWMgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUobWFnaWNOdW1iZXIpO1xuICAgIGNvbnN0IHRhYmxlID0gdHlwZVRhYmxlLmVuY29kZSgpO1xuICAgIGNvbnN0IGxlbiA9IGxlYkVuY29kZShhcmdzLmxlbmd0aCk7XG4gICAgY29uc3QgdHlwcyA9IGNvbmNhdCguLi5hcmdUeXBlcy5tYXAodCA9PiB0LmVuY29kZVR5cGUodHlwZVRhYmxlKSkpO1xuICAgIGNvbnN0IHZhbHMgPSBjb25jYXQoLi4uemlwV2l0aChhcmdUeXBlcywgYXJncywgKHQsIHgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHQuY292YXJpYW50KHgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoZS5tZXNzYWdlICsgJ1xcblxcbicpO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0LmVuY29kZVZhbHVlKHgpO1xuICAgIH0pKTtcbiAgICByZXR1cm4gY29uY2F0KG1hZ2ljLCB0YWJsZSwgbGVuLCB0eXBzLCB2YWxzKTtcbn1cbi8qKlxuICogRGVjb2RlIGEgYmluYXJ5IHZhbHVlXG4gKiBAcGFyYW0gcmV0VHlwZXMgLSBUeXBlcyBleHBlY3RlZCBpbiB0aGUgYnVmZmVyLlxuICogQHBhcmFtIGJ5dGVzIC0gaGV4LWVuY29kZWQgc3RyaW5nLCBvciBidWZmZXIuXG4gKiBAcmV0dXJucyBWYWx1ZSBkZXNlcmlhbGlzZWQgdG8gSlMgdHlwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlKHJldFR5cGVzLCBieXRlcykge1xuICAgIGNvbnN0IGIgPSBuZXcgUGlwZShieXRlcyk7XG4gICAgaWYgKGJ5dGVzLmJ5dGVMZW5ndGggPCBtYWdpY051bWJlci5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXNzYWdlIGxlbmd0aCBzbWFsbGVyIHRoYW4gbWFnaWMgbnVtYmVyJyk7XG4gICAgfVxuICAgIGNvbnN0IG1hZ2ljQnVmZmVyID0gc2FmZVJlYWQoYiwgbWFnaWNOdW1iZXIubGVuZ3RoKTtcbiAgICBjb25zdCBtYWdpYyA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShtYWdpY0J1ZmZlcik7XG4gICAgaWYgKG1hZ2ljICE9PSBtYWdpY051bWJlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIG1hZ2ljIG51bWJlcjogJyArIEpTT04uc3RyaW5naWZ5KG1hZ2ljKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWRUeXBlVGFibGUocGlwZSkge1xuICAgICAgICBjb25zdCB0eXBlVGFibGUgPSBbXTtcbiAgICAgICAgY29uc3QgbGVuID0gTnVtYmVyKGxlYkRlY29kZShwaXBlKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHR5ID0gTnVtYmVyKHNsZWJEZWNvZGUocGlwZSkpO1xuICAgICAgICAgICAgc3dpdGNoICh0eSkge1xuICAgICAgICAgICAgICAgIGNhc2UgLTE4IC8qIElETFR5cGVJZHMuT3B0ICovOlxuICAgICAgICAgICAgICAgIGNhc2UgLTE5IC8qIElETFR5cGVJZHMuVmVjdG9yICovOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBOdW1iZXIoc2xlYkRlY29kZShwaXBlKSk7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVUYWJsZS5wdXNoKFt0eSwgdF0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAtMjAgLyogSURMVHlwZUlkcy5SZWNvcmQgKi86XG4gICAgICAgICAgICAgICAgY2FzZSAtMjEgLyogSURMVHlwZUlkcy5WYXJpYW50ICovOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgb2JqZWN0TGVuZ3RoID0gTnVtYmVyKGxlYkRlY29kZShwaXBlKSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwcmV2SGFzaDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG9iamVjdExlbmd0aC0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNoID0gTnVtYmVyKGxlYkRlY29kZShwaXBlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzaCA+PSBNYXRoLnBvdygyLCAzMikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpZWxkIGlkIG91dCBvZiAzMi1iaXQgcmFuZ2UnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJldkhhc2ggPT09ICdudW1iZXInICYmIHByZXZIYXNoID49IGhhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpZWxkIGlkIGNvbGxpc2lvbiBvciBub3Qgc29ydGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2SGFzaCA9IGhhc2g7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gTnVtYmVyKHNsZWJEZWNvZGUocGlwZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRzLnB1c2goW2hhc2gsIHRdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0eXBlVGFibGUucHVzaChbdHksIGZpZWxkc10pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAtMjIgLyogSURMVHlwZUlkcy5GdW5jICovOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFyZ0xlbmd0aCA9IE51bWJlcihsZWJEZWNvZGUocGlwZSkpO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYXJnTGVuZ3RoLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChOdW1iZXIoc2xlYkRlY29kZShwaXBlKSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldHVyblZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmV0dXJuVmFsdWVzTGVuZ3RoID0gTnVtYmVyKGxlYkRlY29kZShwaXBlKSk7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZXR1cm5WYWx1ZXNMZW5ndGgtLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWVzLnB1c2goTnVtYmVyKHNsZWJEZWNvZGUocGlwZSkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbm5vdGF0aW9ucyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYW5ub3RhdGlvbkxlbmd0aCA9IE51bWJlcihsZWJEZWNvZGUocGlwZSkpO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYW5ub3RhdGlvbkxlbmd0aC0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhbm5vdGF0aW9uID0gTnVtYmVyKGxlYkRlY29kZShwaXBlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGFubm90YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvbnMucHVzaCgncXVlcnknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbm5vdGF0aW9ucy5wdXNoKCdvbmV3YXknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbm5vdGF0aW9ucy5wdXNoKCdjb21wb3NpdGVfcXVlcnknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBhbm5vdGF0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHlwZVRhYmxlLnB1c2goW3R5LCBbYXJncywgcmV0dXJuVmFsdWVzLCBhbm5vdGF0aW9uc11dKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgLTIzIC8qIElETFR5cGVJZHMuU2VydmljZSAqLzoge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2Vydkxlbmd0aCA9IE51bWJlcihsZWJEZWNvZGUocGlwZSkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXRob2RzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzZXJ2TGVuZ3RoLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWVMZW5ndGggPSBOdW1iZXIobGViRGVjb2RlKHBpcGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZ1bmNOYW1lID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKHNhZmVSZWFkKHBpcGUsIG5hbWVMZW5ndGgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZ1bmNUeXBlID0gc2xlYkRlY29kZShwaXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZHMucHVzaChbZnVuY05hbWUsIGZ1bmNUeXBlXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHlwZVRhYmxlLnB1c2goW3R5LCBtZXRob2RzXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgb3BfY29kZTogJyArIHR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByYXdMaXN0ID0gW107XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IE51bWJlcihsZWJEZWNvZGUocGlwZSkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByYXdMaXN0LnB1c2goTnVtYmVyKHNsZWJEZWNvZGUocGlwZSkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3R5cGVUYWJsZSwgcmF3TGlzdF07XG4gICAgfVxuICAgIGNvbnN0IFtyYXdUYWJsZSwgcmF3VHlwZXNdID0gcmVhZFR5cGVUYWJsZShiKTtcbiAgICBpZiAocmF3VHlwZXMubGVuZ3RoIDwgcmV0VHlwZXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV3JvbmcgbnVtYmVyIG9mIHJldHVybiB2YWx1ZXMnKTtcbiAgICB9XG4gICAgY29uc3QgdGFibGUgPSByYXdUYWJsZS5tYXAoXyA9PiBSZWMoKSk7XG4gICAgZnVuY3Rpb24gZ2V0VHlwZSh0KSB7XG4gICAgICAgIGlmICh0IDwgLTI0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Z1dHVyZSB2YWx1ZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHQgPCAwKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIC0xOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbDtcbiAgICAgICAgICAgICAgICBjYXNlIC0yOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQm9vbDtcbiAgICAgICAgICAgICAgICBjYXNlIC0zOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTmF0O1xuICAgICAgICAgICAgICAgIGNhc2UgLTQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJbnQ7XG4gICAgICAgICAgICAgICAgY2FzZSAtNTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE5hdDg7XG4gICAgICAgICAgICAgICAgY2FzZSAtNjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE5hdDE2O1xuICAgICAgICAgICAgICAgIGNhc2UgLTc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOYXQzMjtcbiAgICAgICAgICAgICAgICBjYXNlIC04OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTmF0NjQ7XG4gICAgICAgICAgICAgICAgY2FzZSAtOTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEludDg7XG4gICAgICAgICAgICAgICAgY2FzZSAtMTA6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJbnQxNjtcbiAgICAgICAgICAgICAgICBjYXNlIC0xMTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEludDMyO1xuICAgICAgICAgICAgICAgIGNhc2UgLTEyOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSW50NjQ7XG4gICAgICAgICAgICAgICAgY2FzZSAtMTM6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGbG9hdDMyO1xuICAgICAgICAgICAgICAgIGNhc2UgLTE0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmxvYXQ2NDtcbiAgICAgICAgICAgICAgICBjYXNlIC0xNTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRleHQ7XG4gICAgICAgICAgICAgICAgY2FzZSAtMTY6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSZXNlcnZlZDtcbiAgICAgICAgICAgICAgICBjYXNlIC0xNzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEVtcHR5O1xuICAgICAgICAgICAgICAgIGNhc2UgLTI0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJpbmNpcGFsO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBvcF9jb2RlOiAnICsgdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHQgPj0gcmF3VGFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3R5cGUgaW5kZXggb3V0IG9mIHJhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhYmxlW3RdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBidWlsZFR5cGUoZW50cnkpIHtcbiAgICAgICAgc3dpdGNoIChlbnRyeVswXSkge1xuICAgICAgICAgICAgY2FzZSAtMTkgLyogSURMVHlwZUlkcy5WZWN0b3IgKi86IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0eSA9IGdldFR5cGUoZW50cnlbMV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBWZWModHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAtMTggLyogSURMVHlwZUlkcy5PcHQgKi86IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0eSA9IGdldFR5cGUoZW50cnlbMV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBPcHQodHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAtMjAgLyogSURMVHlwZUlkcy5SZWNvcmQgKi86IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZHMgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtoYXNoLCB0eV0gb2YgZW50cnlbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGBfJHtoYXNofV9gO1xuICAgICAgICAgICAgICAgICAgICBmaWVsZHNbbmFtZV0gPSBnZXRUeXBlKHR5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVjb3JkID0gUmVjb3JkKGZpZWxkcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHVwbGUgPSByZWNvcmQudHJ5QXNUdXBsZSgpO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHR1cGxlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVHVwbGUoLi4udHVwbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIC0yMSAvKiBJRExUeXBlSWRzLlZhcmlhbnQgKi86IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZHMgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtoYXNoLCB0eV0gb2YgZW50cnlbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGBfJHtoYXNofV9gO1xuICAgICAgICAgICAgICAgICAgICBmaWVsZHNbbmFtZV0gPSBnZXRUeXBlKHR5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFZhcmlhbnQoZmllbGRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgLTIyIC8qIElETFR5cGVJZHMuRnVuYyAqLzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IFthcmdzLCByZXR1cm5WYWx1ZXMsIGFubm90YXRpb25zXSA9IGVudHJ5WzFdO1xuICAgICAgICAgICAgICAgIHJldHVybiBGdW5jKGFyZ3MubWFwKCh0KSA9PiBnZXRUeXBlKHQpKSwgcmV0dXJuVmFsdWVzLm1hcCgodCkgPT4gZ2V0VHlwZSh0KSksIGFubm90YXRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgLTIzIC8qIElETFR5cGVJZHMuU2VydmljZSAqLzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlYyA9IHt9O1xuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGhvZHMgPSBlbnRyeVsxXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCB0eXBlUmVmXSBvZiBtZXRob2RzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0eXBlID0gZ2V0VHlwZSh0eXBlUmVmKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgaW5zdGFuY2VvZiBSZWNDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdW5wYWNrIHJlZmVyZW5jZSB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gdHlwZS5nZXRUeXBlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodHlwZSBpbnN0YW5jZW9mIEZ1bmNDbGFzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBzZXJ2aWNlIGRlZmluaXRpb246IHNlcnZpY2VzIGNhbiBvbmx5IGNvbnRhaW4gZnVuY3Rpb25zJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVjW25hbWVdID0gdHlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNlcnZpY2UocmVjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIG9wX2NvZGU6ICcgKyBlbnRyeVswXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmF3VGFibGUuZm9yRWFjaCgoZW50cnksIGkpID0+IHtcbiAgICAgICAgLy8gUHJvY2VzcyBmdW5jdGlvbiB0eXBlIGZpcnN0LCBzbyB0aGF0IHdlIGNhbiBjb25zdHJ1Y3QgdGhlIGNvcnJlY3Qgc2VydmljZSB0eXBlXG4gICAgICAgIGlmIChlbnRyeVswXSA9PT0gLTIyIC8qIElETFR5cGVJZHMuRnVuYyAqLykge1xuICAgICAgICAgICAgY29uc3QgdCA9IGJ1aWxkVHlwZShlbnRyeSk7XG4gICAgICAgICAgICB0YWJsZVtpXS5maWxsKHQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmF3VGFibGUuZm9yRWFjaCgoZW50cnksIGkpID0+IHtcbiAgICAgICAgaWYgKGVudHJ5WzBdICE9PSAtMjIgLyogSURMVHlwZUlkcy5GdW5jICovKSB7XG4gICAgICAgICAgICBjb25zdCB0ID0gYnVpbGRUeXBlKGVudHJ5KTtcbiAgICAgICAgICAgIHRhYmxlW2ldLmZpbGwodCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCB0eXBlcyA9IHJhd1R5cGVzLm1hcCh0ID0+IGdldFR5cGUodCkpO1xuICAgIGNvbnN0IG91dHB1dCA9IHJldFR5cGVzLm1hcCgodCwgaSkgPT4ge1xuICAgICAgICByZXR1cm4gdC5kZWNvZGVWYWx1ZShiLCB0eXBlc1tpXSk7XG4gICAgfSk7XG4gICAgLy8gc2tpcCB1bnVzZWQgdmFsdWVzXG4gICAgZm9yIChsZXQgaW5kID0gcmV0VHlwZXMubGVuZ3RoOyBpbmQgPCB0eXBlcy5sZW5ndGg7IGluZCsrKSB7XG4gICAgICAgIHR5cGVzW2luZF0uZGVjb2RlVmFsdWUoYiwgdHlwZXNbaW5kXSk7XG4gICAgfVxuICAgIGlmIChiLmJ5dGVMZW5ndGggPiAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGVjb2RlOiBMZWZ0LW92ZXIgYnl0ZXMnKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbn1cbi8vIEV4cG9ydCBUeXBlcyBpbnN0YW5jZXMuXG5leHBvcnQgY29uc3QgRW1wdHkgPSBuZXcgRW1wdHlDbGFzcygpO1xuZXhwb3J0IGNvbnN0IFJlc2VydmVkID0gbmV3IFJlc2VydmVkQ2xhc3MoKTtcbi8qKlxuICogQ2xpZW50LW9ubHkgdHlwZSBmb3IgZGVzZXJpYWxpemluZyB1bmtub3duIGRhdGEuIE5vdCBzdXBwb3J0ZWQgYnkgQ2FuZGlkLCBhbmQgaXRzIHVzZSBpcyBkaXNjb3VyYWdlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IFVua25vd24gPSBuZXcgVW5rbm93bkNsYXNzKCk7XG5leHBvcnQgY29uc3QgQm9vbCA9IG5ldyBCb29sQ2xhc3MoKTtcbmV4cG9ydCBjb25zdCBOdWxsID0gbmV3IE51bGxDbGFzcygpO1xuZXhwb3J0IGNvbnN0IFRleHQgPSBuZXcgVGV4dENsYXNzKCk7XG5leHBvcnQgY29uc3QgSW50ID0gbmV3IEludENsYXNzKCk7XG5leHBvcnQgY29uc3QgTmF0ID0gbmV3IE5hdENsYXNzKCk7XG5leHBvcnQgY29uc3QgRmxvYXQzMiA9IG5ldyBGbG9hdENsYXNzKDMyKTtcbmV4cG9ydCBjb25zdCBGbG9hdDY0ID0gbmV3IEZsb2F0Q2xhc3MoNjQpO1xuZXhwb3J0IGNvbnN0IEludDggPSBuZXcgRml4ZWRJbnRDbGFzcyg4KTtcbmV4cG9ydCBjb25zdCBJbnQxNiA9IG5ldyBGaXhlZEludENsYXNzKDE2KTtcbmV4cG9ydCBjb25zdCBJbnQzMiA9IG5ldyBGaXhlZEludENsYXNzKDMyKTtcbmV4cG9ydCBjb25zdCBJbnQ2NCA9IG5ldyBGaXhlZEludENsYXNzKDY0KTtcbmV4cG9ydCBjb25zdCBOYXQ4ID0gbmV3IEZpeGVkTmF0Q2xhc3MoOCk7XG5leHBvcnQgY29uc3QgTmF0MTYgPSBuZXcgRml4ZWROYXRDbGFzcygxNik7XG5leHBvcnQgY29uc3QgTmF0MzIgPSBuZXcgRml4ZWROYXRDbGFzcygzMik7XG5leHBvcnQgY29uc3QgTmF0NjQgPSBuZXcgRml4ZWROYXRDbGFzcyg2NCk7XG5leHBvcnQgY29uc3QgUHJpbmNpcGFsID0gbmV3IFByaW5jaXBhbENsYXNzKCk7XG4vKipcbiAqXG4gKiBAcGFyYW0gdHlwZXMgYXJyYXkgb2YgYW55IHR5cGVzXG4gKiBAcmV0dXJucyBUdXBsZUNsYXNzIGZyb20gdGhvc2UgdHlwZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFR1cGxlKC4uLnR5cGVzKSB7XG4gICAgcmV0dXJuIG5ldyBUdXBsZUNsYXNzKHR5cGVzKTtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSB0IElETCBUeXBlXG4gKiBAcmV0dXJucyBWZWNDbGFzcyBmcm9tIHRoYXQgdHlwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gVmVjKHQpIHtcbiAgICByZXR1cm4gbmV3IFZlY0NsYXNzKHQpO1xufVxuLyoqXG4gKlxuICogQHBhcmFtIHQgSURMIFR5cGVcbiAqIEByZXR1cm5zIE9wdENsYXNzIG9mIFR5cGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIE9wdCh0KSB7XG4gICAgcmV0dXJuIG5ldyBPcHRDbGFzcyh0KTtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSB0IFJlY29yZCBvZiBzdHJpbmcgYW5kIElETCBUeXBlXG4gKiBAcmV0dXJucyBSZWNvcmRDbGFzcyBvZiBzdHJpbmcgYW5kIFR5cGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFJlY29yZCh0KSB7XG4gICAgcmV0dXJuIG5ldyBSZWNvcmRDbGFzcyh0KTtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSBmaWVsZHMgUmVjb3JkIG9mIHN0cmluZyBhbmQgSURMIFR5cGVcbiAqIEByZXR1cm5zIFZhcmlhbnRDbGFzc1xuICovXG5leHBvcnQgZnVuY3Rpb24gVmFyaWFudChmaWVsZHMpIHtcbiAgICByZXR1cm4gbmV3IFZhcmlhbnRDbGFzcyhmaWVsZHMpO1xufVxuLyoqXG4gKlxuICogQHJldHVybnMgbmV3IFJlY0NsYXNzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBSZWMoKSB7XG4gICAgcmV0dXJuIG5ldyBSZWNDbGFzcygpO1xufVxuLyoqXG4gKlxuICogQHBhcmFtIGFyZ3MgYXJyYXkgb2YgSURMIFR5cGVzXG4gKiBAcGFyYW0gcmV0IGFycmF5IG9mIElETCBUeXBlc1xuICogQHBhcmFtIGFubm90YXRpb25zIGFycmF5IG9mIHN0cmluZ3MsIFtdIGJ5IGRlZmF1bHRcbiAqIEByZXR1cm5zIG5ldyBGdW5jQ2xhc3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZ1bmMoYXJncywgcmV0LCBhbm5vdGF0aW9ucyA9IFtdKSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jQ2xhc3MoYXJncywgcmV0LCBhbm5vdGF0aW9ucyk7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gdCBSZWNvcmQgb2Ygc3RyaW5nIGFuZCBGdW5jQ2xhc3NcbiAqIEByZXR1cm5zIFNlcnZpY2VDbGFzc1xuICovXG5leHBvcnQgZnVuY3Rpb24gU2VydmljZSh0KSB7XG4gICAgcmV0dXJuIG5ldyBTZXJ2aWNlQ2xhc3ModCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pZGwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/candid/lib/esm/idl.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dfinity/candid/lib/esm/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@dfinity/candid/lib/esm/index.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IDL: function() { return /* reexport module object */ _idl__WEBPACK_IMPORTED_MODULE_2__; },\n/* harmony export */   InputBox: function() { return /* reexport safe */ _candid_core__WEBPACK_IMPORTED_MODULE_1__.InputBox; },\n/* harmony export */   InputForm: function() { return /* reexport safe */ _candid_core__WEBPACK_IMPORTED_MODULE_1__.InputForm; },\n/* harmony export */   OptionForm: function() { return /* reexport safe */ _candid_core__WEBPACK_IMPORTED_MODULE_1__.OptionForm; },\n/* harmony export */   PipeArrayBuffer: function() { return /* reexport safe */ _utils_buffer__WEBPACK_IMPORTED_MODULE_5__.PipeArrayBuffer; },\n/* harmony export */   RecordForm: function() { return /* reexport safe */ _candid_core__WEBPACK_IMPORTED_MODULE_1__.RecordForm; },\n/* harmony export */   Render: function() { return /* reexport safe */ _candid_ui__WEBPACK_IMPORTED_MODULE_0__.Render; },\n/* harmony export */   TupleForm: function() { return /* reexport safe */ _candid_core__WEBPACK_IMPORTED_MODULE_1__.TupleForm; },\n/* harmony export */   VariantForm: function() { return /* reexport safe */ _candid_core__WEBPACK_IMPORTED_MODULE_1__.VariantForm; },\n/* harmony export */   VecForm: function() { return /* reexport safe */ _candid_core__WEBPACK_IMPORTED_MODULE_1__.VecForm; },\n/* harmony export */   bufFromBufLike: function() { return /* reexport safe */ _utils_buffer__WEBPACK_IMPORTED_MODULE_5__.bufFromBufLike; },\n/* harmony export */   concat: function() { return /* reexport safe */ _utils_buffer__WEBPACK_IMPORTED_MODULE_5__.concat; },\n/* harmony export */   fromHexString: function() { return /* reexport safe */ _utils_buffer__WEBPACK_IMPORTED_MODULE_5__.fromHexString; },\n/* harmony export */   idlLabelToId: function() { return /* reexport safe */ _utils_hash__WEBPACK_IMPORTED_MODULE_3__.idlLabelToId; },\n/* harmony export */   inputBox: function() { return /* reexport safe */ _candid_ui__WEBPACK_IMPORTED_MODULE_0__.inputBox; },\n/* harmony export */   lebDecode: function() { return /* reexport safe */ _utils_leb128__WEBPACK_IMPORTED_MODULE_4__.lebDecode; },\n/* harmony export */   lebEncode: function() { return /* reexport safe */ _utils_leb128__WEBPACK_IMPORTED_MODULE_4__.lebEncode; },\n/* harmony export */   optForm: function() { return /* reexport safe */ _candid_ui__WEBPACK_IMPORTED_MODULE_0__.optForm; },\n/* harmony export */   readIntLE: function() { return /* reexport safe */ _utils_leb128__WEBPACK_IMPORTED_MODULE_4__.readIntLE; },\n/* harmony export */   readUIntLE: function() { return /* reexport safe */ _utils_leb128__WEBPACK_IMPORTED_MODULE_4__.readUIntLE; },\n/* harmony export */   recordForm: function() { return /* reexport safe */ _candid_ui__WEBPACK_IMPORTED_MODULE_0__.recordForm; },\n/* harmony export */   renderInput: function() { return /* reexport safe */ _candid_ui__WEBPACK_IMPORTED_MODULE_0__.renderInput; },\n/* harmony export */   renderValue: function() { return /* reexport safe */ _candid_ui__WEBPACK_IMPORTED_MODULE_0__.renderValue; },\n/* harmony export */   safeRead: function() { return /* reexport safe */ _utils_leb128__WEBPACK_IMPORTED_MODULE_4__.safeRead; },\n/* harmony export */   safeReadUint8: function() { return /* reexport safe */ _utils_leb128__WEBPACK_IMPORTED_MODULE_4__.safeReadUint8; },\n/* harmony export */   slebDecode: function() { return /* reexport safe */ _utils_leb128__WEBPACK_IMPORTED_MODULE_4__.slebDecode; },\n/* harmony export */   slebEncode: function() { return /* reexport safe */ _utils_leb128__WEBPACK_IMPORTED_MODULE_4__.slebEncode; },\n/* harmony export */   toHexString: function() { return /* reexport safe */ _utils_buffer__WEBPACK_IMPORTED_MODULE_5__.toHexString; },\n/* harmony export */   tupleForm: function() { return /* reexport safe */ _candid_ui__WEBPACK_IMPORTED_MODULE_0__.tupleForm; },\n/* harmony export */   uint8ToBuf: function() { return /* reexport safe */ _utils_buffer__WEBPACK_IMPORTED_MODULE_5__.uint8ToBuf; },\n/* harmony export */   variantForm: function() { return /* reexport safe */ _candid_ui__WEBPACK_IMPORTED_MODULE_0__.variantForm; },\n/* harmony export */   vecForm: function() { return /* reexport safe */ _candid_ui__WEBPACK_IMPORTED_MODULE_0__.vecForm; },\n/* harmony export */   writeIntLE: function() { return /* reexport safe */ _utils_leb128__WEBPACK_IMPORTED_MODULE_4__.writeIntLE; },\n/* harmony export */   writeUIntLE: function() { return /* reexport safe */ _utils_leb128__WEBPACK_IMPORTED_MODULE_4__.writeUIntLE; }\n/* harmony export */ });\n/* harmony import */ var _candid_ui__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./candid-ui */ \"(app-pages-browser)/./node_modules/@dfinity/candid/lib/esm/candid-ui.js\");\n/* harmony import */ var _candid_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./candid-core */ \"(app-pages-browser)/./node_modules/@dfinity/candid/lib/esm/candid-core.js\");\n/* harmony import */ var _idl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./idl */ \"(app-pages-browser)/./node_modules/@dfinity/candid/lib/esm/idl.js\");\n/* harmony import */ var _utils_hash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/hash */ \"(app-pages-browser)/./node_modules/@dfinity/candid/lib/esm/utils/hash.js\");\n/* harmony import */ var _utils_leb128__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/leb128 */ \"(app-pages-browser)/./node_modules/@dfinity/candid/lib/esm/utils/leb128.js\");\n/* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/buffer */ \"(app-pages-browser)/./node_modules/@dfinity/candid/lib/esm/utils/buffer.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./types */ \"(app-pages-browser)/./node_modules/@dfinity/candid/lib/esm/types.js\");\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9jYW5kaWQvbGliL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE0QjtBQUNFO0FBQ0Q7QUFDQTtBQUNFO0FBQ0E7QUFDUDtBQUN4QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGRmaW5pdHkvY2FuZGlkL2xpYi9lc20vaW5kZXguanM/OWQ3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL2NhbmRpZC11aSc7XG5leHBvcnQgKiBmcm9tICcuL2NhbmRpZC1jb3JlJztcbmV4cG9ydCAqIGFzIElETCBmcm9tICcuL2lkbCc7XG5leHBvcnQgKiBmcm9tICcuL3V0aWxzL2hhc2gnO1xuZXhwb3J0ICogZnJvbSAnLi91dGlscy9sZWIxMjgnO1xuZXhwb3J0ICogZnJvbSAnLi91dGlscy9idWZmZXInO1xuZXhwb3J0ICogZnJvbSAnLi90eXBlcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/candid/lib/esm/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dfinity/candid/lib/esm/types.js":
/*!*******************************************************!*\
  !*** ./node_modules/@dfinity/candid/lib/esm/types.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9jYW5kaWQvbGliL2VzbS90eXBlcy5qcyIsIm1hcHBpbmdzIjoiO0FBQVU7QUFDViIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGRmaW5pdHkvY2FuZGlkL2xpYi9lc20vdHlwZXMuanM/MmE4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/candid/lib/esm/types.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dfinity/candid/lib/esm/utils/bigint-math.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@dfinity/candid/lib/esm/utils/bigint-math.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   iexp2: function() { return /* binding */ iexp2; },\n/* harmony export */   ilog2: function() { return /* binding */ ilog2; }\n/* harmony export */ });\n/**\n * Equivalent to `Math.log2(n)` with support for `BigInt` values\n * @param n bigint or integer\n * @returns integer\n */\nfunction ilog2(n) {\n    const nBig = BigInt(n);\n    if (n <= 0) {\n        throw new RangeError('Input must be positive');\n    }\n    return nBig.toString(2).length - 1;\n}\n/**\n * Equivalent to `2 ** n` with support for `BigInt` values\n * (necessary for browser preprocessors which replace the `**` operator with `Math.pow`)\n * @param n bigint or integer\n * @returns bigint\n */\nfunction iexp2(n) {\n    const nBig = BigInt(n);\n    if (n < 0) {\n        throw new RangeError('Input must be non-negative');\n    }\n    return BigInt(1) << nBig;\n}\n//# sourceMappingURL=bigint-math.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9jYW5kaWQvbGliL2VzbS91dGlscy9iaWdpbnQtbWF0aC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2NhbmRpZC9saWIvZXNtL3V0aWxzL2JpZ2ludC1tYXRoLmpzPzg3ZjciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFcXVpdmFsZW50IHRvIGBNYXRoLmxvZzIobilgIHdpdGggc3VwcG9ydCBmb3IgYEJpZ0ludGAgdmFsdWVzXG4gKiBAcGFyYW0gbiBiaWdpbnQgb3IgaW50ZWdlclxuICogQHJldHVybnMgaW50ZWdlclxuICovXG5leHBvcnQgZnVuY3Rpb24gaWxvZzIobikge1xuICAgIGNvbnN0IG5CaWcgPSBCaWdJbnQobik7XG4gICAgaWYgKG4gPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5wdXQgbXVzdCBiZSBwb3NpdGl2ZScpO1xuICAgIH1cbiAgICByZXR1cm4gbkJpZy50b1N0cmluZygyKS5sZW5ndGggLSAxO1xufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIGAyICoqIG5gIHdpdGggc3VwcG9ydCBmb3IgYEJpZ0ludGAgdmFsdWVzXG4gKiAobmVjZXNzYXJ5IGZvciBicm93c2VyIHByZXByb2Nlc3NvcnMgd2hpY2ggcmVwbGFjZSB0aGUgYCoqYCBvcGVyYXRvciB3aXRoIGBNYXRoLnBvd2ApXG4gKiBAcGFyYW0gbiBiaWdpbnQgb3IgaW50ZWdlclxuICogQHJldHVybnMgYmlnaW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZXhwMihuKSB7XG4gICAgY29uc3QgbkJpZyA9IEJpZ0ludChuKTtcbiAgICBpZiAobiA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0lucHV0IG11c3QgYmUgbm9uLW5lZ2F0aXZlJyk7XG4gICAgfVxuICAgIHJldHVybiBCaWdJbnQoMSkgPDwgbkJpZztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpZ2ludC1tYXRoLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/candid/lib/esm/utils/bigint-math.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dfinity/candid/lib/esm/utils/buffer.js":
/*!**************************************************************!*\
  !*** ./node_modules/@dfinity/candid/lib/esm/utils/buffer.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PipeArrayBuffer: function() { return /* binding */ PipeArrayBuffer; },\n/* harmony export */   bufFromBufLike: function() { return /* binding */ bufFromBufLike; },\n/* harmony export */   concat: function() { return /* binding */ concat; },\n/* harmony export */   fromHexString: function() { return /* binding */ fromHexString; },\n/* harmony export */   toHexString: function() { return /* binding */ toHexString; },\n/* harmony export */   uint8ToBuf: function() { return /* binding */ uint8ToBuf; }\n/* harmony export */ });\n/**\n * Concatenate multiple array buffers.\n * @param buffers The buffers to concatenate.\n */\nfunction concat(...buffers) {\n    const result = new Uint8Array(buffers.reduce((acc, curr) => acc + curr.byteLength, 0));\n    let index = 0;\n    for (const b of buffers) {\n        result.set(new Uint8Array(b), index);\n        index += b.byteLength;\n    }\n    return result;\n}\n/**\n * Returns an hexadecimal representation of an array buffer.\n * @param bytes The array buffer.\n */\nfunction toHexString(bytes) {\n    return new Uint8Array(bytes).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n/**\n * Return an array buffer from its hexadecimal representation.\n * @param hexString The hexadecimal string.\n */\nfunction fromHexString(hexString) {\n    var _a;\n    return new Uint8Array(((_a = hexString.match(/.{1,2}/g)) !== null && _a !== void 0 ? _a : []).map(byte => parseInt(byte, 16)));\n}\n/**\n * A class that abstracts a pipe-like ArrayBuffer.\n */\nclass PipeArrayBuffer {\n    /**\n     * Creates a new instance of a pipe\n     * @param buffer an optional buffer to start with\n     * @param length an optional amount of bytes to use for the length.\n     */\n    constructor(buffer, length = (buffer === null || buffer === void 0 ? void 0 : buffer.byteLength) || 0) {\n        this._buffer = bufFromBufLike(buffer || new ArrayBuffer(0));\n        this._view = new Uint8Array(this._buffer, 0, length);\n    }\n    get buffer() {\n        // Return a copy of the buffer.\n        return bufFromBufLike(this._view.slice());\n    }\n    get byteLength() {\n        return this._view.byteLength;\n    }\n    /**\n     * Read `num` number of bytes from the front of the pipe.\n     * @param num The number of bytes to read.\n     */\n    read(num) {\n        const result = this._view.subarray(0, num);\n        this._view = this._view.subarray(num);\n        return result.slice().buffer;\n    }\n    readUint8() {\n        const result = this._view[0];\n        this._view = this._view.subarray(1);\n        return result;\n    }\n    /**\n     * Write a buffer to the end of the pipe.\n     * @param buf The bytes to write.\n     */\n    write(buf) {\n        const b = new Uint8Array(buf);\n        const offset = this._view.byteLength;\n        if (this._view.byteOffset + this._view.byteLength + b.byteLength >= this._buffer.byteLength) {\n            // Alloc grow the view to include the new bytes.\n            this.alloc(b.byteLength);\n        }\n        else {\n            // Update the view to include the new bytes.\n            this._view = new Uint8Array(this._buffer, this._view.byteOffset, this._view.byteLength + b.byteLength);\n        }\n        this._view.set(b, offset);\n    }\n    /**\n     * Whether or not there is more data to read from the buffer\n     */\n    get end() {\n        return this._view.byteLength === 0;\n    }\n    /**\n     * Allocate a fixed amount of memory in the buffer. This does not affect the view.\n     * @param amount A number of bytes to add to the buffer.\n     */\n    alloc(amount) {\n        // Add a little bit of exponential growth.\n        const b = new ArrayBuffer(((this._buffer.byteLength + amount) * 1.2) | 0);\n        const v = new Uint8Array(b, 0, this._view.byteLength + amount);\n        v.set(this._view);\n        this._buffer = b;\n        this._view = v;\n    }\n}\n/**\n * Returns a true ArrayBuffer from a Uint8Array, as Uint8Array.buffer is unsafe.\n * @param {Uint8Array} arr Uint8Array to convert\n * @returns ArrayBuffer\n */\nfunction uint8ToBuf(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength).buffer;\n}\n/**\n * Returns a true ArrayBuffer from an ArrayBufferLike object.\n * @param bufLike a buffer-like object\n * @returns ArrayBuffer\n */\nfunction bufFromBufLike(bufLike) {\n    if (bufLike instanceof Uint8Array) {\n        return uint8ToBuf(bufLike);\n    }\n    if (bufLike instanceof ArrayBuffer) {\n        return bufLike;\n    }\n    if (Array.isArray(bufLike)) {\n        return uint8ToBuf(new Uint8Array(bufLike));\n    }\n    if ('buffer' in bufLike) {\n        return bufFromBufLike(bufLike.buffer);\n    }\n    return uint8ToBuf(new Uint8Array(bufLike));\n}\n//# sourceMappingURL=buffer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9jYW5kaWQvbGliL2VzbS91dGlscy9idWZmZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLG9EQUFvRCxJQUFJO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2NhbmRpZC9saWIvZXNtL3V0aWxzL2J1ZmZlci5qcz9iN2I3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29uY2F0ZW5hdGUgbXVsdGlwbGUgYXJyYXkgYnVmZmVycy5cbiAqIEBwYXJhbSBidWZmZXJzIFRoZSBidWZmZXJzIHRvIGNvbmNhdGVuYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0KC4uLmJ1ZmZlcnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShidWZmZXJzLnJlZHVjZSgoYWNjLCBjdXJyKSA9PiBhY2MgKyBjdXJyLmJ5dGVMZW5ndGgsIDApKTtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGZvciAoY29uc3QgYiBvZiBidWZmZXJzKSB7XG4gICAgICAgIHJlc3VsdC5zZXQobmV3IFVpbnQ4QXJyYXkoYiksIGluZGV4KTtcbiAgICAgICAgaW5kZXggKz0gYi5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBSZXR1cm5zIGFuIGhleGFkZWNpbWFsIHJlcHJlc2VudGF0aW9uIG9mIGFuIGFycmF5IGJ1ZmZlci5cbiAqIEBwYXJhbSBieXRlcyBUaGUgYXJyYXkgYnVmZmVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9IZXhTdHJpbmcoYnl0ZXMpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpLnJlZHVjZSgoc3RyLCBieXRlKSA9PiBzdHIgKyBieXRlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpLCAnJyk7XG59XG4vKipcbiAqIFJldHVybiBhbiBhcnJheSBidWZmZXIgZnJvbSBpdHMgaGV4YWRlY2ltYWwgcmVwcmVzZW50YXRpb24uXG4gKiBAcGFyYW0gaGV4U3RyaW5nIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tSGV4U3RyaW5nKGhleFN0cmluZykge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoKChfYSA9IGhleFN0cmluZy5tYXRjaCgvLnsxLDJ9L2cpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSkubWFwKGJ5dGUgPT4gcGFyc2VJbnQoYnl0ZSwgMTYpKSk7XG59XG4vKipcbiAqIEEgY2xhc3MgdGhhdCBhYnN0cmFjdHMgYSBwaXBlLWxpa2UgQXJyYXlCdWZmZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBQaXBlQXJyYXlCdWZmZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYSBwaXBlXG4gICAgICogQHBhcmFtIGJ1ZmZlciBhbiBvcHRpb25hbCBidWZmZXIgdG8gc3RhcnQgd2l0aFxuICAgICAqIEBwYXJhbSBsZW5ndGggYW4gb3B0aW9uYWwgYW1vdW50IG9mIGJ5dGVzIHRvIHVzZSBmb3IgdGhlIGxlbmd0aC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihidWZmZXIsIGxlbmd0aCA9IChidWZmZXIgPT09IG51bGwgfHwgYnVmZmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBidWZmZXIuYnl0ZUxlbmd0aCkgfHwgMCkge1xuICAgICAgICB0aGlzLl9idWZmZXIgPSBidWZGcm9tQnVmTGlrZShidWZmZXIgfHwgbmV3IEFycmF5QnVmZmVyKDApKTtcbiAgICAgICAgdGhpcy5fdmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMuX2J1ZmZlciwgMCwgbGVuZ3RoKTtcbiAgICB9XG4gICAgZ2V0IGJ1ZmZlcigpIHtcbiAgICAgICAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgYnVmZmVyLlxuICAgICAgICByZXR1cm4gYnVmRnJvbUJ1Zkxpa2UodGhpcy5fdmlldy5zbGljZSgpKTtcbiAgICB9XG4gICAgZ2V0IGJ5dGVMZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aWV3LmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYG51bWAgbnVtYmVyIG9mIGJ5dGVzIGZyb20gdGhlIGZyb250IG9mIHRoZSBwaXBlLlxuICAgICAqIEBwYXJhbSBudW0gVGhlIG51bWJlciBvZiBieXRlcyB0byByZWFkLlxuICAgICAqL1xuICAgIHJlYWQobnVtKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3ZpZXcuc3ViYXJyYXkoMCwgbnVtKTtcbiAgICAgICAgdGhpcy5fdmlldyA9IHRoaXMuX3ZpZXcuc3ViYXJyYXkobnVtKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zbGljZSgpLmJ1ZmZlcjtcbiAgICB9XG4gICAgcmVhZFVpbnQ4KCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl92aWV3WzBdO1xuICAgICAgICB0aGlzLl92aWV3ID0gdGhpcy5fdmlldy5zdWJhcnJheSgxKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBidWZmZXIgdG8gdGhlIGVuZCBvZiB0aGUgcGlwZS5cbiAgICAgKiBAcGFyYW0gYnVmIFRoZSBieXRlcyB0byB3cml0ZS5cbiAgICAgKi9cbiAgICB3cml0ZShidWYpIHtcbiAgICAgICAgY29uc3QgYiA9IG5ldyBVaW50OEFycmF5KGJ1Zik7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX3ZpZXcuYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMuX3ZpZXcuYnl0ZU9mZnNldCArIHRoaXMuX3ZpZXcuYnl0ZUxlbmd0aCArIGIuYnl0ZUxlbmd0aCA+PSB0aGlzLl9idWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgLy8gQWxsb2MgZ3JvdyB0aGUgdmlldyB0byBpbmNsdWRlIHRoZSBuZXcgYnl0ZXMuXG4gICAgICAgICAgICB0aGlzLmFsbG9jKGIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHZpZXcgdG8gaW5jbHVkZSB0aGUgbmV3IGJ5dGVzLlxuICAgICAgICAgICAgdGhpcy5fdmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMuX2J1ZmZlciwgdGhpcy5fdmlldy5ieXRlT2Zmc2V0LCB0aGlzLl92aWV3LmJ5dGVMZW5ndGggKyBiLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZpZXcuc2V0KGIsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZXJlIGlzIG1vcmUgZGF0YSB0byByZWFkIGZyb20gdGhlIGJ1ZmZlclxuICAgICAqL1xuICAgIGdldCBlbmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aWV3LmJ5dGVMZW5ndGggPT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsbG9jYXRlIGEgZml4ZWQgYW1vdW50IG9mIG1lbW9yeSBpbiB0aGUgYnVmZmVyLiBUaGlzIGRvZXMgbm90IGFmZmVjdCB0aGUgdmlldy5cbiAgICAgKiBAcGFyYW0gYW1vdW50IEEgbnVtYmVyIG9mIGJ5dGVzIHRvIGFkZCB0byB0aGUgYnVmZmVyLlxuICAgICAqL1xuICAgIGFsbG9jKGFtb3VudCkge1xuICAgICAgICAvLyBBZGQgYSBsaXR0bGUgYml0IG9mIGV4cG9uZW50aWFsIGdyb3d0aC5cbiAgICAgICAgY29uc3QgYiA9IG5ldyBBcnJheUJ1ZmZlcigoKHRoaXMuX2J1ZmZlci5ieXRlTGVuZ3RoICsgYW1vdW50KSAqIDEuMikgfCAwKTtcbiAgICAgICAgY29uc3QgdiA9IG5ldyBVaW50OEFycmF5KGIsIDAsIHRoaXMuX3ZpZXcuYnl0ZUxlbmd0aCArIGFtb3VudCk7XG4gICAgICAgIHYuc2V0KHRoaXMuX3ZpZXcpO1xuICAgICAgICB0aGlzLl9idWZmZXIgPSBiO1xuICAgICAgICB0aGlzLl92aWV3ID0gdjtcbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgYSB0cnVlIEFycmF5QnVmZmVyIGZyb20gYSBVaW50OEFycmF5LCBhcyBVaW50OEFycmF5LmJ1ZmZlciBpcyB1bnNhZmUuXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGFyciBVaW50OEFycmF5IHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIEFycmF5QnVmZmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1aW50OFRvQnVmKGFycikge1xuICAgIHJldHVybiBuZXcgRGF0YVZpZXcoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKS5idWZmZXI7XG59XG4vKipcbiAqIFJldHVybnMgYSB0cnVlIEFycmF5QnVmZmVyIGZyb20gYW4gQXJyYXlCdWZmZXJMaWtlIG9iamVjdC5cbiAqIEBwYXJhbSBidWZMaWtlIGEgYnVmZmVyLWxpa2Ugb2JqZWN0XG4gKiBAcmV0dXJucyBBcnJheUJ1ZmZlclxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVmRnJvbUJ1Zkxpa2UoYnVmTGlrZSkge1xuICAgIGlmIChidWZMaWtlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICByZXR1cm4gdWludDhUb0J1ZihidWZMaWtlKTtcbiAgICB9XG4gICAgaWYgKGJ1Zkxpa2UgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gYnVmTGlrZTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYnVmTGlrZSkpIHtcbiAgICAgICAgcmV0dXJuIHVpbnQ4VG9CdWYobmV3IFVpbnQ4QXJyYXkoYnVmTGlrZSkpO1xuICAgIH1cbiAgICBpZiAoJ2J1ZmZlcicgaW4gYnVmTGlrZSkge1xuICAgICAgICByZXR1cm4gYnVmRnJvbUJ1Zkxpa2UoYnVmTGlrZS5idWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdWludDhUb0J1ZihuZXcgVWludDhBcnJheShidWZMaWtlKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWZmZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/candid/lib/esm/utils/buffer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dfinity/candid/lib/esm/utils/hash.js":
/*!************************************************************!*\
  !*** ./node_modules/@dfinity/candid/lib/esm/utils/hash.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   idlLabelToId: function() { return /* binding */ idlLabelToId; }\n/* harmony export */ });\n/**\n * Hashes a string to a number. Algorithm can be found here:\n * https://caml.inria.fr/pub/papers/garrigue-polymorphic_variants-ml98.pdf\n * @param s - string to hash\n * @returns number representing hashed string\n */\nfunction idlHash(s) {\n    const utf8encoder = new TextEncoder();\n    const array = utf8encoder.encode(s);\n    let h = 0;\n    for (const c of array) {\n        h = (h * 223 + c) % 2 ** 32;\n    }\n    return h;\n}\n/**\n *\n * @param label string\n * @returns number representing hashed label\n */\nfunction idlLabelToId(label) {\n    if (/^_\\d+_$/.test(label) || /^_0x[0-9a-fA-F]+_$/.test(label)) {\n        const num = +label.slice(1, -1);\n        if (Number.isSafeInteger(num) && num >= 0 && num < 2 ** 32) {\n            return num;\n        }\n    }\n    return idlHash(label);\n}\n//# sourceMappingURL=hash.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9jYW5kaWQvbGliL2VzbS91dGlscy9oYXNoLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2NhbmRpZC9saWIvZXNtL3V0aWxzL2hhc2guanM/ODc2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEhhc2hlcyBhIHN0cmluZyB0byBhIG51bWJlci4gQWxnb3JpdGhtIGNhbiBiZSBmb3VuZCBoZXJlOlxuICogaHR0cHM6Ly9jYW1sLmlucmlhLmZyL3B1Yi9wYXBlcnMvZ2FycmlndWUtcG9seW1vcnBoaWNfdmFyaWFudHMtbWw5OC5wZGZcbiAqIEBwYXJhbSBzIC0gc3RyaW5nIHRvIGhhc2hcbiAqIEByZXR1cm5zIG51bWJlciByZXByZXNlbnRpbmcgaGFzaGVkIHN0cmluZ1xuICovXG5mdW5jdGlvbiBpZGxIYXNoKHMpIHtcbiAgICBjb25zdCB1dGY4ZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIGNvbnN0IGFycmF5ID0gdXRmOGVuY29kZXIuZW5jb2RlKHMpO1xuICAgIGxldCBoID0gMDtcbiAgICBmb3IgKGNvbnN0IGMgb2YgYXJyYXkpIHtcbiAgICAgICAgaCA9IChoICogMjIzICsgYykgJSAyICoqIDMyO1xuICAgIH1cbiAgICByZXR1cm4gaDtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSBsYWJlbCBzdHJpbmdcbiAqIEByZXR1cm5zIG51bWJlciByZXByZXNlbnRpbmcgaGFzaGVkIGxhYmVsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZGxMYWJlbFRvSWQobGFiZWwpIHtcbiAgICBpZiAoL15fXFxkK18kLy50ZXN0KGxhYmVsKSB8fCAvXl8weFswLTlhLWZBLUZdK18kLy50ZXN0KGxhYmVsKSkge1xuICAgICAgICBjb25zdCBudW0gPSArbGFiZWwuc2xpY2UoMSwgLTEpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzU2FmZUludGVnZXIobnVtKSAmJiBudW0gPj0gMCAmJiBudW0gPCAyICoqIDMyKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpZGxIYXNoKGxhYmVsKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhc2guanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/candid/lib/esm/utils/hash.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dfinity/candid/lib/esm/utils/leb128.js":
/*!**************************************************************!*\
  !*** ./node_modules/@dfinity/candid/lib/esm/utils/leb128.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   lebDecode: function() { return /* binding */ lebDecode; },\n/* harmony export */   lebEncode: function() { return /* binding */ lebEncode; },\n/* harmony export */   readIntLE: function() { return /* binding */ readIntLE; },\n/* harmony export */   readUIntLE: function() { return /* binding */ readUIntLE; },\n/* harmony export */   safeRead: function() { return /* binding */ safeRead; },\n/* harmony export */   safeReadUint8: function() { return /* binding */ safeReadUint8; },\n/* harmony export */   slebDecode: function() { return /* binding */ slebDecode; },\n/* harmony export */   slebEncode: function() { return /* binding */ slebEncode; },\n/* harmony export */   writeIntLE: function() { return /* binding */ writeIntLE; },\n/* harmony export */   writeUIntLE: function() { return /* binding */ writeUIntLE; }\n/* harmony export */ });\n/* harmony import */ var _buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buffer */ \"(app-pages-browser)/./node_modules/@dfinity/candid/lib/esm/utils/buffer.js\");\n/* eslint-disable no-constant-condition */\n// Note: this file uses buffer-pipe, which on Node only, uses the Node Buffer\n//       implementation, which isn't compatible with the NPM buffer package\n//       which we use everywhere else. This means that we have to transform\n//       one into the other, hence why every function that returns a Buffer\n//       actually return `new Buffer(pipe.buffer)`.\n// TODO: The best solution would be to have our own buffer type around\n//       Uint8Array which is standard.\n\nfunction eob() {\n    throw new Error('unexpected end of buffer');\n}\n/**\n *\n * @param pipe Pipe from buffer-pipe\n * @param num number\n * @returns Buffer\n */\nfunction safeRead(pipe, num) {\n    if (pipe.byteLength < num) {\n        eob();\n    }\n    return pipe.read(num);\n}\n/**\n * @param pipe - PipeArrayBuffer simulating buffer-pipe api\n */\nfunction safeReadUint8(pipe) {\n    const byte = pipe.readUint8();\n    if (byte === undefined) {\n        eob();\n    }\n    return byte;\n}\n/**\n * Encode a positive number (or bigint) into a Buffer. The number will be floored to the\n * nearest integer.\n * @param value The number to encode.\n */\nfunction lebEncode(value) {\n    if (typeof value === 'number') {\n        value = BigInt(value);\n    }\n    if (value < BigInt(0)) {\n        throw new Error('Cannot leb encode negative values.');\n    }\n    const byteLength = (value === BigInt(0) ? 0 : Math.ceil(Math.log2(Number(value)))) + 1;\n    const pipe = new _buffer__WEBPACK_IMPORTED_MODULE_0__.PipeArrayBuffer(new ArrayBuffer(byteLength), 0);\n    while (true) {\n        const i = Number(value & BigInt(0x7f));\n        value /= BigInt(0x80);\n        if (value === BigInt(0)) {\n            pipe.write(new Uint8Array([i]));\n            break;\n        }\n        else {\n            pipe.write(new Uint8Array([i | 0x80]));\n        }\n    }\n    return pipe.buffer;\n}\n/**\n * Decode a leb encoded buffer into a bigint. The number will always be positive (does not\n * support signed leb encoding).\n * @param pipe A Buffer containing the leb encoded bits.\n */\nfunction lebDecode(pipe) {\n    let weight = BigInt(1);\n    let value = BigInt(0);\n    let byte;\n    do {\n        byte = safeReadUint8(pipe);\n        value += BigInt(byte & 0x7f).valueOf() * weight;\n        weight *= BigInt(128);\n    } while (byte >= 0x80);\n    return value;\n}\n/**\n * Encode a number (or bigint) into a Buffer, with support for negative numbers. The number\n * will be floored to the nearest integer.\n * @param value The number to encode.\n */\nfunction slebEncode(value) {\n    if (typeof value === 'number') {\n        value = BigInt(value);\n    }\n    const isNeg = value < BigInt(0);\n    if (isNeg) {\n        value = -value - BigInt(1);\n    }\n    const byteLength = (value === BigInt(0) ? 0 : Math.ceil(Math.log2(Number(value)))) + 1;\n    const pipe = new _buffer__WEBPACK_IMPORTED_MODULE_0__.PipeArrayBuffer(new ArrayBuffer(byteLength), 0);\n    while (true) {\n        const i = getLowerBytes(value);\n        value /= BigInt(0x80);\n        // prettier-ignore\n        if ((isNeg && value === BigInt(0) && (i & 0x40) !== 0)\n            || (!isNeg && value === BigInt(0) && (i & 0x40) === 0)) {\n            pipe.write(new Uint8Array([i]));\n            break;\n        }\n        else {\n            pipe.write(new Uint8Array([i | 0x80]));\n        }\n    }\n    function getLowerBytes(num) {\n        const bytes = num % BigInt(0x80);\n        if (isNeg) {\n            // We swap the bits here again, and remove 1 to do two's complement.\n            return Number(BigInt(0x80) - bytes - BigInt(1));\n        }\n        else {\n            return Number(bytes);\n        }\n    }\n    return pipe.buffer;\n}\n/**\n * Decode a leb encoded buffer into a bigint. The number is decoded with support for negative\n * signed-leb encoding.\n * @param pipe A Buffer containing the signed leb encoded bits.\n */\nfunction slebDecode(pipe) {\n    // Get the size of the buffer, then cut a buffer of that size.\n    const pipeView = new Uint8Array(pipe.buffer);\n    let len = 0;\n    for (; len < pipeView.byteLength; len++) {\n        if (pipeView[len] < 0x80) {\n            // If it's a positive number, we reuse lebDecode.\n            if ((pipeView[len] & 0x40) === 0) {\n                return lebDecode(pipe);\n            }\n            break;\n        }\n    }\n    const bytes = new Uint8Array(safeRead(pipe, len + 1));\n    let value = BigInt(0);\n    for (let i = bytes.byteLength - 1; i >= 0; i--) {\n        value = value * BigInt(0x80) + BigInt(0x80 - (bytes[i] & 0x7f) - 1);\n    }\n    return -value - BigInt(1);\n}\n/**\n *\n * @param value bigint or number\n * @param byteLength number\n * @returns Buffer\n */\nfunction writeUIntLE(value, byteLength) {\n    if (BigInt(value) < BigInt(0)) {\n        throw new Error('Cannot write negative values.');\n    }\n    return writeIntLE(value, byteLength);\n}\n/**\n *\n * @param value - bigint or number\n * @param byteLength - number\n * @returns ArrayBuffer\n */\nfunction writeIntLE(value, byteLength) {\n    value = BigInt(value);\n    const pipe = new _buffer__WEBPACK_IMPORTED_MODULE_0__.PipeArrayBuffer(new ArrayBuffer(Math.min(1, byteLength)), 0);\n    let i = 0;\n    let mul = BigInt(256);\n    let sub = BigInt(0);\n    let byte = Number(value % mul);\n    pipe.write(new Uint8Array([byte]));\n    while (++i < byteLength) {\n        if (value < 0 && sub === BigInt(0) && byte !== 0) {\n            sub = BigInt(1);\n        }\n        byte = Number((value / mul - sub) % BigInt(256));\n        pipe.write(new Uint8Array([byte]));\n        mul *= BigInt(256);\n    }\n    return pipe.buffer;\n}\n/**\n *\n * @param pipe Pipe from buffer-pipe\n * @param byteLength number\n * @returns bigint\n */\nfunction readUIntLE(pipe, byteLength) {\n    let val = BigInt(safeReadUint8(pipe));\n    let mul = BigInt(1);\n    let i = 0;\n    while (++i < byteLength) {\n        mul *= BigInt(256);\n        const byte = BigInt(safeReadUint8(pipe));\n        val = val + mul * byte;\n    }\n    return val;\n}\n/**\n *\n * @param pipe Pipe from buffer-pipe\n * @param byteLength number\n * @returns bigint\n */\nfunction readIntLE(pipe, byteLength) {\n    let val = readUIntLE(pipe, byteLength);\n    const mul = BigInt(2) ** (BigInt(8) * BigInt(byteLength - 1) + BigInt(7));\n    if (val >= mul) {\n        val -= mul * BigInt(2);\n    }\n    return val;\n}\n//# sourceMappingURL=leb128.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9jYW5kaWQvbGliL2VzbS91dGlscy9sZWIxMjguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ21EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0RBQUk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvREFBSTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkJBQTJCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EscUJBQXFCLG9EQUFJO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2NhbmRpZC9saWIvZXNtL3V0aWxzL2xlYjEyOC5qcz81OTdmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnN0YW50LWNvbmRpdGlvbiAqL1xuLy8gTm90ZTogdGhpcyBmaWxlIHVzZXMgYnVmZmVyLXBpcGUsIHdoaWNoIG9uIE5vZGUgb25seSwgdXNlcyB0aGUgTm9kZSBCdWZmZXJcbi8vICAgICAgIGltcGxlbWVudGF0aW9uLCB3aGljaCBpc24ndCBjb21wYXRpYmxlIHdpdGggdGhlIE5QTSBidWZmZXIgcGFja2FnZVxuLy8gICAgICAgd2hpY2ggd2UgdXNlIGV2ZXJ5d2hlcmUgZWxzZS4gVGhpcyBtZWFucyB0aGF0IHdlIGhhdmUgdG8gdHJhbnNmb3JtXG4vLyAgICAgICBvbmUgaW50byB0aGUgb3RoZXIsIGhlbmNlIHdoeSBldmVyeSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBCdWZmZXJcbi8vICAgICAgIGFjdHVhbGx5IHJldHVybiBgbmV3IEJ1ZmZlcihwaXBlLmJ1ZmZlcilgLlxuLy8gVE9ETzogVGhlIGJlc3Qgc29sdXRpb24gd291bGQgYmUgdG8gaGF2ZSBvdXIgb3duIGJ1ZmZlciB0eXBlIGFyb3VuZFxuLy8gICAgICAgVWludDhBcnJheSB3aGljaCBpcyBzdGFuZGFyZC5cbmltcG9ydCB7IFBpcGVBcnJheUJ1ZmZlciBhcyBQaXBlIH0gZnJvbSAnLi9idWZmZXInO1xuZnVuY3Rpb24gZW9iKCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBlbmQgb2YgYnVmZmVyJyk7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gcGlwZSBQaXBlIGZyb20gYnVmZmVyLXBpcGVcbiAqIEBwYXJhbSBudW0gbnVtYmVyXG4gKiBAcmV0dXJucyBCdWZmZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNhZmVSZWFkKHBpcGUsIG51bSkge1xuICAgIGlmIChwaXBlLmJ5dGVMZW5ndGggPCBudW0pIHtcbiAgICAgICAgZW9iKCk7XG4gICAgfVxuICAgIHJldHVybiBwaXBlLnJlYWQobnVtKTtcbn1cbi8qKlxuICogQHBhcmFtIHBpcGUgLSBQaXBlQXJyYXlCdWZmZXIgc2ltdWxhdGluZyBidWZmZXItcGlwZSBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNhZmVSZWFkVWludDgocGlwZSkge1xuICAgIGNvbnN0IGJ5dGUgPSBwaXBlLnJlYWRVaW50OCgpO1xuICAgIGlmIChieXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZW9iKCk7XG4gICAgfVxuICAgIHJldHVybiBieXRlO1xufVxuLyoqXG4gKiBFbmNvZGUgYSBwb3NpdGl2ZSBudW1iZXIgKG9yIGJpZ2ludCkgaW50byBhIEJ1ZmZlci4gVGhlIG51bWJlciB3aWxsIGJlIGZsb29yZWQgdG8gdGhlXG4gKiBuZWFyZXN0IGludGVnZXIuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIG51bWJlciB0byBlbmNvZGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZWJFbmNvZGUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICB2YWx1ZSA9IEJpZ0ludCh2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA8IEJpZ0ludCgwKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBsZWIgZW5jb2RlIG5lZ2F0aXZlIHZhbHVlcy4nKTtcbiAgICB9XG4gICAgY29uc3QgYnl0ZUxlbmd0aCA9ICh2YWx1ZSA9PT0gQmlnSW50KDApID8gMCA6IE1hdGguY2VpbChNYXRoLmxvZzIoTnVtYmVyKHZhbHVlKSkpKSArIDE7XG4gICAgY29uc3QgcGlwZSA9IG5ldyBQaXBlKG5ldyBBcnJheUJ1ZmZlcihieXRlTGVuZ3RoKSwgMCk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgaSA9IE51bWJlcih2YWx1ZSAmIEJpZ0ludCgweDdmKSk7XG4gICAgICAgIHZhbHVlIC89IEJpZ0ludCgweDgwKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSBCaWdJbnQoMCkpIHtcbiAgICAgICAgICAgIHBpcGUud3JpdGUobmV3IFVpbnQ4QXJyYXkoW2ldKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBpcGUud3JpdGUobmV3IFVpbnQ4QXJyYXkoW2kgfCAweDgwXSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwaXBlLmJ1ZmZlcjtcbn1cbi8qKlxuICogRGVjb2RlIGEgbGViIGVuY29kZWQgYnVmZmVyIGludG8gYSBiaWdpbnQuIFRoZSBudW1iZXIgd2lsbCBhbHdheXMgYmUgcG9zaXRpdmUgKGRvZXMgbm90XG4gKiBzdXBwb3J0IHNpZ25lZCBsZWIgZW5jb2RpbmcpLlxuICogQHBhcmFtIHBpcGUgQSBCdWZmZXIgY29udGFpbmluZyB0aGUgbGViIGVuY29kZWQgYml0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxlYkRlY29kZShwaXBlKSB7XG4gICAgbGV0IHdlaWdodCA9IEJpZ0ludCgxKTtcbiAgICBsZXQgdmFsdWUgPSBCaWdJbnQoMCk7XG4gICAgbGV0IGJ5dGU7XG4gICAgZG8ge1xuICAgICAgICBieXRlID0gc2FmZVJlYWRVaW50OChwaXBlKTtcbiAgICAgICAgdmFsdWUgKz0gQmlnSW50KGJ5dGUgJiAweDdmKS52YWx1ZU9mKCkgKiB3ZWlnaHQ7XG4gICAgICAgIHdlaWdodCAqPSBCaWdJbnQoMTI4KTtcbiAgICB9IHdoaWxlIChieXRlID49IDB4ODApO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogRW5jb2RlIGEgbnVtYmVyIChvciBiaWdpbnQpIGludG8gYSBCdWZmZXIsIHdpdGggc3VwcG9ydCBmb3IgbmVnYXRpdmUgbnVtYmVycy4gVGhlIG51bWJlclxuICogd2lsbCBiZSBmbG9vcmVkIHRvIHRoZSBuZWFyZXN0IGludGVnZXIuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIG51bWJlciB0byBlbmNvZGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzbGViRW5jb2RlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFsdWUgPSBCaWdJbnQodmFsdWUpO1xuICAgIH1cbiAgICBjb25zdCBpc05lZyA9IHZhbHVlIDwgQmlnSW50KDApO1xuICAgIGlmIChpc05lZykge1xuICAgICAgICB2YWx1ZSA9IC12YWx1ZSAtIEJpZ0ludCgxKTtcbiAgICB9XG4gICAgY29uc3QgYnl0ZUxlbmd0aCA9ICh2YWx1ZSA9PT0gQmlnSW50KDApID8gMCA6IE1hdGguY2VpbChNYXRoLmxvZzIoTnVtYmVyKHZhbHVlKSkpKSArIDE7XG4gICAgY29uc3QgcGlwZSA9IG5ldyBQaXBlKG5ldyBBcnJheUJ1ZmZlcihieXRlTGVuZ3RoKSwgMCk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgaSA9IGdldExvd2VyQnl0ZXModmFsdWUpO1xuICAgICAgICB2YWx1ZSAvPSBCaWdJbnQoMHg4MCk7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBpZiAoKGlzTmVnICYmIHZhbHVlID09PSBCaWdJbnQoMCkgJiYgKGkgJiAweDQwKSAhPT0gMClcbiAgICAgICAgICAgIHx8ICghaXNOZWcgJiYgdmFsdWUgPT09IEJpZ0ludCgwKSAmJiAoaSAmIDB4NDApID09PSAwKSkge1xuICAgICAgICAgICAgcGlwZS53cml0ZShuZXcgVWludDhBcnJheShbaV0pKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGlwZS53cml0ZShuZXcgVWludDhBcnJheShbaSB8IDB4ODBdKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0TG93ZXJCeXRlcyhudW0pIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBudW0gJSBCaWdJbnQoMHg4MCk7XG4gICAgICAgIGlmIChpc05lZykge1xuICAgICAgICAgICAgLy8gV2Ugc3dhcCB0aGUgYml0cyBoZXJlIGFnYWluLCBhbmQgcmVtb3ZlIDEgdG8gZG8gdHdvJ3MgY29tcGxlbWVudC5cbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIoQmlnSW50KDB4ODApIC0gYnl0ZXMgLSBCaWdJbnQoMSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlcihieXRlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBpcGUuYnVmZmVyO1xufVxuLyoqXG4gKiBEZWNvZGUgYSBsZWIgZW5jb2RlZCBidWZmZXIgaW50byBhIGJpZ2ludC4gVGhlIG51bWJlciBpcyBkZWNvZGVkIHdpdGggc3VwcG9ydCBmb3IgbmVnYXRpdmVcbiAqIHNpZ25lZC1sZWIgZW5jb2RpbmcuXG4gKiBAcGFyYW0gcGlwZSBBIEJ1ZmZlciBjb250YWluaW5nIHRoZSBzaWduZWQgbGViIGVuY29kZWQgYml0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNsZWJEZWNvZGUocGlwZSkge1xuICAgIC8vIEdldCB0aGUgc2l6ZSBvZiB0aGUgYnVmZmVyLCB0aGVuIGN1dCBhIGJ1ZmZlciBvZiB0aGF0IHNpemUuXG4gICAgY29uc3QgcGlwZVZpZXcgPSBuZXcgVWludDhBcnJheShwaXBlLmJ1ZmZlcik7XG4gICAgbGV0IGxlbiA9IDA7XG4gICAgZm9yICg7IGxlbiA8IHBpcGVWaWV3LmJ5dGVMZW5ndGg7IGxlbisrKSB7XG4gICAgICAgIGlmIChwaXBlVmlld1tsZW5dIDwgMHg4MCkge1xuICAgICAgICAgICAgLy8gSWYgaXQncyBhIHBvc2l0aXZlIG51bWJlciwgd2UgcmV1c2UgbGViRGVjb2RlLlxuICAgICAgICAgICAgaWYgKChwaXBlVmlld1tsZW5dICYgMHg0MCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGViRGVjb2RlKHBpcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShzYWZlUmVhZChwaXBlLCBsZW4gKyAxKSk7XG4gICAgbGV0IHZhbHVlID0gQmlnSW50KDApO1xuICAgIGZvciAobGV0IGkgPSBieXRlcy5ieXRlTGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSAqIEJpZ0ludCgweDgwKSArIEJpZ0ludCgweDgwIC0gKGJ5dGVzW2ldICYgMHg3ZikgLSAxKTtcbiAgICB9XG4gICAgcmV0dXJuIC12YWx1ZSAtIEJpZ0ludCgxKTtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSB2YWx1ZSBiaWdpbnQgb3IgbnVtYmVyXG4gKiBAcGFyYW0gYnl0ZUxlbmd0aCBudW1iZXJcbiAqIEByZXR1cm5zIEJ1ZmZlclxuICovXG5leHBvcnQgZnVuY3Rpb24gd3JpdGVVSW50TEUodmFsdWUsIGJ5dGVMZW5ndGgpIHtcbiAgICBpZiAoQmlnSW50KHZhbHVlKSA8IEJpZ0ludCgwKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB3cml0ZSBuZWdhdGl2ZSB2YWx1ZXMuJyk7XG4gICAgfVxuICAgIHJldHVybiB3cml0ZUludExFKHZhbHVlLCBieXRlTGVuZ3RoKTtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIGJpZ2ludCBvciBudW1iZXJcbiAqIEBwYXJhbSBieXRlTGVuZ3RoIC0gbnVtYmVyXG4gKiBAcmV0dXJucyBBcnJheUJ1ZmZlclxuICovXG5leHBvcnQgZnVuY3Rpb24gd3JpdGVJbnRMRSh2YWx1ZSwgYnl0ZUxlbmd0aCkge1xuICAgIHZhbHVlID0gQmlnSW50KHZhbHVlKTtcbiAgICBjb25zdCBwaXBlID0gbmV3IFBpcGUobmV3IEFycmF5QnVmZmVyKE1hdGgubWluKDEsIGJ5dGVMZW5ndGgpKSwgMCk7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBtdWwgPSBCaWdJbnQoMjU2KTtcbiAgICBsZXQgc3ViID0gQmlnSW50KDApO1xuICAgIGxldCBieXRlID0gTnVtYmVyKHZhbHVlICUgbXVsKTtcbiAgICBwaXBlLndyaXRlKG5ldyBVaW50OEFycmF5KFtieXRlXSkpO1xuICAgIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoKSB7XG4gICAgICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSBCaWdJbnQoMCkgJiYgYnl0ZSAhPT0gMCkge1xuICAgICAgICAgICAgc3ViID0gQmlnSW50KDEpO1xuICAgICAgICB9XG4gICAgICAgIGJ5dGUgPSBOdW1iZXIoKHZhbHVlIC8gbXVsIC0gc3ViKSAlIEJpZ0ludCgyNTYpKTtcbiAgICAgICAgcGlwZS53cml0ZShuZXcgVWludDhBcnJheShbYnl0ZV0pKTtcbiAgICAgICAgbXVsICo9IEJpZ0ludCgyNTYpO1xuICAgIH1cbiAgICByZXR1cm4gcGlwZS5idWZmZXI7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gcGlwZSBQaXBlIGZyb20gYnVmZmVyLXBpcGVcbiAqIEBwYXJhbSBieXRlTGVuZ3RoIG51bWJlclxuICogQHJldHVybnMgYmlnaW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkVUludExFKHBpcGUsIGJ5dGVMZW5ndGgpIHtcbiAgICBsZXQgdmFsID0gQmlnSW50KHNhZmVSZWFkVWludDgocGlwZSkpO1xuICAgIGxldCBtdWwgPSBCaWdJbnQoMSk7XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoKSB7XG4gICAgICAgIG11bCAqPSBCaWdJbnQoMjU2KTtcbiAgICAgICAgY29uc3QgYnl0ZSA9IEJpZ0ludChzYWZlUmVhZFVpbnQ4KHBpcGUpKTtcbiAgICAgICAgdmFsID0gdmFsICsgbXVsICogYnl0ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSBwaXBlIFBpcGUgZnJvbSBidWZmZXItcGlwZVxuICogQHBhcmFtIGJ5dGVMZW5ndGggbnVtYmVyXG4gKiBAcmV0dXJucyBiaWdpbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRJbnRMRShwaXBlLCBieXRlTGVuZ3RoKSB7XG4gICAgbGV0IHZhbCA9IHJlYWRVSW50TEUocGlwZSwgYnl0ZUxlbmd0aCk7XG4gICAgY29uc3QgbXVsID0gQmlnSW50KDIpICoqIChCaWdJbnQoOCkgKiBCaWdJbnQoYnl0ZUxlbmd0aCAtIDEpICsgQmlnSW50KDcpKTtcbiAgICBpZiAodmFsID49IG11bCkge1xuICAgICAgICB2YWwgLT0gbXVsICogQmlnSW50KDIpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGViMTI4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/candid/lib/esm/utils/leb128.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dfinity/principal/lib/esm/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@dfinity/principal/lib/esm/index.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JSON_KEY_PRINCIPAL: function() { return /* binding */ JSON_KEY_PRINCIPAL; },\n/* harmony export */   Principal: function() { return /* binding */ Principal; }\n/* harmony export */ });\n/* harmony import */ var _utils_base32__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/base32 */ \"(app-pages-browser)/./node_modules/@dfinity/principal/lib/esm/utils/base32.js\");\n/* harmony import */ var _utils_getCrc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/getCrc */ \"(app-pages-browser)/./node_modules/@dfinity/principal/lib/esm/utils/getCrc.js\");\n/* harmony import */ var _utils_sha224__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/sha224 */ \"(app-pages-browser)/./node_modules/@dfinity/principal/lib/esm/utils/sha224.js\");\n\n\n\nconst JSON_KEY_PRINCIPAL = '__principal__';\nconst SELF_AUTHENTICATING_SUFFIX = 2;\nconst ANONYMOUS_SUFFIX = 4;\nconst MANAGEMENT_CANISTER_PRINCIPAL_HEX_STR = 'aaaaa-aa';\nconst fromHexString = (hexString) => { var _a; return new Uint8Array(((_a = hexString.match(/.{1,2}/g)) !== null && _a !== void 0 ? _a : []).map(byte => parseInt(byte, 16))); };\nconst toHexString = (bytes) => bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\nclass Principal {\n    constructor(_arr) {\n        this._arr = _arr;\n        this._isPrincipal = true;\n    }\n    static anonymous() {\n        return new this(new Uint8Array([ANONYMOUS_SUFFIX]));\n    }\n    /**\n     * Utility method, returning the principal representing the management canister, decoded from the hex string `'aaaaa-aa'`\n     * @returns {Principal} principal of the management canister\n     */\n    static managementCanister() {\n        return this.fromHex(MANAGEMENT_CANISTER_PRINCIPAL_HEX_STR);\n    }\n    static selfAuthenticating(publicKey) {\n        const sha = (0,_utils_sha224__WEBPACK_IMPORTED_MODULE_2__.sha224)(publicKey);\n        return new this(new Uint8Array([...sha, SELF_AUTHENTICATING_SUFFIX]));\n    }\n    static from(other) {\n        if (typeof other === 'string') {\n            return Principal.fromText(other);\n        }\n        else if (Object.getPrototypeOf(other) === Uint8Array.prototype) {\n            return new Principal(other);\n        }\n        else if (typeof other === 'object' &&\n            other !== null &&\n            other._isPrincipal === true) {\n            return new Principal(other._arr);\n        }\n        throw new Error(`Impossible to convert ${JSON.stringify(other)} to Principal.`);\n    }\n    static fromHex(hex) {\n        return new this(fromHexString(hex));\n    }\n    static fromText(text) {\n        let maybePrincipal = text;\n        // If formatted as JSON string, parse it first\n        if (text.includes(JSON_KEY_PRINCIPAL)) {\n            const obj = JSON.parse(text);\n            if (JSON_KEY_PRINCIPAL in obj) {\n                maybePrincipal = obj[JSON_KEY_PRINCIPAL];\n            }\n        }\n        const canisterIdNoDash = maybePrincipal.toLowerCase().replace(/-/g, '');\n        let arr = (0,_utils_base32__WEBPACK_IMPORTED_MODULE_0__.decode)(canisterIdNoDash);\n        arr = arr.slice(4, arr.length);\n        const principal = new this(arr);\n        if (principal.toText() !== maybePrincipal) {\n            throw new Error(`Principal \"${principal.toText()}\" does not have a valid checksum (original value \"${maybePrincipal}\" may not be a valid Principal ID).`);\n        }\n        return principal;\n    }\n    static fromUint8Array(arr) {\n        return new this(arr);\n    }\n    isAnonymous() {\n        return this._arr.byteLength === 1 && this._arr[0] === ANONYMOUS_SUFFIX;\n    }\n    toUint8Array() {\n        return this._arr;\n    }\n    toHex() {\n        return toHexString(this._arr).toUpperCase();\n    }\n    toText() {\n        const checksumArrayBuf = new ArrayBuffer(4);\n        const view = new DataView(checksumArrayBuf);\n        view.setUint32(0, (0,_utils_getCrc__WEBPACK_IMPORTED_MODULE_1__.getCrc32)(this._arr));\n        const checksum = new Uint8Array(checksumArrayBuf);\n        const bytes = Uint8Array.from(this._arr);\n        const array = new Uint8Array([...checksum, ...bytes]);\n        const result = (0,_utils_base32__WEBPACK_IMPORTED_MODULE_0__.encode)(array);\n        const matches = result.match(/.{1,5}/g);\n        if (!matches) {\n            // This should only happen if there's no character, which is unreachable.\n            throw new Error();\n        }\n        return matches.join('-');\n    }\n    toString() {\n        return this.toText();\n    }\n    /**\n     * Serializes to JSON\n     * @returns {JsonnablePrincipal} a JSON object with a single key, {@link JSON_KEY_PRINCIPAL}, whose value is the principal as a string\n     */\n    toJSON() {\n        return { [JSON_KEY_PRINCIPAL]: this.toText() };\n    }\n    /**\n     * Utility method taking a Principal to compare against. Used for determining canister ranges in certificate verification\n     * @param {Principal} other - a {@link Principal} to compare\n     * @returns {'lt' | 'eq' | 'gt'} `'lt' | 'eq' | 'gt'` a string, representing less than, equal to, or greater than\n     */\n    compareTo(other) {\n        for (let i = 0; i < Math.min(this._arr.length, other._arr.length); i++) {\n            if (this._arr[i] < other._arr[i])\n                return 'lt';\n            else if (this._arr[i] > other._arr[i])\n                return 'gt';\n        }\n        // Here, at least one principal is a prefix of the other principal (they could be the same)\n        if (this._arr.length < other._arr.length)\n            return 'lt';\n        if (this._arr.length > other._arr.length)\n            return 'gt';\n        return 'eq';\n    }\n    /**\n     * Utility method checking whether a provided Principal is less than or equal to the current one using the {@link Principal.compareTo} method\n     * @param other a {@link Principal} to compare\n     * @returns {boolean} boolean\n     */\n    ltEq(other) {\n        const cmp = this.compareTo(other);\n        return cmp == 'lt' || cmp == 'eq';\n    }\n    /**\n     * Utility method checking whether a provided Principal is greater than or equal to the current one using the {@link Principal.compareTo} method\n     * @param other a {@link Principal} to compare\n     * @returns {boolean} boolean\n     */\n    gtEq(other) {\n        const cmp = this.compareTo(other);\n        return cmp == 'gt' || cmp == 'eq';\n    }\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9wcmluY2lwYWwvbGliL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFnRDtBQUNOO0FBQ0Y7QUFDakM7QUFDUDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUSxnREFBZ0QsSUFBSTtBQUNuRztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFdBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxREFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHVCQUF1QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFEQUFNO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxtQkFBbUIsb0RBQW9ELGVBQWU7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVEQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxREFBTTtBQUM3Qix3Q0FBd0MsSUFBSTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9CQUFvQixrQ0FBa0MseUJBQXlCO0FBQ2hHO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXLFdBQVcsaUJBQWlCO0FBQ3RELGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTtBQUNBLHdCQUF3QixtREFBbUQ7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnSEFBZ0gsMkJBQTJCO0FBQzNJLHVCQUF1QixpQkFBaUI7QUFDeEMsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUhBQW1ILDJCQUEyQjtBQUM5SSx1QkFBdUIsaUJBQWlCO0FBQ3hDLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9wcmluY2lwYWwvbGliL2VzbS9pbmRleC5qcz84MGY5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlY29kZSwgZW5jb2RlIH0gZnJvbSAnLi91dGlscy9iYXNlMzInO1xuaW1wb3J0IHsgZ2V0Q3JjMzIgfSBmcm9tICcuL3V0aWxzL2dldENyYyc7XG5pbXBvcnQgeyBzaGEyMjQgfSBmcm9tICcuL3V0aWxzL3NoYTIyNCc7XG5leHBvcnQgY29uc3QgSlNPTl9LRVlfUFJJTkNJUEFMID0gJ19fcHJpbmNpcGFsX18nO1xuY29uc3QgU0VMRl9BVVRIRU5USUNBVElOR19TVUZGSVggPSAyO1xuY29uc3QgQU5PTllNT1VTX1NVRkZJWCA9IDQ7XG5jb25zdCBNQU5BR0VNRU5UX0NBTklTVEVSX1BSSU5DSVBBTF9IRVhfU1RSID0gJ2FhYWFhLWFhJztcbmNvbnN0IGZyb21IZXhTdHJpbmcgPSAoaGV4U3RyaW5nKSA9PiB7IHZhciBfYTsgcmV0dXJuIG5ldyBVaW50OEFycmF5KCgoX2EgPSBoZXhTdHJpbmcubWF0Y2goLy57MSwyfS9nKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10pLm1hcChieXRlID0+IHBhcnNlSW50KGJ5dGUsIDE2KSkpOyB9O1xuY29uc3QgdG9IZXhTdHJpbmcgPSAoYnl0ZXMpID0+IGJ5dGVzLnJlZHVjZSgoc3RyLCBieXRlKSA9PiBzdHIgKyBieXRlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpLCAnJyk7XG5leHBvcnQgY2xhc3MgUHJpbmNpcGFsIHtcbiAgICBjb25zdHJ1Y3RvcihfYXJyKSB7XG4gICAgICAgIHRoaXMuX2FyciA9IF9hcnI7XG4gICAgICAgIHRoaXMuX2lzUHJpbmNpcGFsID0gdHJ1ZTtcbiAgICB9XG4gICAgc3RhdGljIGFub255bW91cygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKG5ldyBVaW50OEFycmF5KFtBTk9OWU1PVVNfU1VGRklYXSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZCwgcmV0dXJuaW5nIHRoZSBwcmluY2lwYWwgcmVwcmVzZW50aW5nIHRoZSBtYW5hZ2VtZW50IGNhbmlzdGVyLCBkZWNvZGVkIGZyb20gdGhlIGhleCBzdHJpbmcgYCdhYWFhYS1hYSdgXG4gICAgICogQHJldHVybnMge1ByaW5jaXBhbH0gcHJpbmNpcGFsIG9mIHRoZSBtYW5hZ2VtZW50IGNhbmlzdGVyXG4gICAgICovXG4gICAgc3RhdGljIG1hbmFnZW1lbnRDYW5pc3RlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbUhleChNQU5BR0VNRU5UX0NBTklTVEVSX1BSSU5DSVBBTF9IRVhfU1RSKTtcbiAgICB9XG4gICAgc3RhdGljIHNlbGZBdXRoZW50aWNhdGluZyhwdWJsaWNLZXkpIHtcbiAgICAgICAgY29uc3Qgc2hhID0gc2hhMjI0KHB1YmxpY0tleSk7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyhuZXcgVWludDhBcnJheShbLi4uc2hhLCBTRUxGX0FVVEhFTlRJQ0FUSU5HX1NVRkZJWF0pKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb20ob3RoZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvdGhlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBQcmluY2lwYWwuZnJvbVRleHQob3RoZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZihvdGhlcikgPT09IFVpbnQ4QXJyYXkucHJvdG90eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByaW5jaXBhbChvdGhlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG90aGVyID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgb3RoZXIgIT09IG51bGwgJiZcbiAgICAgICAgICAgIG90aGVyLl9pc1ByaW5jaXBhbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcmluY2lwYWwob3RoZXIuX2Fycik7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbXBvc3NpYmxlIHRvIGNvbnZlcnQgJHtKU09OLnN0cmluZ2lmeShvdGhlcil9IHRvIFByaW5jaXBhbC5gKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21IZXgoaGV4KSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyhmcm9tSGV4U3RyaW5nKGhleCkpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVRleHQodGV4dCkge1xuICAgICAgICBsZXQgbWF5YmVQcmluY2lwYWwgPSB0ZXh0O1xuICAgICAgICAvLyBJZiBmb3JtYXR0ZWQgYXMgSlNPTiBzdHJpbmcsIHBhcnNlIGl0IGZpcnN0XG4gICAgICAgIGlmICh0ZXh0LmluY2x1ZGVzKEpTT05fS0VZX1BSSU5DSVBBTCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG9iaiA9IEpTT04ucGFyc2UodGV4dCk7XG4gICAgICAgICAgICBpZiAoSlNPTl9LRVlfUFJJTkNJUEFMIGluIG9iaikge1xuICAgICAgICAgICAgICAgIG1heWJlUHJpbmNpcGFsID0gb2JqW0pTT05fS0VZX1BSSU5DSVBBTF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FuaXN0ZXJJZE5vRGFzaCA9IG1heWJlUHJpbmNpcGFsLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvLS9nLCAnJyk7XG4gICAgICAgIGxldCBhcnIgPSBkZWNvZGUoY2FuaXN0ZXJJZE5vRGFzaCk7XG4gICAgICAgIGFyciA9IGFyci5zbGljZSg0LCBhcnIubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgcHJpbmNpcGFsID0gbmV3IHRoaXMoYXJyKTtcbiAgICAgICAgaWYgKHByaW5jaXBhbC50b1RleHQoKSAhPT0gbWF5YmVQcmluY2lwYWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUHJpbmNpcGFsIFwiJHtwcmluY2lwYWwudG9UZXh0KCl9XCIgZG9lcyBub3QgaGF2ZSBhIHZhbGlkIGNoZWNrc3VtIChvcmlnaW5hbCB2YWx1ZSBcIiR7bWF5YmVQcmluY2lwYWx9XCIgbWF5IG5vdCBiZSBhIHZhbGlkIFByaW5jaXBhbCBJRCkuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByaW5jaXBhbDtcbiAgICB9XG4gICAgc3RhdGljIGZyb21VaW50OEFycmF5KGFycikge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMoYXJyKTtcbiAgICB9XG4gICAgaXNBbm9ueW1vdXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcnIuYnl0ZUxlbmd0aCA9PT0gMSAmJiB0aGlzLl9hcnJbMF0gPT09IEFOT05ZTU9VU19TVUZGSVg7XG4gICAgfVxuICAgIHRvVWludDhBcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FycjtcbiAgICB9XG4gICAgdG9IZXgoKSB7XG4gICAgICAgIHJldHVybiB0b0hleFN0cmluZyh0aGlzLl9hcnIpLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuICAgIHRvVGV4dCgpIHtcbiAgICAgICAgY29uc3QgY2hlY2tzdW1BcnJheUJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcig0KTtcbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhjaGVja3N1bUFycmF5QnVmKTtcbiAgICAgICAgdmlldy5zZXRVaW50MzIoMCwgZ2V0Q3JjMzIodGhpcy5fYXJyKSk7XG4gICAgICAgIGNvbnN0IGNoZWNrc3VtID0gbmV3IFVpbnQ4QXJyYXkoY2hlY2tzdW1BcnJheUJ1Zik7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gVWludDhBcnJheS5mcm9tKHRoaXMuX2Fycik7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoWy4uLmNoZWNrc3VtLCAuLi5ieXRlc10pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBlbmNvZGUoYXJyYXkpO1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gcmVzdWx0Lm1hdGNoKC8uezEsNX0vZyk7XG4gICAgICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgb25seSBoYXBwZW4gaWYgdGhlcmUncyBubyBjaGFyYWN0ZXIsIHdoaWNoIGlzIHVucmVhY2hhYmxlLlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdGNoZXMuam9pbignLScpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9UZXh0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdG8gSlNPTlxuICAgICAqIEByZXR1cm5zIHtKc29ubmFibGVQcmluY2lwYWx9IGEgSlNPTiBvYmplY3Qgd2l0aCBhIHNpbmdsZSBrZXksIHtAbGluayBKU09OX0tFWV9QUklOQ0lQQUx9LCB3aG9zZSB2YWx1ZSBpcyB0aGUgcHJpbmNpcGFsIGFzIGEgc3RyaW5nXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBbSlNPTl9LRVlfUFJJTkNJUEFMXTogdGhpcy50b1RleHQoKSB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZCB0YWtpbmcgYSBQcmluY2lwYWwgdG8gY29tcGFyZSBhZ2FpbnN0LiBVc2VkIGZvciBkZXRlcm1pbmluZyBjYW5pc3RlciByYW5nZXMgaW4gY2VydGlmaWNhdGUgdmVyaWZpY2F0aW9uXG4gICAgICogQHBhcmFtIHtQcmluY2lwYWx9IG90aGVyIC0gYSB7QGxpbmsgUHJpbmNpcGFsfSB0byBjb21wYXJlXG4gICAgICogQHJldHVybnMgeydsdCcgfCAnZXEnIHwgJ2d0J30gYCdsdCcgfCAnZXEnIHwgJ2d0J2AgYSBzdHJpbmcsIHJlcHJlc2VudGluZyBsZXNzIHRoYW4sIGVxdWFsIHRvLCBvciBncmVhdGVyIHRoYW5cbiAgICAgKi9cbiAgICBjb21wYXJlVG8ob3RoZXIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNYXRoLm1pbih0aGlzLl9hcnIubGVuZ3RoLCBvdGhlci5fYXJyLmxlbmd0aCk7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2FycltpXSA8IG90aGVyLl9hcnJbaV0pXG4gICAgICAgICAgICAgICAgcmV0dXJuICdsdCc7XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9hcnJbaV0gPiBvdGhlci5fYXJyW2ldKVxuICAgICAgICAgICAgICAgIHJldHVybiAnZ3QnO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhlcmUsIGF0IGxlYXN0IG9uZSBwcmluY2lwYWwgaXMgYSBwcmVmaXggb2YgdGhlIG90aGVyIHByaW5jaXBhbCAodGhleSBjb3VsZCBiZSB0aGUgc2FtZSlcbiAgICAgICAgaWYgKHRoaXMuX2Fyci5sZW5ndGggPCBvdGhlci5fYXJyLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiAnbHQnO1xuICAgICAgICBpZiAodGhpcy5fYXJyLmxlbmd0aCA+IG90aGVyLl9hcnIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuICdndCc7XG4gICAgICAgIHJldHVybiAnZXEnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZCBjaGVja2luZyB3aGV0aGVyIGEgcHJvdmlkZWQgUHJpbmNpcGFsIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgY3VycmVudCBvbmUgdXNpbmcgdGhlIHtAbGluayBQcmluY2lwYWwuY29tcGFyZVRvfSBtZXRob2RcbiAgICAgKiBAcGFyYW0gb3RoZXIgYSB7QGxpbmsgUHJpbmNpcGFsfSB0byBjb21wYXJlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGJvb2xlYW5cbiAgICAgKi9cbiAgICBsdEVxKG90aGVyKSB7XG4gICAgICAgIGNvbnN0IGNtcCA9IHRoaXMuY29tcGFyZVRvKG90aGVyKTtcbiAgICAgICAgcmV0dXJuIGNtcCA9PSAnbHQnIHx8IGNtcCA9PSAnZXEnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZCBjaGVja2luZyB3aGV0aGVyIGEgcHJvdmlkZWQgUHJpbmNpcGFsIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgY3VycmVudCBvbmUgdXNpbmcgdGhlIHtAbGluayBQcmluY2lwYWwuY29tcGFyZVRvfSBtZXRob2RcbiAgICAgKiBAcGFyYW0gb3RoZXIgYSB7QGxpbmsgUHJpbmNpcGFsfSB0byBjb21wYXJlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGJvb2xlYW5cbiAgICAgKi9cbiAgICBndEVxKG90aGVyKSB7XG4gICAgICAgIGNvbnN0IGNtcCA9IHRoaXMuY29tcGFyZVRvKG90aGVyKTtcbiAgICAgICAgcmV0dXJuIGNtcCA9PSAnZ3QnIHx8IGNtcCA9PSAnZXEnO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/principal/lib/esm/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dfinity/principal/lib/esm/utils/base32.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@dfinity/principal/lib/esm/utils/base32.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: function() { return /* binding */ decode; },\n/* harmony export */   encode: function() { return /* binding */ encode; }\n/* harmony export */ });\nconst alphabet = 'abcdefghijklmnopqrstuvwxyz234567';\n// Build a lookup table for decoding.\nconst lookupTable = Object.create(null);\nfor (let i = 0; i < alphabet.length; i++) {\n    lookupTable[alphabet[i]] = i;\n}\n// Add aliases for rfc4648.\nlookupTable['0'] = lookupTable.o;\nlookupTable['1'] = lookupTable.i;\n/**\n * @param input The input array to encode.\n * @returns A Base32 string encoding the input.\n */\nfunction encode(input) {\n    // How many bits will we skip from the first byte.\n    let skip = 0;\n    // 5 high bits, carry from one byte to the next.\n    let bits = 0;\n    // The output string in base32.\n    let output = '';\n    function encodeByte(byte) {\n        if (skip < 0) {\n            // we have a carry from the previous byte\n            bits |= byte >> -skip;\n        }\n        else {\n            // no carry\n            bits = (byte << skip) & 248;\n        }\n        if (skip > 3) {\n            // Not enough data to produce a character, get us another one\n            skip -= 8;\n            return 1;\n        }\n        if (skip < 4) {\n            // produce a character\n            output += alphabet[bits >> 3];\n            skip += 5;\n        }\n        return 0;\n    }\n    for (let i = 0; i < input.length;) {\n        i += encodeByte(input[i]);\n    }\n    return output + (skip < 0 ? alphabet[bits >> 3] : '');\n}\n/**\n * @param input The base32 encoded string to decode.\n */\nfunction decode(input) {\n    // how many bits we have from the previous character.\n    let skip = 0;\n    // current byte we're producing.\n    let byte = 0;\n    const output = new Uint8Array(((input.length * 4) / 3) | 0);\n    let o = 0;\n    function decodeChar(char) {\n        // Consume a character from the stream, store\n        // the output in this.output. As before, better\n        // to use update().\n        let val = lookupTable[char.toLowerCase()];\n        if (val === undefined) {\n            throw new Error(`Invalid character: ${JSON.stringify(char)}`);\n        }\n        // move to the high bits\n        val <<= 3;\n        byte |= val >>> skip;\n        skip += 5;\n        if (skip >= 8) {\n            // We have enough bytes to produce an output\n            output[o++] = byte;\n            skip -= 8;\n            if (skip > 0) {\n                byte = (val << (5 - skip)) & 255;\n            }\n            else {\n                byte = 0;\n            }\n        }\n    }\n    for (const c of input) {\n        decodeChar(c);\n    }\n    return output.slice(0, o);\n}\n//# sourceMappingURL=base32.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9wcmluY2lwYWwvbGliL2VzbS91dGlscy9iYXNlMzIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHFCQUFxQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9wcmluY2lwYWwvbGliL2VzbS91dGlscy9iYXNlMzIuanM/MjY1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBhbHBoYWJldCA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejIzNDU2Nyc7XG4vLyBCdWlsZCBhIGxvb2t1cCB0YWJsZSBmb3IgZGVjb2RpbmcuXG5jb25zdCBsb29rdXBUYWJsZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mb3IgKGxldCBpID0gMDsgaSA8IGFscGhhYmV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgbG9va3VwVGFibGVbYWxwaGFiZXRbaV1dID0gaTtcbn1cbi8vIEFkZCBhbGlhc2VzIGZvciByZmM0NjQ4LlxubG9va3VwVGFibGVbJzAnXSA9IGxvb2t1cFRhYmxlLm87XG5sb29rdXBUYWJsZVsnMSddID0gbG9va3VwVGFibGUuaTtcbi8qKlxuICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCBhcnJheSB0byBlbmNvZGUuXG4gKiBAcmV0dXJucyBBIEJhc2UzMiBzdHJpbmcgZW5jb2RpbmcgdGhlIGlucHV0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG4gICAgLy8gSG93IG1hbnkgYml0cyB3aWxsIHdlIHNraXAgZnJvbSB0aGUgZmlyc3QgYnl0ZS5cbiAgICBsZXQgc2tpcCA9IDA7XG4gICAgLy8gNSBoaWdoIGJpdHMsIGNhcnJ5IGZyb20gb25lIGJ5dGUgdG8gdGhlIG5leHQuXG4gICAgbGV0IGJpdHMgPSAwO1xuICAgIC8vIFRoZSBvdXRwdXQgc3RyaW5nIGluIGJhc2UzMi5cbiAgICBsZXQgb3V0cHV0ID0gJyc7XG4gICAgZnVuY3Rpb24gZW5jb2RlQnl0ZShieXRlKSB7XG4gICAgICAgIGlmIChza2lwIDwgMCkge1xuICAgICAgICAgICAgLy8gd2UgaGF2ZSBhIGNhcnJ5IGZyb20gdGhlIHByZXZpb3VzIGJ5dGVcbiAgICAgICAgICAgIGJpdHMgfD0gYnl0ZSA+PiAtc2tpcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5vIGNhcnJ5XG4gICAgICAgICAgICBiaXRzID0gKGJ5dGUgPDwgc2tpcCkgJiAyNDg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNraXAgPiAzKSB7XG4gICAgICAgICAgICAvLyBOb3QgZW5vdWdoIGRhdGEgdG8gcHJvZHVjZSBhIGNoYXJhY3RlciwgZ2V0IHVzIGFub3RoZXIgb25lXG4gICAgICAgICAgICBza2lwIC09IDg7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2tpcCA8IDQpIHtcbiAgICAgICAgICAgIC8vIHByb2R1Y2UgYSBjaGFyYWN0ZXJcbiAgICAgICAgICAgIG91dHB1dCArPSBhbHBoYWJldFtiaXRzID4+IDNdO1xuICAgICAgICAgICAgc2tpcCArPSA1O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDspIHtcbiAgICAgICAgaSArPSBlbmNvZGVCeXRlKGlucHV0W2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dCArIChza2lwIDwgMCA/IGFscGhhYmV0W2JpdHMgPj4gM10gOiAnJyk7XG59XG4vKipcbiAqIEBwYXJhbSBpbnB1dCBUaGUgYmFzZTMyIGVuY29kZWQgc3RyaW5nIHRvIGRlY29kZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuICAgIC8vIGhvdyBtYW55IGJpdHMgd2UgaGF2ZSBmcm9tIHRoZSBwcmV2aW91cyBjaGFyYWN0ZXIuXG4gICAgbGV0IHNraXAgPSAwO1xuICAgIC8vIGN1cnJlbnQgYnl0ZSB3ZSdyZSBwcm9kdWNpbmcuXG4gICAgbGV0IGJ5dGUgPSAwO1xuICAgIGNvbnN0IG91dHB1dCA9IG5ldyBVaW50OEFycmF5KCgoaW5wdXQubGVuZ3RoICogNCkgLyAzKSB8IDApO1xuICAgIGxldCBvID0gMDtcbiAgICBmdW5jdGlvbiBkZWNvZGVDaGFyKGNoYXIpIHtcbiAgICAgICAgLy8gQ29uc3VtZSBhIGNoYXJhY3RlciBmcm9tIHRoZSBzdHJlYW0sIHN0b3JlXG4gICAgICAgIC8vIHRoZSBvdXRwdXQgaW4gdGhpcy5vdXRwdXQuIEFzIGJlZm9yZSwgYmV0dGVyXG4gICAgICAgIC8vIHRvIHVzZSB1cGRhdGUoKS5cbiAgICAgICAgbGV0IHZhbCA9IGxvb2t1cFRhYmxlW2NoYXIudG9Mb3dlckNhc2UoKV07XG4gICAgICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNoYXJhY3RlcjogJHtKU09OLnN0cmluZ2lmeShjaGFyKX1gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtb3ZlIHRvIHRoZSBoaWdoIGJpdHNcbiAgICAgICAgdmFsIDw8PSAzO1xuICAgICAgICBieXRlIHw9IHZhbCA+Pj4gc2tpcDtcbiAgICAgICAgc2tpcCArPSA1O1xuICAgICAgICBpZiAoc2tpcCA+PSA4KSB7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIGVub3VnaCBieXRlcyB0byBwcm9kdWNlIGFuIG91dHB1dFxuICAgICAgICAgICAgb3V0cHV0W28rK10gPSBieXRlO1xuICAgICAgICAgICAgc2tpcCAtPSA4O1xuICAgICAgICAgICAgaWYgKHNraXAgPiAwKSB7XG4gICAgICAgICAgICAgICAgYnl0ZSA9ICh2YWwgPDwgKDUgLSBza2lwKSkgJiAyNTU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBieXRlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGMgb2YgaW5wdXQpIHtcbiAgICAgICAgZGVjb2RlQ2hhcihjKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dC5zbGljZSgwLCBvKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2UzMi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/principal/lib/esm/utils/base32.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dfinity/principal/lib/esm/utils/getCrc.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@dfinity/principal/lib/esm/utils/getCrc.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCrc32: function() { return /* binding */ getCrc32; }\n/* harmony export */ });\n// This file is translated to JavaScript from\n// https://lxp32.github.io/docs/a-simple-example-crc32-calculation/\nconst lookUpTable = new Uint32Array([\n    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,\n    0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,\n    0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,\n    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,\n    0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,\n    0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,\n    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,\n    0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,\n    0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,\n    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,\n    0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,\n    0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,\n    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,\n    0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,\n    0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\n    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,\n    0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,\n    0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,\n    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,\n    0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,\n    0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,\n    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,\n    0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,\n    0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,\n    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,\n    0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,\n    0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,\n    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,\n    0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,\n    0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\n    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,\n    0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d,\n]);\n/**\n * Calculate the CRC32 of an ArrayBufferLike.\n * @param buf The BufferLike to calculate the CRC32 of.\n */\nfunction getCrc32(buf) {\n    const b = new Uint8Array(buf);\n    let crc = -1;\n    for (let i = 0; i < b.length; i++) {\n        const byte = b[i];\n        const t = (byte ^ crc) & 0xff;\n        crc = lookUpTable[t] ^ (crc >>> 8);\n    }\n    return (crc ^ -1) >>> 0;\n}\n//# sourceMappingURL=getCrc.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9wcmluY2lwYWwvbGliL2VzbS91dGlscy9nZXRDcmMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L3ByaW5jaXBhbC9saWIvZXNtL3V0aWxzL2dldENyYy5qcz80NzdmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgZmlsZSBpcyB0cmFuc2xhdGVkIHRvIEphdmFTY3JpcHQgZnJvbVxuLy8gaHR0cHM6Ly9seHAzMi5naXRodWIuaW8vZG9jcy9hLXNpbXBsZS1leGFtcGxlLWNyYzMyLWNhbGN1bGF0aW9uL1xuY29uc3QgbG9va1VwVGFibGUgPSBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4MDAwMDAwMDAsIDB4NzcwNzMwOTYsIDB4ZWUwZTYxMmMsIDB4OTkwOTUxYmEsIDB4MDc2ZGM0MTksIDB4NzA2YWY0OGYsIDB4ZTk2M2E1MzUsIDB4OWU2NDk1YTMsXG4gICAgMHgwZWRiODgzMiwgMHg3OWRjYjhhNCwgMHhlMGQ1ZTkxZSwgMHg5N2QyZDk4OCwgMHgwOWI2NGMyYiwgMHg3ZWIxN2NiZCwgMHhlN2I4MmQwNywgMHg5MGJmMWQ5MSxcbiAgICAweDFkYjcxMDY0LCAweDZhYjAyMGYyLCAweGYzYjk3MTQ4LCAweDg0YmU0MWRlLCAweDFhZGFkNDdkLCAweDZkZGRlNGViLCAweGY0ZDRiNTUxLCAweDgzZDM4NWM3LFxuICAgIDB4MTM2Yzk4NTYsIDB4NjQ2YmE4YzAsIDB4ZmQ2MmY5N2EsIDB4OGE2NWM5ZWMsIDB4MTQwMTVjNGYsIDB4NjMwNjZjZDksIDB4ZmEwZjNkNjMsIDB4OGQwODBkZjUsXG4gICAgMHgzYjZlMjBjOCwgMHg0YzY5MTA1ZSwgMHhkNTYwNDFlNCwgMHhhMjY3NzE3MiwgMHgzYzAzZTRkMSwgMHg0YjA0ZDQ0NywgMHhkMjBkODVmZCwgMHhhNTBhYjU2YixcbiAgICAweDM1YjVhOGZhLCAweDQyYjI5ODZjLCAweGRiYmJjOWQ2LCAweGFjYmNmOTQwLCAweDMyZDg2Y2UzLCAweDQ1ZGY1Yzc1LCAweGRjZDYwZGNmLCAweGFiZDEzZDU5LFxuICAgIDB4MjZkOTMwYWMsIDB4NTFkZTAwM2EsIDB4YzhkNzUxODAsIDB4YmZkMDYxMTYsIDB4MjFiNGY0YjUsIDB4NTZiM2M0MjMsIDB4Y2ZiYTk1OTksIDB4YjhiZGE1MGYsXG4gICAgMHgyODAyYjg5ZSwgMHg1ZjA1ODgwOCwgMHhjNjBjZDliMiwgMHhiMTBiZTkyNCwgMHgyZjZmN2M4NywgMHg1ODY4NGMxMSwgMHhjMTYxMWRhYiwgMHhiNjY2MmQzZCxcbiAgICAweDc2ZGM0MTkwLCAweDAxZGI3MTA2LCAweDk4ZDIyMGJjLCAweGVmZDUxMDJhLCAweDcxYjE4NTg5LCAweDA2YjZiNTFmLCAweDlmYmZlNGE1LCAweGU4YjhkNDMzLFxuICAgIDB4NzgwN2M5YTIsIDB4MGYwMGY5MzQsIDB4OTYwOWE4OGUsIDB4ZTEwZTk4MTgsIDB4N2Y2YTBkYmIsIDB4MDg2ZDNkMmQsIDB4OTE2NDZjOTcsIDB4ZTY2MzVjMDEsXG4gICAgMHg2YjZiNTFmNCwgMHgxYzZjNjE2MiwgMHg4NTY1MzBkOCwgMHhmMjYyMDA0ZSwgMHg2YzA2OTVlZCwgMHgxYjAxYTU3YiwgMHg4MjA4ZjRjMSwgMHhmNTBmYzQ1NyxcbiAgICAweDY1YjBkOWM2LCAweDEyYjdlOTUwLCAweDhiYmViOGVhLCAweGZjYjk4ODdjLCAweDYyZGQxZGRmLCAweDE1ZGEyZDQ5LCAweDhjZDM3Y2YzLCAweGZiZDQ0YzY1LFxuICAgIDB4NGRiMjYxNTgsIDB4M2FiNTUxY2UsIDB4YTNiYzAwNzQsIDB4ZDRiYjMwZTIsIDB4NGFkZmE1NDEsIDB4M2RkODk1ZDcsIDB4YTRkMWM0NmQsIDB4ZDNkNmY0ZmIsXG4gICAgMHg0MzY5ZTk2YSwgMHgzNDZlZDlmYywgMHhhZDY3ODg0NiwgMHhkYTYwYjhkMCwgMHg0NDA0MmQ3MywgMHgzMzAzMWRlNSwgMHhhYTBhNGM1ZiwgMHhkZDBkN2NjOSxcbiAgICAweDUwMDU3MTNjLCAweDI3MDI0MWFhLCAweGJlMGIxMDEwLCAweGM5MGMyMDg2LCAweDU3NjhiNTI1LCAweDIwNmY4NWIzLCAweGI5NjZkNDA5LCAweGNlNjFlNDlmLFxuICAgIDB4NWVkZWY5MGUsIDB4MjlkOWM5OTgsIDB4YjBkMDk4MjIsIDB4YzdkN2E4YjQsIDB4NTliMzNkMTcsIDB4MmViNDBkODEsIDB4YjdiZDVjM2IsIDB4YzBiYTZjYWQsXG4gICAgMHhlZGI4ODMyMCwgMHg5YWJmYjNiNiwgMHgwM2I2ZTIwYywgMHg3NGIxZDI5YSwgMHhlYWQ1NDczOSwgMHg5ZGQyNzdhZiwgMHgwNGRiMjYxNSwgMHg3M2RjMTY4MyxcbiAgICAweGUzNjMwYjEyLCAweDk0NjQzYjg0LCAweDBkNmQ2YTNlLCAweDdhNmE1YWE4LCAweGU0MGVjZjBiLCAweDkzMDlmZjlkLCAweDBhMDBhZTI3LCAweDdkMDc5ZWIxLFxuICAgIDB4ZjAwZjkzNDQsIDB4ODcwOGEzZDIsIDB4MWUwMWYyNjgsIDB4NjkwNmMyZmUsIDB4Zjc2MjU3NWQsIDB4ODA2NTY3Y2IsIDB4MTk2YzM2NzEsIDB4NmU2YjA2ZTcsXG4gICAgMHhmZWQ0MWI3NiwgMHg4OWQzMmJlMCwgMHgxMGRhN2E1YSwgMHg2N2RkNGFjYywgMHhmOWI5ZGY2ZiwgMHg4ZWJlZWZmOSwgMHgxN2I3YmU0MywgMHg2MGIwOGVkNSxcbiAgICAweGQ2ZDZhM2U4LCAweGExZDE5MzdlLCAweDM4ZDhjMmM0LCAweDRmZGZmMjUyLCAweGQxYmI2N2YxLCAweGE2YmM1NzY3LCAweDNmYjUwNmRkLCAweDQ4YjIzNjRiLFxuICAgIDB4ZDgwZDJiZGEsIDB4YWYwYTFiNGMsIDB4MzYwMzRhZjYsIDB4NDEwNDdhNjAsIDB4ZGY2MGVmYzMsIDB4YTg2N2RmNTUsIDB4MzE2ZThlZWYsIDB4NDY2OWJlNzksXG4gICAgMHhjYjYxYjM4YywgMHhiYzY2ODMxYSwgMHgyNTZmZDJhMCwgMHg1MjY4ZTIzNiwgMHhjYzBjNzc5NSwgMHhiYjBiNDcwMywgMHgyMjAyMTZiOSwgMHg1NTA1MjYyZixcbiAgICAweGM1YmEzYmJlLCAweGIyYmQwYjI4LCAweDJiYjQ1YTkyLCAweDVjYjM2YTA0LCAweGMyZDdmZmE3LCAweGI1ZDBjZjMxLCAweDJjZDk5ZThiLCAweDViZGVhZTFkLFxuICAgIDB4OWI2NGMyYjAsIDB4ZWM2M2YyMjYsIDB4NzU2YWEzOWMsIDB4MDI2ZDkzMGEsIDB4OWMwOTA2YTksIDB4ZWIwZTM2M2YsIDB4NzIwNzY3ODUsIDB4MDUwMDU3MTMsXG4gICAgMHg5NWJmNGE4MiwgMHhlMmI4N2ExNCwgMHg3YmIxMmJhZSwgMHgwY2I2MWIzOCwgMHg5MmQyOGU5YiwgMHhlNWQ1YmUwZCwgMHg3Y2RjZWZiNywgMHgwYmRiZGYyMSxcbiAgICAweDg2ZDNkMmQ0LCAweGYxZDRlMjQyLCAweDY4ZGRiM2Y4LCAweDFmZGE4MzZlLCAweDgxYmUxNmNkLCAweGY2YjkyNjViLCAweDZmYjA3N2UxLCAweDE4Yjc0Nzc3LFxuICAgIDB4ODgwODVhZTYsIDB4ZmYwZjZhNzAsIDB4NjYwNjNiY2EsIDB4MTEwMTBiNWMsIDB4OGY2NTllZmYsIDB4Zjg2MmFlNjksIDB4NjE2YmZmZDMsIDB4MTY2Y2NmNDUsXG4gICAgMHhhMDBhZTI3OCwgMHhkNzBkZDJlZSwgMHg0ZTA0ODM1NCwgMHgzOTAzYjNjMiwgMHhhNzY3MjY2MSwgMHhkMDYwMTZmNywgMHg0OTY5NDc0ZCwgMHgzZTZlNzdkYixcbiAgICAweGFlZDE2YTRhLCAweGQ5ZDY1YWRjLCAweDQwZGYwYjY2LCAweDM3ZDgzYmYwLCAweGE5YmNhZTUzLCAweGRlYmI5ZWM1LCAweDQ3YjJjZjdmLCAweDMwYjVmZmU5LFxuICAgIDB4YmRiZGYyMWMsIDB4Y2FiYWMyOGEsIDB4NTNiMzkzMzAsIDB4MjRiNGEzYTYsIDB4YmFkMDM2MDUsIDB4Y2RkNzA2OTMsIDB4NTRkZTU3MjksIDB4MjNkOTY3YmYsXG4gICAgMHhiMzY2N2EyZSwgMHhjNDYxNGFiOCwgMHg1ZDY4MWIwMiwgMHgyYTZmMmI5NCwgMHhiNDBiYmUzNywgMHhjMzBjOGVhMSwgMHg1YTA1ZGYxYiwgMHgyZDAyZWY4ZCxcbl0pO1xuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIENSQzMyIG9mIGFuIEFycmF5QnVmZmVyTGlrZS5cbiAqIEBwYXJhbSBidWYgVGhlIEJ1ZmZlckxpa2UgdG8gY2FsY3VsYXRlIHRoZSBDUkMzMiBvZi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENyYzMyKGJ1Zikge1xuICAgIGNvbnN0IGIgPSBuZXcgVWludDhBcnJheShidWYpO1xuICAgIGxldCBjcmMgPSAtMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYnl0ZSA9IGJbaV07XG4gICAgICAgIGNvbnN0IHQgPSAoYnl0ZSBeIGNyYykgJiAweGZmO1xuICAgICAgICBjcmMgPSBsb29rVXBUYWJsZVt0XSBeIChjcmMgPj4+IDgpO1xuICAgIH1cbiAgICByZXR1cm4gKGNyYyBeIC0xKSA+Pj4gMDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldENyYy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/principal/lib/esm/utils/getCrc.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@dfinity/principal/lib/esm/utils/sha224.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@dfinity/principal/lib/esm/utils/sha224.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha224: function() { return /* binding */ sha224; }\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(app-pages-browser)/../../node_modules/@noble/hashes/esm/sha256.js\");\n\n/**\n * Returns the SHA224 hash of the buffer.\n * @param data Arraybuffer to encode\n */\nfunction sha224(data) {\n    return _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_0__.sha224.create().update(new Uint8Array(data)).digest();\n}\n//# sourceMappingURL=sha224.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9wcmluY2lwYWwvbGliL2VzbS91dGlscy9zaGEyMjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFdBQVcsd0RBQVE7QUFDbkI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGRmaW5pdHkvcHJpbmNpcGFsL2xpYi9lc20vdXRpbHMvc2hhMjI0LmpzPzFiOGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2hhMjI0IGFzIGpzU2hhMjI0IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyNTYnO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBTSEEyMjQgaGFzaCBvZiB0aGUgYnVmZmVyLlxuICogQHBhcmFtIGRhdGEgQXJyYXlidWZmZXIgdG8gZW5jb2RlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaGEyMjQoZGF0YSkge1xuICAgIHJldHVybiBqc1NoYTIyNC5jcmVhdGUoKS51cGRhdGUobmV3IFVpbnQ4QXJyYXkoZGF0YSkpLmRpZ2VzdCgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMjI0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@dfinity/principal/lib/esm/utils/sha224.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/api/image.js":
/*!*********************************************!*\
  !*** ./node_modules/next/dist/api/image.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* reexport default from dynamic */ _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0___default.a; }\n/* harmony export */ });\n/* harmony import */ var _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/lib/image-external */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-external.js\");\n/* harmony import */ var _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n\n//# sourceMappingURL=image.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL2ltYWdlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUF1RDtBQUNWOztBQUU3QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2FwaS9pbWFnZS5qcz80YmQwIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tIFwiLi4vc2hhcmVkL2xpYi9pbWFnZS1leHRlcm5hbFwiO1xuZXhwb3J0ICogZnJvbSBcIi4uL3NoYXJlZC9saWIvaW1hZ2UtZXh0ZXJuYWxcIjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2UuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/api/image.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/process.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _global_process, _global_process1;\nmodule.exports = ((_global_process = __webpack_require__.g.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = __webpack_require__.g.process) == null ? void 0 : _global_process1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! next/dist/compiled/process */ \"(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\");\n\n//# sourceMappingURL=process.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLHFDQUFxQyxxQkFBTSxpRkFBaUYscUJBQU0sa0VBQWtFLHFCQUFNLFdBQVcsbUJBQU8sQ0FBQyw0R0FBNEI7O0FBRXpQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanM/OTI1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfZ2xvYmFsX3Byb2Nlc3MsIF9nbG9iYWxfcHJvY2VzczE7XG5tb2R1bGUuZXhwb3J0cyA9ICgoX2dsb2JhbF9wcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MuZW52KSAmJiB0eXBlb2YgKChfZ2xvYmFsX3Byb2Nlc3MxID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MxLmVudikgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwucHJvY2VzcyA6IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzc1wiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvY2Vzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/picomatch/index.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/picomatch/index.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n(()=>{\"use strict\";var t={170:(t,e,u)=>{const n=u(510);const isWindows=()=>{if(typeof navigator!==\"undefined\"&&navigator.platform){const t=navigator.platform.toLowerCase();return t===\"win32\"||t===\"windows\"}if(typeof process!==\"undefined\"&&process.platform){return process.platform===\"win32\"}return false};function picomatch(t,e,u=false){if(e&&(e.windows===null||e.windows===undefined)){e={...e,windows:isWindows()}}return n(t,e,u)}Object.assign(picomatch,n);t.exports=picomatch},154:t=>{const e=\"\\\\\\\\/\";const u=`[^${e}]`;const n=\"\\\\.\";const o=\"\\\\+\";const s=\"\\\\?\";const r=\"\\\\/\";const a=\"(?=.)\";const i=\"[^/]\";const c=`(?:${r}|$)`;const p=`(?:^|${r})`;const l=`${n}{1,2}${c}`;const f=`(?!${n})`;const A=`(?!${p}${l})`;const _=`(?!${n}{0,1}${c})`;const R=`(?!${l})`;const E=`[^.${r}]`;const h=`${i}*?`;const g=\"/\";const b={DOT_LITERAL:n,PLUS_LITERAL:o,QMARK_LITERAL:s,SLASH_LITERAL:r,ONE_CHAR:a,QMARK:i,END_ANCHOR:c,DOTS_SLASH:l,NO_DOT:f,NO_DOTS:A,NO_DOT_SLASH:_,NO_DOTS_SLASH:R,QMARK_NO_DOT:E,STAR:h,START_ANCHOR:p,SEP:g};const C={...b,SLASH_LITERAL:`[${e}]`,QMARK:u,STAR:`${u}*?`,DOTS_SLASH:`${n}{1,2}(?:[${e}]|$)`,NO_DOT:`(?!${n})`,NO_DOTS:`(?!(?:^|[${e}])${n}{1,2}(?:[${e}]|$))`,NO_DOT_SLASH:`(?!${n}{0,1}(?:[${e}]|$))`,NO_DOTS_SLASH:`(?!${n}{1,2}(?:[${e}]|$))`,QMARK_NO_DOT:`[^.${e}]`,START_ANCHOR:`(?:^|[${e}])`,END_ANCHOR:`(?:[${e}]|$)`,SEP:\"\\\\\"};const y={alnum:\"a-zA-Z0-9\",alpha:\"a-zA-Z\",ascii:\"\\\\x00-\\\\x7F\",blank:\" \\\\t\",cntrl:\"\\\\x00-\\\\x1F\\\\x7F\",digit:\"0-9\",graph:\"\\\\x21-\\\\x7E\",lower:\"a-z\",print:\"\\\\x20-\\\\x7E \",punct:\"\\\\-!\\\"#$%&'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~\",space:\" \\\\t\\\\r\\\\n\\\\v\\\\f\",upper:\"A-Z\",word:\"A-Za-z0-9_\",xdigit:\"A-Fa-f0-9\"};t.exports={MAX_LENGTH:1024*64,POSIX_REGEX_SOURCE:y,REGEX_BACKSLASH:/\\\\(?![*+?^${}(|)[\\]])/g,REGEX_NON_SPECIAL_CHARS:/^[^@![\\].,$*+?^{}()|\\\\/]+/,REGEX_SPECIAL_CHARS:/[-*+?.^${}(|)[\\]]/,REGEX_SPECIAL_CHARS_BACKREF:/(\\\\?)((\\W)(\\3*))/g,REGEX_SPECIAL_CHARS_GLOBAL:/([-*+?.^${}(|)[\\]])/g,REGEX_REMOVE_BACKSLASH:/(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,REPLACEMENTS:{\"***\":\"*\",\"**/**\":\"**\",\"**/**/**\":\"**\"},CHAR_0:48,CHAR_9:57,CHAR_UPPERCASE_A:65,CHAR_LOWERCASE_A:97,CHAR_UPPERCASE_Z:90,CHAR_LOWERCASE_Z:122,CHAR_LEFT_PARENTHESES:40,CHAR_RIGHT_PARENTHESES:41,CHAR_ASTERISK:42,CHAR_AMPERSAND:38,CHAR_AT:64,CHAR_BACKWARD_SLASH:92,CHAR_CARRIAGE_RETURN:13,CHAR_CIRCUMFLEX_ACCENT:94,CHAR_COLON:58,CHAR_COMMA:44,CHAR_DOT:46,CHAR_DOUBLE_QUOTE:34,CHAR_EQUAL:61,CHAR_EXCLAMATION_MARK:33,CHAR_FORM_FEED:12,CHAR_FORWARD_SLASH:47,CHAR_GRAVE_ACCENT:96,CHAR_HASH:35,CHAR_HYPHEN_MINUS:45,CHAR_LEFT_ANGLE_BRACKET:60,CHAR_LEFT_CURLY_BRACE:123,CHAR_LEFT_SQUARE_BRACKET:91,CHAR_LINE_FEED:10,CHAR_NO_BREAK_SPACE:160,CHAR_PERCENT:37,CHAR_PLUS:43,CHAR_QUESTION_MARK:63,CHAR_RIGHT_ANGLE_BRACKET:62,CHAR_RIGHT_CURLY_BRACE:125,CHAR_RIGHT_SQUARE_BRACKET:93,CHAR_SEMICOLON:59,CHAR_SINGLE_QUOTE:39,CHAR_SPACE:32,CHAR_TAB:9,CHAR_UNDERSCORE:95,CHAR_VERTICAL_LINE:124,CHAR_ZERO_WIDTH_NOBREAK_SPACE:65279,extglobChars(t){return{\"!\":{type:\"negate\",open:\"(?:(?!(?:\",close:`))${t.STAR})`},\"?\":{type:\"qmark\",open:\"(?:\",close:\")?\"},\"+\":{type:\"plus\",open:\"(?:\",close:\")+\"},\"*\":{type:\"star\",open:\"(?:\",close:\")*\"},\"@\":{type:\"at\",open:\"(?:\",close:\")\"}}},globChars(t){return t===true?C:b}}},697:(t,e,u)=>{const n=u(154);const o=u(96);const{MAX_LENGTH:s,POSIX_REGEX_SOURCE:r,REGEX_NON_SPECIAL_CHARS:a,REGEX_SPECIAL_CHARS_BACKREF:i,REPLACEMENTS:c}=n;const expandRange=(t,e)=>{if(typeof e.expandRange===\"function\"){return e.expandRange(...t,e)}t.sort();const u=`[${t.join(\"-\")}]`;try{new RegExp(u)}catch(e){return t.map((t=>o.escapeRegex(t))).join(\"..\")}return u};const syntaxError=(t,e)=>`Missing ${t}: \"${e}\" - use \"\\\\\\\\${e}\" to match literal characters`;const parse=(t,e)=>{if(typeof t!==\"string\"){throw new TypeError(\"Expected a string\")}t=c[t]||t;const u={...e};const p=typeof u.maxLength===\"number\"?Math.min(s,u.maxLength):s;let l=t.length;if(l>p){throw new SyntaxError(`Input length: ${l}, exceeds maximum allowed length: ${p}`)}const f={type:\"bos\",value:\"\",output:u.prepend||\"\"};const A=[f];const _=u.capture?\"\":\"?:\";const R=n.globChars(u.windows);const E=n.extglobChars(R);const{DOT_LITERAL:h,PLUS_LITERAL:g,SLASH_LITERAL:b,ONE_CHAR:C,DOTS_SLASH:y,NO_DOT:$,NO_DOT_SLASH:x,NO_DOTS_SLASH:S,QMARK:H,QMARK_NO_DOT:v,STAR:d,START_ANCHOR:L}=R;const globstar=t=>`(${_}(?:(?!${L}${t.dot?y:h}).)*?)`;const T=u.dot?\"\":$;const O=u.dot?H:v;let k=u.bash===true?globstar(u):d;if(u.capture){k=`(${k})`}if(typeof u.noext===\"boolean\"){u.noextglob=u.noext}const m={input:t,index:-1,start:0,dot:u.dot===true,consumed:\"\",output:\"\",prefix:\"\",backtrack:false,negated:false,brackets:0,braces:0,parens:0,quotes:0,globstar:false,tokens:A};t=o.removePrefix(t,m);l=t.length;const w=[];const N=[];const I=[];let B=f;let G;const eos=()=>m.index===l-1;const D=m.peek=(e=1)=>t[m.index+e];const M=m.advance=()=>t[++m.index]||\"\";const remaining=()=>t.slice(m.index+1);const consume=(t=\"\",e=0)=>{m.consumed+=t;m.index+=e};const append=t=>{m.output+=t.output!=null?t.output:t.value;consume(t.value)};const negate=()=>{let t=1;while(D()===\"!\"&&(D(2)!==\"(\"||D(3)===\"?\")){M();m.start++;t++}if(t%2===0){return false}m.negated=true;m.start++;return true};const increment=t=>{m[t]++;I.push(t)};const decrement=t=>{m[t]--;I.pop()};const push=t=>{if(B.type===\"globstar\"){const e=m.braces>0&&(t.type===\"comma\"||t.type===\"brace\");const u=t.extglob===true||w.length&&(t.type===\"pipe\"||t.type===\"paren\");if(t.type!==\"slash\"&&t.type!==\"paren\"&&!e&&!u){m.output=m.output.slice(0,-B.output.length);B.type=\"star\";B.value=\"*\";B.output=k;m.output+=B.output}}if(w.length&&t.type!==\"paren\"){w[w.length-1].inner+=t.value}if(t.value||t.output)append(t);if(B&&B.type===\"text\"&&t.type===\"text\"){B.output=(B.output||B.value)+t.value;B.value+=t.value;return}t.prev=B;A.push(t);B=t};const extglobOpen=(t,e)=>{const n={...E[e],conditions:1,inner:\"\"};n.prev=B;n.parens=m.parens;n.output=m.output;const o=(u.capture?\"(\":\"\")+n.open;increment(\"parens\");push({type:t,value:e,output:m.output?\"\":C});push({type:\"paren\",extglob:true,value:M(),output:o});w.push(n)};const extglobClose=t=>{let n=t.close+(u.capture?\")\":\"\");let o;if(t.type===\"negate\"){let s=k;if(t.inner&&t.inner.length>1&&t.inner.includes(\"/\")){s=globstar(u)}if(s!==k||eos()||/^\\)+$/.test(remaining())){n=t.close=`)$))${s}`}if(t.inner.includes(\"*\")&&(o=remaining())&&/^\\.[^\\\\/.]+$/.test(o)){const u=parse(o,{...e,fastpaths:false}).output;n=t.close=`)${u})${s})`}if(t.prev.type===\"bos\"){m.negatedExtglob=true}}push({type:\"paren\",extglob:true,value:G,output:n});decrement(\"parens\")};if(u.fastpaths!==false&&!/(^[*!]|[/()[\\]{}\"])/.test(t)){let n=false;let s=t.replace(i,((t,e,u,o,s,r)=>{if(o===\"\\\\\"){n=true;return t}if(o===\"?\"){if(e){return e+o+(s?H.repeat(s.length):\"\")}if(r===0){return O+(s?H.repeat(s.length):\"\")}return H.repeat(u.length)}if(o===\".\"){return h.repeat(u.length)}if(o===\"*\"){if(e){return e+o+(s?k:\"\")}return k}return e?t:`\\\\${t}`}));if(n===true){if(u.unescape===true){s=s.replace(/\\\\/g,\"\")}else{s=s.replace(/\\\\+/g,(t=>t.length%2===0?\"\\\\\\\\\":t?\"\\\\\":\"\"))}}if(s===t&&u.contains===true){m.output=t;return m}m.output=o.wrapOutput(s,m,e);return m}while(!eos()){G=M();if(G===\"\\0\"){continue}if(G===\"\\\\\"){const t=D();if(t===\"/\"&&u.bash!==true){continue}if(t===\".\"||t===\";\"){continue}if(!t){G+=\"\\\\\";push({type:\"text\",value:G});continue}const e=/^\\\\+/.exec(remaining());let n=0;if(e&&e[0].length>2){n=e[0].length;m.index+=n;if(n%2!==0){G+=\"\\\\\"}}if(u.unescape===true){G=M()}else{G+=M()}if(m.brackets===0){push({type:\"text\",value:G});continue}}if(m.brackets>0&&(G!==\"]\"||B.value===\"[\"||B.value===\"[^\")){if(u.posix!==false&&G===\":\"){const t=B.value.slice(1);if(t.includes(\"[\")){B.posix=true;if(t.includes(\":\")){const t=B.value.lastIndexOf(\"[\");const e=B.value.slice(0,t);const u=B.value.slice(t+2);const n=r[u];if(n){B.value=e+n;m.backtrack=true;M();if(!f.output&&A.indexOf(B)===1){f.output=C}continue}}}}if(G===\"[\"&&D()!==\":\"||G===\"-\"&&D()===\"]\"){G=`\\\\${G}`}if(G===\"]\"&&(B.value===\"[\"||B.value===\"[^\")){G=`\\\\${G}`}if(u.posix===true&&G===\"!\"&&B.value===\"[\"){G=\"^\"}B.value+=G;append({value:G});continue}if(m.quotes===1&&G!=='\"'){G=o.escapeRegex(G);B.value+=G;append({value:G});continue}if(G==='\"'){m.quotes=m.quotes===1?0:1;if(u.keepQuotes===true){push({type:\"text\",value:G})}continue}if(G===\"(\"){increment(\"parens\");push({type:\"paren\",value:G});continue}if(G===\")\"){if(m.parens===0&&u.strictBrackets===true){throw new SyntaxError(syntaxError(\"opening\",\"(\"))}const t=w[w.length-1];if(t&&m.parens===t.parens+1){extglobClose(w.pop());continue}push({type:\"paren\",value:G,output:m.parens?\")\":\"\\\\)\"});decrement(\"parens\");continue}if(G===\"[\"){if(u.nobracket===true||!remaining().includes(\"]\")){if(u.nobracket!==true&&u.strictBrackets===true){throw new SyntaxError(syntaxError(\"closing\",\"]\"))}G=`\\\\${G}`}else{increment(\"brackets\")}push({type:\"bracket\",value:G});continue}if(G===\"]\"){if(u.nobracket===true||B&&B.type===\"bracket\"&&B.value.length===1){push({type:\"text\",value:G,output:`\\\\${G}`});continue}if(m.brackets===0){if(u.strictBrackets===true){throw new SyntaxError(syntaxError(\"opening\",\"[\"))}push({type:\"text\",value:G,output:`\\\\${G}`});continue}decrement(\"brackets\");const t=B.value.slice(1);if(B.posix!==true&&t[0]===\"^\"&&!t.includes(\"/\")){G=`/${G}`}B.value+=G;append({value:G});if(u.literalBrackets===false||o.hasRegexChars(t)){continue}const e=o.escapeRegex(B.value);m.output=m.output.slice(0,-B.value.length);if(u.literalBrackets===true){m.output+=e;B.value=e;continue}B.value=`(${_}${e}|${B.value})`;m.output+=B.value;continue}if(G===\"{\"&&u.nobrace!==true){increment(\"braces\");const t={type:\"brace\",value:G,output:\"(\",outputIndex:m.output.length,tokensIndex:m.tokens.length};N.push(t);push(t);continue}if(G===\"}\"){const t=N[N.length-1];if(u.nobrace===true||!t){push({type:\"text\",value:G,output:G});continue}let e=\")\";if(t.dots===true){const t=A.slice();const n=[];for(let e=t.length-1;e>=0;e--){A.pop();if(t[e].type===\"brace\"){break}if(t[e].type!==\"dots\"){n.unshift(t[e].value)}}e=expandRange(n,u);m.backtrack=true}if(t.comma!==true&&t.dots!==true){const u=m.output.slice(0,t.outputIndex);const n=m.tokens.slice(t.tokensIndex);t.value=t.output=\"\\\\{\";G=e=\"\\\\}\";m.output=u;for(const t of n){m.output+=t.output||t.value}}push({type:\"brace\",value:G,output:e});decrement(\"braces\");N.pop();continue}if(G===\"|\"){if(w.length>0){w[w.length-1].conditions++}push({type:\"text\",value:G});continue}if(G===\",\"){let t=G;const e=N[N.length-1];if(e&&I[I.length-1]===\"braces\"){e.comma=true;t=\"|\"}push({type:\"comma\",value:G,output:t});continue}if(G===\"/\"){if(B.type===\"dot\"&&m.index===m.start+1){m.start=m.index+1;m.consumed=\"\";m.output=\"\";A.pop();B=f;continue}push({type:\"slash\",value:G,output:b});continue}if(G===\".\"){if(m.braces>0&&B.type===\"dot\"){if(B.value===\".\")B.output=h;const t=N[N.length-1];B.type=\"dots\";B.output+=G;B.value+=G;t.dots=true;continue}if(m.braces+m.parens===0&&B.type!==\"bos\"&&B.type!==\"slash\"){push({type:\"text\",value:G,output:h});continue}push({type:\"dot\",value:G,output:h});continue}if(G===\"?\"){const t=B&&B.value===\"(\";if(!t&&u.noextglob!==true&&D()===\"(\"&&D(2)!==\"?\"){extglobOpen(\"qmark\",G);continue}if(B&&B.type===\"paren\"){const t=D();let e=G;if(B.value===\"(\"&&!/[!=<:]/.test(t)||t===\"<\"&&!/<([!=]|\\w+>)/.test(remaining())){e=`\\\\${G}`}push({type:\"text\",value:G,output:e});continue}if(u.dot!==true&&(B.type===\"slash\"||B.type===\"bos\")){push({type:\"qmark\",value:G,output:v});continue}push({type:\"qmark\",value:G,output:H});continue}if(G===\"!\"){if(u.noextglob!==true&&D()===\"(\"){if(D(2)!==\"?\"||!/[!=<:]/.test(D(3))){extglobOpen(\"negate\",G);continue}}if(u.nonegate!==true&&m.index===0){negate();continue}}if(G===\"+\"){if(u.noextglob!==true&&D()===\"(\"&&D(2)!==\"?\"){extglobOpen(\"plus\",G);continue}if(B&&B.value===\"(\"||u.regex===false){push({type:\"plus\",value:G,output:g});continue}if(B&&(B.type===\"bracket\"||B.type===\"paren\"||B.type===\"brace\")||m.parens>0){push({type:\"plus\",value:G});continue}push({type:\"plus\",value:g});continue}if(G===\"@\"){if(u.noextglob!==true&&D()===\"(\"&&D(2)!==\"?\"){push({type:\"at\",extglob:true,value:G,output:\"\"});continue}push({type:\"text\",value:G});continue}if(G!==\"*\"){if(G===\"$\"||G===\"^\"){G=`\\\\${G}`}const t=a.exec(remaining());if(t){G+=t[0];m.index+=t[0].length}push({type:\"text\",value:G});continue}if(B&&(B.type===\"globstar\"||B.star===true)){B.type=\"star\";B.star=true;B.value+=G;B.output=k;m.backtrack=true;m.globstar=true;consume(G);continue}let e=remaining();if(u.noextglob!==true&&/^\\([^?]/.test(e)){extglobOpen(\"star\",G);continue}if(B.type===\"star\"){if(u.noglobstar===true){consume(G);continue}const n=B.prev;const o=n.prev;const s=n.type===\"slash\"||n.type===\"bos\";const r=o&&(o.type===\"star\"||o.type===\"globstar\");if(u.bash===true&&(!s||e[0]&&e[0]!==\"/\")){push({type:\"star\",value:G,output:\"\"});continue}const a=m.braces>0&&(n.type===\"comma\"||n.type===\"brace\");const i=w.length&&(n.type===\"pipe\"||n.type===\"paren\");if(!s&&n.type!==\"paren\"&&!a&&!i){push({type:\"star\",value:G,output:\"\"});continue}while(e.slice(0,3)===\"/**\"){const u=t[m.index+4];if(u&&u!==\"/\"){break}e=e.slice(3);consume(\"/**\",3)}if(n.type===\"bos\"&&eos()){B.type=\"globstar\";B.value+=G;B.output=globstar(u);m.output=B.output;m.globstar=true;consume(G);continue}if(n.type===\"slash\"&&n.prev.type!==\"bos\"&&!r&&eos()){m.output=m.output.slice(0,-(n.output+B.output).length);n.output=`(?:${n.output}`;B.type=\"globstar\";B.output=globstar(u)+(u.strictSlashes?\")\":\"|$)\");B.value+=G;m.globstar=true;m.output+=n.output+B.output;consume(G);continue}if(n.type===\"slash\"&&n.prev.type!==\"bos\"&&e[0]===\"/\"){const t=e[1]!==void 0?\"|$\":\"\";m.output=m.output.slice(0,-(n.output+B.output).length);n.output=`(?:${n.output}`;B.type=\"globstar\";B.output=`${globstar(u)}${b}|${b}${t})`;B.value+=G;m.output+=n.output+B.output;m.globstar=true;consume(G+M());push({type:\"slash\",value:\"/\",output:\"\"});continue}if(n.type===\"bos\"&&e[0]===\"/\"){B.type=\"globstar\";B.value+=G;B.output=`(?:^|${b}|${globstar(u)}${b})`;m.output=B.output;m.globstar=true;consume(G+M());push({type:\"slash\",value:\"/\",output:\"\"});continue}m.output=m.output.slice(0,-B.output.length);B.type=\"globstar\";B.output=globstar(u);B.value+=G;m.output+=B.output;m.globstar=true;consume(G);continue}const n={type:\"star\",value:G,output:k};if(u.bash===true){n.output=\".*?\";if(B.type===\"bos\"||B.type===\"slash\"){n.output=T+n.output}push(n);continue}if(B&&(B.type===\"bracket\"||B.type===\"paren\")&&u.regex===true){n.output=G;push(n);continue}if(m.index===m.start||B.type===\"slash\"||B.type===\"dot\"){if(B.type===\"dot\"){m.output+=x;B.output+=x}else if(u.dot===true){m.output+=S;B.output+=S}else{m.output+=T;B.output+=T}if(D()!==\"*\"){m.output+=C;B.output+=C}}push(n)}while(m.brackets>0){if(u.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\"]\"));m.output=o.escapeLast(m.output,\"[\");decrement(\"brackets\")}while(m.parens>0){if(u.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\")\"));m.output=o.escapeLast(m.output,\"(\");decrement(\"parens\")}while(m.braces>0){if(u.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\"}\"));m.output=o.escapeLast(m.output,\"{\");decrement(\"braces\")}if(u.strictSlashes!==true&&(B.type===\"star\"||B.type===\"bracket\")){push({type:\"maybe_slash\",value:\"\",output:`${b}?`})}if(m.backtrack===true){m.output=\"\";for(const t of m.tokens){m.output+=t.output!=null?t.output:t.value;if(t.suffix){m.output+=t.suffix}}}return m};parse.fastpaths=(t,e)=>{const u={...e};const r=typeof u.maxLength===\"number\"?Math.min(s,u.maxLength):s;const a=t.length;if(a>r){throw new SyntaxError(`Input length: ${a}, exceeds maximum allowed length: ${r}`)}t=c[t]||t;const{DOT_LITERAL:i,SLASH_LITERAL:p,ONE_CHAR:l,DOTS_SLASH:f,NO_DOT:A,NO_DOTS:_,NO_DOTS_SLASH:R,STAR:E,START_ANCHOR:h}=n.globChars(u.windows);const g=u.dot?_:A;const b=u.dot?R:A;const C=u.capture?\"\":\"?:\";const y={negated:false,prefix:\"\"};let $=u.bash===true?\".*?\":E;if(u.capture){$=`(${$})`}const globstar=t=>{if(t.noglobstar===true)return $;return`(${C}(?:(?!${h}${t.dot?f:i}).)*?)`};const create=t=>{switch(t){case\"*\":return`${g}${l}${$}`;case\".*\":return`${i}${l}${$}`;case\"*.*\":return`${g}${$}${i}${l}${$}`;case\"*/*\":return`${g}${$}${p}${l}${b}${$}`;case\"**\":return g+globstar(u);case\"**/*\":return`(?:${g}${globstar(u)}${p})?${b}${l}${$}`;case\"**/*.*\":return`(?:${g}${globstar(u)}${p})?${b}${$}${i}${l}${$}`;case\"**/.*\":return`(?:${g}${globstar(u)}${p})?${i}${l}${$}`;default:{const e=/^(.*?)\\.(\\w+)$/.exec(t);if(!e)return;const u=create(e[1]);if(!u)return;return u+i+e[2]}}};const x=o.removePrefix(t,y);let S=create(x);if(S&&u.strictSlashes!==true){S+=`${p}?`}return S};t.exports=parse},510:(t,e,u)=>{const n=u(716);const o=u(697);const s=u(96);const r=u(154);const isObject=t=>t&&typeof t===\"object\"&&!Array.isArray(t);const picomatch=(t,e,u=false)=>{if(Array.isArray(t)){const n=t.map((t=>picomatch(t,e,u)));const arrayMatcher=t=>{for(const e of n){const u=e(t);if(u)return u}return false};return arrayMatcher}const n=isObject(t)&&t.tokens&&t.input;if(t===\"\"||typeof t!==\"string\"&&!n){throw new TypeError(\"Expected pattern to be a non-empty string\")}const o=e||{};const s=o.windows;const r=n?picomatch.compileRe(t,e):picomatch.makeRe(t,e,false,true);const a=r.state;delete r.state;let isIgnored=()=>false;if(o.ignore){const t={...e,ignore:null,onMatch:null,onResult:null};isIgnored=picomatch(o.ignore,t,u)}const matcher=(u,n=false)=>{const{isMatch:i,match:c,output:p}=picomatch.test(u,r,e,{glob:t,posix:s});const l={glob:t,state:a,regex:r,posix:s,input:u,output:p,match:c,isMatch:i};if(typeof o.onResult===\"function\"){o.onResult(l)}if(i===false){l.isMatch=false;return n?l:false}if(isIgnored(u)){if(typeof o.onIgnore===\"function\"){o.onIgnore(l)}l.isMatch=false;return n?l:false}if(typeof o.onMatch===\"function\"){o.onMatch(l)}return n?l:true};if(u){matcher.state=a}return matcher};picomatch.test=(t,e,u,{glob:n,posix:o}={})=>{if(typeof t!==\"string\"){throw new TypeError(\"Expected input to be a string\")}if(t===\"\"){return{isMatch:false,output:\"\"}}const r=u||{};const a=r.format||(o?s.toPosixSlashes:null);let i=t===n;let c=i&&a?a(t):t;if(i===false){c=a?a(t):t;i=c===n}if(i===false||r.capture===true){if(r.matchBase===true||r.basename===true){i=picomatch.matchBase(t,e,u,o)}else{i=e.exec(c)}}return{isMatch:Boolean(i),match:i,output:c}};picomatch.matchBase=(t,e,u)=>{const n=e instanceof RegExp?e:picomatch.makeRe(e,u);return n.test(s.basename(t))};picomatch.isMatch=(t,e,u)=>picomatch(e,u)(t);picomatch.parse=(t,e)=>{if(Array.isArray(t))return t.map((t=>picomatch.parse(t,e)));return o(t,{...e,fastpaths:false})};picomatch.scan=(t,e)=>n(t,e);picomatch.compileRe=(t,e,u=false,n=false)=>{if(u===true){return t.output}const o=e||{};const s=o.contains?\"\":\"^\";const r=o.contains?\"\":\"$\";let a=`${s}(?:${t.output})${r}`;if(t&&t.negated===true){a=`^(?!${a}).*$`}const i=picomatch.toRegex(a,e);if(n===true){i.state=t}return i};picomatch.makeRe=(t,e={},u=false,n=false)=>{if(!t||typeof t!==\"string\"){throw new TypeError(\"Expected a non-empty string\")}let s={negated:false,fastpaths:true};if(e.fastpaths!==false&&(t[0]===\".\"||t[0]===\"*\")){s.output=o.fastpaths(t,e)}if(!s.output){s=o(t,e)}return picomatch.compileRe(s,e,u,n)};picomatch.toRegex=(t,e)=>{try{const u=e||{};return new RegExp(t,u.flags||(u.nocase?\"i\":\"\"))}catch(t){if(e&&e.debug===true)throw t;return/$^/}};picomatch.constants=r;t.exports=picomatch},716:(t,e,u)=>{const n=u(96);const{CHAR_ASTERISK:o,CHAR_AT:s,CHAR_BACKWARD_SLASH:r,CHAR_COMMA:a,CHAR_DOT:i,CHAR_EXCLAMATION_MARK:c,CHAR_FORWARD_SLASH:p,CHAR_LEFT_CURLY_BRACE:l,CHAR_LEFT_PARENTHESES:f,CHAR_LEFT_SQUARE_BRACKET:A,CHAR_PLUS:_,CHAR_QUESTION_MARK:R,CHAR_RIGHT_CURLY_BRACE:E,CHAR_RIGHT_PARENTHESES:h,CHAR_RIGHT_SQUARE_BRACKET:g}=u(154);const isPathSeparator=t=>t===p||t===r;const depth=t=>{if(t.isPrefix!==true){t.depth=t.isGlobstar?Infinity:1}};const scan=(t,e)=>{const u=e||{};const b=t.length-1;const C=u.parts===true||u.scanToEnd===true;const y=[];const $=[];const x=[];let S=t;let H=-1;let v=0;let d=0;let L=false;let T=false;let O=false;let k=false;let m=false;let w=false;let N=false;let I=false;let B=false;let G=false;let D=0;let M;let P;let K={value:\"\",depth:0,isGlob:false};const eos=()=>H>=b;const peek=()=>S.charCodeAt(H+1);const advance=()=>{M=P;return S.charCodeAt(++H)};while(H<b){P=advance();let t;if(P===r){N=K.backslashes=true;P=advance();if(P===l){w=true}continue}if(w===true||P===l){D++;while(eos()!==true&&(P=advance())){if(P===r){N=K.backslashes=true;advance();continue}if(P===l){D++;continue}if(w!==true&&P===i&&(P=advance())===i){L=K.isBrace=true;O=K.isGlob=true;G=true;if(C===true){continue}break}if(w!==true&&P===a){L=K.isBrace=true;O=K.isGlob=true;G=true;if(C===true){continue}break}if(P===E){D--;if(D===0){w=false;L=K.isBrace=true;G=true;break}}}if(C===true){continue}break}if(P===p){y.push(H);$.push(K);K={value:\"\",depth:0,isGlob:false};if(G===true)continue;if(M===i&&H===v+1){v+=2;continue}d=H+1;continue}if(u.noext!==true){const t=P===_||P===s||P===o||P===R||P===c;if(t===true&&peek()===f){O=K.isGlob=true;k=K.isExtglob=true;G=true;if(P===c&&H===v){B=true}if(C===true){while(eos()!==true&&(P=advance())){if(P===r){N=K.backslashes=true;P=advance();continue}if(P===h){O=K.isGlob=true;G=true;break}}continue}break}}if(P===o){if(M===o)m=K.isGlobstar=true;O=K.isGlob=true;G=true;if(C===true){continue}break}if(P===R){O=K.isGlob=true;G=true;if(C===true){continue}break}if(P===A){while(eos()!==true&&(t=advance())){if(t===r){N=K.backslashes=true;advance();continue}if(t===g){T=K.isBracket=true;O=K.isGlob=true;G=true;break}}if(C===true){continue}break}if(u.nonegate!==true&&P===c&&H===v){I=K.negated=true;v++;continue}if(u.noparen!==true&&P===f){O=K.isGlob=true;if(C===true){while(eos()!==true&&(P=advance())){if(P===f){N=K.backslashes=true;P=advance();continue}if(P===h){G=true;break}}continue}break}if(O===true){G=true;if(C===true){continue}break}}if(u.noext===true){k=false;O=false}let U=S;let X=\"\";let F=\"\";if(v>0){X=S.slice(0,v);S=S.slice(v);d-=v}if(U&&O===true&&d>0){U=S.slice(0,d);F=S.slice(d)}else if(O===true){U=\"\";F=S}else{U=S}if(U&&U!==\"\"&&U!==\"/\"&&U!==S){if(isPathSeparator(U.charCodeAt(U.length-1))){U=U.slice(0,-1)}}if(u.unescape===true){if(F)F=n.removeBackslashes(F);if(U&&N===true){U=n.removeBackslashes(U)}}const Q={prefix:X,input:t,start:v,base:U,glob:F,isBrace:L,isBracket:T,isGlob:O,isExtglob:k,isGlobstar:m,negated:I,negatedExtglob:B};if(u.tokens===true){Q.maxDepth=0;if(!isPathSeparator(P)){$.push(K)}Q.tokens=$}if(u.parts===true||u.tokens===true){let e;for(let n=0;n<y.length;n++){const o=e?e+1:v;const s=y[n];const r=t.slice(o,s);if(u.tokens){if(n===0&&v!==0){$[n].isPrefix=true;$[n].value=X}else{$[n].value=r}depth($[n]);Q.maxDepth+=$[n].depth}if(n!==0||r!==\"\"){x.push(r)}e=s}if(e&&e+1<t.length){const n=t.slice(e+1);x.push(n);if(u.tokens){$[$.length-1].value=n;depth($[$.length-1]);Q.maxDepth+=$[$.length-1].depth}}Q.slashes=y;Q.parts=x}return Q};t.exports=scan},96:(t,e,u)=>{const{REGEX_BACKSLASH:n,REGEX_REMOVE_BACKSLASH:o,REGEX_SPECIAL_CHARS:s,REGEX_SPECIAL_CHARS_GLOBAL:r}=u(154);e.isObject=t=>t!==null&&typeof t===\"object\"&&!Array.isArray(t);e.hasRegexChars=t=>s.test(t);e.isRegexChar=t=>t.length===1&&e.hasRegexChars(t);e.escapeRegex=t=>t.replace(r,\"\\\\$1\");e.toPosixSlashes=t=>t.replace(n,\"/\");e.removeBackslashes=t=>t.replace(o,(t=>t===\"\\\\\"?\"\":t));e.escapeLast=(t,u,n)=>{const o=t.lastIndexOf(u,n);if(o===-1)return t;if(t[o-1]===\"\\\\\")return e.escapeLast(t,u,o-1);return`${t.slice(0,o)}\\\\${t.slice(o)}`};e.removePrefix=(t,e={})=>{let u=t;if(u.startsWith(\"./\")){u=u.slice(2);e.prefix=\"./\"}return u};e.wrapOutput=(t,e={},u={})=>{const n=u.contains?\"\":\"^\";const o=u.contains?\"\":\"$\";let s=`${n}(?:${t})${o}`;if(e.negated===true){s=`(?:^(?!${s}).*$)`}return s};e.basename=(t,{windows:e}={})=>{const u=t.split(e?/[\\\\/]/:\"/\");const n=u[u.length-1];if(n===\"\"){return u[u.length-2]}return n}}};var e={};function __nccwpck_require__(u){var n=e[u];if(n!==undefined){return n.exports}var o=e[u]={exports:{}};var s=true;try{t[u](o,o.exports,__nccwpck_require__);s=false}finally{if(s)delete e[u]}return o.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var u=__nccwpck_require__(170);module.exports=u})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcGljb21hdGNoL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7O0FBQUEsTUFBTSxhQUFhLE9BQU8sY0FBYyxlQUFlLHFCQUFxQix1REFBdUQseUNBQXlDLGtDQUFrQyxVQUFVLE9BQU8sZ0JBQWdCLE9BQU8sV0FBVyxPQUFPLE9BQU8sb0JBQW9CLGNBQWMsZ0NBQWdDLGlEQUFpRCxHQUFHLDBCQUEwQixnQkFBZ0IsMkJBQTJCLG9CQUFvQixTQUFTLGdCQUFnQixhQUFhLEVBQUUsR0FBRyxjQUFjLGNBQWMsY0FBYyxjQUFjLGdCQUFnQixlQUFlLGNBQWMsRUFBRSxLQUFLLGdCQUFnQixFQUFFLEdBQUcsV0FBVyxHQUFHLElBQUksRUFBRSxFQUFFLEVBQUUsY0FBYyxFQUFFLEdBQUcsY0FBYyxFQUFFLEVBQUUsRUFBRSxHQUFHLGNBQWMsR0FBRyxJQUFJLEVBQUUsRUFBRSxHQUFHLGNBQWMsRUFBRSxHQUFHLGNBQWMsRUFBRSxHQUFHLFdBQVcsRUFBRSxJQUFJLFlBQVksU0FBUyx3TUFBd00sU0FBUyx1QkFBdUIsRUFBRSxtQkFBbUIsRUFBRSxrQkFBa0IsR0FBRyxJQUFJLE1BQU0sRUFBRSxtQkFBbUIsRUFBRSx1QkFBdUIsRUFBRSxJQUFJLEdBQUcsSUFBSSxNQUFNLEVBQUUsMEJBQTBCLEdBQUcsSUFBSSxNQUFNLEVBQUUsMkJBQTJCLEdBQUcsSUFBSSxNQUFNLEVBQUUsMEJBQTBCLEVBQUUseUJBQXlCLEVBQUUsc0JBQXNCLEVBQUUsZ0JBQWdCLFNBQVMseUxBQXlMLGFBQWEsRUFBRSw4RUFBOEUsV0FBVyxzRUFBc0UscURBQXFELHlDQUF5QyxnR0FBZ0csNEVBQTRFLHVDQUF1QyxtM0JBQW0zQixPQUFPLEtBQUssMENBQTBDLE9BQU8sR0FBRyxNQUFNLG1DQUFtQyxNQUFNLGtDQUFrQyxNQUFNLGtDQUFrQyxNQUFNLGlDQUFpQyxjQUFjLHNCQUFzQixlQUFlLGVBQWUsY0FBYyxNQUFNLHlHQUF5RyxHQUFHLDBCQUEwQixzQ0FBc0MsNkJBQTZCLFNBQVMsWUFBWSxZQUFZLEdBQUcsSUFBSSxjQUFjLFNBQVMsK0NBQStDLFVBQVUsb0NBQW9DLEVBQUUsS0FBSyxFQUFFLGVBQWUsRUFBRSwrQkFBK0Isb0JBQW9CLHdCQUF3Qix5Q0FBeUMsVUFBVSxTQUFTLE1BQU0sZ0VBQWdFLGVBQWUsUUFBUSx1Q0FBdUMsRUFBRSxvQ0FBb0MsRUFBRSxHQUFHLFNBQVMsMENBQTBDLFlBQVksMEJBQTBCLCtCQUErQiwwQkFBMEIsTUFBTSwwSkFBMEosR0FBRyxzQkFBc0IsRUFBRSxRQUFRLEVBQUUsRUFBRSxVQUFVLFFBQVEsbUJBQW1CLGtCQUFrQixrQ0FBa0MsY0FBYyxNQUFNLEVBQUUsR0FBRywrQkFBK0Isb0JBQW9CLFNBQVMsdUtBQXVLLHNCQUFzQixXQUFXLFdBQVcsV0FBVyxXQUFXLFFBQVEsTUFBTSw0QkFBNEIsbUNBQW1DLHVDQUF1Qyx1Q0FBdUMsMkJBQTJCLGNBQWMsWUFBWSxpQkFBaUIsMENBQTBDLGtCQUFrQixrQkFBa0IsUUFBUSwyQ0FBMkMsSUFBSSxVQUFVLElBQUksWUFBWSxhQUFhLGVBQWUsVUFBVSxhQUFhLG9CQUFvQixPQUFPLFdBQVcsb0JBQW9CLE9BQU8sU0FBUyxlQUFlLHdCQUF3Qix5REFBeUQsd0VBQXdFLCtDQUErQyw0Q0FBNEMsY0FBYyxZQUFZLFdBQVcsb0JBQW9CLCtCQUErQiw2QkFBNkIsK0JBQStCLHdDQUF3QyxxQ0FBcUMsaUJBQWlCLE9BQU8sU0FBUyxVQUFVLEtBQUssMEJBQTBCLFNBQVMsK0JBQStCLFNBQVMsa0JBQWtCLGtCQUFrQixrQ0FBa0Msb0JBQW9CLE1BQU0sb0NBQW9DLEVBQUUsTUFBTSw2Q0FBNkMsRUFBRSxXQUFXLHVCQUF1QixpQ0FBaUMsTUFBTSxzQkFBc0IsUUFBUSxxREFBcUQsY0FBYyw0Q0FBNEMsaUJBQWlCLEVBQUUsRUFBRSxtRUFBbUUsaUJBQWlCLHFCQUFxQixTQUFTLGNBQWMsRUFBRSxHQUFHLEVBQUUsR0FBRyx3QkFBd0IsdUJBQXVCLE1BQU0sMkNBQTJDLEVBQUUscUJBQXFCLDBDQUEwQyxjQUFjLFlBQVksbUNBQW1DLGFBQWEsT0FBTyxTQUFTLFlBQVksTUFBTSxxQ0FBcUMsVUFBVSxtQ0FBbUMsMEJBQTBCLFlBQVksMEJBQTBCLFlBQVksTUFBTSxvQkFBb0IsU0FBUyxnQkFBZ0IsRUFBRSxFQUFFLEdBQUcsYUFBYSxzQkFBc0Isc0JBQXNCLEtBQUssMERBQTBELDZCQUE2QixXQUFXLFNBQVMsNkJBQTZCLFNBQVMsY0FBYyxNQUFNLGFBQWEsU0FBUyxhQUFhLFlBQVksMkJBQTJCLFNBQVMsa0JBQWtCLEdBQUcsU0FBUyxPQUFPLFFBQVEsTUFBTSxvQkFBb0IsRUFBRSxTQUFTLGlDQUFpQyxRQUFRLHFCQUFxQixjQUFjLFdBQVcsWUFBWSxTQUFTLHNCQUFzQixNQUFNLEtBQUssT0FBTyxtQkFBbUIsTUFBTSxvQkFBb0IsRUFBRSxVQUFVLDJEQUEyRCw2QkFBNkIseUJBQXlCLG9CQUFvQixhQUFhLG9CQUFvQixpQ0FBaUMsMkJBQTJCLDJCQUEyQixhQUFhLE1BQU0sWUFBWSxpQkFBaUIsSUFBSSxnQ0FBZ0MsV0FBVyxZQUFZLDJDQUEyQyxPQUFPLEVBQUUsRUFBRSw2Q0FBNkMsT0FBTyxFQUFFLEVBQUUsMkNBQTJDLE1BQU0sV0FBVyxRQUFRLFFBQVEsRUFBRSxTQUFTLDBCQUEwQixtQkFBbUIsV0FBVyxRQUFRLFFBQVEsRUFBRSxTQUFTLFlBQVksMEJBQTBCLHdCQUF3QixNQUFNLG9CQUFvQixFQUFFLFNBQVMsWUFBWSxvQkFBb0IsTUFBTSxxQkFBcUIsRUFBRSxTQUFTLFlBQVksMENBQTBDLGtEQUFrRCxzQkFBc0IsNkJBQTZCLHNCQUFzQixTQUFTLE1BQU0sK0NBQStDLEVBQUUsb0JBQW9CLFNBQVMsWUFBWSxtREFBbUQsZ0RBQWdELGtEQUFrRCxPQUFPLEVBQUUsRUFBRSxLQUFLLHNCQUFzQixNQUFNLHVCQUF1QixFQUFFLFNBQVMsWUFBWSxrRUFBa0UsTUFBTSxnQ0FBZ0MsRUFBRSxFQUFFLEVBQUUsU0FBUyxtQkFBbUIsNEJBQTRCLGtEQUFrRCxNQUFNLGdDQUFnQyxFQUFFLEVBQUUsRUFBRSxTQUFTLHNCQUFzQix5QkFBeUIsaURBQWlELE1BQU0sRUFBRSxFQUFFLFdBQVcsUUFBUSxRQUFRLEVBQUUsa0RBQWtELFNBQVMsK0JBQStCLDJDQUEyQyw2QkFBNkIsWUFBWSxVQUFVLFNBQVMsWUFBWSxFQUFFLEVBQUUsRUFBRSxHQUFHLFFBQVEsR0FBRyxrQkFBa0IsU0FBUyxTQUFTLHFCQUFxQixvQkFBb0IsU0FBUyx5RkFBeUYsVUFBVSxRQUFRLFNBQVMsU0FBUyxHQUFHLHNCQUFzQix5QkFBeUIsTUFBTSw2QkFBNkIsRUFBRSxTQUFTLFVBQVUsa0JBQWtCLGtCQUFrQixXQUFXLHFCQUFxQixLQUFLLEtBQUssUUFBUSx3QkFBd0IsTUFBTSx1QkFBdUIsdUJBQXVCLG1CQUFtQixpQkFBaUIsa0NBQWtDLHdDQUF3QyxzQ0FBc0MscUJBQXFCLEVBQUUsUUFBUSxFQUFFLFdBQVcsa0JBQWtCLDZCQUE2QixNQUFNLDhCQUE4QixFQUFFLG9CQUFvQixRQUFRLFNBQVMsWUFBWSxlQUFlLDJCQUEyQixNQUFNLG9CQUFvQixFQUFFLFNBQVMsWUFBWSxRQUFRLHNCQUFzQixnQ0FBZ0MsYUFBYSxNQUFNLE1BQU0sOEJBQThCLEVBQUUsU0FBUyxZQUFZLHdDQUF3QyxrQkFBa0IsY0FBYyxZQUFZLFFBQVEsSUFBSSxTQUFTLE1BQU0sOEJBQThCLEVBQUUsU0FBUyxZQUFZLCtCQUErQiw0QkFBNEIsc0JBQXNCLGNBQWMsWUFBWSxXQUFXLFlBQVksU0FBUyw0REFBNEQsTUFBTSw2QkFBNkIsRUFBRSxTQUFTLE1BQU0sNEJBQTRCLEVBQUUsU0FBUyxZQUFZLHlCQUF5QixrREFBa0QsdUJBQXVCLFNBQVMsd0JBQXdCLFlBQVksUUFBUSxpRkFBaUYsT0FBTyxFQUFFLEVBQUUsTUFBTSw2QkFBNkIsRUFBRSxTQUFTLHFEQUFxRCxNQUFNLDhCQUE4QixFQUFFLFNBQVMsTUFBTSw4QkFBOEIsRUFBRSxTQUFTLFlBQVksa0NBQWtDLHFDQUFxQyx3QkFBd0IsVUFBVSxtQ0FBbUMsU0FBUyxVQUFVLFlBQVksOENBQThDLHNCQUFzQixTQUFTLHNDQUFzQyxNQUFNLDZCQUE2QixFQUFFLFNBQVMsNEVBQTRFLE1BQU0sb0JBQW9CLEVBQUUsU0FBUyxNQUFNLG9CQUFvQixFQUFFLFNBQVMsWUFBWSw4Q0FBOEMsTUFBTSx5Q0FBeUMsRUFBRSxTQUFTLE1BQU0sb0JBQW9CLEVBQUUsU0FBUyxZQUFZLHFCQUFxQixPQUFPLEVBQUUsRUFBRSw0QkFBNEIsTUFBTSxRQUFRLHFCQUFxQixNQUFNLG9CQUFvQixFQUFFLFNBQVMsNENBQTRDLGNBQWMsWUFBWSxXQUFXLFdBQVcsaUJBQWlCLGdCQUFnQixXQUFXLFNBQVMsa0JBQWtCLDBDQUEwQyxzQkFBc0IsU0FBUyxvQkFBb0Isd0JBQXdCLFdBQVcsU0FBUyxlQUFlLGVBQWUseUNBQXlDLGtEQUFrRCwwQ0FBMEMsTUFBTSw4QkFBOEIsRUFBRSxTQUFTLHlEQUF5RCxzREFBc0QsaUNBQWlDLE1BQU0sOEJBQThCLEVBQUUsU0FBUyw0QkFBNEIscUJBQXFCLGVBQWUsTUFBTSxhQUFhLGlCQUFpQiwwQkFBMEIsa0JBQWtCLFdBQVcscUJBQXFCLGtCQUFrQixnQkFBZ0IsV0FBVyxTQUFTLHFEQUFxRCx1REFBdUQsZUFBZSxTQUFTLEVBQUUsa0JBQWtCLGlEQUFpRCxXQUFXLGdCQUFnQiw0QkFBNEIsV0FBVyxTQUFTLHNEQUFzRCw4QkFBOEIsdURBQXVELGVBQWUsU0FBUyxFQUFFLGtCQUFrQixZQUFZLFlBQVksRUFBRSxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUUsR0FBRyxXQUFXLDRCQUE0QixnQkFBZ0IsZUFBZSxNQUFNLGlDQUFpQyxFQUFFLFNBQVMsK0JBQStCLGtCQUFrQixXQUFXLGlCQUFpQixFQUFFLEdBQUcsWUFBWSxFQUFFLEVBQUUsR0FBRyxrQkFBa0IsZ0JBQWdCLGVBQWUsTUFBTSxpQ0FBaUMsRUFBRSxTQUFTLDRDQUE0QyxrQkFBa0IscUJBQXFCLFdBQVcsbUJBQW1CLGdCQUFnQixXQUFXLFNBQVMsU0FBUyw4QkFBOEIsa0JBQWtCLGVBQWUscUNBQXFDLG9CQUFvQixRQUFRLFNBQVMsOERBQThELFdBQVcsUUFBUSxTQUFTLHdEQUF3RCxtQkFBbUIsWUFBWSxZQUFZLHNCQUFzQixZQUFZLFlBQVksS0FBSyxZQUFZLFlBQVksY0FBYyxZQUFZLGFBQWEsUUFBUSxvQkFBb0IsNkVBQTZFLG9DQUFvQyxzQkFBc0Isa0JBQWtCLDZFQUE2RSxvQ0FBb0Msb0JBQW9CLGtCQUFrQix5RUFBeUUsSUFBSSxpQ0FBaUMsR0FBRyxvQkFBb0Isa0VBQWtFLE1BQU0sc0NBQXNDLEVBQUUsR0FBRyxFQUFFLHVCQUF1QixZQUFZLHlCQUF5QiwwQ0FBMEMsYUFBYSxxQkFBcUIsVUFBVSx3QkFBd0IsU0FBUyxNQUFNLGdFQUFnRSxpQkFBaUIsUUFBUSx1Q0FBdUMsRUFBRSxvQ0FBb0MsRUFBRSxHQUFHLFVBQVUsTUFBTSwrR0FBK0csd0JBQXdCLGtCQUFrQixrQkFBa0IsMEJBQTBCLFNBQVMseUJBQXlCLDRCQUE0QixjQUFjLE1BQU0sRUFBRSxHQUFHLG1CQUFtQixnQ0FBZ0MsVUFBVSxFQUFFLFFBQVEsRUFBRSxFQUFFLFVBQVUsU0FBUyxpQkFBaUIsVUFBVSxpQkFBaUIsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsa0JBQWtCLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLG1CQUFtQixFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLG1CQUFtQixFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSw4QkFBOEIsdUJBQXVCLEVBQUUsRUFBRSxZQUFZLEVBQUUsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLHlCQUF5QixFQUFFLEVBQUUsWUFBWSxFQUFFLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLHdCQUF3QixFQUFFLEVBQUUsWUFBWSxFQUFFLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxTQUFTLGlDQUFpQyxhQUFhLHFCQUFxQixhQUFhLG1CQUFtQiw0QkFBNEIsZ0JBQWdCLDhCQUE4QixNQUFNLEVBQUUsR0FBRyxVQUFVLGdCQUFnQixlQUFlLGVBQWUsZUFBZSxjQUFjLGVBQWUsNERBQTRELGdDQUFnQyxxQkFBcUIscUNBQXFDLHVCQUF1QixrQkFBa0IsYUFBYSxjQUFjLGNBQWMsb0JBQW9CLHVDQUF1QyxvQ0FBb0MsaUVBQWlFLGNBQWMsa0JBQWtCLG9FQUFvRSxnQkFBZ0IsZUFBZSx3QkFBd0IsYUFBYSxTQUFTLDZDQUE2QyxrQ0FBa0MsNEJBQTRCLE1BQU0sMkJBQTJCLHVCQUF1QixlQUFlLEVBQUUsU0FBUyxtRUFBbUUsbUNBQW1DLGNBQWMsY0FBYyxnQkFBZ0IsaUJBQWlCLGlCQUFpQixtQ0FBbUMsY0FBYyxnQkFBZ0IsaUJBQWlCLGtDQUFrQyxhQUFhLGlCQUFpQixNQUFNLGdCQUFnQixnQkFBZ0IsdUJBQXVCLGVBQWUsR0FBRyxJQUFJLHdCQUF3QixxREFBcUQsV0FBVyxPQUFPLHlCQUF5QixjQUFjLDRDQUE0QyxZQUFZLGtCQUFrQixjQUFjLFdBQVcsUUFBUSxnQ0FBZ0MsMENBQTBDLCtCQUErQixLQUFLLGFBQWEsT0FBTyxzQ0FBc0MsOEJBQThCLG9EQUFvRCw4QkFBOEIsNkNBQTZDLHdCQUF3Qiw0REFBNEQsWUFBWSxxQkFBcUIsR0FBRyw2QkFBNkIsNENBQTRDLGFBQWEsZ0JBQWdCLGNBQWMsMEJBQTBCLDBCQUEwQixTQUFTLEVBQUUsS0FBSyxTQUFTLEdBQUcsRUFBRSxFQUFFLHdCQUF3QixTQUFTLEVBQUUsTUFBTSwrQkFBK0IsYUFBYSxVQUFVLFVBQVUsd0JBQXdCLG9CQUFvQiw0QkFBNEIsbURBQW1ELE9BQU8sOEJBQThCLGtEQUFrRCwwQkFBMEIsY0FBYyxTQUFTLHFDQUFxQywwQkFBMEIsSUFBSSxjQUFjLGdEQUFnRCxTQUFTLDZCQUE2QixhQUFhLHNCQUFzQixvQkFBb0IsZUFBZSxjQUFjLE1BQU0sK1NBQStTLFFBQVEsc0NBQXNDLGdCQUFnQixzQkFBc0Isa0NBQWtDLG1CQUFtQixjQUFjLG1CQUFtQiwyQ0FBMkMsV0FBVyxXQUFXLFdBQVcsUUFBUSxTQUFTLFFBQVEsUUFBUSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFFBQVEsTUFBTSxNQUFNLE9BQU8sK0JBQStCLG1CQUFtQixpQ0FBaUMsbUJBQW1CLElBQUksMEJBQTBCLFdBQVcsWUFBWSxNQUFNLFVBQVUscUJBQXFCLFlBQVksVUFBVSxPQUFPLFNBQVMsb0JBQW9CLElBQUksbUNBQW1DLFVBQVUscUJBQXFCLFVBQVUsU0FBUyxVQUFVLElBQUksU0FBUyx1Q0FBdUMsaUJBQWlCLGdCQUFnQixPQUFPLGFBQWEsU0FBUyxNQUFNLG9CQUFvQixpQkFBaUIsZ0JBQWdCLE9BQU8sYUFBYSxTQUFTLE1BQU0sVUFBVSxJQUFJLFVBQVUsUUFBUSxpQkFBaUIsT0FBTyxRQUFRLGFBQWEsU0FBUyxNQUFNLFVBQVUsVUFBVSxVQUFVLEdBQUcsK0JBQStCLHFCQUFxQixtQkFBbUIsS0FBSyxTQUFTLE1BQU0sU0FBUyxtQkFBbUIsMENBQTBDLHlCQUF5QixnQkFBZ0IsbUJBQW1CLE9BQU8saUJBQWlCLE9BQU8sYUFBYSxtQ0FBbUMsVUFBVSxxQkFBcUIsWUFBWSxTQUFTLFVBQVUsZ0JBQWdCLE9BQU8sT0FBTyxTQUFTLE9BQU8sVUFBVSw2QkFBNkIsZ0JBQWdCLE9BQU8sYUFBYSxTQUFTLE1BQU0sVUFBVSxnQkFBZ0IsT0FBTyxhQUFhLFNBQVMsTUFBTSxVQUFVLG1DQUFtQyxVQUFVLHFCQUFxQixVQUFVLFNBQVMsVUFBVSxtQkFBbUIsZ0JBQWdCLE9BQU8sT0FBTyxhQUFhLFNBQVMsTUFBTSxvQ0FBb0MsaUJBQWlCLElBQUksU0FBUyw0QkFBNEIsZ0JBQWdCLGFBQWEsbUNBQW1DLFVBQVUscUJBQXFCLFlBQVksU0FBUyxVQUFVLE9BQU8sT0FBTyxTQUFTLE1BQU0sYUFBYSxPQUFPLGFBQWEsU0FBUyxPQUFPLG1CQUFtQixRQUFRLFFBQVEsUUFBUSxTQUFTLFNBQVMsUUFBUSxlQUFlLGFBQWEsS0FBSyxxQkFBcUIsZUFBZSxhQUFhLGtCQUFrQixLQUFLLElBQUksS0FBSyxJQUFJLDhCQUE4Qiw4Q0FBOEMsaUJBQWlCLHNCQUFzQiw4QkFBOEIsZ0JBQWdCLDBCQUEwQixTQUFTLDJIQUEySCxvQkFBb0IsYUFBYSx3QkFBd0IsVUFBVSxXQUFXLG9DQUFvQyxNQUFNLFlBQVksV0FBVyxLQUFLLGdCQUFnQixhQUFhLHFCQUFxQixhQUFhLGlCQUFpQixtQkFBbUIsYUFBYSxLQUFLLGFBQWEsWUFBWSx1QkFBdUIsa0JBQWtCLFVBQVUsSUFBSSxvQkFBb0IscUJBQXFCLFVBQVUsYUFBYSxzQkFBc0IscUJBQXFCLGlDQUFpQyxZQUFZLFVBQVUsVUFBVSxlQUFlLGNBQWMsTUFBTSw4RkFBOEYsUUFBUSwrREFBK0QsNkJBQTZCLGtEQUFrRCxxQ0FBcUMscUNBQXFDLHVEQUF1RCx1QkFBdUIsMkJBQTJCLG1CQUFtQiw4Q0FBOEMsU0FBUyxhQUFhLElBQUksV0FBVyxHQUFHLHNCQUFzQixJQUFJLFFBQVEsdUJBQXVCLGFBQWEsY0FBYyxVQUFVLG9CQUFvQixLQUFLLElBQUksMEJBQTBCLDBCQUEwQixTQUFTLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxFQUFFLHFCQUFxQixZQUFZLEVBQUUsT0FBTyxVQUFVLGVBQWUsVUFBVSxHQUFHLElBQUksK0JBQStCLHNCQUFzQixXQUFXLHFCQUFxQixZQUFZLFNBQVMsZ0NBQWdDLFdBQVcsa0JBQWtCLGlCQUFpQixZQUFZLFlBQVksV0FBVyxJQUFJLHNDQUFzQyxRQUFRLFFBQVEsaUJBQWlCLGlCQUFpQixtRUFBbUUsU0FBUyxLQUFLLCtCQUErQixpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9waWNvbWF0Y2gvaW5kZXguanM/NjQwNSJdLCJzb3VyY2VzQ29udGVudCI6WyIoKCk9PntcInVzZSBzdHJpY3RcIjt2YXIgdD17MTcwOih0LGUsdSk9Pntjb25zdCBuPXUoNTEwKTtjb25zdCBpc1dpbmRvd3M9KCk9PntpZih0eXBlb2YgbmF2aWdhdG9yIT09XCJ1bmRlZmluZWRcIiYmbmF2aWdhdG9yLnBsYXRmb3JtKXtjb25zdCB0PW5hdmlnYXRvci5wbGF0Zm9ybS50b0xvd2VyQ2FzZSgpO3JldHVybiB0PT09XCJ3aW4zMlwifHx0PT09XCJ3aW5kb3dzXCJ9aWYodHlwZW9mIHByb2Nlc3MhPT1cInVuZGVmaW5lZFwiJiZwcm9jZXNzLnBsYXRmb3JtKXtyZXR1cm4gcHJvY2Vzcy5wbGF0Zm9ybT09PVwid2luMzJcIn1yZXR1cm4gZmFsc2V9O2Z1bmN0aW9uIHBpY29tYXRjaCh0LGUsdT1mYWxzZSl7aWYoZSYmKGUud2luZG93cz09PW51bGx8fGUud2luZG93cz09PXVuZGVmaW5lZCkpe2U9ey4uLmUsd2luZG93czppc1dpbmRvd3MoKX19cmV0dXJuIG4odCxlLHUpfU9iamVjdC5hc3NpZ24ocGljb21hdGNoLG4pO3QuZXhwb3J0cz1waWNvbWF0Y2h9LDE1NDp0PT57Y29uc3QgZT1cIlxcXFxcXFxcL1wiO2NvbnN0IHU9YFteJHtlfV1gO2NvbnN0IG49XCJcXFxcLlwiO2NvbnN0IG89XCJcXFxcK1wiO2NvbnN0IHM9XCJcXFxcP1wiO2NvbnN0IHI9XCJcXFxcL1wiO2NvbnN0IGE9XCIoPz0uKVwiO2NvbnN0IGk9XCJbXi9dXCI7Y29uc3QgYz1gKD86JHtyfXwkKWA7Y29uc3QgcD1gKD86Xnwke3J9KWA7Y29uc3QgbD1gJHtufXsxLDJ9JHtjfWA7Y29uc3QgZj1gKD8hJHtufSlgO2NvbnN0IEE9YCg/ISR7cH0ke2x9KWA7Y29uc3QgXz1gKD8hJHtufXswLDF9JHtjfSlgO2NvbnN0IFI9YCg/ISR7bH0pYDtjb25zdCBFPWBbXi4ke3J9XWA7Y29uc3QgaD1gJHtpfSo/YDtjb25zdCBnPVwiL1wiO2NvbnN0IGI9e0RPVF9MSVRFUkFMOm4sUExVU19MSVRFUkFMOm8sUU1BUktfTElURVJBTDpzLFNMQVNIX0xJVEVSQUw6cixPTkVfQ0hBUjphLFFNQVJLOmksRU5EX0FOQ0hPUjpjLERPVFNfU0xBU0g6bCxOT19ET1Q6ZixOT19ET1RTOkEsTk9fRE9UX1NMQVNIOl8sTk9fRE9UU19TTEFTSDpSLFFNQVJLX05PX0RPVDpFLFNUQVI6aCxTVEFSVF9BTkNIT1I6cCxTRVA6Z307Y29uc3QgQz17Li4uYixTTEFTSF9MSVRFUkFMOmBbJHtlfV1gLFFNQVJLOnUsU1RBUjpgJHt1fSo/YCxET1RTX1NMQVNIOmAke259ezEsMn0oPzpbJHtlfV18JClgLE5PX0RPVDpgKD8hJHtufSlgLE5PX0RPVFM6YCg/ISg/Ol58WyR7ZX1dKSR7bn17MSwyfSg/Olske2V9XXwkKSlgLE5PX0RPVF9TTEFTSDpgKD8hJHtufXswLDF9KD86WyR7ZX1dfCQpKWAsTk9fRE9UU19TTEFTSDpgKD8hJHtufXsxLDJ9KD86WyR7ZX1dfCQpKWAsUU1BUktfTk9fRE9UOmBbXi4ke2V9XWAsU1RBUlRfQU5DSE9SOmAoPzpefFske2V9XSlgLEVORF9BTkNIT1I6YCg/Olske2V9XXwkKWAsU0VQOlwiXFxcXFwifTtjb25zdCB5PXthbG51bTpcImEtekEtWjAtOVwiLGFscGhhOlwiYS16QS1aXCIsYXNjaWk6XCJcXFxceDAwLVxcXFx4N0ZcIixibGFuazpcIiBcXFxcdFwiLGNudHJsOlwiXFxcXHgwMC1cXFxceDFGXFxcXHg3RlwiLGRpZ2l0OlwiMC05XCIsZ3JhcGg6XCJcXFxceDIxLVxcXFx4N0VcIixsb3dlcjpcImEtelwiLHByaW50OlwiXFxcXHgyMC1cXFxceDdFIFwiLHB1bmN0OlwiXFxcXC0hXFxcIiMkJSYnKClcXFxcKissLi86Ozw9Pj9AW1xcXFxdXl9ge3x9flwiLHNwYWNlOlwiIFxcXFx0XFxcXHJcXFxcblxcXFx2XFxcXGZcIix1cHBlcjpcIkEtWlwiLHdvcmQ6XCJBLVphLXowLTlfXCIseGRpZ2l0OlwiQS1GYS1mMC05XCJ9O3QuZXhwb3J0cz17TUFYX0xFTkdUSDoxMDI0KjY0LFBPU0lYX1JFR0VYX1NPVVJDRTp5LFJFR0VYX0JBQ0tTTEFTSDovXFxcXCg/IVsqKz9eJHt9KHwpW1xcXV0pL2csUkVHRVhfTk9OX1NQRUNJQUxfQ0hBUlM6L15bXkAhW1xcXS4sJCorP157fSgpfFxcXFwvXSsvLFJFR0VYX1NQRUNJQUxfQ0hBUlM6L1stKis/Ll4ke30ofClbXFxdXS8sUkVHRVhfU1BFQ0lBTF9DSEFSU19CQUNLUkVGOi8oXFxcXD8pKChcXFcpKFxcMyopKS9nLFJFR0VYX1NQRUNJQUxfQ0hBUlNfR0xPQkFMOi8oWy0qKz8uXiR7fSh8KVtcXF1dKS9nLFJFR0VYX1JFTU9WRV9CQUNLU0xBU0g6Lyg/OlxcWy4qP1teXFxcXF1cXF18XFxcXCg/PS4pKS9nLFJFUExBQ0VNRU5UUzp7XCIqKipcIjpcIipcIixcIioqLyoqXCI6XCIqKlwiLFwiKiovKiovKipcIjpcIioqXCJ9LENIQVJfMDo0OCxDSEFSXzk6NTcsQ0hBUl9VUFBFUkNBU0VfQTo2NSxDSEFSX0xPV0VSQ0FTRV9BOjk3LENIQVJfVVBQRVJDQVNFX1o6OTAsQ0hBUl9MT1dFUkNBU0VfWjoxMjIsQ0hBUl9MRUZUX1BBUkVOVEhFU0VTOjQwLENIQVJfUklHSFRfUEFSRU5USEVTRVM6NDEsQ0hBUl9BU1RFUklTSzo0MixDSEFSX0FNUEVSU0FORDozOCxDSEFSX0FUOjY0LENIQVJfQkFDS1dBUkRfU0xBU0g6OTIsQ0hBUl9DQVJSSUFHRV9SRVRVUk46MTMsQ0hBUl9DSVJDVU1GTEVYX0FDQ0VOVDo5NCxDSEFSX0NPTE9OOjU4LENIQVJfQ09NTUE6NDQsQ0hBUl9ET1Q6NDYsQ0hBUl9ET1VCTEVfUVVPVEU6MzQsQ0hBUl9FUVVBTDo2MSxDSEFSX0VYQ0xBTUFUSU9OX01BUks6MzMsQ0hBUl9GT1JNX0ZFRUQ6MTIsQ0hBUl9GT1JXQVJEX1NMQVNIOjQ3LENIQVJfR1JBVkVfQUNDRU5UOjk2LENIQVJfSEFTSDozNSxDSEFSX0hZUEhFTl9NSU5VUzo0NSxDSEFSX0xFRlRfQU5HTEVfQlJBQ0tFVDo2MCxDSEFSX0xFRlRfQ1VSTFlfQlJBQ0U6MTIzLENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVDo5MSxDSEFSX0xJTkVfRkVFRDoxMCxDSEFSX05PX0JSRUFLX1NQQUNFOjE2MCxDSEFSX1BFUkNFTlQ6MzcsQ0hBUl9QTFVTOjQzLENIQVJfUVVFU1RJT05fTUFSSzo2MyxDSEFSX1JJR0hUX0FOR0xFX0JSQUNLRVQ6NjIsQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRToxMjUsQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVDo5MyxDSEFSX1NFTUlDT0xPTjo1OSxDSEFSX1NJTkdMRV9RVU9URTozOSxDSEFSX1NQQUNFOjMyLENIQVJfVEFCOjksQ0hBUl9VTkRFUlNDT1JFOjk1LENIQVJfVkVSVElDQUxfTElORToxMjQsQ0hBUl9aRVJPX1dJRFRIX05PQlJFQUtfU1BBQ0U6NjUyNzksZXh0Z2xvYkNoYXJzKHQpe3JldHVybntcIiFcIjp7dHlwZTpcIm5lZ2F0ZVwiLG9wZW46XCIoPzooPyEoPzpcIixjbG9zZTpgKSkke3QuU1RBUn0pYH0sXCI/XCI6e3R5cGU6XCJxbWFya1wiLG9wZW46XCIoPzpcIixjbG9zZTpcIik/XCJ9LFwiK1wiOnt0eXBlOlwicGx1c1wiLG9wZW46XCIoPzpcIixjbG9zZTpcIikrXCJ9LFwiKlwiOnt0eXBlOlwic3RhclwiLG9wZW46XCIoPzpcIixjbG9zZTpcIikqXCJ9LFwiQFwiOnt0eXBlOlwiYXRcIixvcGVuOlwiKD86XCIsY2xvc2U6XCIpXCJ9fX0sZ2xvYkNoYXJzKHQpe3JldHVybiB0PT09dHJ1ZT9DOmJ9fX0sNjk3Oih0LGUsdSk9Pntjb25zdCBuPXUoMTU0KTtjb25zdCBvPXUoOTYpO2NvbnN0e01BWF9MRU5HVEg6cyxQT1NJWF9SRUdFWF9TT1VSQ0U6cixSRUdFWF9OT05fU1BFQ0lBTF9DSEFSUzphLFJFR0VYX1NQRUNJQUxfQ0hBUlNfQkFDS1JFRjppLFJFUExBQ0VNRU5UUzpjfT1uO2NvbnN0IGV4cGFuZFJhbmdlPSh0LGUpPT57aWYodHlwZW9mIGUuZXhwYW5kUmFuZ2U9PT1cImZ1bmN0aW9uXCIpe3JldHVybiBlLmV4cGFuZFJhbmdlKC4uLnQsZSl9dC5zb3J0KCk7Y29uc3QgdT1gWyR7dC5qb2luKFwiLVwiKX1dYDt0cnl7bmV3IFJlZ0V4cCh1KX1jYXRjaChlKXtyZXR1cm4gdC5tYXAoKHQ9Pm8uZXNjYXBlUmVnZXgodCkpKS5qb2luKFwiLi5cIil9cmV0dXJuIHV9O2NvbnN0IHN5bnRheEVycm9yPSh0LGUpPT5gTWlzc2luZyAke3R9OiBcIiR7ZX1cIiAtIHVzZSBcIlxcXFxcXFxcJHtlfVwiIHRvIG1hdGNoIGxpdGVyYWwgY2hhcmFjdGVyc2A7Y29uc3QgcGFyc2U9KHQsZSk9PntpZih0eXBlb2YgdCE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhIHN0cmluZ1wiKX10PWNbdF18fHQ7Y29uc3QgdT17Li4uZX07Y29uc3QgcD10eXBlb2YgdS5tYXhMZW5ndGg9PT1cIm51bWJlclwiP01hdGgubWluKHMsdS5tYXhMZW5ndGgpOnM7bGV0IGw9dC5sZW5ndGg7aWYobD5wKXt0aHJvdyBuZXcgU3ludGF4RXJyb3IoYElucHV0IGxlbmd0aDogJHtsfSwgZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgbGVuZ3RoOiAke3B9YCl9Y29uc3QgZj17dHlwZTpcImJvc1wiLHZhbHVlOlwiXCIsb3V0cHV0OnUucHJlcGVuZHx8XCJcIn07Y29uc3QgQT1bZl07Y29uc3QgXz11LmNhcHR1cmU/XCJcIjpcIj86XCI7Y29uc3QgUj1uLmdsb2JDaGFycyh1LndpbmRvd3MpO2NvbnN0IEU9bi5leHRnbG9iQ2hhcnMoUik7Y29uc3R7RE9UX0xJVEVSQUw6aCxQTFVTX0xJVEVSQUw6ZyxTTEFTSF9MSVRFUkFMOmIsT05FX0NIQVI6QyxET1RTX1NMQVNIOnksTk9fRE9UOiQsTk9fRE9UX1NMQVNIOngsTk9fRE9UU19TTEFTSDpTLFFNQVJLOkgsUU1BUktfTk9fRE9UOnYsU1RBUjpkLFNUQVJUX0FOQ0hPUjpMfT1SO2NvbnN0IGdsb2JzdGFyPXQ9PmAoJHtffSg/Oig/ISR7TH0ke3QuZG90P3k6aH0pLikqPylgO2NvbnN0IFQ9dS5kb3Q/XCJcIjokO2NvbnN0IE89dS5kb3Q/SDp2O2xldCBrPXUuYmFzaD09PXRydWU/Z2xvYnN0YXIodSk6ZDtpZih1LmNhcHR1cmUpe2s9YCgke2t9KWB9aWYodHlwZW9mIHUubm9leHQ9PT1cImJvb2xlYW5cIil7dS5ub2V4dGdsb2I9dS5ub2V4dH1jb25zdCBtPXtpbnB1dDp0LGluZGV4Oi0xLHN0YXJ0OjAsZG90OnUuZG90PT09dHJ1ZSxjb25zdW1lZDpcIlwiLG91dHB1dDpcIlwiLHByZWZpeDpcIlwiLGJhY2t0cmFjazpmYWxzZSxuZWdhdGVkOmZhbHNlLGJyYWNrZXRzOjAsYnJhY2VzOjAscGFyZW5zOjAscXVvdGVzOjAsZ2xvYnN0YXI6ZmFsc2UsdG9rZW5zOkF9O3Q9by5yZW1vdmVQcmVmaXgodCxtKTtsPXQubGVuZ3RoO2NvbnN0IHc9W107Y29uc3QgTj1bXTtjb25zdCBJPVtdO2xldCBCPWY7bGV0IEc7Y29uc3QgZW9zPSgpPT5tLmluZGV4PT09bC0xO2NvbnN0IEQ9bS5wZWVrPShlPTEpPT50W20uaW5kZXgrZV07Y29uc3QgTT1tLmFkdmFuY2U9KCk9PnRbKyttLmluZGV4XXx8XCJcIjtjb25zdCByZW1haW5pbmc9KCk9PnQuc2xpY2UobS5pbmRleCsxKTtjb25zdCBjb25zdW1lPSh0PVwiXCIsZT0wKT0+e20uY29uc3VtZWQrPXQ7bS5pbmRleCs9ZX07Y29uc3QgYXBwZW5kPXQ9PnttLm91dHB1dCs9dC5vdXRwdXQhPW51bGw/dC5vdXRwdXQ6dC52YWx1ZTtjb25zdW1lKHQudmFsdWUpfTtjb25zdCBuZWdhdGU9KCk9PntsZXQgdD0xO3doaWxlKEQoKT09PVwiIVwiJiYoRCgyKSE9PVwiKFwifHxEKDMpPT09XCI/XCIpKXtNKCk7bS5zdGFydCsrO3QrK31pZih0JTI9PT0wKXtyZXR1cm4gZmFsc2V9bS5uZWdhdGVkPXRydWU7bS5zdGFydCsrO3JldHVybiB0cnVlfTtjb25zdCBpbmNyZW1lbnQ9dD0+e21bdF0rKztJLnB1c2godCl9O2NvbnN0IGRlY3JlbWVudD10PT57bVt0XS0tO0kucG9wKCl9O2NvbnN0IHB1c2g9dD0+e2lmKEIudHlwZT09PVwiZ2xvYnN0YXJcIil7Y29uc3QgZT1tLmJyYWNlcz4wJiYodC50eXBlPT09XCJjb21tYVwifHx0LnR5cGU9PT1cImJyYWNlXCIpO2NvbnN0IHU9dC5leHRnbG9iPT09dHJ1ZXx8dy5sZW5ndGgmJih0LnR5cGU9PT1cInBpcGVcInx8dC50eXBlPT09XCJwYXJlblwiKTtpZih0LnR5cGUhPT1cInNsYXNoXCImJnQudHlwZSE9PVwicGFyZW5cIiYmIWUmJiF1KXttLm91dHB1dD1tLm91dHB1dC5zbGljZSgwLC1CLm91dHB1dC5sZW5ndGgpO0IudHlwZT1cInN0YXJcIjtCLnZhbHVlPVwiKlwiO0Iub3V0cHV0PWs7bS5vdXRwdXQrPUIub3V0cHV0fX1pZih3Lmxlbmd0aCYmdC50eXBlIT09XCJwYXJlblwiKXt3W3cubGVuZ3RoLTFdLmlubmVyKz10LnZhbHVlfWlmKHQudmFsdWV8fHQub3V0cHV0KWFwcGVuZCh0KTtpZihCJiZCLnR5cGU9PT1cInRleHRcIiYmdC50eXBlPT09XCJ0ZXh0XCIpe0Iub3V0cHV0PShCLm91dHB1dHx8Qi52YWx1ZSkrdC52YWx1ZTtCLnZhbHVlKz10LnZhbHVlO3JldHVybn10LnByZXY9QjtBLnB1c2godCk7Qj10fTtjb25zdCBleHRnbG9iT3Blbj0odCxlKT0+e2NvbnN0IG49ey4uLkVbZV0sY29uZGl0aW9uczoxLGlubmVyOlwiXCJ9O24ucHJldj1CO24ucGFyZW5zPW0ucGFyZW5zO24ub3V0cHV0PW0ub3V0cHV0O2NvbnN0IG89KHUuY2FwdHVyZT9cIihcIjpcIlwiKStuLm9wZW47aW5jcmVtZW50KFwicGFyZW5zXCIpO3B1c2goe3R5cGU6dCx2YWx1ZTplLG91dHB1dDptLm91dHB1dD9cIlwiOkN9KTtwdXNoKHt0eXBlOlwicGFyZW5cIixleHRnbG9iOnRydWUsdmFsdWU6TSgpLG91dHB1dDpvfSk7dy5wdXNoKG4pfTtjb25zdCBleHRnbG9iQ2xvc2U9dD0+e2xldCBuPXQuY2xvc2UrKHUuY2FwdHVyZT9cIilcIjpcIlwiKTtsZXQgbztpZih0LnR5cGU9PT1cIm5lZ2F0ZVwiKXtsZXQgcz1rO2lmKHQuaW5uZXImJnQuaW5uZXIubGVuZ3RoPjEmJnQuaW5uZXIuaW5jbHVkZXMoXCIvXCIpKXtzPWdsb2JzdGFyKHUpfWlmKHMhPT1rfHxlb3MoKXx8L15cXCkrJC8udGVzdChyZW1haW5pbmcoKSkpe249dC5jbG9zZT1gKSQpKSR7c31gfWlmKHQuaW5uZXIuaW5jbHVkZXMoXCIqXCIpJiYobz1yZW1haW5pbmcoKSkmJi9eXFwuW15cXFxcLy5dKyQvLnRlc3Qobykpe2NvbnN0IHU9cGFyc2Uobyx7Li4uZSxmYXN0cGF0aHM6ZmFsc2V9KS5vdXRwdXQ7bj10LmNsb3NlPWApJHt1fSkke3N9KWB9aWYodC5wcmV2LnR5cGU9PT1cImJvc1wiKXttLm5lZ2F0ZWRFeHRnbG9iPXRydWV9fXB1c2goe3R5cGU6XCJwYXJlblwiLGV4dGdsb2I6dHJ1ZSx2YWx1ZTpHLG91dHB1dDpufSk7ZGVjcmVtZW50KFwicGFyZW5zXCIpfTtpZih1LmZhc3RwYXRocyE9PWZhbHNlJiYhLyheWyohXXxbLygpW1xcXXt9XCJdKS8udGVzdCh0KSl7bGV0IG49ZmFsc2U7bGV0IHM9dC5yZXBsYWNlKGksKCh0LGUsdSxvLHMscik9PntpZihvPT09XCJcXFxcXCIpe249dHJ1ZTtyZXR1cm4gdH1pZihvPT09XCI/XCIpe2lmKGUpe3JldHVybiBlK28rKHM/SC5yZXBlYXQocy5sZW5ndGgpOlwiXCIpfWlmKHI9PT0wKXtyZXR1cm4gTysocz9ILnJlcGVhdChzLmxlbmd0aCk6XCJcIil9cmV0dXJuIEgucmVwZWF0KHUubGVuZ3RoKX1pZihvPT09XCIuXCIpe3JldHVybiBoLnJlcGVhdCh1Lmxlbmd0aCl9aWYobz09PVwiKlwiKXtpZihlKXtyZXR1cm4gZStvKyhzP2s6XCJcIil9cmV0dXJuIGt9cmV0dXJuIGU/dDpgXFxcXCR7dH1gfSkpO2lmKG49PT10cnVlKXtpZih1LnVuZXNjYXBlPT09dHJ1ZSl7cz1zLnJlcGxhY2UoL1xcXFwvZyxcIlwiKX1lbHNle3M9cy5yZXBsYWNlKC9cXFxcKy9nLCh0PT50Lmxlbmd0aCUyPT09MD9cIlxcXFxcXFxcXCI6dD9cIlxcXFxcIjpcIlwiKSl9fWlmKHM9PT10JiZ1LmNvbnRhaW5zPT09dHJ1ZSl7bS5vdXRwdXQ9dDtyZXR1cm4gbX1tLm91dHB1dD1vLndyYXBPdXRwdXQocyxtLGUpO3JldHVybiBtfXdoaWxlKCFlb3MoKSl7Rz1NKCk7aWYoRz09PVwiXFwwXCIpe2NvbnRpbnVlfWlmKEc9PT1cIlxcXFxcIil7Y29uc3QgdD1EKCk7aWYodD09PVwiL1wiJiZ1LmJhc2ghPT10cnVlKXtjb250aW51ZX1pZih0PT09XCIuXCJ8fHQ9PT1cIjtcIil7Y29udGludWV9aWYoIXQpe0crPVwiXFxcXFwiO3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6R30pO2NvbnRpbnVlfWNvbnN0IGU9L15cXFxcKy8uZXhlYyhyZW1haW5pbmcoKSk7bGV0IG49MDtpZihlJiZlWzBdLmxlbmd0aD4yKXtuPWVbMF0ubGVuZ3RoO20uaW5kZXgrPW47aWYobiUyIT09MCl7Rys9XCJcXFxcXCJ9fWlmKHUudW5lc2NhcGU9PT10cnVlKXtHPU0oKX1lbHNle0crPU0oKX1pZihtLmJyYWNrZXRzPT09MCl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHfSk7Y29udGludWV9fWlmKG0uYnJhY2tldHM+MCYmKEchPT1cIl1cInx8Qi52YWx1ZT09PVwiW1wifHxCLnZhbHVlPT09XCJbXlwiKSl7aWYodS5wb3NpeCE9PWZhbHNlJiZHPT09XCI6XCIpe2NvbnN0IHQ9Qi52YWx1ZS5zbGljZSgxKTtpZih0LmluY2x1ZGVzKFwiW1wiKSl7Qi5wb3NpeD10cnVlO2lmKHQuaW5jbHVkZXMoXCI6XCIpKXtjb25zdCB0PUIudmFsdWUubGFzdEluZGV4T2YoXCJbXCIpO2NvbnN0IGU9Qi52YWx1ZS5zbGljZSgwLHQpO2NvbnN0IHU9Qi52YWx1ZS5zbGljZSh0KzIpO2NvbnN0IG49clt1XTtpZihuKXtCLnZhbHVlPWUrbjttLmJhY2t0cmFjaz10cnVlO00oKTtpZighZi5vdXRwdXQmJkEuaW5kZXhPZihCKT09PTEpe2Yub3V0cHV0PUN9Y29udGludWV9fX19aWYoRz09PVwiW1wiJiZEKCkhPT1cIjpcInx8Rz09PVwiLVwiJiZEKCk9PT1cIl1cIil7Rz1gXFxcXCR7R31gfWlmKEc9PT1cIl1cIiYmKEIudmFsdWU9PT1cIltcInx8Qi52YWx1ZT09PVwiW15cIikpe0c9YFxcXFwke0d9YH1pZih1LnBvc2l4PT09dHJ1ZSYmRz09PVwiIVwiJiZCLnZhbHVlPT09XCJbXCIpe0c9XCJeXCJ9Qi52YWx1ZSs9RzthcHBlbmQoe3ZhbHVlOkd9KTtjb250aW51ZX1pZihtLnF1b3Rlcz09PTEmJkchPT0nXCInKXtHPW8uZXNjYXBlUmVnZXgoRyk7Qi52YWx1ZSs9RzthcHBlbmQoe3ZhbHVlOkd9KTtjb250aW51ZX1pZihHPT09J1wiJyl7bS5xdW90ZXM9bS5xdW90ZXM9PT0xPzA6MTtpZih1LmtlZXBRdW90ZXM9PT10cnVlKXtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkd9KX1jb250aW51ZX1pZihHPT09XCIoXCIpe2luY3JlbWVudChcInBhcmVuc1wiKTtwdXNoKHt0eXBlOlwicGFyZW5cIix2YWx1ZTpHfSk7Y29udGludWV9aWYoRz09PVwiKVwiKXtpZihtLnBhcmVucz09PTAmJnUuc3RyaWN0QnJhY2tldHM9PT10cnVlKXt0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJvcGVuaW5nXCIsXCIoXCIpKX1jb25zdCB0PXdbdy5sZW5ndGgtMV07aWYodCYmbS5wYXJlbnM9PT10LnBhcmVucysxKXtleHRnbG9iQ2xvc2Uody5wb3AoKSk7Y29udGludWV9cHVzaCh7dHlwZTpcInBhcmVuXCIsdmFsdWU6RyxvdXRwdXQ6bS5wYXJlbnM/XCIpXCI6XCJcXFxcKVwifSk7ZGVjcmVtZW50KFwicGFyZW5zXCIpO2NvbnRpbnVlfWlmKEc9PT1cIltcIil7aWYodS5ub2JyYWNrZXQ9PT10cnVlfHwhcmVtYWluaW5nKCkuaW5jbHVkZXMoXCJdXCIpKXtpZih1Lm5vYnJhY2tldCE9PXRydWUmJnUuc3RyaWN0QnJhY2tldHM9PT10cnVlKXt0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJjbG9zaW5nXCIsXCJdXCIpKX1HPWBcXFxcJHtHfWB9ZWxzZXtpbmNyZW1lbnQoXCJicmFja2V0c1wiKX1wdXNoKHt0eXBlOlwiYnJhY2tldFwiLHZhbHVlOkd9KTtjb250aW51ZX1pZihHPT09XCJdXCIpe2lmKHUubm9icmFja2V0PT09dHJ1ZXx8QiYmQi50eXBlPT09XCJicmFja2V0XCImJkIudmFsdWUubGVuZ3RoPT09MSl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHLG91dHB1dDpgXFxcXCR7R31gfSk7Y29udGludWV9aWYobS5icmFja2V0cz09PTApe2lmKHUuc3RyaWN0QnJhY2tldHM9PT10cnVlKXt0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJvcGVuaW5nXCIsXCJbXCIpKX1wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkcsb3V0cHV0OmBcXFxcJHtHfWB9KTtjb250aW51ZX1kZWNyZW1lbnQoXCJicmFja2V0c1wiKTtjb25zdCB0PUIudmFsdWUuc2xpY2UoMSk7aWYoQi5wb3NpeCE9PXRydWUmJnRbMF09PT1cIl5cIiYmIXQuaW5jbHVkZXMoXCIvXCIpKXtHPWAvJHtHfWB9Qi52YWx1ZSs9RzthcHBlbmQoe3ZhbHVlOkd9KTtpZih1LmxpdGVyYWxCcmFja2V0cz09PWZhbHNlfHxvLmhhc1JlZ2V4Q2hhcnModCkpe2NvbnRpbnVlfWNvbnN0IGU9by5lc2NhcGVSZWdleChCLnZhbHVlKTttLm91dHB1dD1tLm91dHB1dC5zbGljZSgwLC1CLnZhbHVlLmxlbmd0aCk7aWYodS5saXRlcmFsQnJhY2tldHM9PT10cnVlKXttLm91dHB1dCs9ZTtCLnZhbHVlPWU7Y29udGludWV9Qi52YWx1ZT1gKCR7X30ke2V9fCR7Qi52YWx1ZX0pYDttLm91dHB1dCs9Qi52YWx1ZTtjb250aW51ZX1pZihHPT09XCJ7XCImJnUubm9icmFjZSE9PXRydWUpe2luY3JlbWVudChcImJyYWNlc1wiKTtjb25zdCB0PXt0eXBlOlwiYnJhY2VcIix2YWx1ZTpHLG91dHB1dDpcIihcIixvdXRwdXRJbmRleDptLm91dHB1dC5sZW5ndGgsdG9rZW5zSW5kZXg6bS50b2tlbnMubGVuZ3RofTtOLnB1c2godCk7cHVzaCh0KTtjb250aW51ZX1pZihHPT09XCJ9XCIpe2NvbnN0IHQ9TltOLmxlbmd0aC0xXTtpZih1Lm5vYnJhY2U9PT10cnVlfHwhdCl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHLG91dHB1dDpHfSk7Y29udGludWV9bGV0IGU9XCIpXCI7aWYodC5kb3RzPT09dHJ1ZSl7Y29uc3QgdD1BLnNsaWNlKCk7Y29uc3Qgbj1bXTtmb3IobGV0IGU9dC5sZW5ndGgtMTtlPj0wO2UtLSl7QS5wb3AoKTtpZih0W2VdLnR5cGU9PT1cImJyYWNlXCIpe2JyZWFrfWlmKHRbZV0udHlwZSE9PVwiZG90c1wiKXtuLnVuc2hpZnQodFtlXS52YWx1ZSl9fWU9ZXhwYW5kUmFuZ2Uobix1KTttLmJhY2t0cmFjaz10cnVlfWlmKHQuY29tbWEhPT10cnVlJiZ0LmRvdHMhPT10cnVlKXtjb25zdCB1PW0ub3V0cHV0LnNsaWNlKDAsdC5vdXRwdXRJbmRleCk7Y29uc3Qgbj1tLnRva2Vucy5zbGljZSh0LnRva2Vuc0luZGV4KTt0LnZhbHVlPXQub3V0cHV0PVwiXFxcXHtcIjtHPWU9XCJcXFxcfVwiO20ub3V0cHV0PXU7Zm9yKGNvbnN0IHQgb2Ygbil7bS5vdXRwdXQrPXQub3V0cHV0fHx0LnZhbHVlfX1wdXNoKHt0eXBlOlwiYnJhY2VcIix2YWx1ZTpHLG91dHB1dDplfSk7ZGVjcmVtZW50KFwiYnJhY2VzXCIpO04ucG9wKCk7Y29udGludWV9aWYoRz09PVwifFwiKXtpZih3Lmxlbmd0aD4wKXt3W3cubGVuZ3RoLTFdLmNvbmRpdGlvbnMrK31wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkd9KTtjb250aW51ZX1pZihHPT09XCIsXCIpe2xldCB0PUc7Y29uc3QgZT1OW04ubGVuZ3RoLTFdO2lmKGUmJklbSS5sZW5ndGgtMV09PT1cImJyYWNlc1wiKXtlLmNvbW1hPXRydWU7dD1cInxcIn1wdXNoKHt0eXBlOlwiY29tbWFcIix2YWx1ZTpHLG91dHB1dDp0fSk7Y29udGludWV9aWYoRz09PVwiL1wiKXtpZihCLnR5cGU9PT1cImRvdFwiJiZtLmluZGV4PT09bS5zdGFydCsxKXttLnN0YXJ0PW0uaW5kZXgrMTttLmNvbnN1bWVkPVwiXCI7bS5vdXRwdXQ9XCJcIjtBLnBvcCgpO0I9Zjtjb250aW51ZX1wdXNoKHt0eXBlOlwic2xhc2hcIix2YWx1ZTpHLG91dHB1dDpifSk7Y29udGludWV9aWYoRz09PVwiLlwiKXtpZihtLmJyYWNlcz4wJiZCLnR5cGU9PT1cImRvdFwiKXtpZihCLnZhbHVlPT09XCIuXCIpQi5vdXRwdXQ9aDtjb25zdCB0PU5bTi5sZW5ndGgtMV07Qi50eXBlPVwiZG90c1wiO0Iub3V0cHV0Kz1HO0IudmFsdWUrPUc7dC5kb3RzPXRydWU7Y29udGludWV9aWYobS5icmFjZXMrbS5wYXJlbnM9PT0wJiZCLnR5cGUhPT1cImJvc1wiJiZCLnR5cGUhPT1cInNsYXNoXCIpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6RyxvdXRwdXQ6aH0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJkb3RcIix2YWx1ZTpHLG91dHB1dDpofSk7Y29udGludWV9aWYoRz09PVwiP1wiKXtjb25zdCB0PUImJkIudmFsdWU9PT1cIihcIjtpZighdCYmdS5ub2V4dGdsb2IhPT10cnVlJiZEKCk9PT1cIihcIiYmRCgyKSE9PVwiP1wiKXtleHRnbG9iT3BlbihcInFtYXJrXCIsRyk7Y29udGludWV9aWYoQiYmQi50eXBlPT09XCJwYXJlblwiKXtjb25zdCB0PUQoKTtsZXQgZT1HO2lmKEIudmFsdWU9PT1cIihcIiYmIS9bIT08Ol0vLnRlc3QodCl8fHQ9PT1cIjxcIiYmIS88KFshPV18XFx3Kz4pLy50ZXN0KHJlbWFpbmluZygpKSl7ZT1gXFxcXCR7R31gfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6RyxvdXRwdXQ6ZX0pO2NvbnRpbnVlfWlmKHUuZG90IT09dHJ1ZSYmKEIudHlwZT09PVwic2xhc2hcInx8Qi50eXBlPT09XCJib3NcIikpe3B1c2goe3R5cGU6XCJxbWFya1wiLHZhbHVlOkcsb3V0cHV0OnZ9KTtjb250aW51ZX1wdXNoKHt0eXBlOlwicW1hcmtcIix2YWx1ZTpHLG91dHB1dDpIfSk7Y29udGludWV9aWYoRz09PVwiIVwiKXtpZih1Lm5vZXh0Z2xvYiE9PXRydWUmJkQoKT09PVwiKFwiKXtpZihEKDIpIT09XCI/XCJ8fCEvWyE9PDpdLy50ZXN0KEQoMykpKXtleHRnbG9iT3BlbihcIm5lZ2F0ZVwiLEcpO2NvbnRpbnVlfX1pZih1Lm5vbmVnYXRlIT09dHJ1ZSYmbS5pbmRleD09PTApe25lZ2F0ZSgpO2NvbnRpbnVlfX1pZihHPT09XCIrXCIpe2lmKHUubm9leHRnbG9iIT09dHJ1ZSYmRCgpPT09XCIoXCImJkQoMikhPT1cIj9cIil7ZXh0Z2xvYk9wZW4oXCJwbHVzXCIsRyk7Y29udGludWV9aWYoQiYmQi52YWx1ZT09PVwiKFwifHx1LnJlZ2V4PT09ZmFsc2Upe3B1c2goe3R5cGU6XCJwbHVzXCIsdmFsdWU6RyxvdXRwdXQ6Z30pO2NvbnRpbnVlfWlmKEImJihCLnR5cGU9PT1cImJyYWNrZXRcInx8Qi50eXBlPT09XCJwYXJlblwifHxCLnR5cGU9PT1cImJyYWNlXCIpfHxtLnBhcmVucz4wKXtwdXNoKHt0eXBlOlwicGx1c1wiLHZhbHVlOkd9KTtjb250aW51ZX1wdXNoKHt0eXBlOlwicGx1c1wiLHZhbHVlOmd9KTtjb250aW51ZX1pZihHPT09XCJAXCIpe2lmKHUubm9leHRnbG9iIT09dHJ1ZSYmRCgpPT09XCIoXCImJkQoMikhPT1cIj9cIil7cHVzaCh7dHlwZTpcImF0XCIsZXh0Z2xvYjp0cnVlLHZhbHVlOkcsb3V0cHV0OlwiXCJ9KTtjb250aW51ZX1wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkd9KTtjb250aW51ZX1pZihHIT09XCIqXCIpe2lmKEc9PT1cIiRcInx8Rz09PVwiXlwiKXtHPWBcXFxcJHtHfWB9Y29uc3QgdD1hLmV4ZWMocmVtYWluaW5nKCkpO2lmKHQpe0crPXRbMF07bS5pbmRleCs9dFswXS5sZW5ndGh9cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHfSk7Y29udGludWV9aWYoQiYmKEIudHlwZT09PVwiZ2xvYnN0YXJcInx8Qi5zdGFyPT09dHJ1ZSkpe0IudHlwZT1cInN0YXJcIjtCLnN0YXI9dHJ1ZTtCLnZhbHVlKz1HO0Iub3V0cHV0PWs7bS5iYWNrdHJhY2s9dHJ1ZTttLmdsb2JzdGFyPXRydWU7Y29uc3VtZShHKTtjb250aW51ZX1sZXQgZT1yZW1haW5pbmcoKTtpZih1Lm5vZXh0Z2xvYiE9PXRydWUmJi9eXFwoW14/XS8udGVzdChlKSl7ZXh0Z2xvYk9wZW4oXCJzdGFyXCIsRyk7Y29udGludWV9aWYoQi50eXBlPT09XCJzdGFyXCIpe2lmKHUubm9nbG9ic3Rhcj09PXRydWUpe2NvbnN1bWUoRyk7Y29udGludWV9Y29uc3Qgbj1CLnByZXY7Y29uc3Qgbz1uLnByZXY7Y29uc3Qgcz1uLnR5cGU9PT1cInNsYXNoXCJ8fG4udHlwZT09PVwiYm9zXCI7Y29uc3Qgcj1vJiYoby50eXBlPT09XCJzdGFyXCJ8fG8udHlwZT09PVwiZ2xvYnN0YXJcIik7aWYodS5iYXNoPT09dHJ1ZSYmKCFzfHxlWzBdJiZlWzBdIT09XCIvXCIpKXtwdXNoKHt0eXBlOlwic3RhclwiLHZhbHVlOkcsb3V0cHV0OlwiXCJ9KTtjb250aW51ZX1jb25zdCBhPW0uYnJhY2VzPjAmJihuLnR5cGU9PT1cImNvbW1hXCJ8fG4udHlwZT09PVwiYnJhY2VcIik7Y29uc3QgaT13Lmxlbmd0aCYmKG4udHlwZT09PVwicGlwZVwifHxuLnR5cGU9PT1cInBhcmVuXCIpO2lmKCFzJiZuLnR5cGUhPT1cInBhcmVuXCImJiFhJiYhaSl7cHVzaCh7dHlwZTpcInN0YXJcIix2YWx1ZTpHLG91dHB1dDpcIlwifSk7Y29udGludWV9d2hpbGUoZS5zbGljZSgwLDMpPT09XCIvKipcIil7Y29uc3QgdT10W20uaW5kZXgrNF07aWYodSYmdSE9PVwiL1wiKXticmVha31lPWUuc2xpY2UoMyk7Y29uc3VtZShcIi8qKlwiLDMpfWlmKG4udHlwZT09PVwiYm9zXCImJmVvcygpKXtCLnR5cGU9XCJnbG9ic3RhclwiO0IudmFsdWUrPUc7Qi5vdXRwdXQ9Z2xvYnN0YXIodSk7bS5vdXRwdXQ9Qi5vdXRwdXQ7bS5nbG9ic3Rhcj10cnVlO2NvbnN1bWUoRyk7Y29udGludWV9aWYobi50eXBlPT09XCJzbGFzaFwiJiZuLnByZXYudHlwZSE9PVwiYm9zXCImJiFyJiZlb3MoKSl7bS5vdXRwdXQ9bS5vdXRwdXQuc2xpY2UoMCwtKG4ub3V0cHV0K0Iub3V0cHV0KS5sZW5ndGgpO24ub3V0cHV0PWAoPzoke24ub3V0cHV0fWA7Qi50eXBlPVwiZ2xvYnN0YXJcIjtCLm91dHB1dD1nbG9ic3Rhcih1KSsodS5zdHJpY3RTbGFzaGVzP1wiKVwiOlwifCQpXCIpO0IudmFsdWUrPUc7bS5nbG9ic3Rhcj10cnVlO20ub3V0cHV0Kz1uLm91dHB1dCtCLm91dHB1dDtjb25zdW1lKEcpO2NvbnRpbnVlfWlmKG4udHlwZT09PVwic2xhc2hcIiYmbi5wcmV2LnR5cGUhPT1cImJvc1wiJiZlWzBdPT09XCIvXCIpe2NvbnN0IHQ9ZVsxXSE9PXZvaWQgMD9cInwkXCI6XCJcIjttLm91dHB1dD1tLm91dHB1dC5zbGljZSgwLC0obi5vdXRwdXQrQi5vdXRwdXQpLmxlbmd0aCk7bi5vdXRwdXQ9YCg/OiR7bi5vdXRwdXR9YDtCLnR5cGU9XCJnbG9ic3RhclwiO0Iub3V0cHV0PWAke2dsb2JzdGFyKHUpfSR7Yn18JHtifSR7dH0pYDtCLnZhbHVlKz1HO20ub3V0cHV0Kz1uLm91dHB1dCtCLm91dHB1dDttLmdsb2JzdGFyPXRydWU7Y29uc3VtZShHK00oKSk7cHVzaCh7dHlwZTpcInNsYXNoXCIsdmFsdWU6XCIvXCIsb3V0cHV0OlwiXCJ9KTtjb250aW51ZX1pZihuLnR5cGU9PT1cImJvc1wiJiZlWzBdPT09XCIvXCIpe0IudHlwZT1cImdsb2JzdGFyXCI7Qi52YWx1ZSs9RztCLm91dHB1dD1gKD86Xnwke2J9fCR7Z2xvYnN0YXIodSl9JHtifSlgO20ub3V0cHV0PUIub3V0cHV0O20uZ2xvYnN0YXI9dHJ1ZTtjb25zdW1lKEcrTSgpKTtwdXNoKHt0eXBlOlwic2xhc2hcIix2YWx1ZTpcIi9cIixvdXRwdXQ6XCJcIn0pO2NvbnRpbnVlfW0ub3V0cHV0PW0ub3V0cHV0LnNsaWNlKDAsLUIub3V0cHV0Lmxlbmd0aCk7Qi50eXBlPVwiZ2xvYnN0YXJcIjtCLm91dHB1dD1nbG9ic3Rhcih1KTtCLnZhbHVlKz1HO20ub3V0cHV0Kz1CLm91dHB1dDttLmdsb2JzdGFyPXRydWU7Y29uc3VtZShHKTtjb250aW51ZX1jb25zdCBuPXt0eXBlOlwic3RhclwiLHZhbHVlOkcsb3V0cHV0Omt9O2lmKHUuYmFzaD09PXRydWUpe24ub3V0cHV0PVwiLio/XCI7aWYoQi50eXBlPT09XCJib3NcInx8Qi50eXBlPT09XCJzbGFzaFwiKXtuLm91dHB1dD1UK24ub3V0cHV0fXB1c2gobik7Y29udGludWV9aWYoQiYmKEIudHlwZT09PVwiYnJhY2tldFwifHxCLnR5cGU9PT1cInBhcmVuXCIpJiZ1LnJlZ2V4PT09dHJ1ZSl7bi5vdXRwdXQ9RztwdXNoKG4pO2NvbnRpbnVlfWlmKG0uaW5kZXg9PT1tLnN0YXJ0fHxCLnR5cGU9PT1cInNsYXNoXCJ8fEIudHlwZT09PVwiZG90XCIpe2lmKEIudHlwZT09PVwiZG90XCIpe20ub3V0cHV0Kz14O0Iub3V0cHV0Kz14fWVsc2UgaWYodS5kb3Q9PT10cnVlKXttLm91dHB1dCs9UztCLm91dHB1dCs9U31lbHNle20ub3V0cHV0Kz1UO0Iub3V0cHV0Kz1UfWlmKEQoKSE9PVwiKlwiKXttLm91dHB1dCs9QztCLm91dHB1dCs9Q319cHVzaChuKX13aGlsZShtLmJyYWNrZXRzPjApe2lmKHUuc3RyaWN0QnJhY2tldHM9PT10cnVlKXRocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcImNsb3NpbmdcIixcIl1cIikpO20ub3V0cHV0PW8uZXNjYXBlTGFzdChtLm91dHB1dCxcIltcIik7ZGVjcmVtZW50KFwiYnJhY2tldHNcIil9d2hpbGUobS5wYXJlbnM+MCl7aWYodS5zdHJpY3RCcmFja2V0cz09PXRydWUpdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKFwiY2xvc2luZ1wiLFwiKVwiKSk7bS5vdXRwdXQ9by5lc2NhcGVMYXN0KG0ub3V0cHV0LFwiKFwiKTtkZWNyZW1lbnQoXCJwYXJlbnNcIil9d2hpbGUobS5icmFjZXM+MCl7aWYodS5zdHJpY3RCcmFja2V0cz09PXRydWUpdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKFwiY2xvc2luZ1wiLFwifVwiKSk7bS5vdXRwdXQ9by5lc2NhcGVMYXN0KG0ub3V0cHV0LFwie1wiKTtkZWNyZW1lbnQoXCJicmFjZXNcIil9aWYodS5zdHJpY3RTbGFzaGVzIT09dHJ1ZSYmKEIudHlwZT09PVwic3RhclwifHxCLnR5cGU9PT1cImJyYWNrZXRcIikpe3B1c2goe3R5cGU6XCJtYXliZV9zbGFzaFwiLHZhbHVlOlwiXCIsb3V0cHV0OmAke2J9P2B9KX1pZihtLmJhY2t0cmFjaz09PXRydWUpe20ub3V0cHV0PVwiXCI7Zm9yKGNvbnN0IHQgb2YgbS50b2tlbnMpe20ub3V0cHV0Kz10Lm91dHB1dCE9bnVsbD90Lm91dHB1dDp0LnZhbHVlO2lmKHQuc3VmZml4KXttLm91dHB1dCs9dC5zdWZmaXh9fX1yZXR1cm4gbX07cGFyc2UuZmFzdHBhdGhzPSh0LGUpPT57Y29uc3QgdT17Li4uZX07Y29uc3Qgcj10eXBlb2YgdS5tYXhMZW5ndGg9PT1cIm51bWJlclwiP01hdGgubWluKHMsdS5tYXhMZW5ndGgpOnM7Y29uc3QgYT10Lmxlbmd0aDtpZihhPnIpe3Rocm93IG5ldyBTeW50YXhFcnJvcihgSW5wdXQgbGVuZ3RoOiAke2F9LCBleGNlZWRzIG1heGltdW0gYWxsb3dlZCBsZW5ndGg6ICR7cn1gKX10PWNbdF18fHQ7Y29uc3R7RE9UX0xJVEVSQUw6aSxTTEFTSF9MSVRFUkFMOnAsT05FX0NIQVI6bCxET1RTX1NMQVNIOmYsTk9fRE9UOkEsTk9fRE9UUzpfLE5PX0RPVFNfU0xBU0g6UixTVEFSOkUsU1RBUlRfQU5DSE9SOmh9PW4uZ2xvYkNoYXJzKHUud2luZG93cyk7Y29uc3QgZz11LmRvdD9fOkE7Y29uc3QgYj11LmRvdD9SOkE7Y29uc3QgQz11LmNhcHR1cmU/XCJcIjpcIj86XCI7Y29uc3QgeT17bmVnYXRlZDpmYWxzZSxwcmVmaXg6XCJcIn07bGV0ICQ9dS5iYXNoPT09dHJ1ZT9cIi4qP1wiOkU7aWYodS5jYXB0dXJlKXskPWAoJHskfSlgfWNvbnN0IGdsb2JzdGFyPXQ9PntpZih0Lm5vZ2xvYnN0YXI9PT10cnVlKXJldHVybiAkO3JldHVybmAoJHtDfSg/Oig/ISR7aH0ke3QuZG90P2Y6aX0pLikqPylgfTtjb25zdCBjcmVhdGU9dD0+e3N3aXRjaCh0KXtjYXNlXCIqXCI6cmV0dXJuYCR7Z30ke2x9JHskfWA7Y2FzZVwiLipcIjpyZXR1cm5gJHtpfSR7bH0keyR9YDtjYXNlXCIqLipcIjpyZXR1cm5gJHtnfSR7JH0ke2l9JHtsfSR7JH1gO2Nhc2VcIiovKlwiOnJldHVybmAke2d9JHskfSR7cH0ke2x9JHtifSR7JH1gO2Nhc2VcIioqXCI6cmV0dXJuIGcrZ2xvYnN0YXIodSk7Y2FzZVwiKiovKlwiOnJldHVybmAoPzoke2d9JHtnbG9ic3Rhcih1KX0ke3B9KT8ke2J9JHtsfSR7JH1gO2Nhc2VcIioqLyouKlwiOnJldHVybmAoPzoke2d9JHtnbG9ic3Rhcih1KX0ke3B9KT8ke2J9JHskfSR7aX0ke2x9JHskfWA7Y2FzZVwiKiovLipcIjpyZXR1cm5gKD86JHtnfSR7Z2xvYnN0YXIodSl9JHtwfSk/JHtpfSR7bH0keyR9YDtkZWZhdWx0Ontjb25zdCBlPS9eKC4qPylcXC4oXFx3KykkLy5leGVjKHQpO2lmKCFlKXJldHVybjtjb25zdCB1PWNyZWF0ZShlWzFdKTtpZighdSlyZXR1cm47cmV0dXJuIHUraStlWzJdfX19O2NvbnN0IHg9by5yZW1vdmVQcmVmaXgodCx5KTtsZXQgUz1jcmVhdGUoeCk7aWYoUyYmdS5zdHJpY3RTbGFzaGVzIT09dHJ1ZSl7Uys9YCR7cH0/YH1yZXR1cm4gU307dC5leHBvcnRzPXBhcnNlfSw1MTA6KHQsZSx1KT0+e2NvbnN0IG49dSg3MTYpO2NvbnN0IG89dSg2OTcpO2NvbnN0IHM9dSg5Nik7Y29uc3Qgcj11KDE1NCk7Y29uc3QgaXNPYmplY3Q9dD0+dCYmdHlwZW9mIHQ9PT1cIm9iamVjdFwiJiYhQXJyYXkuaXNBcnJheSh0KTtjb25zdCBwaWNvbWF0Y2g9KHQsZSx1PWZhbHNlKT0+e2lmKEFycmF5LmlzQXJyYXkodCkpe2NvbnN0IG49dC5tYXAoKHQ9PnBpY29tYXRjaCh0LGUsdSkpKTtjb25zdCBhcnJheU1hdGNoZXI9dD0+e2Zvcihjb25zdCBlIG9mIG4pe2NvbnN0IHU9ZSh0KTtpZih1KXJldHVybiB1fXJldHVybiBmYWxzZX07cmV0dXJuIGFycmF5TWF0Y2hlcn1jb25zdCBuPWlzT2JqZWN0KHQpJiZ0LnRva2VucyYmdC5pbnB1dDtpZih0PT09XCJcInx8dHlwZW9mIHQhPT1cInN0cmluZ1wiJiYhbil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIHBhdHRlcm4gdG8gYmUgYSBub24tZW1wdHkgc3RyaW5nXCIpfWNvbnN0IG89ZXx8e307Y29uc3Qgcz1vLndpbmRvd3M7Y29uc3Qgcj1uP3BpY29tYXRjaC5jb21waWxlUmUodCxlKTpwaWNvbWF0Y2gubWFrZVJlKHQsZSxmYWxzZSx0cnVlKTtjb25zdCBhPXIuc3RhdGU7ZGVsZXRlIHIuc3RhdGU7bGV0IGlzSWdub3JlZD0oKT0+ZmFsc2U7aWYoby5pZ25vcmUpe2NvbnN0IHQ9ey4uLmUsaWdub3JlOm51bGwsb25NYXRjaDpudWxsLG9uUmVzdWx0Om51bGx9O2lzSWdub3JlZD1waWNvbWF0Y2goby5pZ25vcmUsdCx1KX1jb25zdCBtYXRjaGVyPSh1LG49ZmFsc2UpPT57Y29uc3R7aXNNYXRjaDppLG1hdGNoOmMsb3V0cHV0OnB9PXBpY29tYXRjaC50ZXN0KHUscixlLHtnbG9iOnQscG9zaXg6c30pO2NvbnN0IGw9e2dsb2I6dCxzdGF0ZTphLHJlZ2V4OnIscG9zaXg6cyxpbnB1dDp1LG91dHB1dDpwLG1hdGNoOmMsaXNNYXRjaDppfTtpZih0eXBlb2Ygby5vblJlc3VsdD09PVwiZnVuY3Rpb25cIil7by5vblJlc3VsdChsKX1pZihpPT09ZmFsc2Upe2wuaXNNYXRjaD1mYWxzZTtyZXR1cm4gbj9sOmZhbHNlfWlmKGlzSWdub3JlZCh1KSl7aWYodHlwZW9mIG8ub25JZ25vcmU9PT1cImZ1bmN0aW9uXCIpe28ub25JZ25vcmUobCl9bC5pc01hdGNoPWZhbHNlO3JldHVybiBuP2w6ZmFsc2V9aWYodHlwZW9mIG8ub25NYXRjaD09PVwiZnVuY3Rpb25cIil7by5vbk1hdGNoKGwpfXJldHVybiBuP2w6dHJ1ZX07aWYodSl7bWF0Y2hlci5zdGF0ZT1hfXJldHVybiBtYXRjaGVyfTtwaWNvbWF0Y2gudGVzdD0odCxlLHUse2dsb2I6bixwb3NpeDpvfT17fSk9PntpZih0eXBlb2YgdCE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBpbnB1dCB0byBiZSBhIHN0cmluZ1wiKX1pZih0PT09XCJcIil7cmV0dXJue2lzTWF0Y2g6ZmFsc2Usb3V0cHV0OlwiXCJ9fWNvbnN0IHI9dXx8e307Y29uc3QgYT1yLmZvcm1hdHx8KG8/cy50b1Bvc2l4U2xhc2hlczpudWxsKTtsZXQgaT10PT09bjtsZXQgYz1pJiZhP2EodCk6dDtpZihpPT09ZmFsc2Upe2M9YT9hKHQpOnQ7aT1jPT09bn1pZihpPT09ZmFsc2V8fHIuY2FwdHVyZT09PXRydWUpe2lmKHIubWF0Y2hCYXNlPT09dHJ1ZXx8ci5iYXNlbmFtZT09PXRydWUpe2k9cGljb21hdGNoLm1hdGNoQmFzZSh0LGUsdSxvKX1lbHNle2k9ZS5leGVjKGMpfX1yZXR1cm57aXNNYXRjaDpCb29sZWFuKGkpLG1hdGNoOmksb3V0cHV0OmN9fTtwaWNvbWF0Y2gubWF0Y2hCYXNlPSh0LGUsdSk9Pntjb25zdCBuPWUgaW5zdGFuY2VvZiBSZWdFeHA/ZTpwaWNvbWF0Y2gubWFrZVJlKGUsdSk7cmV0dXJuIG4udGVzdChzLmJhc2VuYW1lKHQpKX07cGljb21hdGNoLmlzTWF0Y2g9KHQsZSx1KT0+cGljb21hdGNoKGUsdSkodCk7cGljb21hdGNoLnBhcnNlPSh0LGUpPT57aWYoQXJyYXkuaXNBcnJheSh0KSlyZXR1cm4gdC5tYXAoKHQ9PnBpY29tYXRjaC5wYXJzZSh0LGUpKSk7cmV0dXJuIG8odCx7Li4uZSxmYXN0cGF0aHM6ZmFsc2V9KX07cGljb21hdGNoLnNjYW49KHQsZSk9Pm4odCxlKTtwaWNvbWF0Y2guY29tcGlsZVJlPSh0LGUsdT1mYWxzZSxuPWZhbHNlKT0+e2lmKHU9PT10cnVlKXtyZXR1cm4gdC5vdXRwdXR9Y29uc3Qgbz1lfHx7fTtjb25zdCBzPW8uY29udGFpbnM/XCJcIjpcIl5cIjtjb25zdCByPW8uY29udGFpbnM/XCJcIjpcIiRcIjtsZXQgYT1gJHtzfSg/OiR7dC5vdXRwdXR9KSR7cn1gO2lmKHQmJnQubmVnYXRlZD09PXRydWUpe2E9YF4oPyEke2F9KS4qJGB9Y29uc3QgaT1waWNvbWF0Y2gudG9SZWdleChhLGUpO2lmKG49PT10cnVlKXtpLnN0YXRlPXR9cmV0dXJuIGl9O3BpY29tYXRjaC5tYWtlUmU9KHQsZT17fSx1PWZhbHNlLG49ZmFsc2UpPT57aWYoIXR8fHR5cGVvZiB0IT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgbm9uLWVtcHR5IHN0cmluZ1wiKX1sZXQgcz17bmVnYXRlZDpmYWxzZSxmYXN0cGF0aHM6dHJ1ZX07aWYoZS5mYXN0cGF0aHMhPT1mYWxzZSYmKHRbMF09PT1cIi5cInx8dFswXT09PVwiKlwiKSl7cy5vdXRwdXQ9by5mYXN0cGF0aHModCxlKX1pZighcy5vdXRwdXQpe3M9byh0LGUpfXJldHVybiBwaWNvbWF0Y2guY29tcGlsZVJlKHMsZSx1LG4pfTtwaWNvbWF0Y2gudG9SZWdleD0odCxlKT0+e3RyeXtjb25zdCB1PWV8fHt9O3JldHVybiBuZXcgUmVnRXhwKHQsdS5mbGFnc3x8KHUubm9jYXNlP1wiaVwiOlwiXCIpKX1jYXRjaCh0KXtpZihlJiZlLmRlYnVnPT09dHJ1ZSl0aHJvdyB0O3JldHVybi8kXi99fTtwaWNvbWF0Y2guY29uc3RhbnRzPXI7dC5leHBvcnRzPXBpY29tYXRjaH0sNzE2Oih0LGUsdSk9Pntjb25zdCBuPXUoOTYpO2NvbnN0e0NIQVJfQVNURVJJU0s6byxDSEFSX0FUOnMsQ0hBUl9CQUNLV0FSRF9TTEFTSDpyLENIQVJfQ09NTUE6YSxDSEFSX0RPVDppLENIQVJfRVhDTEFNQVRJT05fTUFSSzpjLENIQVJfRk9SV0FSRF9TTEFTSDpwLENIQVJfTEVGVF9DVVJMWV9CUkFDRTpsLENIQVJfTEVGVF9QQVJFTlRIRVNFUzpmLENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVDpBLENIQVJfUExVUzpfLENIQVJfUVVFU1RJT05fTUFSSzpSLENIQVJfUklHSFRfQ1VSTFlfQlJBQ0U6RSxDSEFSX1JJR0hUX1BBUkVOVEhFU0VTOmgsQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVDpnfT11KDE1NCk7Y29uc3QgaXNQYXRoU2VwYXJhdG9yPXQ9PnQ9PT1wfHx0PT09cjtjb25zdCBkZXB0aD10PT57aWYodC5pc1ByZWZpeCE9PXRydWUpe3QuZGVwdGg9dC5pc0dsb2JzdGFyP0luZmluaXR5OjF9fTtjb25zdCBzY2FuPSh0LGUpPT57Y29uc3QgdT1lfHx7fTtjb25zdCBiPXQubGVuZ3RoLTE7Y29uc3QgQz11LnBhcnRzPT09dHJ1ZXx8dS5zY2FuVG9FbmQ9PT10cnVlO2NvbnN0IHk9W107Y29uc3QgJD1bXTtjb25zdCB4PVtdO2xldCBTPXQ7bGV0IEg9LTE7bGV0IHY9MDtsZXQgZD0wO2xldCBMPWZhbHNlO2xldCBUPWZhbHNlO2xldCBPPWZhbHNlO2xldCBrPWZhbHNlO2xldCBtPWZhbHNlO2xldCB3PWZhbHNlO2xldCBOPWZhbHNlO2xldCBJPWZhbHNlO2xldCBCPWZhbHNlO2xldCBHPWZhbHNlO2xldCBEPTA7bGV0IE07bGV0IFA7bGV0IEs9e3ZhbHVlOlwiXCIsZGVwdGg6MCxpc0dsb2I6ZmFsc2V9O2NvbnN0IGVvcz0oKT0+SD49Yjtjb25zdCBwZWVrPSgpPT5TLmNoYXJDb2RlQXQoSCsxKTtjb25zdCBhZHZhbmNlPSgpPT57TT1QO3JldHVybiBTLmNoYXJDb2RlQXQoKytIKX07d2hpbGUoSDxiKXtQPWFkdmFuY2UoKTtsZXQgdDtpZihQPT09cil7Tj1LLmJhY2tzbGFzaGVzPXRydWU7UD1hZHZhbmNlKCk7aWYoUD09PWwpe3c9dHJ1ZX1jb250aW51ZX1pZih3PT09dHJ1ZXx8UD09PWwpe0QrKzt3aGlsZShlb3MoKSE9PXRydWUmJihQPWFkdmFuY2UoKSkpe2lmKFA9PT1yKXtOPUsuYmFja3NsYXNoZXM9dHJ1ZTthZHZhbmNlKCk7Y29udGludWV9aWYoUD09PWwpe0QrKztjb250aW51ZX1pZih3IT09dHJ1ZSYmUD09PWkmJihQPWFkdmFuY2UoKSk9PT1pKXtMPUsuaXNCcmFjZT10cnVlO089Sy5pc0dsb2I9dHJ1ZTtHPXRydWU7aWYoQz09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKHchPT10cnVlJiZQPT09YSl7TD1LLmlzQnJhY2U9dHJ1ZTtPPUsuaXNHbG9iPXRydWU7Rz10cnVlO2lmKEM9PT10cnVlKXtjb250aW51ZX1icmVha31pZihQPT09RSl7RC0tO2lmKEQ9PT0wKXt3PWZhbHNlO0w9Sy5pc0JyYWNlPXRydWU7Rz10cnVlO2JyZWFrfX19aWYoQz09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKFA9PT1wKXt5LnB1c2goSCk7JC5wdXNoKEspO0s9e3ZhbHVlOlwiXCIsZGVwdGg6MCxpc0dsb2I6ZmFsc2V9O2lmKEc9PT10cnVlKWNvbnRpbnVlO2lmKE09PT1pJiZIPT09disxKXt2Kz0yO2NvbnRpbnVlfWQ9SCsxO2NvbnRpbnVlfWlmKHUubm9leHQhPT10cnVlKXtjb25zdCB0PVA9PT1ffHxQPT09c3x8UD09PW98fFA9PT1SfHxQPT09YztpZih0PT09dHJ1ZSYmcGVlaygpPT09Zil7Tz1LLmlzR2xvYj10cnVlO2s9Sy5pc0V4dGdsb2I9dHJ1ZTtHPXRydWU7aWYoUD09PWMmJkg9PT12KXtCPXRydWV9aWYoQz09PXRydWUpe3doaWxlKGVvcygpIT09dHJ1ZSYmKFA9YWR2YW5jZSgpKSl7aWYoUD09PXIpe049Sy5iYWNrc2xhc2hlcz10cnVlO1A9YWR2YW5jZSgpO2NvbnRpbnVlfWlmKFA9PT1oKXtPPUsuaXNHbG9iPXRydWU7Rz10cnVlO2JyZWFrfX1jb250aW51ZX1icmVha319aWYoUD09PW8pe2lmKE09PT1vKW09Sy5pc0dsb2JzdGFyPXRydWU7Tz1LLmlzR2xvYj10cnVlO0c9dHJ1ZTtpZihDPT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYoUD09PVIpe089Sy5pc0dsb2I9dHJ1ZTtHPXRydWU7aWYoQz09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKFA9PT1BKXt3aGlsZShlb3MoKSE9PXRydWUmJih0PWFkdmFuY2UoKSkpe2lmKHQ9PT1yKXtOPUsuYmFja3NsYXNoZXM9dHJ1ZTthZHZhbmNlKCk7Y29udGludWV9aWYodD09PWcpe1Q9Sy5pc0JyYWNrZXQ9dHJ1ZTtPPUsuaXNHbG9iPXRydWU7Rz10cnVlO2JyZWFrfX1pZihDPT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYodS5ub25lZ2F0ZSE9PXRydWUmJlA9PT1jJiZIPT09dil7ST1LLm5lZ2F0ZWQ9dHJ1ZTt2Kys7Y29udGludWV9aWYodS5ub3BhcmVuIT09dHJ1ZSYmUD09PWYpe089Sy5pc0dsb2I9dHJ1ZTtpZihDPT09dHJ1ZSl7d2hpbGUoZW9zKCkhPT10cnVlJiYoUD1hZHZhbmNlKCkpKXtpZihQPT09Zil7Tj1LLmJhY2tzbGFzaGVzPXRydWU7UD1hZHZhbmNlKCk7Y29udGludWV9aWYoUD09PWgpe0c9dHJ1ZTticmVha319Y29udGludWV9YnJlYWt9aWYoTz09PXRydWUpe0c9dHJ1ZTtpZihDPT09dHJ1ZSl7Y29udGludWV9YnJlYWt9fWlmKHUubm9leHQ9PT10cnVlKXtrPWZhbHNlO089ZmFsc2V9bGV0IFU9UztsZXQgWD1cIlwiO2xldCBGPVwiXCI7aWYodj4wKXtYPVMuc2xpY2UoMCx2KTtTPVMuc2xpY2Uodik7ZC09dn1pZihVJiZPPT09dHJ1ZSYmZD4wKXtVPVMuc2xpY2UoMCxkKTtGPVMuc2xpY2UoZCl9ZWxzZSBpZihPPT09dHJ1ZSl7VT1cIlwiO0Y9U31lbHNle1U9U31pZihVJiZVIT09XCJcIiYmVSE9PVwiL1wiJiZVIT09Uyl7aWYoaXNQYXRoU2VwYXJhdG9yKFUuY2hhckNvZGVBdChVLmxlbmd0aC0xKSkpe1U9VS5zbGljZSgwLC0xKX19aWYodS51bmVzY2FwZT09PXRydWUpe2lmKEYpRj1uLnJlbW92ZUJhY2tzbGFzaGVzKEYpO2lmKFUmJk49PT10cnVlKXtVPW4ucmVtb3ZlQmFja3NsYXNoZXMoVSl9fWNvbnN0IFE9e3ByZWZpeDpYLGlucHV0OnQsc3RhcnQ6dixiYXNlOlUsZ2xvYjpGLGlzQnJhY2U6TCxpc0JyYWNrZXQ6VCxpc0dsb2I6Tyxpc0V4dGdsb2I6ayxpc0dsb2JzdGFyOm0sbmVnYXRlZDpJLG5lZ2F0ZWRFeHRnbG9iOkJ9O2lmKHUudG9rZW5zPT09dHJ1ZSl7US5tYXhEZXB0aD0wO2lmKCFpc1BhdGhTZXBhcmF0b3IoUCkpeyQucHVzaChLKX1RLnRva2Vucz0kfWlmKHUucGFydHM9PT10cnVlfHx1LnRva2Vucz09PXRydWUpe2xldCBlO2ZvcihsZXQgbj0wO248eS5sZW5ndGg7bisrKXtjb25zdCBvPWU/ZSsxOnY7Y29uc3Qgcz15W25dO2NvbnN0IHI9dC5zbGljZShvLHMpO2lmKHUudG9rZW5zKXtpZihuPT09MCYmdiE9PTApeyRbbl0uaXNQcmVmaXg9dHJ1ZTskW25dLnZhbHVlPVh9ZWxzZXskW25dLnZhbHVlPXJ9ZGVwdGgoJFtuXSk7US5tYXhEZXB0aCs9JFtuXS5kZXB0aH1pZihuIT09MHx8ciE9PVwiXCIpe3gucHVzaChyKX1lPXN9aWYoZSYmZSsxPHQubGVuZ3RoKXtjb25zdCBuPXQuc2xpY2UoZSsxKTt4LnB1c2gobik7aWYodS50b2tlbnMpeyRbJC5sZW5ndGgtMV0udmFsdWU9bjtkZXB0aCgkWyQubGVuZ3RoLTFdKTtRLm1heERlcHRoKz0kWyQubGVuZ3RoLTFdLmRlcHRofX1RLnNsYXNoZXM9eTtRLnBhcnRzPXh9cmV0dXJuIFF9O3QuZXhwb3J0cz1zY2FufSw5NjoodCxlLHUpPT57Y29uc3R7UkVHRVhfQkFDS1NMQVNIOm4sUkVHRVhfUkVNT1ZFX0JBQ0tTTEFTSDpvLFJFR0VYX1NQRUNJQUxfQ0hBUlM6cyxSRUdFWF9TUEVDSUFMX0NIQVJTX0dMT0JBTDpyfT11KDE1NCk7ZS5pc09iamVjdD10PT50IT09bnVsbCYmdHlwZW9mIHQ9PT1cIm9iamVjdFwiJiYhQXJyYXkuaXNBcnJheSh0KTtlLmhhc1JlZ2V4Q2hhcnM9dD0+cy50ZXN0KHQpO2UuaXNSZWdleENoYXI9dD0+dC5sZW5ndGg9PT0xJiZlLmhhc1JlZ2V4Q2hhcnModCk7ZS5lc2NhcGVSZWdleD10PT50LnJlcGxhY2UocixcIlxcXFwkMVwiKTtlLnRvUG9zaXhTbGFzaGVzPXQ9PnQucmVwbGFjZShuLFwiL1wiKTtlLnJlbW92ZUJhY2tzbGFzaGVzPXQ9PnQucmVwbGFjZShvLCh0PT50PT09XCJcXFxcXCI/XCJcIjp0KSk7ZS5lc2NhcGVMYXN0PSh0LHUsbik9Pntjb25zdCBvPXQubGFzdEluZGV4T2YodSxuKTtpZihvPT09LTEpcmV0dXJuIHQ7aWYodFtvLTFdPT09XCJcXFxcXCIpcmV0dXJuIGUuZXNjYXBlTGFzdCh0LHUsby0xKTtyZXR1cm5gJHt0LnNsaWNlKDAsbyl9XFxcXCR7dC5zbGljZShvKX1gfTtlLnJlbW92ZVByZWZpeD0odCxlPXt9KT0+e2xldCB1PXQ7aWYodS5zdGFydHNXaXRoKFwiLi9cIikpe3U9dS5zbGljZSgyKTtlLnByZWZpeD1cIi4vXCJ9cmV0dXJuIHV9O2Uud3JhcE91dHB1dD0odCxlPXt9LHU9e30pPT57Y29uc3Qgbj11LmNvbnRhaW5zP1wiXCI6XCJeXCI7Y29uc3Qgbz11LmNvbnRhaW5zP1wiXCI6XCIkXCI7bGV0IHM9YCR7bn0oPzoke3R9KSR7b31gO2lmKGUubmVnYXRlZD09PXRydWUpe3M9YCg/Ol4oPyEke3N9KS4qJClgfXJldHVybiBzfTtlLmJhc2VuYW1lPSh0LHt3aW5kb3dzOmV9PXt9KT0+e2NvbnN0IHU9dC5zcGxpdChlPy9bXFxcXC9dLzpcIi9cIik7Y29uc3Qgbj11W3UubGVuZ3RoLTFdO2lmKG49PT1cIlwiKXtyZXR1cm4gdVt1Lmxlbmd0aC0yXX1yZXR1cm4gbn19fTt2YXIgZT17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHUpe3ZhciBuPWVbdV07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgbz1lW3VdPXtleHBvcnRzOnt9fTt2YXIgcz10cnVlO3RyeXt0W3VdKG8sby5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO3M9ZmFsc2V9ZmluYWxseXtpZihzKWRlbGV0ZSBlW3VdfXJldHVybiBvLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciB1PV9fbmNjd3Bja19yZXF1aXJlX18oMTcwKTttb2R1bGUuZXhwb3J0cz11fSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/picomatch/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/process/browser.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={229:function(e){var t=e.exports={};var r;var n;function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{if(typeof setTimeout===\"function\"){r=setTimeout}else{r=defaultSetTimout}}catch(e){r=defaultSetTimout}try{if(typeof clearTimeout===\"function\"){n=clearTimeout}else{n=defaultClearTimeout}}catch(e){n=defaultClearTimeout}})();function runTimeout(e){if(r===setTimeout){return setTimeout(e,0)}if((r===defaultSetTimout||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout){return clearTimeout(e)}if((n===defaultClearTimeout||!n)&&clearTimeout){n=clearTimeout;return clearTimeout(e)}try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}var i=[];var o=false;var u;var a=-1;function cleanUpNextTick(){if(!o||!u){return}o=false;if(u.length){i=u.concat(i)}else{a=-1}if(i.length){drainQueue()}}function drainQueue(){if(o){return}var e=runTimeout(cleanUpNextTick);o=true;var t=i.length;while(t){u=i;i=[];while(++a<t){if(u){u[a].run()}}a=-1;t=i.length}u=null;o=false;runClearTimeout(e)}t.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var r=1;r<arguments.length;r++){t[r-1]=arguments[r]}}i.push(new Item(e,t));if(i.length===1&&!o){runTimeout(drainQueue)}};function Item(e,t){this.fun=e;this.array=t}Item.prototype.run=function(){this.fun.apply(null,this.array)};t.title=\"browser\";t.browser=true;t.env={};t.argv=[];t.version=\"\";t.versions={};function noop(){}t.on=noop;t.addListener=noop;t.once=noop;t.off=noop;t.removeListener=noop;t.removeAllListeners=noop;t.emit=noop;t.prependListener=noop;t.prependOnceListener=noop;t.listeners=function(e){return[]};t.binding=function(e){throw new Error(\"process.binding is not supported\")};t.cwd=function(){return\"/\"};t.chdir=function(e){throw new Error(\"process.chdir is not supported\")};t.umask=function(){return 0}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var o=true;try{e[r](i,i.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(229);module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxZQUFZLE9BQU8sZ0JBQWdCLG1CQUFtQixNQUFNLE1BQU0sNEJBQTRCLG1EQUFtRCwrQkFBK0IscURBQXFELFlBQVksSUFBSSxtQ0FBbUMsYUFBYSxLQUFLLG9CQUFvQixTQUFTLG1CQUFtQixJQUFJLHFDQUFxQyxlQUFlLEtBQUssdUJBQXVCLFNBQVMsdUJBQXVCLElBQUksdUJBQXVCLG1CQUFtQix1QkFBdUIsMkNBQTJDLGFBQWEsdUJBQXVCLElBQUksY0FBYyxTQUFTLElBQUksd0JBQXdCLFNBQVMsMEJBQTBCLDRCQUE0QixxQkFBcUIsdUJBQXVCLGdEQUFnRCxlQUFlLHVCQUF1QixJQUFJLFlBQVksU0FBUyxJQUFJLHNCQUFzQixTQUFTLHdCQUF3QixTQUFTLFlBQVksTUFBTSxTQUFTLDJCQUEyQixXQUFXLE9BQU8sUUFBUSxhQUFhLGNBQWMsS0FBSyxLQUFLLGFBQWEsY0FBYyxzQkFBc0IsTUFBTSxPQUFPLGtDQUFrQyxPQUFPLGVBQWUsU0FBUyxJQUFJLEtBQUssYUFBYSxNQUFNLFlBQVksS0FBSyxXQUFXLE9BQU8sUUFBUSxtQkFBbUIsdUJBQXVCLG9DQUFvQyx1QkFBdUIsWUFBWSxtQkFBbUIsS0FBSyxxQkFBcUIsc0JBQXNCLHFCQUFxQix5QkFBeUIsbUJBQW1CLFdBQVcsYUFBYSw4QkFBOEIsaUNBQWlDLGtCQUFrQixlQUFlLFNBQVMsVUFBVSxhQUFhLGNBQWMsaUJBQWlCLFVBQVUsbUJBQW1CLFlBQVksV0FBVyxzQkFBc0IsMEJBQTBCLFlBQVksdUJBQXVCLDJCQUEyQix3QkFBd0IsVUFBVSxzQkFBc0IscURBQXFELGlCQUFpQixXQUFXLG9CQUFvQixtREFBbUQsbUJBQW1CLFlBQVksU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssK0JBQStCLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3MvYnJvd3Nlci5qcz9iZWNmIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciBlPXsyMjk6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5leHBvcnRzPXt9O3ZhciByO3ZhciBuO2Z1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfWZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9KGZ1bmN0aW9uKCl7dHJ5e2lmKHR5cGVvZiBzZXRUaW1lb3V0PT09XCJmdW5jdGlvblwiKXtyPXNldFRpbWVvdXR9ZWxzZXtyPWRlZmF1bHRTZXRUaW1vdXR9fWNhdGNoKGUpe3I9ZGVmYXVsdFNldFRpbW91dH10cnl7aWYodHlwZW9mIGNsZWFyVGltZW91dD09PVwiZnVuY3Rpb25cIil7bj1jbGVhclRpbWVvdXR9ZWxzZXtuPWRlZmF1bHRDbGVhclRpbWVvdXR9fWNhdGNoKGUpe249ZGVmYXVsdENsZWFyVGltZW91dH19KSgpO2Z1bmN0aW9uIHJ1blRpbWVvdXQoZSl7aWYocj09PXNldFRpbWVvdXQpe3JldHVybiBzZXRUaW1lb3V0KGUsMCl9aWYoKHI9PT1kZWZhdWx0U2V0VGltb3V0fHwhcikmJnNldFRpbWVvdXQpe3I9c2V0VGltZW91dDtyZXR1cm4gc2V0VGltZW91dChlLDApfXRyeXtyZXR1cm4gcihlLDApfWNhdGNoKHQpe3RyeXtyZXR1cm4gci5jYWxsKG51bGwsZSwwKX1jYXRjaCh0KXtyZXR1cm4gci5jYWxsKHRoaXMsZSwwKX19fWZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChlKXtpZihuPT09Y2xlYXJUaW1lb3V0KXtyZXR1cm4gY2xlYXJUaW1lb3V0KGUpfWlmKChuPT09ZGVmYXVsdENsZWFyVGltZW91dHx8IW4pJiZjbGVhclRpbWVvdXQpe249Y2xlYXJUaW1lb3V0O3JldHVybiBjbGVhclRpbWVvdXQoZSl9dHJ5e3JldHVybiBuKGUpfWNhdGNoKHQpe3RyeXtyZXR1cm4gbi5jYWxsKG51bGwsZSl9Y2F0Y2godCl7cmV0dXJuIG4uY2FsbCh0aGlzLGUpfX19dmFyIGk9W107dmFyIG89ZmFsc2U7dmFyIHU7dmFyIGE9LTE7ZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCl7aWYoIW98fCF1KXtyZXR1cm59bz1mYWxzZTtpZih1Lmxlbmd0aCl7aT11LmNvbmNhdChpKX1lbHNle2E9LTF9aWYoaS5sZW5ndGgpe2RyYWluUXVldWUoKX19ZnVuY3Rpb24gZHJhaW5RdWV1ZSgpe2lmKG8pe3JldHVybn12YXIgZT1ydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7bz10cnVlO3ZhciB0PWkubGVuZ3RoO3doaWxlKHQpe3U9aTtpPVtdO3doaWxlKCsrYTx0KXtpZih1KXt1W2FdLnJ1bigpfX1hPS0xO3Q9aS5sZW5ndGh9dT1udWxsO289ZmFsc2U7cnVuQ2xlYXJUaW1lb3V0KGUpfXQubmV4dFRpY2s9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSk7aWYoYXJndW1lbnRzLmxlbmd0aD4xKXtmb3IodmFyIHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKXt0W3ItMV09YXJndW1lbnRzW3JdfX1pLnB1c2gobmV3IEl0ZW0oZSx0KSk7aWYoaS5sZW5ndGg9PT0xJiYhbyl7cnVuVGltZW91dChkcmFpblF1ZXVlKX19O2Z1bmN0aW9uIEl0ZW0oZSx0KXt0aGlzLmZ1bj1lO3RoaXMuYXJyYXk9dH1JdGVtLnByb3RvdHlwZS5ydW49ZnVuY3Rpb24oKXt0aGlzLmZ1bi5hcHBseShudWxsLHRoaXMuYXJyYXkpfTt0LnRpdGxlPVwiYnJvd3NlclwiO3QuYnJvd3Nlcj10cnVlO3QuZW52PXt9O3QuYXJndj1bXTt0LnZlcnNpb249XCJcIjt0LnZlcnNpb25zPXt9O2Z1bmN0aW9uIG5vb3AoKXt9dC5vbj1ub29wO3QuYWRkTGlzdGVuZXI9bm9vcDt0Lm9uY2U9bm9vcDt0Lm9mZj1ub29wO3QucmVtb3ZlTGlzdGVuZXI9bm9vcDt0LnJlbW92ZUFsbExpc3RlbmVycz1ub29wO3QuZW1pdD1ub29wO3QucHJlcGVuZExpc3RlbmVyPW5vb3A7dC5wcmVwZW5kT25jZUxpc3RlbmVyPW5vb3A7dC5saXN0ZW5lcnM9ZnVuY3Rpb24oZSl7cmV0dXJuW119O3QuYmluZGluZz1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZFwiKX07dC5jd2Q9ZnVuY3Rpb24oKXtyZXR1cm5cIi9cIn07dC5jaGRpcj1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3QudW1hc2s9ZnVuY3Rpb24oKXtyZXR1cm4gMH19fTt2YXIgdD17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHIpe3ZhciBuPXRbcl07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgaT10W3JdPXtleHBvcnRzOnt9fTt2YXIgbz10cnVlO3RyeXtlW3JdKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO289ZmFsc2V9ZmluYWxseXtpZihvKWRlbGV0ZSB0W3JdfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciByPV9fbmNjd3Bja19yZXF1aXJlX18oMjI5KTttb2R1bGUuZXhwb3J0cz1yfSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/base64-js/index.js":
/*!*********************************************!*\
  !*** ../../node_modules/base64-js/index.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGtCQUFrQjtBQUNsQixtQkFBbUI7QUFDbkIscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLFVBQVU7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcz80Y2M0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/base64-js/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/bignumber.js/bignumber.js":
/*!****************************************************!*\
  !*** ../../node_modules/bignumber.js/bignumber.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var __WEBPACK_AMD_DEFINE_RESULT__;;(function (globalObject) {\r\n  'use strict';\r\n\r\n/*\r\n *      bignumber.js v9.1.2\r\n *      A JavaScript library for arbitrary-precision arithmetic.\r\n *      https://github.com/MikeMcl/bignumber.js\r\n *      Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>\r\n *      MIT Licensed.\r\n *\r\n *      BigNumber.prototype methods     |  BigNumber methods\r\n *                                      |\r\n *      absoluteValue            abs    |  clone\r\n *      comparedTo                      |  config               set\r\n *      decimalPlaces            dp     |      DECIMAL_PLACES\r\n *      dividedBy                div    |      ROUNDING_MODE\r\n *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT\r\n *      exponentiatedBy          pow    |      RANGE\r\n *      integerValue                    |      CRYPTO\r\n *      isEqualTo                eq     |      MODULO_MODE\r\n *      isFinite                        |      POW_PRECISION\r\n *      isGreaterThan            gt     |      FORMAT\r\n *      isGreaterThanOrEqualTo   gte    |      ALPHABET\r\n *      isInteger                       |  isBigNumber\r\n *      isLessThan               lt     |  maximum              max\r\n *      isLessThanOrEqualTo      lte    |  minimum              min\r\n *      isNaN                           |  random\r\n *      isNegative                      |  sum\r\n *      isPositive                      |\r\n *      isZero                          |\r\n *      minus                           |\r\n *      modulo                   mod    |\r\n *      multipliedBy             times  |\r\n *      negated                         |\r\n *      plus                            |\r\n *      precision                sd     |\r\n *      shiftedBy                       |\r\n *      squareRoot               sqrt   |\r\n *      toExponential                   |\r\n *      toFixed                         |\r\n *      toFormat                        |\r\n *      toFraction                      |\r\n *      toJSON                          |\r\n *      toNumber                        |\r\n *      toPrecision                     |\r\n *      toString                        |\r\n *      valueOf                         |\r\n *\r\n */\r\n\r\n\r\n  var BigNumber,\r\n    isNumeric = /^-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?$/i,\r\n    mathceil = Math.ceil,\r\n    mathfloor = Math.floor,\r\n\r\n    bignumberError = '[BigNumber Error] ',\r\n    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',\r\n\r\n    BASE = 1e14,\r\n    LOG_BASE = 14,\r\n    MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1\r\n    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1\r\n    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],\r\n    SQRT_BASE = 1e7,\r\n\r\n    // EDITABLE\r\n    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and\r\n    // the arguments to toExponential, toFixed, toFormat, and toPrecision.\r\n    MAX = 1E9;                                   // 0 to MAX_INT32\r\n\r\n\r\n  /*\r\n   * Create and return a BigNumber constructor.\r\n   */\r\n  function clone(configObject) {\r\n    var div, convertBase, parseNumeric,\r\n      P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },\r\n      ONE = new BigNumber(1),\r\n\r\n\r\n      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------\r\n\r\n\r\n      // The default values below must be integers within the inclusive ranges stated.\r\n      // The values can also be changed at run-time using BigNumber.set.\r\n\r\n      // The maximum number of decimal places for operations involving division.\r\n      DECIMAL_PLACES = 20,                     // 0 to MAX\r\n\r\n      // The rounding mode used when rounding to the above decimal places, and when using\r\n      // toExponential, toFixed, toFormat and toPrecision, and round (default value).\r\n      // UP         0 Away from zero.\r\n      // DOWN       1 Towards zero.\r\n      // CEIL       2 Towards +Infinity.\r\n      // FLOOR      3 Towards -Infinity.\r\n      // HALF_UP    4 Towards nearest neighbour. If equidistant, up.\r\n      // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\r\n      // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\r\n      // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\r\n      // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\r\n      ROUNDING_MODE = 4,                       // 0 to 8\r\n\r\n      // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]\r\n\r\n      // The exponent value at and beneath which toString returns exponential notation.\r\n      // Number type: -7\r\n      TO_EXP_NEG = -7,                         // 0 to -MAX\r\n\r\n      // The exponent value at and above which toString returns exponential notation.\r\n      // Number type: 21\r\n      TO_EXP_POS = 21,                         // 0 to MAX\r\n\r\n      // RANGE : [MIN_EXP, MAX_EXP]\r\n\r\n      // The minimum exponent value, beneath which underflow to zero occurs.\r\n      // Number type: -324  (5e-324)\r\n      MIN_EXP = -1e7,                          // -1 to -MAX\r\n\r\n      // The maximum exponent value, above which overflow to Infinity occurs.\r\n      // Number type:  308  (1.7976931348623157e+308)\r\n      // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.\r\n      MAX_EXP = 1e7,                           // 1 to MAX\r\n\r\n      // Whether to use cryptographically-secure random number generation, if available.\r\n      CRYPTO = false,                          // true or false\r\n\r\n      // The modulo mode used when calculating the modulus: a mod n.\r\n      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\r\n      // The remainder (r) is calculated as: r = a - n * q.\r\n      //\r\n      // UP        0 The remainder is positive if the dividend is negative, else is negative.\r\n      // DOWN      1 The remainder has the same sign as the dividend.\r\n      //             This modulo mode is commonly known as 'truncated division' and is\r\n      //             equivalent to (a % n) in JavaScript.\r\n      // FLOOR     3 The remainder has the same sign as the divisor (Python %).\r\n      // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.\r\n      // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).\r\n      //             The remainder is always positive.\r\n      //\r\n      // The truncated division, floored division, Euclidian division and IEEE 754 remainder\r\n      // modes are commonly used for the modulus operation.\r\n      // Although the other rounding modes can also be used, they may not give useful results.\r\n      MODULO_MODE = 1,                         // 0 to 9\r\n\r\n      // The maximum number of significant digits of the result of the exponentiatedBy operation.\r\n      // If POW_PRECISION is 0, there will be unlimited significant digits.\r\n      POW_PRECISION = 0,                       // 0 to MAX\r\n\r\n      // The format specification used by the BigNumber.prototype.toFormat method.\r\n      FORMAT = {\r\n        prefix: '',\r\n        groupSize: 3,\r\n        secondaryGroupSize: 0,\r\n        groupSeparator: ',',\r\n        decimalSeparator: '.',\r\n        fractionGroupSize: 0,\r\n        fractionGroupSeparator: '\\xA0',        // non-breaking space\r\n        suffix: ''\r\n      },\r\n\r\n      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',\r\n      // '-', '.', whitespace, or repeated character.\r\n      // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'\r\n      ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz',\r\n      alphabetHasNormalDecimalDigits = true;\r\n\r\n\r\n    //------------------------------------------------------------------------------------------\r\n\r\n\r\n    // CONSTRUCTOR\r\n\r\n\r\n    /*\r\n     * The BigNumber constructor and exported function.\r\n     * Create and return a new instance of a BigNumber object.\r\n     *\r\n     * v {number|string|BigNumber} A numeric value.\r\n     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.\r\n     */\r\n    function BigNumber(v, b) {\r\n      var alphabet, c, caseChanged, e, i, isNum, len, str,\r\n        x = this;\r\n\r\n      // Enable constructor call without `new`.\r\n      if (!(x instanceof BigNumber)) return new BigNumber(v, b);\r\n\r\n      if (b == null) {\r\n\r\n        if (v && v._isBigNumber === true) {\r\n          x.s = v.s;\r\n\r\n          if (!v.c || v.e > MAX_EXP) {\r\n            x.c = x.e = null;\r\n          } else if (v.e < MIN_EXP) {\r\n            x.c = [x.e = 0];\r\n          } else {\r\n            x.e = v.e;\r\n            x.c = v.c.slice();\r\n          }\r\n\r\n          return;\r\n        }\r\n\r\n        if ((isNum = typeof v == 'number') && v * 0 == 0) {\r\n\r\n          // Use `1 / n` to handle minus zero also.\r\n          x.s = 1 / v < 0 ? (v = -v, -1) : 1;\r\n\r\n          // Fast path for integers, where n < 2147483648 (2**31).\r\n          if (v === ~~v) {\r\n            for (e = 0, i = v; i >= 10; i /= 10, e++);\r\n\r\n            if (e > MAX_EXP) {\r\n              x.c = x.e = null;\r\n            } else {\r\n              x.e = e;\r\n              x.c = [v];\r\n            }\r\n\r\n            return;\r\n          }\r\n\r\n          str = String(v);\r\n        } else {\r\n\r\n          if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);\r\n\r\n          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;\r\n        }\r\n\r\n        // Decimal point?\r\n        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n\r\n        // Exponential form?\r\n        if ((i = str.search(/e/i)) > 0) {\r\n\r\n          // Determine exponent.\r\n          if (e < 0) e = i;\r\n          e += +str.slice(i + 1);\r\n          str = str.substring(0, i);\r\n        } else if (e < 0) {\r\n\r\n          // Integer.\r\n          e = str.length;\r\n        }\r\n\r\n      } else {\r\n\r\n        // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n        intCheck(b, 2, ALPHABET.length, 'Base');\r\n\r\n        // Allow exponential notation to be used with base 10 argument, while\r\n        // also rounding to DECIMAL_PLACES as with other bases.\r\n        if (b == 10 && alphabetHasNormalDecimalDigits) {\r\n          x = new BigNumber(v);\r\n          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);\r\n        }\r\n\r\n        str = String(v);\r\n\r\n        if (isNum = typeof v == 'number') {\r\n\r\n          // Avoid potential interpretation of Infinity and NaN as base 44+ values.\r\n          if (v * 0 != 0) return parseNumeric(x, str, isNum, b);\r\n\r\n          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;\r\n\r\n          // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\r\n          if (BigNumber.DEBUG && str.replace(/^0\\.0*|\\./, '').length > 15) {\r\n            throw Error\r\n             (tooManyDigits + v);\r\n          }\r\n        } else {\r\n          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;\r\n        }\r\n\r\n        alphabet = ALPHABET.slice(0, b);\r\n        e = i = 0;\r\n\r\n        // Check that str is a valid base b number.\r\n        // Don't use RegExp, so alphabet can contain special characters.\r\n        for (len = str.length; i < len; i++) {\r\n          if (alphabet.indexOf(c = str.charAt(i)) < 0) {\r\n            if (c == '.') {\r\n\r\n              // If '.' is not the first character and it has not be found before.\r\n              if (i > e) {\r\n                e = len;\r\n                continue;\r\n              }\r\n            } else if (!caseChanged) {\r\n\r\n              // Allow e.g. hexadecimal 'FF' as well as 'ff'.\r\n              if (str == str.toUpperCase() && (str = str.toLowerCase()) ||\r\n                  str == str.toLowerCase() && (str = str.toUpperCase())) {\r\n                caseChanged = true;\r\n                i = -1;\r\n                e = 0;\r\n                continue;\r\n              }\r\n            }\r\n\r\n            return parseNumeric(x, String(v), isNum, b);\r\n          }\r\n        }\r\n\r\n        // Prevent later check for length on converted number.\r\n        isNum = false;\r\n        str = convertBase(str, b, 10, x.s);\r\n\r\n        // Decimal point?\r\n        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n        else e = str.length;\r\n      }\r\n\r\n      // Determine leading zeros.\r\n      for (i = 0; str.charCodeAt(i) === 48; i++);\r\n\r\n      // Determine trailing zeros.\r\n      for (len = str.length; str.charCodeAt(--len) === 48;);\r\n\r\n      if (str = str.slice(i, ++len)) {\r\n        len -= i;\r\n\r\n        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\r\n        if (isNum && BigNumber.DEBUG &&\r\n          len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {\r\n            throw Error\r\n             (tooManyDigits + (x.s * v));\r\n        }\r\n\r\n         // Overflow?\r\n        if ((e = e - i - 1) > MAX_EXP) {\r\n\r\n          // Infinity.\r\n          x.c = x.e = null;\r\n\r\n        // Underflow?\r\n        } else if (e < MIN_EXP) {\r\n\r\n          // Zero.\r\n          x.c = [x.e = 0];\r\n        } else {\r\n          x.e = e;\r\n          x.c = [];\r\n\r\n          // Transform base\r\n\r\n          // e is the base 10 exponent.\r\n          // i is where to slice str to get the first element of the coefficient array.\r\n          i = (e + 1) % LOG_BASE;\r\n          if (e < 0) i += LOG_BASE;  // i < 1\r\n\r\n          if (i < len) {\r\n            if (i) x.c.push(+str.slice(0, i));\r\n\r\n            for (len -= LOG_BASE; i < len;) {\r\n              x.c.push(+str.slice(i, i += LOG_BASE));\r\n            }\r\n\r\n            i = LOG_BASE - (str = str.slice(i)).length;\r\n          } else {\r\n            i -= len;\r\n          }\r\n\r\n          for (; i--; str += '0');\r\n          x.c.push(+str);\r\n        }\r\n      } else {\r\n\r\n        // Zero.\r\n        x.c = [x.e = 0];\r\n      }\r\n    }\r\n\r\n\r\n    // CONSTRUCTOR PROPERTIES\r\n\r\n\r\n    BigNumber.clone = clone;\r\n\r\n    BigNumber.ROUND_UP = 0;\r\n    BigNumber.ROUND_DOWN = 1;\r\n    BigNumber.ROUND_CEIL = 2;\r\n    BigNumber.ROUND_FLOOR = 3;\r\n    BigNumber.ROUND_HALF_UP = 4;\r\n    BigNumber.ROUND_HALF_DOWN = 5;\r\n    BigNumber.ROUND_HALF_EVEN = 6;\r\n    BigNumber.ROUND_HALF_CEIL = 7;\r\n    BigNumber.ROUND_HALF_FLOOR = 8;\r\n    BigNumber.EUCLID = 9;\r\n\r\n\r\n    /*\r\n     * Configure infrequently-changing library-wide settings.\r\n     *\r\n     * Accept an object with the following optional properties (if the value of a property is\r\n     * a number, it must be an integer within the inclusive range stated):\r\n     *\r\n     *   DECIMAL_PLACES   {number}           0 to MAX\r\n     *   ROUNDING_MODE    {number}           0 to 8\r\n     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]\r\n     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]\r\n     *   CRYPTO           {boolean}          true or false\r\n     *   MODULO_MODE      {number}           0 to 9\r\n     *   POW_PRECISION       {number}           0 to MAX\r\n     *   ALPHABET         {string}           A string of two or more unique characters which does\r\n     *                                       not contain '.'.\r\n     *   FORMAT           {object}           An object with some of the following properties:\r\n     *     prefix                 {string}\r\n     *     groupSize              {number}\r\n     *     secondaryGroupSize     {number}\r\n     *     groupSeparator         {string}\r\n     *     decimalSeparator       {string}\r\n     *     fractionGroupSize      {number}\r\n     *     fractionGroupSeparator {string}\r\n     *     suffix                 {string}\r\n     *\r\n     * (The values assigned to the above FORMAT object properties are not checked for validity.)\r\n     *\r\n     * E.g.\r\n     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })\r\n     *\r\n     * Ignore properties/parameters set to null or undefined, except for ALPHABET.\r\n     *\r\n     * Return an object with the properties current values.\r\n     */\r\n    BigNumber.config = BigNumber.set = function (obj) {\r\n      var p, v;\r\n\r\n      if (obj != null) {\r\n\r\n        if (typeof obj == 'object') {\r\n\r\n          // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.\r\n          // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, MAX, p);\r\n            DECIMAL_PLACES = v;\r\n          }\r\n\r\n          // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.\r\n          // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, 8, p);\r\n            ROUNDING_MODE = v;\r\n          }\r\n\r\n          // EXPONENTIAL_AT {number|number[]}\r\n          // Integer, -MAX to MAX inclusive or\r\n          // [integer -MAX to 0 inclusive, 0 to MAX inclusive].\r\n          // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {\r\n            v = obj[p];\r\n            if (v && v.pop) {\r\n              intCheck(v[0], -MAX, 0, p);\r\n              intCheck(v[1], 0, MAX, p);\r\n              TO_EXP_NEG = v[0];\r\n              TO_EXP_POS = v[1];\r\n            } else {\r\n              intCheck(v, -MAX, MAX, p);\r\n              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);\r\n            }\r\n          }\r\n\r\n          // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or\r\n          // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].\r\n          // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'\r\n          if (obj.hasOwnProperty(p = 'RANGE')) {\r\n            v = obj[p];\r\n            if (v && v.pop) {\r\n              intCheck(v[0], -MAX, -1, p);\r\n              intCheck(v[1], 1, MAX, p);\r\n              MIN_EXP = v[0];\r\n              MAX_EXP = v[1];\r\n            } else {\r\n              intCheck(v, -MAX, MAX, p);\r\n              if (v) {\r\n                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);\r\n              } else {\r\n                throw Error\r\n                 (bignumberError + p + ' cannot be zero: ' + v);\r\n              }\r\n            }\r\n          }\r\n\r\n          // CRYPTO {boolean} true or false.\r\n          // '[BigNumber Error] CRYPTO not true or false: {v}'\r\n          // '[BigNumber Error] crypto unavailable'\r\n          if (obj.hasOwnProperty(p = 'CRYPTO')) {\r\n            v = obj[p];\r\n            if (v === !!v) {\r\n              if (v) {\r\n                if (typeof crypto != 'undefined' && crypto &&\r\n                 (crypto.getRandomValues || crypto.randomBytes)) {\r\n                  CRYPTO = v;\r\n                } else {\r\n                  CRYPTO = !v;\r\n                  throw Error\r\n                   (bignumberError + 'crypto unavailable');\r\n                }\r\n              } else {\r\n                CRYPTO = v;\r\n              }\r\n            } else {\r\n              throw Error\r\n               (bignumberError + p + ' not true or false: ' + v);\r\n            }\r\n          }\r\n\r\n          // MODULO_MODE {number} Integer, 0 to 9 inclusive.\r\n          // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'MODULO_MODE')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, 9, p);\r\n            MODULO_MODE = v;\r\n          }\r\n\r\n          // POW_PRECISION {number} Integer, 0 to MAX inclusive.\r\n          // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'POW_PRECISION')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, MAX, p);\r\n            POW_PRECISION = v;\r\n          }\r\n\r\n          // FORMAT {object}\r\n          // '[BigNumber Error] FORMAT not an object: {v}'\r\n          if (obj.hasOwnProperty(p = 'FORMAT')) {\r\n            v = obj[p];\r\n            if (typeof v == 'object') FORMAT = v;\r\n            else throw Error\r\n             (bignumberError + p + ' not an object: ' + v);\r\n          }\r\n\r\n          // ALPHABET {string}\r\n          // '[BigNumber Error] ALPHABET invalid: {v}'\r\n          if (obj.hasOwnProperty(p = 'ALPHABET')) {\r\n            v = obj[p];\r\n\r\n            // Disallow if less than two characters,\r\n            // or if it contains '+', '-', '.', whitespace, or a repeated character.\r\n            if (typeof v == 'string' && !/^.?$|[+\\-.\\s]|(.).*\\1/.test(v)) {\r\n              alphabetHasNormalDecimalDigits = v.slice(0, 10) == '0123456789';\r\n              ALPHABET = v;\r\n            } else {\r\n              throw Error\r\n               (bignumberError + p + ' invalid: ' + v);\r\n            }\r\n          }\r\n\r\n        } else {\r\n\r\n          // '[BigNumber Error] Object expected: {v}'\r\n          throw Error\r\n           (bignumberError + 'Object expected: ' + obj);\r\n        }\r\n      }\r\n\r\n      return {\r\n        DECIMAL_PLACES: DECIMAL_PLACES,\r\n        ROUNDING_MODE: ROUNDING_MODE,\r\n        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],\r\n        RANGE: [MIN_EXP, MAX_EXP],\r\n        CRYPTO: CRYPTO,\r\n        MODULO_MODE: MODULO_MODE,\r\n        POW_PRECISION: POW_PRECISION,\r\n        FORMAT: FORMAT,\r\n        ALPHABET: ALPHABET\r\n      };\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if v is a BigNumber instance, otherwise return false.\r\n     *\r\n     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.\r\n     *\r\n     * v {any}\r\n     *\r\n     * '[BigNumber Error] Invalid BigNumber: {v}'\r\n     */\r\n    BigNumber.isBigNumber = function (v) {\r\n      if (!v || v._isBigNumber !== true) return false;\r\n      if (!BigNumber.DEBUG) return true;\r\n\r\n      var i, n,\r\n        c = v.c,\r\n        e = v.e,\r\n        s = v.s;\r\n\r\n      out: if ({}.toString.call(c) == '[object Array]') {\r\n\r\n        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {\r\n\r\n          // If the first element is zero, the BigNumber value must be zero.\r\n          if (c[0] === 0) {\r\n            if (e === 0 && c.length === 1) return true;\r\n            break out;\r\n          }\r\n\r\n          // Calculate number of digits that c[0] should have, based on the exponent.\r\n          i = (e + 1) % LOG_BASE;\r\n          if (i < 1) i += LOG_BASE;\r\n\r\n          // Calculate number of digits of c[0].\r\n          //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {\r\n          if (String(c[0]).length == i) {\r\n\r\n            for (i = 0; i < c.length; i++) {\r\n              n = c[i];\r\n              if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;\r\n            }\r\n\r\n            // Last element cannot be zero, unless it is the only element.\r\n            if (n !== 0) return true;\r\n          }\r\n        }\r\n\r\n      // Infinity/NaN\r\n      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {\r\n        return true;\r\n      }\r\n\r\n      throw Error\r\n        (bignumberError + 'Invalid BigNumber: ' + v);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the maximum of the arguments.\r\n     *\r\n     * arguments {number|string|BigNumber}\r\n     */\r\n    BigNumber.maximum = BigNumber.max = function () {\r\n      return maxOrMin(arguments, -1);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the minimum of the arguments.\r\n     *\r\n     * arguments {number|string|BigNumber}\r\n     */\r\n    BigNumber.minimum = BigNumber.min = function () {\r\n      return maxOrMin(arguments, 1);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,\r\n     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing\r\n     * zeros are produced).\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'\r\n     * '[BigNumber Error] crypto unavailable'\r\n     */\r\n    BigNumber.random = (function () {\r\n      var pow2_53 = 0x20000000000000;\r\n\r\n      // Return a 53 bit integer n, where 0 <= n < 9007199254740992.\r\n      // Check if Math.random() produces more than 32 bits of randomness.\r\n      // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.\r\n      // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.\r\n      var random53bitInt = (Math.random() * pow2_53) & 0x1fffff\r\n       ? function () { return mathfloor(Math.random() * pow2_53); }\r\n       : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +\r\n         (Math.random() * 0x800000 | 0); };\r\n\r\n      return function (dp) {\r\n        var a, b, e, k, v,\r\n          i = 0,\r\n          c = [],\r\n          rand = new BigNumber(ONE);\r\n\r\n        if (dp == null) dp = DECIMAL_PLACES;\r\n        else intCheck(dp, 0, MAX);\r\n\r\n        k = mathceil(dp / LOG_BASE);\r\n\r\n        if (CRYPTO) {\r\n\r\n          // Browsers supporting crypto.getRandomValues.\r\n          if (crypto.getRandomValues) {\r\n\r\n            a = crypto.getRandomValues(new Uint32Array(k *= 2));\r\n\r\n            for (; i < k;) {\r\n\r\n              // 53 bits:\r\n              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)\r\n              // 11111 11111111 11111111 11111111 11100000 00000000 00000000\r\n              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)\r\n              //                                     11111 11111111 11111111\r\n              // 0x20000 is 2^21.\r\n              v = a[i] * 0x20000 + (a[i + 1] >>> 11);\r\n\r\n              // Rejection sampling:\r\n              // 0 <= v < 9007199254740992\r\n              // Probability that v >= 9e15, is\r\n              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251\r\n              if (v >= 9e15) {\r\n                b = crypto.getRandomValues(new Uint32Array(2));\r\n                a[i] = b[0];\r\n                a[i + 1] = b[1];\r\n              } else {\r\n\r\n                // 0 <= v <= 8999999999999999\r\n                // 0 <= (v % 1e14) <= 99999999999999\r\n                c.push(v % 1e14);\r\n                i += 2;\r\n              }\r\n            }\r\n            i = k / 2;\r\n\r\n          // Node.js supporting crypto.randomBytes.\r\n          } else if (crypto.randomBytes) {\r\n\r\n            // buffer\r\n            a = crypto.randomBytes(k *= 7);\r\n\r\n            for (; i < k;) {\r\n\r\n              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40\r\n              // 0x100000000 is 2^32, 0x1000000 is 2^24\r\n              // 11111 11111111 11111111 11111111 11111111 11111111 11111111\r\n              // 0 <= v < 9007199254740992\r\n              v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +\r\n                 (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +\r\n                 (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];\r\n\r\n              if (v >= 9e15) {\r\n                crypto.randomBytes(7).copy(a, i);\r\n              } else {\r\n\r\n                // 0 <= (v % 1e14) <= 99999999999999\r\n                c.push(v % 1e14);\r\n                i += 7;\r\n              }\r\n            }\r\n            i = k / 7;\r\n          } else {\r\n            CRYPTO = false;\r\n            throw Error\r\n             (bignumberError + 'crypto unavailable');\r\n          }\r\n        }\r\n\r\n        // Use Math.random.\r\n        if (!CRYPTO) {\r\n\r\n          for (; i < k;) {\r\n            v = random53bitInt();\r\n            if (v < 9e15) c[i++] = v % 1e14;\r\n          }\r\n        }\r\n\r\n        k = c[--i];\r\n        dp %= LOG_BASE;\r\n\r\n        // Convert trailing digits to zeros according to dp.\r\n        if (k && dp) {\r\n          v = POWS_TEN[LOG_BASE - dp];\r\n          c[i] = mathfloor(k / v) * v;\r\n        }\r\n\r\n        // Remove trailing elements which are zero.\r\n        for (; c[i] === 0; c.pop(), i--);\r\n\r\n        // Zero?\r\n        if (i < 0) {\r\n          c = [e = 0];\r\n        } else {\r\n\r\n          // Remove leading elements which are zero and adjust exponent accordingly.\r\n          for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);\r\n\r\n          // Count the digits of the first element of c to determine leading zeros, and...\r\n          for (i = 1, v = c[0]; v >= 10; v /= 10, i++);\r\n\r\n          // adjust the exponent accordingly.\r\n          if (i < LOG_BASE) e -= LOG_BASE - i;\r\n        }\r\n\r\n        rand.e = e;\r\n        rand.c = c;\r\n        return rand;\r\n      };\r\n    })();\r\n\r\n\r\n    /*\r\n     * Return a BigNumber whose value is the sum of the arguments.\r\n     *\r\n     * arguments {number|string|BigNumber}\r\n     */\r\n    BigNumber.sum = function () {\r\n      var i = 1,\r\n        args = arguments,\r\n        sum = new BigNumber(args[0]);\r\n      for (; i < args.length;) sum = sum.plus(args[i++]);\r\n      return sum;\r\n    };\r\n\r\n\r\n    // PRIVATE FUNCTIONS\r\n\r\n\r\n    // Called by BigNumber and BigNumber.prototype.toString.\r\n    convertBase = (function () {\r\n      var decimal = '0123456789';\r\n\r\n      /*\r\n       * Convert string of baseIn to an array of numbers of baseOut.\r\n       * Eg. toBaseOut('255', 10, 16) returns [15, 15].\r\n       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].\r\n       */\r\n      function toBaseOut(str, baseIn, baseOut, alphabet) {\r\n        var j,\r\n          arr = [0],\r\n          arrL,\r\n          i = 0,\r\n          len = str.length;\r\n\r\n        for (; i < len;) {\r\n          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);\r\n\r\n          arr[0] += alphabet.indexOf(str.charAt(i++));\r\n\r\n          for (j = 0; j < arr.length; j++) {\r\n\r\n            if (arr[j] > baseOut - 1) {\r\n              if (arr[j + 1] == null) arr[j + 1] = 0;\r\n              arr[j + 1] += arr[j] / baseOut | 0;\r\n              arr[j] %= baseOut;\r\n            }\r\n          }\r\n        }\r\n\r\n        return arr.reverse();\r\n      }\r\n\r\n      // Convert a numeric string of baseIn to a numeric string of baseOut.\r\n      // If the caller is toString, we are converting from base 10 to baseOut.\r\n      // If the caller is BigNumber, we are converting from baseIn to base 10.\r\n      return function (str, baseIn, baseOut, sign, callerIsToString) {\r\n        var alphabet, d, e, k, r, x, xc, y,\r\n          i = str.indexOf('.'),\r\n          dp = DECIMAL_PLACES,\r\n          rm = ROUNDING_MODE;\r\n\r\n        // Non-integer.\r\n        if (i >= 0) {\r\n          k = POW_PRECISION;\r\n\r\n          // Unlimited precision.\r\n          POW_PRECISION = 0;\r\n          str = str.replace('.', '');\r\n          y = new BigNumber(baseIn);\r\n          x = y.pow(str.length - i);\r\n          POW_PRECISION = k;\r\n\r\n          // Convert str as if an integer, then restore the fraction part by dividing the\r\n          // result by its base raised to a power.\r\n\r\n          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),\r\n           10, baseOut, decimal);\r\n          y.e = y.c.length;\r\n        }\r\n\r\n        // Convert the number as integer.\r\n\r\n        xc = toBaseOut(str, baseIn, baseOut, callerIsToString\r\n         ? (alphabet = ALPHABET, decimal)\r\n         : (alphabet = decimal, ALPHABET));\r\n\r\n        // xc now represents str as an integer and converted to baseOut. e is the exponent.\r\n        e = k = xc.length;\r\n\r\n        // Remove trailing zeros.\r\n        for (; xc[--k] == 0; xc.pop());\r\n\r\n        // Zero?\r\n        if (!xc[0]) return alphabet.charAt(0);\r\n\r\n        // Does str represent an integer? If so, no need for the division.\r\n        if (i < 0) {\r\n          --e;\r\n        } else {\r\n          x.c = xc;\r\n          x.e = e;\r\n\r\n          // The sign is needed for correct rounding.\r\n          x.s = sign;\r\n          x = div(x, y, dp, rm, baseOut);\r\n          xc = x.c;\r\n          r = x.r;\r\n          e = x.e;\r\n        }\r\n\r\n        // xc now represents str converted to baseOut.\r\n\r\n        // THe index of the rounding digit.\r\n        d = e + dp + 1;\r\n\r\n        // The rounding digit: the digit to the right of the digit that may be rounded up.\r\n        i = xc[d];\r\n\r\n        // Look at the rounding digits and mode to determine whether to round up.\r\n\r\n        k = baseOut / 2;\r\n        r = r || d < 0 || xc[d + 1] != null;\r\n\r\n        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n              : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||\r\n               rm == (x.s < 0 ? 8 : 7));\r\n\r\n        // If the index of the rounding digit is not greater than zero, or xc represents\r\n        // zero, then the result of the base conversion is zero or, if rounding up, a value\r\n        // such as 0.00001.\r\n        if (d < 1 || !xc[0]) {\r\n\r\n          // 1^-dp or 0\r\n          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);\r\n        } else {\r\n\r\n          // Truncate xc to the required number of decimal places.\r\n          xc.length = d;\r\n\r\n          // Round up?\r\n          if (r) {\r\n\r\n            // Rounding up may mean the previous digit has to be rounded up and so on.\r\n            for (--baseOut; ++xc[--d] > baseOut;) {\r\n              xc[d] = 0;\r\n\r\n              if (!d) {\r\n                ++e;\r\n                xc = [1].concat(xc);\r\n              }\r\n            }\r\n          }\r\n\r\n          // Determine trailing zeros.\r\n          for (k = xc.length; !xc[--k];);\r\n\r\n          // E.g. [4, 11, 15] becomes 4bf.\r\n          for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));\r\n\r\n          // Add leading zeros, decimal point and trailing zeros as required.\r\n          str = toFixedPoint(str, e, alphabet.charAt(0));\r\n        }\r\n\r\n        // The caller will add the sign.\r\n        return str;\r\n      };\r\n    })();\r\n\r\n\r\n    // Perform division in the specified base. Called by div and convertBase.\r\n    div = (function () {\r\n\r\n      // Assume non-zero x and k.\r\n      function multiply(x, k, base) {\r\n        var m, temp, xlo, xhi,\r\n          carry = 0,\r\n          i = x.length,\r\n          klo = k % SQRT_BASE,\r\n          khi = k / SQRT_BASE | 0;\r\n\r\n        for (x = x.slice(); i--;) {\r\n          xlo = x[i] % SQRT_BASE;\r\n          xhi = x[i] / SQRT_BASE | 0;\r\n          m = khi * xlo + xhi * klo;\r\n          temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;\r\n          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;\r\n          x[i] = temp % base;\r\n        }\r\n\r\n        if (carry) x = [carry].concat(x);\r\n\r\n        return x;\r\n      }\r\n\r\n      function compare(a, b, aL, bL) {\r\n        var i, cmp;\r\n\r\n        if (aL != bL) {\r\n          cmp = aL > bL ? 1 : -1;\r\n        } else {\r\n\r\n          for (i = cmp = 0; i < aL; i++) {\r\n\r\n            if (a[i] != b[i]) {\r\n              cmp = a[i] > b[i] ? 1 : -1;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        return cmp;\r\n      }\r\n\r\n      function subtract(a, b, aL, base) {\r\n        var i = 0;\r\n\r\n        // Subtract b from a.\r\n        for (; aL--;) {\r\n          a[aL] -= i;\r\n          i = a[aL] < b[aL] ? 1 : 0;\r\n          a[aL] = i * base + a[aL] - b[aL];\r\n        }\r\n\r\n        // Remove leading zeros.\r\n        for (; !a[0] && a.length > 1; a.splice(0, 1));\r\n      }\r\n\r\n      // x: dividend, y: divisor.\r\n      return function (x, y, dp, rm, base) {\r\n        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,\r\n          yL, yz,\r\n          s = x.s == y.s ? 1 : -1,\r\n          xc = x.c,\r\n          yc = y.c;\r\n\r\n        // Either NaN, Infinity or 0?\r\n        if (!xc || !xc[0] || !yc || !yc[0]) {\r\n\r\n          return new BigNumber(\r\n\r\n           // Return NaN if either NaN, or both Infinity or 0.\r\n           !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :\r\n\r\n            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.\r\n            xc && xc[0] == 0 || !yc ? s * 0 : s / 0\r\n         );\r\n        }\r\n\r\n        q = new BigNumber(s);\r\n        qc = q.c = [];\r\n        e = x.e - y.e;\r\n        s = dp + e + 1;\r\n\r\n        if (!base) {\r\n          base = BASE;\r\n          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);\r\n          s = s / LOG_BASE | 0;\r\n        }\r\n\r\n        // Result exponent may be one less then the current value of e.\r\n        // The coefficients of the BigNumbers from convertBase may have trailing zeros.\r\n        for (i = 0; yc[i] == (xc[i] || 0); i++);\r\n\r\n        if (yc[i] > (xc[i] || 0)) e--;\r\n\r\n        if (s < 0) {\r\n          qc.push(1);\r\n          more = true;\r\n        } else {\r\n          xL = xc.length;\r\n          yL = yc.length;\r\n          i = 0;\r\n          s += 2;\r\n\r\n          // Normalise xc and yc so highest order digit of yc is >= base / 2.\r\n\r\n          n = mathfloor(base / (yc[0] + 1));\r\n\r\n          // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.\r\n          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {\r\n          if (n > 1) {\r\n            yc = multiply(yc, n, base);\r\n            xc = multiply(xc, n, base);\r\n            yL = yc.length;\r\n            xL = xc.length;\r\n          }\r\n\r\n          xi = yL;\r\n          rem = xc.slice(0, yL);\r\n          remL = rem.length;\r\n\r\n          // Add zeros to make remainder as long as divisor.\r\n          for (; remL < yL; rem[remL++] = 0);\r\n          yz = yc.slice();\r\n          yz = [0].concat(yz);\r\n          yc0 = yc[0];\r\n          if (yc[1] >= base / 2) yc0++;\r\n          // Not necessary, but to prevent trial digit n > base, when using base 3.\r\n          // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;\r\n\r\n          do {\r\n            n = 0;\r\n\r\n            // Compare divisor and remainder.\r\n            cmp = compare(yc, rem, yL, remL);\r\n\r\n            // If divisor < remainder.\r\n            if (cmp < 0) {\r\n\r\n              // Calculate trial digit, n.\r\n\r\n              rem0 = rem[0];\r\n              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\r\n\r\n              // n is how many times the divisor goes into the current remainder.\r\n              n = mathfloor(rem0 / yc0);\r\n\r\n              //  Algorithm:\r\n              //  product = divisor multiplied by trial digit (n).\r\n              //  Compare product and remainder.\r\n              //  If product is greater than remainder:\r\n              //    Subtract divisor from product, decrement trial digit.\r\n              //  Subtract product from remainder.\r\n              //  If product was less than remainder at the last compare:\r\n              //    Compare new remainder and divisor.\r\n              //    If remainder is greater than divisor:\r\n              //      Subtract divisor from remainder, increment trial digit.\r\n\r\n              if (n > 1) {\r\n\r\n                // n may be > base only when base is 3.\r\n                if (n >= base) n = base - 1;\r\n\r\n                // product = divisor * trial digit.\r\n                prod = multiply(yc, n, base);\r\n                prodL = prod.length;\r\n                remL = rem.length;\r\n\r\n                // Compare product and remainder.\r\n                // If product > remainder then trial digit n too high.\r\n                // n is 1 too high about 5% of the time, and is not known to have\r\n                // ever been more than 1 too high.\r\n                while (compare(prod, rem, prodL, remL) == 1) {\r\n                  n--;\r\n\r\n                  // Subtract divisor from product.\r\n                  subtract(prod, yL < prodL ? yz : yc, prodL, base);\r\n                  prodL = prod.length;\r\n                  cmp = 1;\r\n                }\r\n              } else {\r\n\r\n                // n is 0 or 1, cmp is -1.\r\n                // If n is 0, there is no need to compare yc and rem again below,\r\n                // so change cmp to 1 to avoid it.\r\n                // If n is 1, leave cmp as -1, so yc and rem are compared again.\r\n                if (n == 0) {\r\n\r\n                  // divisor < remainder, so n must be at least 1.\r\n                  cmp = n = 1;\r\n                }\r\n\r\n                // product = divisor\r\n                prod = yc.slice();\r\n                prodL = prod.length;\r\n              }\r\n\r\n              if (prodL < remL) prod = [0].concat(prod);\r\n\r\n              // Subtract product from remainder.\r\n              subtract(rem, prod, remL, base);\r\n              remL = rem.length;\r\n\r\n               // If product was < remainder.\r\n              if (cmp == -1) {\r\n\r\n                // Compare divisor and new remainder.\r\n                // If divisor < new remainder, subtract divisor from remainder.\r\n                // Trial digit n too low.\r\n                // n is 1 too low about 5% of the time, and very rarely 2 too low.\r\n                while (compare(yc, rem, yL, remL) < 1) {\r\n                  n++;\r\n\r\n                  // Subtract divisor from remainder.\r\n                  subtract(rem, yL < remL ? yz : yc, remL, base);\r\n                  remL = rem.length;\r\n                }\r\n              }\r\n            } else if (cmp === 0) {\r\n              n++;\r\n              rem = [0];\r\n            } // else cmp === 1 and n will be 0\r\n\r\n            // Add the next digit, n, to the result array.\r\n            qc[i++] = n;\r\n\r\n            // Update the remainder.\r\n            if (rem[0]) {\r\n              rem[remL++] = xc[xi] || 0;\r\n            } else {\r\n              rem = [xc[xi]];\r\n              remL = 1;\r\n            }\r\n          } while ((xi++ < xL || rem[0] != null) && s--);\r\n\r\n          more = rem[0] != null;\r\n\r\n          // Leading zero?\r\n          if (!qc[0]) qc.splice(0, 1);\r\n        }\r\n\r\n        if (base == BASE) {\r\n\r\n          // To calculate q.e, first get the number of digits of qc[0].\r\n          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);\r\n\r\n          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);\r\n\r\n        // Caller is convertBase.\r\n        } else {\r\n          q.e = e;\r\n          q.r = +more;\r\n        }\r\n\r\n        return q;\r\n      };\r\n    })();\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of BigNumber n in fixed-point or exponential\r\n     * notation rounded to the specified decimal places or significant digits.\r\n     *\r\n     * n: a BigNumber.\r\n     * i: the index of the last digit required (i.e. the digit that may be rounded up).\r\n     * rm: the rounding mode.\r\n     * id: 1 (toExponential) or 2 (toPrecision).\r\n     */\r\n    function format(n, i, rm, id) {\r\n      var c0, e, ne, len, str;\r\n\r\n      if (rm == null) rm = ROUNDING_MODE;\r\n      else intCheck(rm, 0, 8);\r\n\r\n      if (!n.c) return n.toString();\r\n\r\n      c0 = n.c[0];\r\n      ne = n.e;\r\n\r\n      if (i == null) {\r\n        str = coeffToString(n.c);\r\n        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)\r\n         ? toExponential(str, ne)\r\n         : toFixedPoint(str, ne, '0');\r\n      } else {\r\n        n = round(new BigNumber(n), i, rm);\r\n\r\n        // n.e may have changed if the value was rounded up.\r\n        e = n.e;\r\n\r\n        str = coeffToString(n.c);\r\n        len = str.length;\r\n\r\n        // toPrecision returns exponential notation if the number of significant digits\r\n        // specified is less than the number of digits necessary to represent the integer\r\n        // part of the value in fixed-point notation.\r\n\r\n        // Exponential notation.\r\n        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {\r\n\r\n          // Append zeros?\r\n          for (; len < i; str += '0', len++);\r\n          str = toExponential(str, e);\r\n\r\n        // Fixed-point notation.\r\n        } else {\r\n          i -= ne;\r\n          str = toFixedPoint(str, e, '0');\r\n\r\n          // Append zeros?\r\n          if (e + 1 > len) {\r\n            if (--i > 0) for (str += '.'; i--; str += '0');\r\n          } else {\r\n            i += e - len;\r\n            if (i > 0) {\r\n              if (e + 1 == len) str += '.';\r\n              for (; i--; str += '0');\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return n.s < 0 && c0 ? '-' + str : str;\r\n    }\r\n\r\n\r\n    // Handle BigNumber.max and BigNumber.min.\r\n    // If any number is NaN, return NaN.\r\n    function maxOrMin(args, n) {\r\n      var k, y,\r\n        i = 1,\r\n        x = new BigNumber(args[0]);\r\n\r\n      for (; i < args.length; i++) {\r\n        y = new BigNumber(args[i]);\r\n        if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {\r\n          x = y;\r\n        }\r\n      }\r\n\r\n      return x;\r\n    }\r\n\r\n\r\n    /*\r\n     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.\r\n     * Called by minus, plus and times.\r\n     */\r\n    function normalise(n, c, e) {\r\n      var i = 1,\r\n        j = c.length;\r\n\r\n       // Remove trailing zeros.\r\n      for (; !c[--j]; c.pop());\r\n\r\n      // Calculate the base 10 exponent. First get the number of digits of c[0].\r\n      for (j = c[0]; j >= 10; j /= 10, i++);\r\n\r\n      // Overflow?\r\n      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {\r\n\r\n        // Infinity.\r\n        n.c = n.e = null;\r\n\r\n      // Underflow?\r\n      } else if (e < MIN_EXP) {\r\n\r\n        // Zero.\r\n        n.c = [n.e = 0];\r\n      } else {\r\n        n.e = e;\r\n        n.c = c;\r\n      }\r\n\r\n      return n;\r\n    }\r\n\r\n\r\n    // Handle values that fail the validity test in BigNumber.\r\n    parseNumeric = (function () {\r\n      var basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i,\r\n        dotAfter = /^([^.]+)\\.$/,\r\n        dotBefore = /^\\.([^.]+)$/,\r\n        isInfinityOrNaN = /^-?(Infinity|NaN)$/,\r\n        whitespaceOrPlus = /^\\s*\\+(?=[\\w.])|^\\s+|\\s+$/g;\r\n\r\n      return function (x, str, isNum, b) {\r\n        var base,\r\n          s = isNum ? str : str.replace(whitespaceOrPlus, '');\r\n\r\n        // No exception on Infinity or NaN.\r\n        if (isInfinityOrNaN.test(s)) {\r\n          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;\r\n        } else {\r\n          if (!isNum) {\r\n\r\n            // basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i\r\n            s = s.replace(basePrefix, function (m, p1, p2) {\r\n              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;\r\n              return !b || b == base ? p1 : m;\r\n            });\r\n\r\n            if (b) {\r\n              base = b;\r\n\r\n              // E.g. '1.' to '1', '.1' to '0.1'\r\n              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');\r\n            }\r\n\r\n            if (str != s) return new BigNumber(s, base);\r\n          }\r\n\r\n          // '[BigNumber Error] Not a number: {n}'\r\n          // '[BigNumber Error] Not a base {b} number: {n}'\r\n          if (BigNumber.DEBUG) {\r\n            throw Error\r\n              (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);\r\n          }\r\n\r\n          // NaN\r\n          x.s = null;\r\n        }\r\n\r\n        x.c = x.e = null;\r\n      }\r\n    })();\r\n\r\n\r\n    /*\r\n     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.\r\n     * If r is truthy, it is known that there are more digits after the rounding digit.\r\n     */\r\n    function round(x, sd, rm, r) {\r\n      var d, i, j, k, n, ni, rd,\r\n        xc = x.c,\r\n        pows10 = POWS_TEN;\r\n\r\n      // if x is not Infinity or NaN...\r\n      if (xc) {\r\n\r\n        // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.\r\n        // n is a base 1e14 number, the value of the element of array x.c containing rd.\r\n        // ni is the index of n within x.c.\r\n        // d is the number of digits of n.\r\n        // i is the index of rd within n including leading zeros.\r\n        // j is the actual index of rd within n (if < 0, rd is a leading zero).\r\n        out: {\r\n\r\n          // Get the number of digits of the first element of xc.\r\n          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);\r\n          i = sd - d;\r\n\r\n          // If the rounding digit is in the first element of xc...\r\n          if (i < 0) {\r\n            i += LOG_BASE;\r\n            j = sd;\r\n            n = xc[ni = 0];\r\n\r\n            // Get the rounding digit at index j of n.\r\n            rd = mathfloor(n / pows10[d - j - 1] % 10);\r\n          } else {\r\n            ni = mathceil((i + 1) / LOG_BASE);\r\n\r\n            if (ni >= xc.length) {\r\n\r\n              if (r) {\r\n\r\n                // Needed by sqrt.\r\n                for (; xc.length <= ni; xc.push(0));\r\n                n = rd = 0;\r\n                d = 1;\r\n                i %= LOG_BASE;\r\n                j = i - LOG_BASE + 1;\r\n              } else {\r\n                break out;\r\n              }\r\n            } else {\r\n              n = k = xc[ni];\r\n\r\n              // Get the number of digits of n.\r\n              for (d = 1; k >= 10; k /= 10, d++);\r\n\r\n              // Get the index of rd within n.\r\n              i %= LOG_BASE;\r\n\r\n              // Get the index of rd within n, adjusted for leading zeros.\r\n              // The number of leading zeros of n is given by LOG_BASE - d.\r\n              j = i - LOG_BASE + d;\r\n\r\n              // Get the rounding digit at index j of n.\r\n              rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);\r\n            }\r\n          }\r\n\r\n          r = r || sd < 0 ||\r\n\r\n          // Are there any non-zero digits after the rounding digit?\r\n          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right\r\n          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.\r\n           xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);\r\n\r\n          r = rm < 4\r\n           ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n           : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&\r\n\r\n            // Check whether the digit to the left of the rounding digit is odd.\r\n            ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||\r\n             rm == (x.s < 0 ? 8 : 7));\r\n\r\n          if (sd < 1 || !xc[0]) {\r\n            xc.length = 0;\r\n\r\n            if (r) {\r\n\r\n              // Convert sd to decimal places.\r\n              sd -= x.e + 1;\r\n\r\n              // 1, 0.1, 0.01, 0.001, 0.0001 etc.\r\n              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];\r\n              x.e = -sd || 0;\r\n            } else {\r\n\r\n              // Zero.\r\n              xc[0] = x.e = 0;\r\n            }\r\n\r\n            return x;\r\n          }\r\n\r\n          // Remove excess digits.\r\n          if (i == 0) {\r\n            xc.length = ni;\r\n            k = 1;\r\n            ni--;\r\n          } else {\r\n            xc.length = ni + 1;\r\n            k = pows10[LOG_BASE - i];\r\n\r\n            // E.g. 56700 becomes 56000 if 7 is the rounding digit.\r\n            // j > 0 means i > number of leading zeros of n.\r\n            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;\r\n          }\r\n\r\n          // Round up?\r\n          if (r) {\r\n\r\n            for (; ;) {\r\n\r\n              // If the digit to be rounded up is in the first element of xc...\r\n              if (ni == 0) {\r\n\r\n                // i will be the length of xc[0] before k is added.\r\n                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);\r\n                j = xc[0] += k;\r\n                for (k = 1; j >= 10; j /= 10, k++);\r\n\r\n                // if i != k the length has increased.\r\n                if (i != k) {\r\n                  x.e++;\r\n                  if (xc[0] == BASE) xc[0] = 1;\r\n                }\r\n\r\n                break;\r\n              } else {\r\n                xc[ni] += k;\r\n                if (xc[ni] != BASE) break;\r\n                xc[ni--] = 0;\r\n                k = 1;\r\n              }\r\n            }\r\n          }\r\n\r\n          // Remove trailing zeros.\r\n          for (i = xc.length; xc[--i] === 0; xc.pop());\r\n        }\r\n\r\n        // Overflow? Infinity.\r\n        if (x.e > MAX_EXP) {\r\n          x.c = x.e = null;\r\n\r\n        // Underflow? Zero.\r\n        } else if (x.e < MIN_EXP) {\r\n          x.c = [x.e = 0];\r\n        }\r\n      }\r\n\r\n      return x;\r\n    }\r\n\r\n\r\n    function valueOf(n) {\r\n      var str,\r\n        e = n.e;\r\n\r\n      if (e === null) return n.toString();\r\n\r\n      str = coeffToString(n.c);\r\n\r\n      str = e <= TO_EXP_NEG || e >= TO_EXP_POS\r\n        ? toExponential(str, e)\r\n        : toFixedPoint(str, e, '0');\r\n\r\n      return n.s < 0 ? '-' + str : str;\r\n    }\r\n\r\n\r\n    // PROTOTYPE/INSTANCE METHODS\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the absolute value of this BigNumber.\r\n     */\r\n    P.absoluteValue = P.abs = function () {\r\n      var x = new BigNumber(this);\r\n      if (x.s < 0) x.s = 1;\r\n      return x;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return\r\n     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n     *   0 if they have the same value,\r\n     *   or null if the value of either is NaN.\r\n     */\r\n    P.comparedTo = function (y, b) {\r\n      return compare(this, new BigNumber(y, b));\r\n    };\r\n\r\n\r\n    /*\r\n     * If dp is undefined or null or true or false, return the number of decimal places of the\r\n     * value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.\r\n     *\r\n     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this\r\n     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or\r\n     * ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     */\r\n    P.decimalPlaces = P.dp = function (dp, rm) {\r\n      var c, n, v,\r\n        x = this;\r\n\r\n      if (dp != null) {\r\n        intCheck(dp, 0, MAX);\r\n        if (rm == null) rm = ROUNDING_MODE;\r\n        else intCheck(rm, 0, 8);\r\n\r\n        return round(new BigNumber(x), dp + x.e + 1, rm);\r\n      }\r\n\r\n      if (!(c = x.c)) return null;\r\n      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;\r\n\r\n      // Subtract the number of trailing zeros of the last number.\r\n      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);\r\n      if (n < 0) n = 0;\r\n\r\n      return n;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n / 0 = I\r\n     *  n / N = N\r\n     *  n / I = 0\r\n     *  0 / n = 0\r\n     *  0 / 0 = N\r\n     *  0 / N = N\r\n     *  0 / I = 0\r\n     *  N / n = N\r\n     *  N / 0 = N\r\n     *  N / N = N\r\n     *  N / I = N\r\n     *  I / n = I\r\n     *  I / 0 = I\r\n     *  I / N = N\r\n     *  I / I = N\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of\r\n     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n     */\r\n    P.dividedBy = P.div = function (y, b) {\r\n      return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the integer part of dividing the value of this\r\n     * BigNumber by the value of BigNumber(y, b).\r\n     */\r\n    P.dividedToIntegerBy = P.idiv = function (y, b) {\r\n      return div(this, new BigNumber(y, b), 0, 1);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.\r\n     *\r\n     * If m is present, return the result modulo m.\r\n     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.\r\n     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.\r\n     *\r\n     * The modular power operation works efficiently when x, n, and m are integers, otherwise it\r\n     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.\r\n     *\r\n     * n {number|string|BigNumber} The exponent. An integer.\r\n     * [m] {number|string|BigNumber} The modulus.\r\n     *\r\n     * '[BigNumber Error] Exponent not an integer: {n}'\r\n     */\r\n    P.exponentiatedBy = P.pow = function (n, m) {\r\n      var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,\r\n        x = this;\r\n\r\n      n = new BigNumber(n);\r\n\r\n      // Allow NaN and Infinity, but not other non-integers.\r\n      if (n.c && !n.isInteger()) {\r\n        throw Error\r\n          (bignumberError + 'Exponent not an integer: ' + valueOf(n));\r\n      }\r\n\r\n      if (m != null) m = new BigNumber(m);\r\n\r\n      // Exponent of MAX_SAFE_INTEGER is 15.\r\n      nIsBig = n.e > 14;\r\n\r\n      // If x is NaN, Infinity, 0 or 1, or n is Infinity, NaN or 0.\r\n      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {\r\n\r\n        // The sign of the result of pow when x is negative depends on the evenness of n.\r\n        // If +n overflows to Infinity, the evenness of n would be not be known.\r\n        y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));\r\n        return m ? y.mod(m) : y;\r\n      }\r\n\r\n      nIsNeg = n.s < 0;\r\n\r\n      if (m) {\r\n\r\n        // x % m returns NaN if abs(m) is zero, or m is NaN.\r\n        if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);\r\n\r\n        isModExp = !nIsNeg && x.isInteger() && m.isInteger();\r\n\r\n        if (isModExp) x = x.mod(m);\r\n\r\n      // Overflow to Infinity: >=2**1e10 or >=1.0000024**1e15.\r\n      // Underflow to 0: <=0.79**1e10 or <=0.9999975**1e15.\r\n      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0\r\n        // [1, 240000000]\r\n        ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7\r\n        // [80000000000000]  [99999750000000]\r\n        : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {\r\n\r\n        // If x is negative and n is odd, k = -0, else k = 0.\r\n        k = x.s < 0 && isOdd(n) ? -0 : 0;\r\n\r\n        // If x >= 1, k = Infinity.\r\n        if (x.e > -1) k = 1 / k;\r\n\r\n        // If n is negative return 0, else return Infinity.\r\n        return new BigNumber(nIsNeg ? 1 / k : k);\r\n\r\n      } else if (POW_PRECISION) {\r\n\r\n        // Truncating each coefficient array to a length of k after each multiplication\r\n        // equates to truncating significant digits to POW_PRECISION + [28, 41],\r\n        // i.e. there will be a minimum of 28 guard digits retained.\r\n        k = mathceil(POW_PRECISION / LOG_BASE + 2);\r\n      }\r\n\r\n      if (nIsBig) {\r\n        half = new BigNumber(0.5);\r\n        if (nIsNeg) n.s = 1;\r\n        nIsOdd = isOdd(n);\r\n      } else {\r\n        i = Math.abs(+valueOf(n));\r\n        nIsOdd = i % 2;\r\n      }\r\n\r\n      y = new BigNumber(ONE);\r\n\r\n      // Performs 54 loop iterations for n of 9007199254740991.\r\n      for (; ;) {\r\n\r\n        if (nIsOdd) {\r\n          y = y.times(x);\r\n          if (!y.c) break;\r\n\r\n          if (k) {\r\n            if (y.c.length > k) y.c.length = k;\r\n          } else if (isModExp) {\r\n            y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));\r\n          }\r\n        }\r\n\r\n        if (i) {\r\n          i = mathfloor(i / 2);\r\n          if (i === 0) break;\r\n          nIsOdd = i % 2;\r\n        } else {\r\n          n = n.times(half);\r\n          round(n, n.e + 1, 1);\r\n\r\n          if (n.e > 14) {\r\n            nIsOdd = isOdd(n);\r\n          } else {\r\n            i = +valueOf(n);\r\n            if (i === 0) break;\r\n            nIsOdd = i % 2;\r\n          }\r\n        }\r\n\r\n        x = x.times(x);\r\n\r\n        if (k) {\r\n          if (x.c && x.c.length > k) x.c.length = k;\r\n        } else if (isModExp) {\r\n          x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));\r\n        }\r\n      }\r\n\r\n      if (isModExp) return y;\r\n      if (nIsNeg) y = ONE.div(y);\r\n\r\n      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer\r\n     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'\r\n     */\r\n    P.integerValue = function (rm) {\r\n      var n = new BigNumber(this);\r\n      if (rm == null) rm = ROUNDING_MODE;\r\n      else intCheck(rm, 0, 8);\r\n      return round(n, n.e + 1, rm);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),\r\n     * otherwise return false.\r\n     */\r\n    P.isEqualTo = P.eq = function (y, b) {\r\n      return compare(this, new BigNumber(y, b)) === 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is a finite number, otherwise return false.\r\n     */\r\n    P.isFinite = function () {\r\n      return !!this.c;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n     * otherwise return false.\r\n     */\r\n    P.isGreaterThan = P.gt = function (y, b) {\r\n      return compare(this, new BigNumber(y, b)) > 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is greater than or equal to the value of\r\n     * BigNumber(y, b), otherwise return false.\r\n     */\r\n    P.isGreaterThanOrEqualTo = P.gte = function (y, b) {\r\n      return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;\r\n\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is an integer, otherwise return false.\r\n     */\r\n    P.isInteger = function () {\r\n      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n     * otherwise return false.\r\n     */\r\n    P.isLessThan = P.lt = function (y, b) {\r\n      return compare(this, new BigNumber(y, b)) < 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is less than or equal to the value of\r\n     * BigNumber(y, b), otherwise return false.\r\n     */\r\n    P.isLessThanOrEqualTo = P.lte = function (y, b) {\r\n      return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is NaN, otherwise return false.\r\n     */\r\n    P.isNaN = function () {\r\n      return !this.s;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is negative, otherwise return false.\r\n     */\r\n    P.isNegative = function () {\r\n      return this.s < 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is positive, otherwise return false.\r\n     */\r\n    P.isPositive = function () {\r\n      return this.s > 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.\r\n     */\r\n    P.isZero = function () {\r\n      return !!this.c && this.c[0] == 0;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n - 0 = n\r\n     *  n - N = N\r\n     *  n - I = -I\r\n     *  0 - n = -n\r\n     *  0 - 0 = 0\r\n     *  0 - N = N\r\n     *  0 - I = -I\r\n     *  N - n = N\r\n     *  N - 0 = N\r\n     *  N - N = N\r\n     *  N - I = N\r\n     *  I - n = I\r\n     *  I - 0 = I\r\n     *  I - N = N\r\n     *  I - I = N\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber minus the value of\r\n     * BigNumber(y, b).\r\n     */\r\n    P.minus = function (y, b) {\r\n      var i, j, t, xLTy,\r\n        x = this,\r\n        a = x.s;\r\n\r\n      y = new BigNumber(y, b);\r\n      b = y.s;\r\n\r\n      // Either NaN?\r\n      if (!a || !b) return new BigNumber(NaN);\r\n\r\n      // Signs differ?\r\n      if (a != b) {\r\n        y.s = -b;\r\n        return x.plus(y);\r\n      }\r\n\r\n      var xe = x.e / LOG_BASE,\r\n        ye = y.e / LOG_BASE,\r\n        xc = x.c,\r\n        yc = y.c;\r\n\r\n      if (!xe || !ye) {\r\n\r\n        // Either Infinity?\r\n        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);\r\n\r\n        // Either zero?\r\n        if (!xc[0] || !yc[0]) {\r\n\r\n          // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\r\n          return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :\r\n\r\n           // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity\r\n           ROUNDING_MODE == 3 ? -0 : 0);\r\n        }\r\n      }\r\n\r\n      xe = bitFloor(xe);\r\n      ye = bitFloor(ye);\r\n      xc = xc.slice();\r\n\r\n      // Determine which is the bigger number.\r\n      if (a = xe - ye) {\r\n\r\n        if (xLTy = a < 0) {\r\n          a = -a;\r\n          t = xc;\r\n        } else {\r\n          ye = xe;\r\n          t = yc;\r\n        }\r\n\r\n        t.reverse();\r\n\r\n        // Prepend zeros to equalise exponents.\r\n        for (b = a; b--; t.push(0));\r\n        t.reverse();\r\n      } else {\r\n\r\n        // Exponents equal. Check digit by digit.\r\n        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;\r\n\r\n        for (a = b = 0; b < j; b++) {\r\n\r\n          if (xc[b] != yc[b]) {\r\n            xLTy = xc[b] < yc[b];\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      // x < y? Point xc to the array of the bigger number.\r\n      if (xLTy) {\r\n        t = xc;\r\n        xc = yc;\r\n        yc = t;\r\n        y.s = -y.s;\r\n      }\r\n\r\n      b = (j = yc.length) - (i = xc.length);\r\n\r\n      // Append zeros to xc if shorter.\r\n      // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.\r\n      if (b > 0) for (; b--; xc[i++] = 0);\r\n      b = BASE - 1;\r\n\r\n      // Subtract yc from xc.\r\n      for (; j > a;) {\r\n\r\n        if (xc[--j] < yc[j]) {\r\n          for (i = j; i && !xc[--i]; xc[i] = b);\r\n          --xc[i];\r\n          xc[j] += BASE;\r\n        }\r\n\r\n        xc[j] -= yc[j];\r\n      }\r\n\r\n      // Remove leading zeros and adjust exponent accordingly.\r\n      for (; xc[0] == 0; xc.splice(0, 1), --ye);\r\n\r\n      // Zero?\r\n      if (!xc[0]) {\r\n\r\n        // Following IEEE 754 (2008) 6.3,\r\n        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.\r\n        y.s = ROUNDING_MODE == 3 ? -1 : 1;\r\n        y.c = [y.e = 0];\r\n        return y;\r\n      }\r\n\r\n      // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity\r\n      // for finite x and y.\r\n      return normalise(y, xc, ye);\r\n    };\r\n\r\n\r\n    /*\r\n     *   n % 0 =  N\r\n     *   n % N =  N\r\n     *   n % I =  n\r\n     *   0 % n =  0\r\n     *  -0 % n = -0\r\n     *   0 % 0 =  N\r\n     *   0 % N =  N\r\n     *   0 % I =  0\r\n     *   N % n =  N\r\n     *   N % 0 =  N\r\n     *   N % N =  N\r\n     *   N % I =  N\r\n     *   I % n =  N\r\n     *   I % 0 =  N\r\n     *   I % N =  N\r\n     *   I % I =  N\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of\r\n     * BigNumber(y, b). The result depends on the value of MODULO_MODE.\r\n     */\r\n    P.modulo = P.mod = function (y, b) {\r\n      var q, s,\r\n        x = this;\r\n\r\n      y = new BigNumber(y, b);\r\n\r\n      // Return NaN if x is Infinity or NaN, or y is NaN or zero.\r\n      if (!x.c || !y.s || y.c && !y.c[0]) {\r\n        return new BigNumber(NaN);\r\n\r\n      // Return x if y is Infinity or x is zero.\r\n      } else if (!y.c || x.c && !x.c[0]) {\r\n        return new BigNumber(x);\r\n      }\r\n\r\n      if (MODULO_MODE == 9) {\r\n\r\n        // Euclidian division: q = sign(y) * floor(x / abs(y))\r\n        // r = x - qy    where  0 <= r < abs(y)\r\n        s = y.s;\r\n        y.s = 1;\r\n        q = div(x, y, 0, 3);\r\n        y.s = s;\r\n        q.s *= s;\r\n      } else {\r\n        q = div(x, y, 0, MODULO_MODE);\r\n      }\r\n\r\n      y = x.minus(q.times(y));\r\n\r\n      // To match JavaScript %, ensure sign of zero is sign of dividend.\r\n      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;\r\n\r\n      return y;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n * 0 = 0\r\n     *  n * N = N\r\n     *  n * I = I\r\n     *  0 * n = 0\r\n     *  0 * 0 = 0\r\n     *  0 * N = N\r\n     *  0 * I = N\r\n     *  N * n = N\r\n     *  N * 0 = N\r\n     *  N * N = N\r\n     *  N * I = N\r\n     *  I * n = I\r\n     *  I * 0 = N\r\n     *  I * N = N\r\n     *  I * I = I\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value\r\n     * of BigNumber(y, b).\r\n     */\r\n    P.multipliedBy = P.times = function (y, b) {\r\n      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,\r\n        base, sqrtBase,\r\n        x = this,\r\n        xc = x.c,\r\n        yc = (y = new BigNumber(y, b)).c;\r\n\r\n      // Either NaN, Infinity or 0?\r\n      if (!xc || !yc || !xc[0] || !yc[0]) {\r\n\r\n        // Return NaN if either is NaN, or one is 0 and the other is Infinity.\r\n        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {\r\n          y.c = y.e = y.s = null;\r\n        } else {\r\n          y.s *= x.s;\r\n\r\n          // Return Infinity if either is Infinity.\r\n          if (!xc || !yc) {\r\n            y.c = y.e = null;\r\n\r\n          // Return 0 if either is 0.\r\n          } else {\r\n            y.c = [0];\r\n            y.e = 0;\r\n          }\r\n        }\r\n\r\n        return y;\r\n      }\r\n\r\n      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);\r\n      y.s *= x.s;\r\n      xcL = xc.length;\r\n      ycL = yc.length;\r\n\r\n      // Ensure xc points to longer array and xcL to its length.\r\n      if (xcL < ycL) {\r\n        zc = xc;\r\n        xc = yc;\r\n        yc = zc;\r\n        i = xcL;\r\n        xcL = ycL;\r\n        ycL = i;\r\n      }\r\n\r\n      // Initialise the result array with zeros.\r\n      for (i = xcL + ycL, zc = []; i--; zc.push(0));\r\n\r\n      base = BASE;\r\n      sqrtBase = SQRT_BASE;\r\n\r\n      for (i = ycL; --i >= 0;) {\r\n        c = 0;\r\n        ylo = yc[i] % sqrtBase;\r\n        yhi = yc[i] / sqrtBase | 0;\r\n\r\n        for (k = xcL, j = i + k; j > i;) {\r\n          xlo = xc[--k] % sqrtBase;\r\n          xhi = xc[k] / sqrtBase | 0;\r\n          m = yhi * xlo + xhi * ylo;\r\n          xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;\r\n          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;\r\n          zc[j--] = xlo % base;\r\n        }\r\n\r\n        zc[j] = c;\r\n      }\r\n\r\n      if (c) {\r\n        ++e;\r\n      } else {\r\n        zc.splice(0, 1);\r\n      }\r\n\r\n      return normalise(y, zc, e);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the value of this BigNumber negated,\r\n     * i.e. multiplied by -1.\r\n     */\r\n    P.negated = function () {\r\n      var x = new BigNumber(this);\r\n      x.s = -x.s || null;\r\n      return x;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n + 0 = n\r\n     *  n + N = N\r\n     *  n + I = I\r\n     *  0 + n = n\r\n     *  0 + 0 = 0\r\n     *  0 + N = N\r\n     *  0 + I = I\r\n     *  N + n = N\r\n     *  N + 0 = N\r\n     *  N + N = N\r\n     *  N + I = N\r\n     *  I + n = I\r\n     *  I + 0 = I\r\n     *  I + N = N\r\n     *  I + I = I\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber plus the value of\r\n     * BigNumber(y, b).\r\n     */\r\n    P.plus = function (y, b) {\r\n      var t,\r\n        x = this,\r\n        a = x.s;\r\n\r\n      y = new BigNumber(y, b);\r\n      b = y.s;\r\n\r\n      // Either NaN?\r\n      if (!a || !b) return new BigNumber(NaN);\r\n\r\n      // Signs differ?\r\n       if (a != b) {\r\n        y.s = -b;\r\n        return x.minus(y);\r\n      }\r\n\r\n      var xe = x.e / LOG_BASE,\r\n        ye = y.e / LOG_BASE,\r\n        xc = x.c,\r\n        yc = y.c;\r\n\r\n      if (!xe || !ye) {\r\n\r\n        // Return Infinity if either Infinity.\r\n        if (!xc || !yc) return new BigNumber(a / 0);\r\n\r\n        // Either zero?\r\n        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\r\n        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);\r\n      }\r\n\r\n      xe = bitFloor(xe);\r\n      ye = bitFloor(ye);\r\n      xc = xc.slice();\r\n\r\n      // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.\r\n      if (a = xe - ye) {\r\n        if (a > 0) {\r\n          ye = xe;\r\n          t = yc;\r\n        } else {\r\n          a = -a;\r\n          t = xc;\r\n        }\r\n\r\n        t.reverse();\r\n        for (; a--; t.push(0));\r\n        t.reverse();\r\n      }\r\n\r\n      a = xc.length;\r\n      b = yc.length;\r\n\r\n      // Point xc to the longer array, and b to the shorter length.\r\n      if (a - b < 0) {\r\n        t = yc;\r\n        yc = xc;\r\n        xc = t;\r\n        b = a;\r\n      }\r\n\r\n      // Only start adding at yc.length - 1 as the further digits of xc can be ignored.\r\n      for (a = 0; b;) {\r\n        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;\r\n        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;\r\n      }\r\n\r\n      if (a) {\r\n        xc = [a].concat(xc);\r\n        ++ye;\r\n      }\r\n\r\n      // No need to check for zero, as +x + +y != 0 && -x + -y != 0\r\n      // ye = MAX_EXP + 1 possible\r\n      return normalise(y, xc, ye);\r\n    };\r\n\r\n\r\n    /*\r\n     * If sd is undefined or null or true or false, return the number of significant digits of\r\n     * the value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.\r\n     * If sd is true include integer-part trailing zeros in the count.\r\n     *\r\n     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this\r\n     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or\r\n     * ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.\r\n     *                     boolean: whether to count integer-part trailing zeros: true or false.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n     */\r\n    P.precision = P.sd = function (sd, rm) {\r\n      var c, n, v,\r\n        x = this;\r\n\r\n      if (sd != null && sd !== !!sd) {\r\n        intCheck(sd, 1, MAX);\r\n        if (rm == null) rm = ROUNDING_MODE;\r\n        else intCheck(rm, 0, 8);\r\n\r\n        return round(new BigNumber(x), sd, rm);\r\n      }\r\n\r\n      if (!(c = x.c)) return null;\r\n      v = c.length - 1;\r\n      n = v * LOG_BASE + 1;\r\n\r\n      if (v = c[v]) {\r\n\r\n        // Subtract the number of trailing zeros of the last element.\r\n        for (; v % 10 == 0; v /= 10, n--);\r\n\r\n        // Add the number of digits of the first element.\r\n        for (v = c[0]; v >= 10; v /= 10, n++);\r\n      }\r\n\r\n      if (sd && x.e + 1 > n) n = x.e + 1;\r\n\r\n      return n;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places\r\n     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.\r\n     *\r\n     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'\r\n     */\r\n    P.shiftedBy = function (k) {\r\n      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);\r\n      return this.times('1e' + k);\r\n    };\r\n\r\n\r\n    /*\r\n     *  sqrt(-n) =  N\r\n     *  sqrt(N) =  N\r\n     *  sqrt(-I) =  N\r\n     *  sqrt(I) =  I\r\n     *  sqrt(0) =  0\r\n     *  sqrt(-0) = -0\r\n     *\r\n     * Return a new BigNumber whose value is the square root of the value of this BigNumber,\r\n     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n     */\r\n    P.squareRoot = P.sqrt = function () {\r\n      var m, n, r, rep, t,\r\n        x = this,\r\n        c = x.c,\r\n        s = x.s,\r\n        e = x.e,\r\n        dp = DECIMAL_PLACES + 4,\r\n        half = new BigNumber('0.5');\r\n\r\n      // Negative/NaN/Infinity/zero?\r\n      if (s !== 1 || !c || !c[0]) {\r\n        return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);\r\n      }\r\n\r\n      // Initial estimate.\r\n      s = Math.sqrt(+valueOf(x));\r\n\r\n      // Math.sqrt underflow/overflow?\r\n      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\r\n      if (s == 0 || s == 1 / 0) {\r\n        n = coeffToString(c);\r\n        if ((n.length + e) % 2 == 0) n += '0';\r\n        s = Math.sqrt(+n);\r\n        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);\r\n\r\n        if (s == 1 / 0) {\r\n          n = '5e' + e;\r\n        } else {\r\n          n = s.toExponential();\r\n          n = n.slice(0, n.indexOf('e') + 1) + e;\r\n        }\r\n\r\n        r = new BigNumber(n);\r\n      } else {\r\n        r = new BigNumber(s + '');\r\n      }\r\n\r\n      // Check for zero.\r\n      // r could be zero if MIN_EXP is changed after the this value was created.\r\n      // This would cause a division by zero (x/t) and hence Infinity below, which would cause\r\n      // coeffToString to throw.\r\n      if (r.c[0]) {\r\n        e = r.e;\r\n        s = e + dp;\r\n        if (s < 3) s = 0;\r\n\r\n        // Newton-Raphson iteration.\r\n        for (; ;) {\r\n          t = r;\r\n          r = half.times(t.plus(div(x, t, dp, 1)));\r\n\r\n          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {\r\n\r\n            // The exponent of r may here be one less than the final result exponent,\r\n            // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits\r\n            // are indexed correctly.\r\n            if (r.e < e) --s;\r\n            n = n.slice(s - 3, s + 1);\r\n\r\n            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits\r\n            // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the\r\n            // iteration.\r\n            if (n == '9999' || !rep && n == '4999') {\r\n\r\n              // On the first iteration only, check to see if rounding up gives the\r\n              // exact result as the nines may infinitely repeat.\r\n              if (!rep) {\r\n                round(t, t.e + DECIMAL_PLACES + 2, 0);\r\n\r\n                if (t.times(t).eq(x)) {\r\n                  r = t;\r\n                  break;\r\n                }\r\n              }\r\n\r\n              dp += 4;\r\n              s += 4;\r\n              rep = 1;\r\n            } else {\r\n\r\n              // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact\r\n              // result. If not, then there are further digits and m will be truthy.\r\n              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n                // Truncate to the first rounding digit.\r\n                round(r, r.e + DECIMAL_PLACES + 2, 1);\r\n                m = !r.times(r).eq(x);\r\n              }\r\n\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in exponential notation and\r\n     * rounded using ROUNDING_MODE to dp fixed decimal places.\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     */\r\n    P.toExponential = function (dp, rm) {\r\n      if (dp != null) {\r\n        intCheck(dp, 0, MAX);\r\n        dp++;\r\n      }\r\n      return format(this, dp, rm, 1);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in fixed-point notation rounding\r\n     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',\r\n     * but e.g. (-0.00001).toFixed(0) is '-0'.\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     */\r\n    P.toFixed = function (dp, rm) {\r\n      if (dp != null) {\r\n        intCheck(dp, 0, MAX);\r\n        dp = dp + this.e + 1;\r\n      }\r\n      return format(this, dp, rm);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in fixed-point notation rounded\r\n     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties\r\n     * of the format or FORMAT object (see BigNumber.set).\r\n     *\r\n     * The formatting object may contain some or all of the properties shown below.\r\n     *\r\n     * FORMAT = {\r\n     *   prefix: '',\r\n     *   groupSize: 3,\r\n     *   secondaryGroupSize: 0,\r\n     *   groupSeparator: ',',\r\n     *   decimalSeparator: '.',\r\n     *   fractionGroupSize: 0,\r\n     *   fractionGroupSeparator: '\\xA0',      // non-breaking space\r\n     *   suffix: ''\r\n     * };\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     * [format] {object} Formatting options. See FORMAT pbject above.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     * '[BigNumber Error] Argument not an object: {format}'\r\n     */\r\n    P.toFormat = function (dp, rm, format) {\r\n      var str,\r\n        x = this;\r\n\r\n      if (format == null) {\r\n        if (dp != null && rm && typeof rm == 'object') {\r\n          format = rm;\r\n          rm = null;\r\n        } else if (dp && typeof dp == 'object') {\r\n          format = dp;\r\n          dp = rm = null;\r\n        } else {\r\n          format = FORMAT;\r\n        }\r\n      } else if (typeof format != 'object') {\r\n        throw Error\r\n          (bignumberError + 'Argument not an object: ' + format);\r\n      }\r\n\r\n      str = x.toFixed(dp, rm);\r\n\r\n      if (x.c) {\r\n        var i,\r\n          arr = str.split('.'),\r\n          g1 = +format.groupSize,\r\n          g2 = +format.secondaryGroupSize,\r\n          groupSeparator = format.groupSeparator || '',\r\n          intPart = arr[0],\r\n          fractionPart = arr[1],\r\n          isNeg = x.s < 0,\r\n          intDigits = isNeg ? intPart.slice(1) : intPart,\r\n          len = intDigits.length;\r\n\r\n        if (g2) {\r\n          i = g1;\r\n          g1 = g2;\r\n          g2 = i;\r\n          len -= i;\r\n        }\r\n\r\n        if (g1 > 0 && len > 0) {\r\n          i = len % g1 || g1;\r\n          intPart = intDigits.substr(0, i);\r\n          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);\r\n          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);\r\n          if (isNeg) intPart = '-' + intPart;\r\n        }\r\n\r\n        str = fractionPart\r\n         ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)\r\n          ? fractionPart.replace(new RegExp('\\\\d{' + g2 + '}\\\\B', 'g'),\r\n           '$&' + (format.fractionGroupSeparator || ''))\r\n          : fractionPart)\r\n         : intPart;\r\n      }\r\n\r\n      return (format.prefix || '') + str + (format.suffix || '');\r\n    };\r\n\r\n\r\n    /*\r\n     * Return an array of two BigNumbers representing the value of this BigNumber as a simple\r\n     * fraction with an integer numerator and an integer denominator.\r\n     * The denominator will be a positive non-zero value less than or equal to the specified\r\n     * maximum denominator. If a maximum denominator is not specified, the denominator will be\r\n     * the lowest value necessary to represent the number exactly.\r\n     *\r\n     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.\r\n     *\r\n     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'\r\n     */\r\n    P.toFraction = function (md) {\r\n      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,\r\n        x = this,\r\n        xc = x.c;\r\n\r\n      if (md != null) {\r\n        n = new BigNumber(md);\r\n\r\n        // Throw if md is less than one or is not an integer, unless it is Infinity.\r\n        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {\r\n          throw Error\r\n            (bignumberError + 'Argument ' +\r\n              (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));\r\n        }\r\n      }\r\n\r\n      if (!xc) return new BigNumber(x);\r\n\r\n      d = new BigNumber(ONE);\r\n      n1 = d0 = new BigNumber(ONE);\r\n      d1 = n0 = new BigNumber(ONE);\r\n      s = coeffToString(xc);\r\n\r\n      // Determine initial denominator.\r\n      // d is a power of 10 and the minimum max denominator that specifies the value exactly.\r\n      e = d.e = s.length - x.e - 1;\r\n      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];\r\n      md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;\r\n\r\n      exp = MAX_EXP;\r\n      MAX_EXP = 1 / 0;\r\n      n = new BigNumber(s);\r\n\r\n      // n0 = d1 = 0\r\n      n0.c[0] = 0;\r\n\r\n      for (; ;)  {\r\n        q = div(n, d, 0, 1);\r\n        d2 = d0.plus(q.times(d1));\r\n        if (d2.comparedTo(md) == 1) break;\r\n        d0 = d1;\r\n        d1 = d2;\r\n        n1 = n0.plus(q.times(d2 = n1));\r\n        n0 = d2;\r\n        d = n.minus(q.times(d2 = d));\r\n        n = d2;\r\n      }\r\n\r\n      d2 = div(md.minus(d0), d1, 0, 1);\r\n      n0 = n0.plus(d2.times(n1));\r\n      d0 = d0.plus(d2.times(d1));\r\n      n0.s = n1.s = x.s;\r\n      e = e * 2;\r\n\r\n      // Determine which fraction is closer to x, n0/d0 or n1/d1\r\n      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(\r\n          div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];\r\n\r\n      MAX_EXP = exp;\r\n\r\n      return r;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return the value of this BigNumber converted to a number primitive.\r\n     */\r\n    P.toNumber = function () {\r\n      return +valueOf(this);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber rounded to sd significant digits\r\n     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits\r\n     * necessary to represent the integer part of the value in fixed-point notation, then use\r\n     * exponential notation.\r\n     *\r\n     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n     */\r\n    P.toPrecision = function (sd, rm) {\r\n      if (sd != null) intCheck(sd, 1, MAX);\r\n      return format(this, sd, rm, 2);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in base b, or base 10 if b is\r\n     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and\r\n     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent\r\n     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than\r\n     * TO_EXP_NEG, return exponential notation.\r\n     *\r\n     * [b] {number} Integer, 2 to ALPHABET.length inclusive.\r\n     *\r\n     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n     */\r\n    P.toString = function (b) {\r\n      var str,\r\n        n = this,\r\n        s = n.s,\r\n        e = n.e;\r\n\r\n      // Infinity or NaN?\r\n      if (e === null) {\r\n        if (s) {\r\n          str = 'Infinity';\r\n          if (s < 0) str = '-' + str;\r\n        } else {\r\n          str = 'NaN';\r\n        }\r\n      } else {\r\n        if (b == null) {\r\n          str = e <= TO_EXP_NEG || e >= TO_EXP_POS\r\n           ? toExponential(coeffToString(n.c), e)\r\n           : toFixedPoint(coeffToString(n.c), e, '0');\r\n        } else if (b === 10 && alphabetHasNormalDecimalDigits) {\r\n          n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);\r\n          str = toFixedPoint(coeffToString(n.c), n.e, '0');\r\n        } else {\r\n          intCheck(b, 2, ALPHABET.length, 'Base');\r\n          str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);\r\n        }\r\n\r\n        if (s < 0 && n.c[0]) str = '-' + str;\r\n      }\r\n\r\n      return str;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return as toString, but do not accept a base argument, and include the minus sign for\r\n     * negative zero.\r\n     */\r\n    P.valueOf = P.toJSON = function () {\r\n      return valueOf(this);\r\n    };\r\n\r\n\r\n    P._isBigNumber = true;\r\n\r\n    if (configObject != null) BigNumber.set(configObject);\r\n\r\n    return BigNumber;\r\n  }\r\n\r\n\r\n  // PRIVATE HELPER FUNCTIONS\r\n\r\n  // These functions don't need access to variables,\r\n  // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.\r\n\r\n\r\n  function bitFloor(n) {\r\n    var i = n | 0;\r\n    return n > 0 || n === i ? i : i - 1;\r\n  }\r\n\r\n\r\n  // Return a coefficient array as a string of base 10 digits.\r\n  function coeffToString(a) {\r\n    var s, z,\r\n      i = 1,\r\n      j = a.length,\r\n      r = a[0] + '';\r\n\r\n    for (; i < j;) {\r\n      s = a[i++] + '';\r\n      z = LOG_BASE - s.length;\r\n      for (; z--; s = '0' + s);\r\n      r += s;\r\n    }\r\n\r\n    // Determine trailing zeros.\r\n    for (j = r.length; r.charCodeAt(--j) === 48;);\r\n\r\n    return r.slice(0, j + 1 || 1);\r\n  }\r\n\r\n\r\n  // Compare the value of BigNumbers x and y.\r\n  function compare(x, y) {\r\n    var a, b,\r\n      xc = x.c,\r\n      yc = y.c,\r\n      i = x.s,\r\n      j = y.s,\r\n      k = x.e,\r\n      l = y.e;\r\n\r\n    // Either NaN?\r\n    if (!i || !j) return null;\r\n\r\n    a = xc && !xc[0];\r\n    b = yc && !yc[0];\r\n\r\n    // Either zero?\r\n    if (a || b) return a ? b ? 0 : -j : i;\r\n\r\n    // Signs differ?\r\n    if (i != j) return i;\r\n\r\n    a = i < 0;\r\n    b = k == l;\r\n\r\n    // Either Infinity?\r\n    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;\r\n\r\n    // Compare exponents.\r\n    if (!b) return k > l ^ a ? 1 : -1;\r\n\r\n    j = (k = xc.length) < (l = yc.length) ? k : l;\r\n\r\n    // Compare digit by digit.\r\n    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;\r\n\r\n    // Compare lengths.\r\n    return k == l ? 0 : k > l ^ a ? 1 : -1;\r\n  }\r\n\r\n\r\n  /*\r\n   * Check that n is a primitive number, an integer, and in range, otherwise throw.\r\n   */\r\n  function intCheck(n, min, max, name) {\r\n    if (n < min || n > max || n !== mathfloor(n)) {\r\n      throw Error\r\n       (bignumberError + (name || 'Argument') + (typeof n == 'number'\r\n         ? n < min || n > max ? ' out of range: ' : ' not an integer: '\r\n         : ' not a primitive number: ') + String(n));\r\n    }\r\n  }\r\n\r\n\r\n  // Assumes finite n.\r\n  function isOdd(n) {\r\n    var k = n.c.length - 1;\r\n    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;\r\n  }\r\n\r\n\r\n  function toExponential(str, e) {\r\n    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +\r\n     (e < 0 ? 'e' : 'e+') + e;\r\n  }\r\n\r\n\r\n  function toFixedPoint(str, e, z) {\r\n    var len, zs;\r\n\r\n    // Negative exponent?\r\n    if (e < 0) {\r\n\r\n      // Prepend zeros.\r\n      for (zs = z + '.'; ++e; zs += z);\r\n      str = zs + str;\r\n\r\n    // Positive exponent\r\n    } else {\r\n      len = str.length;\r\n\r\n      // Append zeros.\r\n      if (++e > len) {\r\n        for (zs = z, e -= len; --e; zs += z);\r\n        str += zs;\r\n      } else if (e < len) {\r\n        str = str.slice(0, e) + '.' + str.slice(e);\r\n      }\r\n    }\r\n\r\n    return str;\r\n  }\r\n\r\n\r\n  // EXPORT\r\n\r\n\r\n  BigNumber = clone();\r\n  BigNumber['default'] = BigNumber.BigNumber = BigNumber;\r\n\r\n  // AMD.\r\n  if (true) {\r\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () { return BigNumber; }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\r\n  // Node.js and other environments that support module.exports.\r\n  } else {}\r\n})(this);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYmlnbnVtYmVyLmpzL2JpZ251bWJlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxtQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsdURBQXVEO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixvQkFBb0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsU0FBUztBQUN2QztBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixJQUFJO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFdBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFNBQVM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLEtBQUs7QUFDL0MsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixLQUFLO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7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QUFDViwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLG9DQUFvQyxtREFBbUQsR0FBRyxHQUFHO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixLQUFLO0FBQ3pCO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixLQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxLQUFLO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsTUFBTTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5QkFBeUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLEtBQUs7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUF5QztBQUMvQyxJQUFJLG1DQUFPLGNBQWMsbUJBQW1CO0FBQUEsa0dBQUM7QUFDN0M7QUFDQTtBQUNBLElBQUksS0FBSyxFQVVOO0FBQ0gsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL2JpZ251bWJlci5qcy9iaWdudW1iZXIuanM/MDUyNyJdLCJzb3VyY2VzQ29udGVudCI6WyI7KGZ1bmN0aW9uIChnbG9iYWxPYmplY3QpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4vKlxyXG4gKiAgICAgIGJpZ251bWJlci5qcyB2OS4xLjJcclxuICogICAgICBBIEphdmFTY3JpcHQgbGlicmFyeSBmb3IgYXJiaXRyYXJ5LXByZWNpc2lvbiBhcml0aG1ldGljLlxyXG4gKiAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2JpZ251bWJlci5qc1xyXG4gKiAgICAgIENvcHlyaWdodCAoYykgMjAyMiBNaWNoYWVsIE1jbGF1Z2hsaW4gPE04Y2g4OGxAZ21haWwuY29tPlxyXG4gKiAgICAgIE1JVCBMaWNlbnNlZC5cclxuICpcclxuICogICAgICBCaWdOdW1iZXIucHJvdG90eXBlIG1ldGhvZHMgICAgIHwgIEJpZ051bWJlciBtZXRob2RzXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgYWJzb2x1dGVWYWx1ZSAgICAgICAgICAgIGFicyAgICB8ICBjbG9uZVxyXG4gKiAgICAgIGNvbXBhcmVkVG8gICAgICAgICAgICAgICAgICAgICAgfCAgY29uZmlnICAgICAgICAgICAgICAgc2V0XHJcbiAqICAgICAgZGVjaW1hbFBsYWNlcyAgICAgICAgICAgIGRwICAgICB8ICAgICAgREVDSU1BTF9QTEFDRVNcclxuICogICAgICBkaXZpZGVkQnkgICAgICAgICAgICAgICAgZGl2ICAgIHwgICAgICBST1VORElOR19NT0RFXHJcbiAqICAgICAgZGl2aWRlZFRvSW50ZWdlckJ5ICAgICAgIGlkaXYgICB8ICAgICAgRVhQT05FTlRJQUxfQVRcclxuICogICAgICBleHBvbmVudGlhdGVkQnkgICAgICAgICAgcG93ICAgIHwgICAgICBSQU5HRVxyXG4gKiAgICAgIGludGVnZXJWYWx1ZSAgICAgICAgICAgICAgICAgICAgfCAgICAgIENSWVBUT1xyXG4gKiAgICAgIGlzRXF1YWxUbyAgICAgICAgICAgICAgICBlcSAgICAgfCAgICAgIE1PRFVMT19NT0RFXHJcbiAqICAgICAgaXNGaW5pdGUgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgUE9XX1BSRUNJU0lPTlxyXG4gKiAgICAgIGlzR3JlYXRlclRoYW4gICAgICAgICAgICBndCAgICAgfCAgICAgIEZPUk1BVFxyXG4gKiAgICAgIGlzR3JlYXRlclRoYW5PckVxdWFsVG8gICBndGUgICAgfCAgICAgIEFMUEhBQkVUXHJcbiAqICAgICAgaXNJbnRlZ2VyICAgICAgICAgICAgICAgICAgICAgICB8ICBpc0JpZ051bWJlclxyXG4gKiAgICAgIGlzTGVzc1RoYW4gICAgICAgICAgICAgICBsdCAgICAgfCAgbWF4aW11bSAgICAgICAgICAgICAgbWF4XHJcbiAqICAgICAgaXNMZXNzVGhhbk9yRXF1YWxUbyAgICAgIGx0ZSAgICB8ICBtaW5pbXVtICAgICAgICAgICAgICBtaW5cclxuICogICAgICBpc05hTiAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHJhbmRvbVxyXG4gKiAgICAgIGlzTmVnYXRpdmUgICAgICAgICAgICAgICAgICAgICAgfCAgc3VtXHJcbiAqICAgICAgaXNQb3NpdGl2ZSAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgaXNaZXJvICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgbWludXMgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgbW9kdWxvICAgICAgICAgICAgICAgICAgIG1vZCAgICB8XHJcbiAqICAgICAgbXVsdGlwbGllZEJ5ICAgICAgICAgICAgIHRpbWVzICB8XHJcbiAqICAgICAgbmVnYXRlZCAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgcGx1cyAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgcHJlY2lzaW9uICAgICAgICAgICAgICAgIHNkICAgICB8XHJcbiAqICAgICAgc2hpZnRlZEJ5ICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgc3F1YXJlUm9vdCAgICAgICAgICAgICAgIHNxcnQgICB8XHJcbiAqICAgICAgdG9FeHBvbmVudGlhbCAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9GaXhlZCAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9Gb3JtYXQgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9GcmFjdGlvbiAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9KU09OICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9OdW1iZXIgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9QcmVjaXNpb24gICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9TdHJpbmcgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdmFsdWVPZiAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqXHJcbiAqL1xyXG5cclxuXHJcbiAgdmFyIEJpZ051bWJlcixcclxuICAgIGlzTnVtZXJpYyA9IC9eLT8oPzpcXGQrKD86XFwuXFxkKik/fFxcLlxcZCspKD86ZVsrLV0/XFxkKyk/JC9pLFxyXG4gICAgbWF0aGNlaWwgPSBNYXRoLmNlaWwsXHJcbiAgICBtYXRoZmxvb3IgPSBNYXRoLmZsb29yLFxyXG5cclxuICAgIGJpZ251bWJlckVycm9yID0gJ1tCaWdOdW1iZXIgRXJyb3JdICcsXHJcbiAgICB0b29NYW55RGlnaXRzID0gYmlnbnVtYmVyRXJyb3IgKyAnTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czogJyxcclxuXHJcbiAgICBCQVNFID0gMWUxNCxcclxuICAgIExPR19CQVNFID0gMTQsXHJcbiAgICBNQVhfU0FGRV9JTlRFR0VSID0gMHgxZmZmZmZmZmZmZmZmZiwgICAgICAgICAvLyAyXjUzIC0gMVxyXG4gICAgLy8gTUFYX0lOVDMyID0gMHg3ZmZmZmZmZiwgICAgICAgICAgICAgICAgICAgLy8gMl4zMSAtIDFcclxuICAgIFBPV1NfVEVOID0gWzEsIDEwLCAxMDAsIDFlMywgMWU0LCAxZTUsIDFlNiwgMWU3LCAxZTgsIDFlOSwgMWUxMCwgMWUxMSwgMWUxMiwgMWUxM10sXHJcbiAgICBTUVJUX0JBU0UgPSAxZTcsXHJcblxyXG4gICAgLy8gRURJVEFCTEVcclxuICAgIC8vIFRoZSBsaW1pdCBvbiB0aGUgdmFsdWUgb2YgREVDSU1BTF9QTEFDRVMsIFRPX0VYUF9ORUcsIFRPX0VYUF9QT1MsIE1JTl9FWFAsIE1BWF9FWFAsIGFuZFxyXG4gICAgLy8gdGhlIGFyZ3VtZW50cyB0byB0b0V4cG9uZW50aWFsLCB0b0ZpeGVkLCB0b0Zvcm1hdCwgYW5kIHRvUHJlY2lzaW9uLlxyXG4gICAgTUFYID0gMUU5OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhfSU5UMzJcclxuXHJcblxyXG4gIC8qXHJcbiAgICogQ3JlYXRlIGFuZCByZXR1cm4gYSBCaWdOdW1iZXIgY29uc3RydWN0b3IuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gY2xvbmUoY29uZmlnT2JqZWN0KSB7XHJcbiAgICB2YXIgZGl2LCBjb252ZXJ0QmFzZSwgcGFyc2VOdW1lcmljLFxyXG4gICAgICBQID0gQmlnTnVtYmVyLnByb3RvdHlwZSA9IHsgY29uc3RydWN0b3I6IEJpZ051bWJlciwgdG9TdHJpbmc6IG51bGwsIHZhbHVlT2Y6IG51bGwgfSxcclxuICAgICAgT05FID0gbmV3IEJpZ051bWJlcigxKSxcclxuXHJcblxyXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVESVRBQkxFIENPTkZJRyBERUZBVUxUUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWVzIGJlbG93IG11c3QgYmUgaW50ZWdlcnMgd2l0aGluIHRoZSBpbmNsdXNpdmUgcmFuZ2VzIHN0YXRlZC5cclxuICAgICAgLy8gVGhlIHZhbHVlcyBjYW4gYWxzbyBiZSBjaGFuZ2VkIGF0IHJ1bi10aW1lIHVzaW5nIEJpZ051bWJlci5zZXQuXHJcblxyXG4gICAgICAvLyBUaGUgbWF4aW11bSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIG9wZXJhdGlvbnMgaW52b2x2aW5nIGRpdmlzaW9uLlxyXG4gICAgICBERUNJTUFMX1BMQUNFUyA9IDIwLCAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgICAvLyBUaGUgcm91bmRpbmcgbW9kZSB1c2VkIHdoZW4gcm91bmRpbmcgdG8gdGhlIGFib3ZlIGRlY2ltYWwgcGxhY2VzLCBhbmQgd2hlbiB1c2luZ1xyXG4gICAgICAvLyB0b0V4cG9uZW50aWFsLCB0b0ZpeGVkLCB0b0Zvcm1hdCBhbmQgdG9QcmVjaXNpb24sIGFuZCByb3VuZCAoZGVmYXVsdCB2YWx1ZSkuXHJcbiAgICAgIC8vIFVQICAgICAgICAgMCBBd2F5IGZyb20gemVyby5cclxuICAgICAgLy8gRE9XTiAgICAgICAxIFRvd2FyZHMgemVyby5cclxuICAgICAgLy8gQ0VJTCAgICAgICAyIFRvd2FyZHMgK0luZmluaXR5LlxyXG4gICAgICAvLyBGTE9PUiAgICAgIDMgVG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgIC8vIEhBTEZfVVAgICAgNCBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdXAuXHJcbiAgICAgIC8vIEhBTEZfRE9XTiAgNSBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgZG93bi5cclxuICAgICAgLy8gSEFMRl9FVkVOICA2IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzIGV2ZW4gbmVpZ2hib3VyLlxyXG4gICAgICAvLyBIQUxGX0NFSUwgIDcgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgK0luZmluaXR5LlxyXG4gICAgICAvLyBIQUxGX0ZMT09SIDggVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgICBST1VORElOR19NT0RFID0gNCwgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOFxyXG5cclxuICAgICAgLy8gRVhQT05FTlRJQUxfQVQgOiBbVE9fRVhQX05FRyAsIFRPX0VYUF9QT1NdXHJcblxyXG4gICAgICAvLyBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGJlbmVhdGggd2hpY2ggdG9TdHJpbmcgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgLy8gTnVtYmVyIHR5cGU6IC03XHJcbiAgICAgIFRPX0VYUF9ORUcgPSAtNywgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byAtTUFYXHJcblxyXG4gICAgICAvLyBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGFib3ZlIHdoaWNoIHRvU3RyaW5nIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgIC8vIE51bWJlciB0eXBlOiAyMVxyXG4gICAgICBUT19FWFBfUE9TID0gMjEsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgICAvLyBSQU5HRSA6IFtNSU5fRVhQLCBNQVhfRVhQXVxyXG5cclxuICAgICAgLy8gVGhlIG1pbmltdW0gZXhwb25lbnQgdmFsdWUsIGJlbmVhdGggd2hpY2ggdW5kZXJmbG93IHRvIHplcm8gb2NjdXJzLlxyXG4gICAgICAvLyBOdW1iZXIgdHlwZTogLTMyNCAgKDVlLTMyNClcclxuICAgICAgTUlOX0VYUCA9IC0xZTcsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtMSB0byAtTUFYXHJcblxyXG4gICAgICAvLyBUaGUgbWF4aW11bSBleHBvbmVudCB2YWx1ZSwgYWJvdmUgd2hpY2ggb3ZlcmZsb3cgdG8gSW5maW5pdHkgb2NjdXJzLlxyXG4gICAgICAvLyBOdW1iZXIgdHlwZTogIDMwOCAgKDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4KVxyXG4gICAgICAvLyBGb3IgTUFYX0VYUCA+IDFlNywgZS5nLiBuZXcgQmlnTnVtYmVyKCcxZTEwMDAwMDAwMCcpLnBsdXMoMSkgbWF5IGJlIHNsb3cuXHJcbiAgICAgIE1BWF9FWFAgPSAxZTcsICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMSB0byBNQVhcclxuXHJcbiAgICAgIC8vIFdoZXRoZXIgdG8gdXNlIGNyeXB0b2dyYXBoaWNhbGx5LXNlY3VyZSByYW5kb20gbnVtYmVyIGdlbmVyYXRpb24sIGlmIGF2YWlsYWJsZS5cclxuICAgICAgQ1JZUFRPID0gZmFsc2UsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnVlIG9yIGZhbHNlXHJcblxyXG4gICAgICAvLyBUaGUgbW9kdWxvIG1vZGUgdXNlZCB3aGVuIGNhbGN1bGF0aW5nIHRoZSBtb2R1bHVzOiBhIG1vZCBuLlxyXG4gICAgICAvLyBUaGUgcXVvdGllbnQgKHEgPSBhIC8gbikgaXMgY2FsY3VsYXRlZCBhY2NvcmRpbmcgdG8gdGhlIGNvcnJlc3BvbmRpbmcgcm91bmRpbmcgbW9kZS5cclxuICAgICAgLy8gVGhlIHJlbWFpbmRlciAocikgaXMgY2FsY3VsYXRlZCBhczogciA9IGEgLSBuICogcS5cclxuICAgICAgLy9cclxuICAgICAgLy8gVVAgICAgICAgIDAgVGhlIHJlbWFpbmRlciBpcyBwb3NpdGl2ZSBpZiB0aGUgZGl2aWRlbmQgaXMgbmVnYXRpdmUsIGVsc2UgaXMgbmVnYXRpdmUuXHJcbiAgICAgIC8vIERPV04gICAgICAxIFRoZSByZW1haW5kZXIgaGFzIHRoZSBzYW1lIHNpZ24gYXMgdGhlIGRpdmlkZW5kLlxyXG4gICAgICAvLyAgICAgICAgICAgICBUaGlzIG1vZHVsbyBtb2RlIGlzIGNvbW1vbmx5IGtub3duIGFzICd0cnVuY2F0ZWQgZGl2aXNpb24nIGFuZCBpc1xyXG4gICAgICAvLyAgICAgICAgICAgICBlcXVpdmFsZW50IHRvIChhICUgbikgaW4gSmF2YVNjcmlwdC5cclxuICAgICAgLy8gRkxPT1IgICAgIDMgVGhlIHJlbWFpbmRlciBoYXMgdGhlIHNhbWUgc2lnbiBhcyB0aGUgZGl2aXNvciAoUHl0aG9uICUpLlxyXG4gICAgICAvLyBIQUxGX0VWRU4gNiBUaGlzIG1vZHVsbyBtb2RlIGltcGxlbWVudHMgdGhlIElFRUUgNzU0IHJlbWFpbmRlciBmdW5jdGlvbi5cclxuICAgICAgLy8gRVVDTElEICAgIDkgRXVjbGlkaWFuIGRpdmlzaW9uLiBxID0gc2lnbihuKSAqIGZsb29yKGEgLyBhYnMobikpLlxyXG4gICAgICAvLyAgICAgICAgICAgICBUaGUgcmVtYWluZGVyIGlzIGFsd2F5cyBwb3NpdGl2ZS5cclxuICAgICAgLy9cclxuICAgICAgLy8gVGhlIHRydW5jYXRlZCBkaXZpc2lvbiwgZmxvb3JlZCBkaXZpc2lvbiwgRXVjbGlkaWFuIGRpdmlzaW9uIGFuZCBJRUVFIDc1NCByZW1haW5kZXJcclxuICAgICAgLy8gbW9kZXMgYXJlIGNvbW1vbmx5IHVzZWQgZm9yIHRoZSBtb2R1bHVzIG9wZXJhdGlvbi5cclxuICAgICAgLy8gQWx0aG91Z2ggdGhlIG90aGVyIHJvdW5kaW5nIG1vZGVzIGNhbiBhbHNvIGJlIHVzZWQsIHRoZXkgbWF5IG5vdCBnaXZlIHVzZWZ1bCByZXN1bHRzLlxyXG4gICAgICBNT0RVTE9fTU9ERSA9IDEsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOVxyXG5cclxuICAgICAgLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBvZiB0aGUgcmVzdWx0IG9mIHRoZSBleHBvbmVudGlhdGVkQnkgb3BlcmF0aW9uLlxyXG4gICAgICAvLyBJZiBQT1dfUFJFQ0lTSU9OIGlzIDAsIHRoZXJlIHdpbGwgYmUgdW5saW1pdGVkIHNpZ25pZmljYW50IGRpZ2l0cy5cclxuICAgICAgUE9XX1BSRUNJU0lPTiA9IDAsICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWFxyXG5cclxuICAgICAgLy8gVGhlIGZvcm1hdCBzcGVjaWZpY2F0aW9uIHVzZWQgYnkgdGhlIEJpZ051bWJlci5wcm90b3R5cGUudG9Gb3JtYXQgbWV0aG9kLlxyXG4gICAgICBGT1JNQVQgPSB7XHJcbiAgICAgICAgcHJlZml4OiAnJyxcclxuICAgICAgICBncm91cFNpemU6IDMsXHJcbiAgICAgICAgc2Vjb25kYXJ5R3JvdXBTaXplOiAwLFxyXG4gICAgICAgIGdyb3VwU2VwYXJhdG9yOiAnLCcsXHJcbiAgICAgICAgZGVjaW1hbFNlcGFyYXRvcjogJy4nLFxyXG4gICAgICAgIGZyYWN0aW9uR3JvdXBTaXplOiAwLFxyXG4gICAgICAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3I6ICdcXHhBMCcsICAgICAgICAvLyBub24tYnJlYWtpbmcgc3BhY2VcclxuICAgICAgICBzdWZmaXg6ICcnXHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvLyBUaGUgYWxwaGFiZXQgdXNlZCBmb3IgYmFzZSBjb252ZXJzaW9uLiBJdCBtdXN0IGJlIGF0IGxlYXN0IDIgY2hhcmFjdGVycyBsb25nLCB3aXRoIG5vICcrJyxcclxuICAgICAgLy8gJy0nLCAnLicsIHdoaXRlc3BhY2UsIG9yIHJlcGVhdGVkIGNoYXJhY3Rlci5cclxuICAgICAgLy8gJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJF8nXHJcbiAgICAgIEFMUEhBQkVUID0gJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eicsXHJcbiAgICAgIGFscGhhYmV0SGFzTm9ybWFsRGVjaW1hbERpZ2l0cyA9IHRydWU7XHJcblxyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuICAgIC8vIENPTlNUUlVDVE9SXHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBUaGUgQmlnTnVtYmVyIGNvbnN0cnVjdG9yIGFuZCBleHBvcnRlZCBmdW5jdGlvbi5cclxuICAgICAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IGluc3RhbmNlIG9mIGEgQmlnTnVtYmVyIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiB2IHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gQSBudW1lcmljIHZhbHVlLlxyXG4gICAgICogW2JdIHtudW1iZXJ9IFRoZSBiYXNlIG9mIHYuIEludGVnZXIsIDIgdG8gQUxQSEFCRVQubGVuZ3RoIGluY2x1c2l2ZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQmlnTnVtYmVyKHYsIGIpIHtcclxuICAgICAgdmFyIGFscGhhYmV0LCBjLCBjYXNlQ2hhbmdlZCwgZSwgaSwgaXNOdW0sIGxlbiwgc3RyLFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgLy8gRW5hYmxlIGNvbnN0cnVjdG9yIGNhbGwgd2l0aG91dCBgbmV3YC5cclxuICAgICAgaWYgKCEoeCBpbnN0YW5jZW9mIEJpZ051bWJlcikpIHJldHVybiBuZXcgQmlnTnVtYmVyKHYsIGIpO1xyXG5cclxuICAgICAgaWYgKGIgPT0gbnVsbCkge1xyXG5cclxuICAgICAgICBpZiAodiAmJiB2Ll9pc0JpZ051bWJlciA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgeC5zID0gdi5zO1xyXG5cclxuICAgICAgICAgIGlmICghdi5jIHx8IHYuZSA+IE1BWF9FWFApIHtcclxuICAgICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgICAgICAgIH0gZWxzZSBpZiAodi5lIDwgTUlOX0VYUCkge1xyXG4gICAgICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB4LmUgPSB2LmU7XHJcbiAgICAgICAgICAgIHguYyA9IHYuYy5zbGljZSgpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICgoaXNOdW0gPSB0eXBlb2YgdiA9PSAnbnVtYmVyJykgJiYgdiAqIDAgPT0gMCkge1xyXG5cclxuICAgICAgICAgIC8vIFVzZSBgMSAvIG5gIHRvIGhhbmRsZSBtaW51cyB6ZXJvIGFsc28uXHJcbiAgICAgICAgICB4LnMgPSAxIC8gdiA8IDAgPyAodiA9IC12LCAtMSkgOiAxO1xyXG5cclxuICAgICAgICAgIC8vIEZhc3QgcGF0aCBmb3IgaW50ZWdlcnMsIHdoZXJlIG4gPCAyMTQ3NDgzNjQ4ICgyKiozMSkuXHJcbiAgICAgICAgICBpZiAodiA9PT0gfn52KSB7XHJcbiAgICAgICAgICAgIGZvciAoZSA9IDAsIGkgPSB2OyBpID49IDEwOyBpIC89IDEwLCBlKyspO1xyXG5cclxuICAgICAgICAgICAgaWYgKGUgPiBNQVhfRVhQKSB7XHJcbiAgICAgICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB4LmUgPSBlO1xyXG4gICAgICAgICAgICAgIHguYyA9IFt2XTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHN0ciA9IFN0cmluZyh2KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIGlmICghaXNOdW1lcmljLnRlc3Qoc3RyID0gU3RyaW5nKHYpKSkgcmV0dXJuIHBhcnNlTnVtZXJpYyh4LCBzdHIsIGlzTnVtKTtcclxuXHJcbiAgICAgICAgICB4LnMgPSBzdHIuY2hhckNvZGVBdCgwKSA9PSA0NSA/IChzdHIgPSBzdHIuc2xpY2UoMSksIC0xKSA6IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEZWNpbWFsIHBvaW50P1xyXG4gICAgICAgIGlmICgoZSA9IHN0ci5pbmRleE9mKCcuJykpID4gLTEpIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG5cclxuICAgICAgICAvLyBFeHBvbmVudGlhbCBmb3JtP1xyXG4gICAgICAgIGlmICgoaSA9IHN0ci5zZWFyY2goL2UvaSkpID4gMCkge1xyXG5cclxuICAgICAgICAgIC8vIERldGVybWluZSBleHBvbmVudC5cclxuICAgICAgICAgIGlmIChlIDwgMCkgZSA9IGk7XHJcbiAgICAgICAgICBlICs9ICtzdHIuc2xpY2UoaSArIDEpO1xyXG4gICAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBpKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGUgPCAwKSB7XHJcblxyXG4gICAgICAgICAgLy8gSW50ZWdlci5cclxuICAgICAgICAgIGUgPSBzdHIubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBCYXNlIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtifSdcclxuICAgICAgICBpbnRDaGVjayhiLCAyLCBBTFBIQUJFVC5sZW5ndGgsICdCYXNlJyk7XHJcblxyXG4gICAgICAgIC8vIEFsbG93IGV4cG9uZW50aWFsIG5vdGF0aW9uIHRvIGJlIHVzZWQgd2l0aCBiYXNlIDEwIGFyZ3VtZW50LCB3aGlsZVxyXG4gICAgICAgIC8vIGFsc28gcm91bmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYXMgd2l0aCBvdGhlciBiYXNlcy5cclxuICAgICAgICBpZiAoYiA9PSAxMCAmJiBhbHBoYWJldEhhc05vcm1hbERlY2ltYWxEaWdpdHMpIHtcclxuICAgICAgICAgIHggPSBuZXcgQmlnTnVtYmVyKHYpO1xyXG4gICAgICAgICAgcmV0dXJuIHJvdW5kKHgsIERFQ0lNQUxfUExBQ0VTICsgeC5lICsgMSwgUk9VTkRJTkdfTU9ERSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdHIgPSBTdHJpbmcodik7XHJcblxyXG4gICAgICAgIGlmIChpc051bSA9IHR5cGVvZiB2ID09ICdudW1iZXInKSB7XHJcblxyXG4gICAgICAgICAgLy8gQXZvaWQgcG90ZW50aWFsIGludGVycHJldGF0aW9uIG9mIEluZmluaXR5IGFuZCBOYU4gYXMgYmFzZSA0NCsgdmFsdWVzLlxyXG4gICAgICAgICAgaWYgKHYgKiAwICE9IDApIHJldHVybiBwYXJzZU51bWVyaWMoeCwgc3RyLCBpc051bSwgYik7XHJcblxyXG4gICAgICAgICAgeC5zID0gMSAvIHYgPCAwID8gKHN0ciA9IHN0ci5zbGljZSgxKSwgLTEpIDogMTtcclxuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czoge259J1xyXG4gICAgICAgICAgaWYgKEJpZ051bWJlci5ERUJVRyAmJiBzdHIucmVwbGFjZSgvXjBcXC4wKnxcXC4vLCAnJykubGVuZ3RoID4gMTUpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICh0b29NYW55RGlnaXRzICsgdik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHgucyA9IHN0ci5jaGFyQ29kZUF0KDApID09PSA0NSA/IChzdHIgPSBzdHIuc2xpY2UoMSksIC0xKSA6IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhbHBoYWJldCA9IEFMUEhBQkVULnNsaWNlKDAsIGIpO1xyXG4gICAgICAgIGUgPSBpID0gMDtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCBzdHIgaXMgYSB2YWxpZCBiYXNlIGIgbnVtYmVyLlxyXG4gICAgICAgIC8vIERvbid0IHVzZSBSZWdFeHAsIHNvIGFscGhhYmV0IGNhbiBjb250YWluIHNwZWNpYWwgY2hhcmFjdGVycy5cclxuICAgICAgICBmb3IgKGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgaWYgKGFscGhhYmV0LmluZGV4T2YoYyA9IHN0ci5jaGFyQXQoaSkpIDwgMCkge1xyXG4gICAgICAgICAgICBpZiAoYyA9PSAnLicpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gSWYgJy4nIGlzIG5vdCB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCBpdCBoYXMgbm90IGJlIGZvdW5kIGJlZm9yZS5cclxuICAgICAgICAgICAgICBpZiAoaSA+IGUpIHtcclxuICAgICAgICAgICAgICAgIGUgPSBsZW47XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWNhc2VDaGFuZ2VkKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEFsbG93IGUuZy4gaGV4YWRlY2ltYWwgJ0ZGJyBhcyB3ZWxsIGFzICdmZicuXHJcbiAgICAgICAgICAgICAgaWYgKHN0ciA9PSBzdHIudG9VcHBlckNhc2UoKSAmJiAoc3RyID0gc3RyLnRvTG93ZXJDYXNlKCkpIHx8XHJcbiAgICAgICAgICAgICAgICAgIHN0ciA9PSBzdHIudG9Mb3dlckNhc2UoKSAmJiAoc3RyID0gc3RyLnRvVXBwZXJDYXNlKCkpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpID0gLTE7XHJcbiAgICAgICAgICAgICAgICBlID0gMDtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpYyh4LCBTdHJpbmcodiksIGlzTnVtLCBiKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFByZXZlbnQgbGF0ZXIgY2hlY2sgZm9yIGxlbmd0aCBvbiBjb252ZXJ0ZWQgbnVtYmVyLlxyXG4gICAgICAgIGlzTnVtID0gZmFsc2U7XHJcbiAgICAgICAgc3RyID0gY29udmVydEJhc2Uoc3RyLCBiLCAxMCwgeC5zKTtcclxuXHJcbiAgICAgICAgLy8gRGVjaW1hbCBwb2ludD9cclxuICAgICAgICBpZiAoKGUgPSBzdHIuaW5kZXhPZignLicpKSA+IC0xKSBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuICAgICAgICBlbHNlIGUgPSBzdHIubGVuZ3RoO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgZm9yIChpID0gMDsgc3RyLmNoYXJDb2RlQXQoaSkgPT09IDQ4OyBpKyspO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKGxlbiA9IHN0ci5sZW5ndGg7IHN0ci5jaGFyQ29kZUF0KC0tbGVuKSA9PT0gNDg7KTtcclxuXHJcbiAgICAgIGlmIChzdHIgPSBzdHIuc2xpY2UoaSwgKytsZW4pKSB7XHJcbiAgICAgICAgbGVuIC09IGk7XHJcblxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOdW1iZXIgcHJpbWl0aXZlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiB7bn0nXHJcbiAgICAgICAgaWYgKGlzTnVtICYmIEJpZ051bWJlci5ERUJVRyAmJlxyXG4gICAgICAgICAgbGVuID4gMTUgJiYgKHYgPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHYgIT09IG1hdGhmbG9vcih2KSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICh0b29NYW55RGlnaXRzICsgKHgucyAqIHYpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICAvLyBPdmVyZmxvdz9cclxuICAgICAgICBpZiAoKGUgPSBlIC0gaSAtIDEpID4gTUFYX0VYUCkge1xyXG5cclxuICAgICAgICAgIC8vIEluZmluaXR5LlxyXG4gICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gVW5kZXJmbG93P1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZSA8IE1JTl9FWFApIHtcclxuXHJcbiAgICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4LmUgPSBlO1xyXG4gICAgICAgICAgeC5jID0gW107XHJcblxyXG4gICAgICAgICAgLy8gVHJhbnNmb3JtIGJhc2VcclxuXHJcbiAgICAgICAgICAvLyBlIGlzIHRoZSBiYXNlIDEwIGV4cG9uZW50LlxyXG4gICAgICAgICAgLy8gaSBpcyB3aGVyZSB0byBzbGljZSBzdHIgdG8gZ2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBjb2VmZmljaWVudCBhcnJheS5cclxuICAgICAgICAgIGkgPSAoZSArIDEpICUgTE9HX0JBU0U7XHJcbiAgICAgICAgICBpZiAoZSA8IDApIGkgKz0gTE9HX0JBU0U7ICAvLyBpIDwgMVxyXG5cclxuICAgICAgICAgIGlmIChpIDwgbGVuKSB7XHJcbiAgICAgICAgICAgIGlmIChpKSB4LmMucHVzaCgrc3RyLnNsaWNlKDAsIGkpKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAobGVuIC09IExPR19CQVNFOyBpIDwgbGVuOykge1xyXG4gICAgICAgICAgICAgIHguYy5wdXNoKCtzdHIuc2xpY2UoaSwgaSArPSBMT0dfQkFTRSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpID0gTE9HX0JBU0UgLSAoc3RyID0gc3RyLnNsaWNlKGkpKS5sZW5ndGg7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpIC09IGxlbjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmb3IgKDsgaS0tOyBzdHIgKz0gJzAnKTtcclxuICAgICAgICAgIHguYy5wdXNoKCtzdHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gWmVyby5cclxuICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gQ09OU1RSVUNUT1IgUFJPUEVSVElFU1xyXG5cclxuXHJcbiAgICBCaWdOdW1iZXIuY2xvbmUgPSBjbG9uZTtcclxuXHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfVVAgPSAwO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0RPV04gPSAxO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0NFSUwgPSAyO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0ZMT09SID0gMztcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX1VQID0gNDtcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0RPV04gPSA1O1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRVZFTiA9IDY7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9DRUlMID0gNztcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0ZMT09SID0gODtcclxuICAgIEJpZ051bWJlci5FVUNMSUQgPSA5O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogQ29uZmlndXJlIGluZnJlcXVlbnRseS1jaGFuZ2luZyBsaWJyYXJ5LXdpZGUgc2V0dGluZ3MuXHJcbiAgICAgKlxyXG4gICAgICogQWNjZXB0IGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgb3B0aW9uYWwgcHJvcGVydGllcyAoaWYgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgaXNcclxuICAgICAqIGEgbnVtYmVyLCBpdCBtdXN0IGJlIGFuIGludGVnZXIgd2l0aGluIHRoZSBpbmNsdXNpdmUgcmFuZ2Ugc3RhdGVkKTpcclxuICAgICAqXHJcbiAgICAgKiAgIERFQ0lNQUxfUExBQ0VTICAge251bWJlcn0gICAgICAgICAgIDAgdG8gTUFYXHJcbiAgICAgKiAgIFJPVU5ESU5HX01PREUgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gOFxyXG4gICAgICogICBFWFBPTkVOVElBTF9BVCAgIHtudW1iZXJ8bnVtYmVyW119ICAtTUFYIHRvIE1BWCAgb3IgIFstTUFYIHRvIDAsIDAgdG8gTUFYXVxyXG4gICAgICogICBSQU5HRSAgICAgICAgICAgIHtudW1iZXJ8bnVtYmVyW119ICAtTUFYIHRvIE1BWCAobm90IHplcm8pICBvciAgWy1NQVggdG8gLTEsIDEgdG8gTUFYXVxyXG4gICAgICogICBDUllQVE8gICAgICAgICAgIHtib29sZWFufSAgICAgICAgICB0cnVlIG9yIGZhbHNlXHJcbiAgICAgKiAgIE1PRFVMT19NT0RFICAgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gOVxyXG4gICAgICogICBQT1dfUFJFQ0lTSU9OICAgICAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIE1BWFxyXG4gICAgICogICBBTFBIQUJFVCAgICAgICAgIHtzdHJpbmd9ICAgICAgICAgICBBIHN0cmluZyBvZiB0d28gb3IgbW9yZSB1bmlxdWUgY2hhcmFjdGVycyB3aGljaCBkb2VzXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdCBjb250YWluICcuJy5cclxuICAgICAqICAgRk9STUFUICAgICAgICAgICB7b2JqZWN0fSAgICAgICAgICAgQW4gb2JqZWN0IHdpdGggc29tZSBvZiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XHJcbiAgICAgKiAgICAgcHJlZml4ICAgICAgICAgICAgICAgICB7c3RyaW5nfVxyXG4gICAgICogICAgIGdyb3VwU2l6ZSAgICAgICAgICAgICAge251bWJlcn1cclxuICAgICAqICAgICBzZWNvbmRhcnlHcm91cFNpemUgICAgIHtudW1iZXJ9XHJcbiAgICAgKiAgICAgZ3JvdXBTZXBhcmF0b3IgICAgICAgICB7c3RyaW5nfVxyXG4gICAgICogICAgIGRlY2ltYWxTZXBhcmF0b3IgICAgICAge3N0cmluZ31cclxuICAgICAqICAgICBmcmFjdGlvbkdyb3VwU2l6ZSAgICAgIHtudW1iZXJ9XHJcbiAgICAgKiAgICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvciB7c3RyaW5nfVxyXG4gICAgICogICAgIHN1ZmZpeCAgICAgICAgICAgICAgICAge3N0cmluZ31cclxuICAgICAqXHJcbiAgICAgKiAoVGhlIHZhbHVlcyBhc3NpZ25lZCB0byB0aGUgYWJvdmUgRk9STUFUIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3QgY2hlY2tlZCBmb3IgdmFsaWRpdHkuKVxyXG4gICAgICpcclxuICAgICAqIEUuZy5cclxuICAgICAqIEJpZ051bWJlci5jb25maWcoeyBERUNJTUFMX1BMQUNFUyA6IDIwLCBST1VORElOR19NT0RFIDogNCB9KVxyXG4gICAgICpcclxuICAgICAqIElnbm9yZSBwcm9wZXJ0aWVzL3BhcmFtZXRlcnMgc2V0IHRvIG51bGwgb3IgdW5kZWZpbmVkLCBleGNlcHQgZm9yIEFMUEhBQkVULlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhbiBvYmplY3Qgd2l0aCB0aGUgcHJvcGVydGllcyBjdXJyZW50IHZhbHVlcy5cclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLmNvbmZpZyA9IEJpZ051bWJlci5zZXQgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgIHZhciBwLCB2O1xyXG5cclxuICAgICAgaWYgKG9iaiAhPSBudWxsKSB7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqID09ICdvYmplY3QnKSB7XHJcblxyXG4gICAgICAgICAgLy8gREVDSU1BTF9QTEFDRVMge251bWJlcn0gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIERFQ0lNQUxfUExBQ0VTIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdERUNJTUFMX1BMQUNFUycpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIDAsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgIERFQ0lNQUxfUExBQ0VTID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBST1VORElOR19NT0RFIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gUk9VTkRJTkdfTU9ERSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnUk9VTkRJTkdfTU9ERScpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIDAsIDgsIHApO1xyXG4gICAgICAgICAgICBST1VORElOR19NT0RFID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBFWFBPTkVOVElBTF9BVCB7bnVtYmVyfG51bWJlcltdfVxyXG4gICAgICAgICAgLy8gSW50ZWdlciwgLU1BWCB0byBNQVggaW5jbHVzaXZlIG9yXHJcbiAgICAgICAgICAvLyBbaW50ZWdlciAtTUFYIHRvIDAgaW5jbHVzaXZlLCAwIHRvIE1BWCBpbmNsdXNpdmVdLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEVYUE9ORU5USUFMX0FUIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdFWFBPTkVOVElBTF9BVCcpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGlmICh2ICYmIHYucG9wKSB7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlswXSwgLU1BWCwgMCwgcCk7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlsxXSwgMCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgICBUT19FWFBfTkVHID0gdlswXTtcclxuICAgICAgICAgICAgICBUT19FWFBfUE9TID0gdlsxXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2LCAtTUFYLCBNQVgsIHApO1xyXG4gICAgICAgICAgICAgIFRPX0VYUF9ORUcgPSAtKFRPX0VYUF9QT1MgPSB2IDwgMCA/IC12IDogdik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSQU5HRSB7bnVtYmVyfG51bWJlcltdfSBOb24temVybyBpbnRlZ2VyLCAtTUFYIHRvIE1BWCBpbmNsdXNpdmUgb3JcclxuICAgICAgICAgIC8vIFtpbnRlZ2VyIC1NQVggdG8gLTEgaW5jbHVzaXZlLCBpbnRlZ2VyIDEgdG8gTUFYIGluY2x1c2l2ZV0uXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gUkFOR0Uge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfGNhbm5vdCBiZSB6ZXJvfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ1JBTkdFJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaWYgKHYgJiYgdi5wb3ApIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2WzBdLCAtTUFYLCAtMSwgcCk7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlsxXSwgMSwgTUFYLCBwKTtcclxuICAgICAgICAgICAgICBNSU5fRVhQID0gdlswXTtcclxuICAgICAgICAgICAgICBNQVhfRVhQID0gdlsxXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2LCAtTUFYLCBNQVgsIHApO1xyXG4gICAgICAgICAgICAgIGlmICh2KSB7XHJcbiAgICAgICAgICAgICAgICBNSU5fRVhQID0gLShNQVhfRVhQID0gdiA8IDAgPyAtdiA6IHYpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIGNhbm5vdCBiZSB6ZXJvOiAnICsgdik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQ1JZUFRPIHtib29sZWFufSB0cnVlIG9yIGZhbHNlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIENSWVBUTyBub3QgdHJ1ZSBvciBmYWxzZToge3Z9J1xyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIGNyeXB0byB1bmF2YWlsYWJsZSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdDUllQVE8nKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpZiAodiA9PT0gISF2KSB7XHJcbiAgICAgICAgICAgICAgaWYgKHYpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3J5cHRvICE9ICd1bmRlZmluZWQnICYmIGNyeXB0byAmJlxyXG4gICAgICAgICAgICAgICAgIChjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIHx8IGNyeXB0by5yYW5kb21CeXRlcykpIHtcclxuICAgICAgICAgICAgICAgICAgQ1JZUFRPID0gdjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIENSWVBUTyA9ICF2O1xyXG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ2NyeXB0byB1bmF2YWlsYWJsZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBDUllQVE8gPSB2O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBub3QgdHJ1ZSBvciBmYWxzZTogJyArIHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gTU9EVUxPX01PREUge251bWJlcn0gSW50ZWdlciwgMCB0byA5IGluY2x1c2l2ZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBNT0RVTE9fTU9ERSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnTU9EVUxPX01PREUnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAwLCA5LCBwKTtcclxuICAgICAgICAgICAgTU9EVUxPX01PREUgPSB2O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFBPV19QUkVDSVNJT04ge251bWJlcn0gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIFBPV19QUkVDSVNJT04ge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ1BPV19QUkVDSVNJT04nKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAwLCBNQVgsIHApO1xyXG4gICAgICAgICAgICBQT1dfUFJFQ0lTSU9OID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBGT1JNQVQge29iamVjdH1cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBGT1JNQVQgbm90IGFuIG9iamVjdDoge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0ZPUk1BVCcpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PSAnb2JqZWN0JykgRk9STUFUID0gdjtcclxuICAgICAgICAgICAgZWxzZSB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgbm90IGFuIG9iamVjdDogJyArIHYpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEFMUEhBQkVUIHtzdHJpbmd9XHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gQUxQSEFCRVQgaW52YWxpZDoge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0FMUEhBQkVUJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuXHJcbiAgICAgICAgICAgIC8vIERpc2FsbG93IGlmIGxlc3MgdGhhbiB0d28gY2hhcmFjdGVycyxcclxuICAgICAgICAgICAgLy8gb3IgaWYgaXQgY29udGFpbnMgJysnLCAnLScsICcuJywgd2hpdGVzcGFjZSwgb3IgYSByZXBlYXRlZCBjaGFyYWN0ZXIuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PSAnc3RyaW5nJyAmJiAhL14uPyR8WytcXC0uXFxzXXwoLikuKlxcMS8udGVzdCh2KSkge1xyXG4gICAgICAgICAgICAgIGFscGhhYmV0SGFzTm9ybWFsRGVjaW1hbERpZ2l0cyA9IHYuc2xpY2UoMCwgMTApID09ICcwMTIzNDU2Nzg5JztcclxuICAgICAgICAgICAgICBBTFBIQUJFVCA9IHY7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgaW52YWxpZDogJyArIHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE9iamVjdCBleHBlY3RlZDoge3Z9J1xyXG4gICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnT2JqZWN0IGV4cGVjdGVkOiAnICsgb2JqKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgREVDSU1BTF9QTEFDRVM6IERFQ0lNQUxfUExBQ0VTLFxyXG4gICAgICAgIFJPVU5ESU5HX01PREU6IFJPVU5ESU5HX01PREUsXHJcbiAgICAgICAgRVhQT05FTlRJQUxfQVQ6IFtUT19FWFBfTkVHLCBUT19FWFBfUE9TXSxcclxuICAgICAgICBSQU5HRTogW01JTl9FWFAsIE1BWF9FWFBdLFxyXG4gICAgICAgIENSWVBUTzogQ1JZUFRPLFxyXG4gICAgICAgIE1PRFVMT19NT0RFOiBNT0RVTE9fTU9ERSxcclxuICAgICAgICBQT1dfUFJFQ0lTSU9OOiBQT1dfUFJFQ0lTSU9OLFxyXG4gICAgICAgIEZPUk1BVDogRk9STUFULFxyXG4gICAgICAgIEFMUEhBQkVUOiBBTFBIQUJFVFxyXG4gICAgICB9O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHYgaXMgYSBCaWdOdW1iZXIgaW5zdGFuY2UsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKlxyXG4gICAgICogSWYgQmlnTnVtYmVyLkRFQlVHIGlzIHRydWUsIHRocm93IGlmIGEgQmlnTnVtYmVyIGluc3RhbmNlIGlzIG5vdCB3ZWxsLWZvcm1lZC5cclxuICAgICAqXHJcbiAgICAgKiB2IHthbnl9XHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEludmFsaWQgQmlnTnVtYmVyOiB7dn0nXHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5pc0JpZ051bWJlciA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgIGlmICghdiB8fCB2Ll9pc0JpZ051bWJlciAhPT0gdHJ1ZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAoIUJpZ051bWJlci5ERUJVRykgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICB2YXIgaSwgbixcclxuICAgICAgICBjID0gdi5jLFxyXG4gICAgICAgIGUgPSB2LmUsXHJcbiAgICAgICAgcyA9IHYucztcclxuXHJcbiAgICAgIG91dDogaWYgKHt9LnRvU3RyaW5nLmNhbGwoYykgPT0gJ1tvYmplY3QgQXJyYXldJykge1xyXG5cclxuICAgICAgICBpZiAoKHMgPT09IDEgfHwgcyA9PT0gLTEpICYmIGUgPj0gLU1BWCAmJiBlIDw9IE1BWCAmJiBlID09PSBtYXRoZmxvb3IoZSkpIHtcclxuXHJcbiAgICAgICAgICAvLyBJZiB0aGUgZmlyc3QgZWxlbWVudCBpcyB6ZXJvLCB0aGUgQmlnTnVtYmVyIHZhbHVlIG11c3QgYmUgemVyby5cclxuICAgICAgICAgIGlmIChjWzBdID09PSAwKSB7XHJcbiAgICAgICAgICAgIGlmIChlID09PSAwICYmIGMubGVuZ3RoID09PSAxKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIENhbGN1bGF0ZSBudW1iZXIgb2YgZGlnaXRzIHRoYXQgY1swXSBzaG91bGQgaGF2ZSwgYmFzZWQgb24gdGhlIGV4cG9uZW50LlxyXG4gICAgICAgICAgaSA9IChlICsgMSkgJSBMT0dfQkFTRTtcclxuICAgICAgICAgIGlmIChpIDwgMSkgaSArPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBjWzBdLlxyXG4gICAgICAgICAgLy9pZiAoTWF0aC5jZWlsKE1hdGgubG9nKGNbMF0gKyAxKSAvIE1hdGguTE4xMCkgPT0gaSkge1xyXG4gICAgICAgICAgaWYgKFN0cmluZyhjWzBdKS5sZW5ndGggPT0gaSkge1xyXG5cclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICBuID0gY1tpXTtcclxuICAgICAgICAgICAgICBpZiAobiA8IDAgfHwgbiA+PSBCQVNFIHx8IG4gIT09IG1hdGhmbG9vcihuKSkgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBMYXN0IGVsZW1lbnQgY2Fubm90IGJlIHplcm8sIHVubGVzcyBpdCBpcyB0aGUgb25seSBlbGVtZW50LlxyXG4gICAgICAgICAgICBpZiAobiAhPT0gMCkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgLy8gSW5maW5pdHkvTmFOXHJcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gbnVsbCAmJiBlID09PSBudWxsICYmIChzID09PSBudWxsIHx8IHMgPT09IDEgfHwgcyA9PT0gLTEpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0ludmFsaWQgQmlnTnVtYmVyOiAnICsgdik7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgbWF4aW11bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5tYXhpbXVtID0gQmlnTnVtYmVyLm1heCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIG1heE9yTWluKGFyZ3VtZW50cywgLTEpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIG1pbmltdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIubWluaW11bSA9IEJpZ051bWJlci5taW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBtYXhPck1pbihhcmd1bWVudHMsIDEpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2l0aCBhIHJhbmRvbSB2YWx1ZSBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gMCBhbmQgbGVzcyB0aGFuIDEsXHJcbiAgICAgKiBhbmQgd2l0aCBkcCwgb3IgREVDSU1BTF9QTEFDRVMgaWYgZHAgaXMgb21pdHRlZCwgZGVjaW1hbCBwbGFjZXMgKG9yIGxlc3MgaWYgdHJhaWxpbmdcclxuICAgICAqIHplcm9zIGFyZSBwcm9kdWNlZCkuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB9J1xyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIGNyeXB0byB1bmF2YWlsYWJsZSdcclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLnJhbmRvbSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBwb3cyXzUzID0gMHgyMDAwMDAwMDAwMDAwMDtcclxuXHJcbiAgICAgIC8vIFJldHVybiBhIDUzIGJpdCBpbnRlZ2VyIG4sIHdoZXJlIDAgPD0gbiA8IDkwMDcxOTkyNTQ3NDA5OTIuXHJcbiAgICAgIC8vIENoZWNrIGlmIE1hdGgucmFuZG9tKCkgcHJvZHVjZXMgbW9yZSB0aGFuIDMyIGJpdHMgb2YgcmFuZG9tbmVzcy5cclxuICAgICAgLy8gSWYgaXQgZG9lcywgYXNzdW1lIGF0IGxlYXN0IDUzIGJpdHMgYXJlIHByb2R1Y2VkLCBvdGhlcndpc2UgYXNzdW1lIGF0IGxlYXN0IDMwIGJpdHMuXHJcbiAgICAgIC8vIDB4NDAwMDAwMDAgaXMgMl4zMCwgMHg4MDAwMDAgaXMgMl4yMywgMHgxZmZmZmYgaXMgMl4yMSAtIDEuXHJcbiAgICAgIHZhciByYW5kb201M2JpdEludCA9IChNYXRoLnJhbmRvbSgpICogcG93Ml81MykgJiAweDFmZmZmZlxyXG4gICAgICAgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXRoZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBvdzJfNTMpOyB9XHJcbiAgICAgICA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICgoTWF0aC5yYW5kb20oKSAqIDB4NDAwMDAwMDAgfCAwKSAqIDB4ODAwMDAwKSArXHJcbiAgICAgICAgIChNYXRoLnJhbmRvbSgpICogMHg4MDAwMDAgfCAwKTsgfTtcclxuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZHApIHtcclxuICAgICAgICB2YXIgYSwgYiwgZSwgaywgdixcclxuICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgYyA9IFtdLFxyXG4gICAgICAgICAgcmFuZCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuXHJcbiAgICAgICAgaWYgKGRwID09IG51bGwpIGRwID0gREVDSU1BTF9QTEFDRVM7XHJcbiAgICAgICAgZWxzZSBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuXHJcbiAgICAgICAgayA9IG1hdGhjZWlsKGRwIC8gTE9HX0JBU0UpO1xyXG5cclxuICAgICAgICBpZiAoQ1JZUFRPKSB7XHJcblxyXG4gICAgICAgICAgLy8gQnJvd3NlcnMgc3VwcG9ydGluZyBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLlxyXG4gICAgICAgICAgaWYgKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcclxuXHJcbiAgICAgICAgICAgIGEgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheShrICo9IDIpKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoOyBpIDwgazspIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gNTMgYml0czpcclxuICAgICAgICAgICAgICAvLyAoKE1hdGgucG93KDIsIDMyKSAtIDEpICogTWF0aC5wb3coMiwgMjEpKS50b1N0cmluZygyKVxyXG4gICAgICAgICAgICAgIC8vIDExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwXHJcbiAgICAgICAgICAgICAgLy8gKChNYXRoLnBvdygyLCAzMikgLSAxKSA+Pj4gMTEpLnRvU3RyaW5nKDIpXHJcbiAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTExMTEgMTExMTExMTEgMTExMTExMTFcclxuICAgICAgICAgICAgICAvLyAweDIwMDAwIGlzIDJeMjEuXHJcbiAgICAgICAgICAgICAgdiA9IGFbaV0gKiAweDIwMDAwICsgKGFbaSArIDFdID4+PiAxMSk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIFJlamVjdGlvbiBzYW1wbGluZzpcclxuICAgICAgICAgICAgICAvLyAwIDw9IHYgPCA5MDA3MTk5MjU0NzQwOTkyXHJcbiAgICAgICAgICAgICAgLy8gUHJvYmFiaWxpdHkgdGhhdCB2ID49IDllMTUsIGlzXHJcbiAgICAgICAgICAgICAgLy8gNzE5OTI1NDc0MDk5MiAvIDkwMDcxOTkyNTQ3NDA5OTIgfj0gMC4wMDA4LCBpLmUuIDEgaW4gMTI1MVxyXG4gICAgICAgICAgICAgIGlmICh2ID49IDllMTUpIHtcclxuICAgICAgICAgICAgICAgIGIgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheSgyKSk7XHJcbiAgICAgICAgICAgICAgICBhW2ldID0gYlswXTtcclxuICAgICAgICAgICAgICAgIGFbaSArIDFdID0gYlsxXTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIDAgPD0gdiA8PSA4OTk5OTk5OTk5OTk5OTk5XHJcbiAgICAgICAgICAgICAgICAvLyAwIDw9ICh2ICUgMWUxNCkgPD0gOTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICAgIGMucHVzaCh2ICUgMWUxNCk7XHJcbiAgICAgICAgICAgICAgICBpICs9IDI7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkgPSBrIC8gMjtcclxuXHJcbiAgICAgICAgICAvLyBOb2RlLmpzIHN1cHBvcnRpbmcgY3J5cHRvLnJhbmRvbUJ5dGVzLlxyXG4gICAgICAgICAgfSBlbHNlIGlmIChjcnlwdG8ucmFuZG9tQnl0ZXMpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGJ1ZmZlclxyXG4gICAgICAgICAgICBhID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGsgKj0gNyk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGs7KSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIDB4MTAwMDAwMDAwMDAwMCBpcyAyXjQ4LCAweDEwMDAwMDAwMDAwIGlzIDJeNDBcclxuICAgICAgICAgICAgICAvLyAweDEwMDAwMDAwMCBpcyAyXjMyLCAweDEwMDAwMDAgaXMgMl4yNFxyXG4gICAgICAgICAgICAgIC8vIDExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExXHJcbiAgICAgICAgICAgICAgLy8gMCA8PSB2IDwgOTAwNzE5OTI1NDc0MDk5MlxyXG4gICAgICAgICAgICAgIHYgPSAoKGFbaV0gJiAzMSkgKiAweDEwMDAwMDAwMDAwMDApICsgKGFbaSArIDFdICogMHgxMDAwMDAwMDAwMCkgK1xyXG4gICAgICAgICAgICAgICAgIChhW2kgKyAyXSAqIDB4MTAwMDAwMDAwKSArIChhW2kgKyAzXSAqIDB4MTAwMDAwMCkgK1xyXG4gICAgICAgICAgICAgICAgIChhW2kgKyA0XSA8PCAxNikgKyAoYVtpICsgNV0gPDwgOCkgKyBhW2kgKyA2XTtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKHYgPj0gOWUxNSkge1xyXG4gICAgICAgICAgICAgICAgY3J5cHRvLnJhbmRvbUJ5dGVzKDcpLmNvcHkoYSwgaSk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAwIDw9ICh2ICUgMWUxNCkgPD0gOTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICAgIGMucHVzaCh2ICUgMWUxNCk7XHJcbiAgICAgICAgICAgICAgICBpICs9IDc7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkgPSBrIC8gNztcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIENSWVBUTyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ2NyeXB0byB1bmF2YWlsYWJsZScpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXNlIE1hdGgucmFuZG9tLlxyXG4gICAgICAgIGlmICghQ1JZUFRPKSB7XHJcblxyXG4gICAgICAgICAgZm9yICg7IGkgPCBrOykge1xyXG4gICAgICAgICAgICB2ID0gcmFuZG9tNTNiaXRJbnQoKTtcclxuICAgICAgICAgICAgaWYgKHYgPCA5ZTE1KSBjW2krK10gPSB2ICUgMWUxNDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGsgPSBjWy0taV07XHJcbiAgICAgICAgZHAgJT0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgdHJhaWxpbmcgZGlnaXRzIHRvIHplcm9zIGFjY29yZGluZyB0byBkcC5cclxuICAgICAgICBpZiAoayAmJiBkcCkge1xyXG4gICAgICAgICAgdiA9IFBPV1NfVEVOW0xPR19CQVNFIC0gZHBdO1xyXG4gICAgICAgICAgY1tpXSA9IG1hdGhmbG9vcihrIC8gdikgKiB2O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIGVsZW1lbnRzIHdoaWNoIGFyZSB6ZXJvLlxyXG4gICAgICAgIGZvciAoOyBjW2ldID09PSAwOyBjLnBvcCgpLCBpLS0pO1xyXG5cclxuICAgICAgICAvLyBaZXJvP1xyXG4gICAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgICAgYyA9IFtlID0gMF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyBlbGVtZW50cyB3aGljaCBhcmUgemVybyBhbmQgYWRqdXN0IGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgICAgICAgZm9yIChlID0gLTEgOyBjWzBdID09PSAwOyBjLnNwbGljZSgwLCAxKSwgZSAtPSBMT0dfQkFTRSk7XHJcblxyXG4gICAgICAgICAgLy8gQ291bnQgdGhlIGRpZ2l0cyBvZiB0aGUgZmlyc3QgZWxlbWVudCBvZiBjIHRvIGRldGVybWluZSBsZWFkaW5nIHplcm9zLCBhbmQuLi5cclxuICAgICAgICAgIGZvciAoaSA9IDEsIHYgPSBjWzBdOyB2ID49IDEwOyB2IC89IDEwLCBpKyspO1xyXG5cclxuICAgICAgICAgIC8vIGFkanVzdCB0aGUgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgICAgICBpZiAoaSA8IExPR19CQVNFKSBlIC09IExPR19CQVNFIC0gaTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJhbmQuZSA9IGU7XHJcbiAgICAgICAgcmFuZC5jID0gYztcclxuICAgICAgICByZXR1cm4gcmFuZDtcclxuICAgICAgfTtcclxuICAgIH0pKCk7XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHN1bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5zdW0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBpID0gMSxcclxuICAgICAgICBhcmdzID0gYXJndW1lbnRzLFxyXG4gICAgICAgIHN1bSA9IG5ldyBCaWdOdW1iZXIoYXJnc1swXSk7XHJcbiAgICAgIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7KSBzdW0gPSBzdW0ucGx1cyhhcmdzW2krK10pO1xyXG4gICAgICByZXR1cm4gc3VtO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLy8gUFJJVkFURSBGVU5DVElPTlNcclxuXHJcblxyXG4gICAgLy8gQ2FsbGVkIGJ5IEJpZ051bWJlciBhbmQgQmlnTnVtYmVyLnByb3RvdHlwZS50b1N0cmluZy5cclxuICAgIGNvbnZlcnRCYXNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGRlY2ltYWwgPSAnMDEyMzQ1Njc4OSc7XHJcblxyXG4gICAgICAvKlxyXG4gICAgICAgKiBDb252ZXJ0IHN0cmluZyBvZiBiYXNlSW4gdG8gYW4gYXJyYXkgb2YgbnVtYmVycyBvZiBiYXNlT3V0LlxyXG4gICAgICAgKiBFZy4gdG9CYXNlT3V0KCcyNTUnLCAxMCwgMTYpIHJldHVybnMgWzE1LCAxNV0uXHJcbiAgICAgICAqIEVnLiB0b0Jhc2VPdXQoJ2ZmJywgMTYsIDEwKSByZXR1cm5zIFsyLCA1LCA1XS5cclxuICAgICAgICovXHJcbiAgICAgIGZ1bmN0aW9uIHRvQmFzZU91dChzdHIsIGJhc2VJbiwgYmFzZU91dCwgYWxwaGFiZXQpIHtcclxuICAgICAgICB2YXIgaixcclxuICAgICAgICAgIGFyciA9IFswXSxcclxuICAgICAgICAgIGFyckwsXHJcbiAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOykge1xyXG4gICAgICAgICAgZm9yIChhcnJMID0gYXJyLmxlbmd0aDsgYXJyTC0tOyBhcnJbYXJyTF0gKj0gYmFzZUluKTtcclxuXHJcbiAgICAgICAgICBhcnJbMF0gKz0gYWxwaGFiZXQuaW5kZXhPZihzdHIuY2hhckF0KGkrKykpO1xyXG5cclxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBhcnIubGVuZ3RoOyBqKyspIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChhcnJbal0gPiBiYXNlT3V0IC0gMSkge1xyXG4gICAgICAgICAgICAgIGlmIChhcnJbaiArIDFdID09IG51bGwpIGFycltqICsgMV0gPSAwO1xyXG4gICAgICAgICAgICAgIGFycltqICsgMV0gKz0gYXJyW2pdIC8gYmFzZU91dCB8IDA7XHJcbiAgICAgICAgICAgICAgYXJyW2pdICU9IGJhc2VPdXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBhcnIucmV2ZXJzZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDb252ZXJ0IGEgbnVtZXJpYyBzdHJpbmcgb2YgYmFzZUluIHRvIGEgbnVtZXJpYyBzdHJpbmcgb2YgYmFzZU91dC5cclxuICAgICAgLy8gSWYgdGhlIGNhbGxlciBpcyB0b1N0cmluZywgd2UgYXJlIGNvbnZlcnRpbmcgZnJvbSBiYXNlIDEwIHRvIGJhc2VPdXQuXHJcbiAgICAgIC8vIElmIHRoZSBjYWxsZXIgaXMgQmlnTnVtYmVyLCB3ZSBhcmUgY29udmVydGluZyBmcm9tIGJhc2VJbiB0byBiYXNlIDEwLlxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHN0ciwgYmFzZUluLCBiYXNlT3V0LCBzaWduLCBjYWxsZXJJc1RvU3RyaW5nKSB7XHJcbiAgICAgICAgdmFyIGFscGhhYmV0LCBkLCBlLCBrLCByLCB4LCB4YywgeSxcclxuICAgICAgICAgIGkgPSBzdHIuaW5kZXhPZignLicpLFxyXG4gICAgICAgICAgZHAgPSBERUNJTUFMX1BMQUNFUyxcclxuICAgICAgICAgIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuXHJcbiAgICAgICAgLy8gTm9uLWludGVnZXIuXHJcbiAgICAgICAgaWYgKGkgPj0gMCkge1xyXG4gICAgICAgICAgayA9IFBPV19QUkVDSVNJT047XHJcblxyXG4gICAgICAgICAgLy8gVW5saW1pdGVkIHByZWNpc2lvbi5cclxuICAgICAgICAgIFBPV19QUkVDSVNJT04gPSAwO1xyXG4gICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoJy4nLCAnJyk7XHJcbiAgICAgICAgICB5ID0gbmV3IEJpZ051bWJlcihiYXNlSW4pO1xyXG4gICAgICAgICAgeCA9IHkucG93KHN0ci5sZW5ndGggLSBpKTtcclxuICAgICAgICAgIFBPV19QUkVDSVNJT04gPSBrO1xyXG5cclxuICAgICAgICAgIC8vIENvbnZlcnQgc3RyIGFzIGlmIGFuIGludGVnZXIsIHRoZW4gcmVzdG9yZSB0aGUgZnJhY3Rpb24gcGFydCBieSBkaXZpZGluZyB0aGVcclxuICAgICAgICAgIC8vIHJlc3VsdCBieSBpdHMgYmFzZSByYWlzZWQgdG8gYSBwb3dlci5cclxuXHJcbiAgICAgICAgICB5LmMgPSB0b0Jhc2VPdXQodG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcoeC5jKSwgeC5lLCAnMCcpLFxyXG4gICAgICAgICAgIDEwLCBiYXNlT3V0LCBkZWNpbWFsKTtcclxuICAgICAgICAgIHkuZSA9IHkuYy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IHRoZSBudW1iZXIgYXMgaW50ZWdlci5cclxuXHJcbiAgICAgICAgeGMgPSB0b0Jhc2VPdXQoc3RyLCBiYXNlSW4sIGJhc2VPdXQsIGNhbGxlcklzVG9TdHJpbmdcclxuICAgICAgICAgPyAoYWxwaGFiZXQgPSBBTFBIQUJFVCwgZGVjaW1hbClcclxuICAgICAgICAgOiAoYWxwaGFiZXQgPSBkZWNpbWFsLCBBTFBIQUJFVCkpO1xyXG5cclxuICAgICAgICAvLyB4YyBub3cgcmVwcmVzZW50cyBzdHIgYXMgYW4gaW50ZWdlciBhbmQgY29udmVydGVkIHRvIGJhc2VPdXQuIGUgaXMgdGhlIGV4cG9uZW50LlxyXG4gICAgICAgIGUgPSBrID0geGMubGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgZm9yICg7IHhjWy0ta10gPT0gMDsgeGMucG9wKCkpO1xyXG5cclxuICAgICAgICAvLyBaZXJvP1xyXG4gICAgICAgIGlmICgheGNbMF0pIHJldHVybiBhbHBoYWJldC5jaGFyQXQoMCk7XHJcblxyXG4gICAgICAgIC8vIERvZXMgc3RyIHJlcHJlc2VudCBhbiBpbnRlZ2VyPyBJZiBzbywgbm8gbmVlZCBmb3IgdGhlIGRpdmlzaW9uLlxyXG4gICAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgICAgLS1lO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4LmMgPSB4YztcclxuICAgICAgICAgIHguZSA9IGU7XHJcblxyXG4gICAgICAgICAgLy8gVGhlIHNpZ24gaXMgbmVlZGVkIGZvciBjb3JyZWN0IHJvdW5kaW5nLlxyXG4gICAgICAgICAgeC5zID0gc2lnbjtcclxuICAgICAgICAgIHggPSBkaXYoeCwgeSwgZHAsIHJtLCBiYXNlT3V0KTtcclxuICAgICAgICAgIHhjID0geC5jO1xyXG4gICAgICAgICAgciA9IHgucjtcclxuICAgICAgICAgIGUgPSB4LmU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB4YyBub3cgcmVwcmVzZW50cyBzdHIgY29udmVydGVkIHRvIGJhc2VPdXQuXHJcblxyXG4gICAgICAgIC8vIFRIZSBpbmRleCBvZiB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgZCA9IGUgKyBkcCArIDE7XHJcblxyXG4gICAgICAgIC8vIFRoZSByb3VuZGluZyBkaWdpdDogdGhlIGRpZ2l0IHRvIHRoZSByaWdodCBvZiB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cC5cclxuICAgICAgICBpID0geGNbZF07XHJcblxyXG4gICAgICAgIC8vIExvb2sgYXQgdGhlIHJvdW5kaW5nIGRpZ2l0cyBhbmQgbW9kZSB0byBkZXRlcm1pbmUgd2hldGhlciB0byByb3VuZCB1cC5cclxuXHJcbiAgICAgICAgayA9IGJhc2VPdXQgLyAyO1xyXG4gICAgICAgIHIgPSByIHx8IGQgPCAwIHx8IHhjW2QgKyAxXSAhPSBudWxsO1xyXG5cclxuICAgICAgICByID0gcm0gPCA0ID8gKGkgIT0gbnVsbCB8fCByKSAmJiAocm0gPT0gMCB8fCBybSA9PSAoeC5zIDwgMCA/IDMgOiAyKSlcclxuICAgICAgICAgICAgICA6IGkgPiBrIHx8IGkgPT0gayAmJihybSA9PSA0IHx8IHIgfHwgcm0gPT0gNiAmJiB4Y1tkIC0gMV0gJiAxIHx8XHJcbiAgICAgICAgICAgICAgIHJtID09ICh4LnMgPCAwID8gOCA6IDcpKTtcclxuXHJcbiAgICAgICAgLy8gSWYgdGhlIGluZGV4IG9mIHRoZSByb3VuZGluZyBkaWdpdCBpcyBub3QgZ3JlYXRlciB0aGFuIHplcm8sIG9yIHhjIHJlcHJlc2VudHNcclxuICAgICAgICAvLyB6ZXJvLCB0aGVuIHRoZSByZXN1bHQgb2YgdGhlIGJhc2UgY29udmVyc2lvbiBpcyB6ZXJvIG9yLCBpZiByb3VuZGluZyB1cCwgYSB2YWx1ZVxyXG4gICAgICAgIC8vIHN1Y2ggYXMgMC4wMDAwMS5cclxuICAgICAgICBpZiAoZCA8IDEgfHwgIXhjWzBdKSB7XHJcblxyXG4gICAgICAgICAgLy8gMV4tZHAgb3IgMFxyXG4gICAgICAgICAgc3RyID0gciA/IHRvRml4ZWRQb2ludChhbHBoYWJldC5jaGFyQXQoMSksIC1kcCwgYWxwaGFiZXQuY2hhckF0KDApKSA6IGFscGhhYmV0LmNoYXJBdCgwKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIC8vIFRydW5jYXRlIHhjIHRvIHRoZSByZXF1aXJlZCBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgICAgICB4Yy5sZW5ndGggPSBkO1xyXG5cclxuICAgICAgICAgIC8vIFJvdW5kIHVwP1xyXG4gICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFJvdW5kaW5nIHVwIG1heSBtZWFuIHRoZSBwcmV2aW91cyBkaWdpdCBoYXMgdG8gYmUgcm91bmRlZCB1cCBhbmQgc28gb24uXHJcbiAgICAgICAgICAgIGZvciAoLS1iYXNlT3V0OyArK3hjWy0tZF0gPiBiYXNlT3V0Oykge1xyXG4gICAgICAgICAgICAgIHhjW2RdID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKCFkKSB7XHJcbiAgICAgICAgICAgICAgICArK2U7XHJcbiAgICAgICAgICAgICAgICB4YyA9IFsxXS5jb25jYXQoeGMpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICAgIGZvciAoayA9IHhjLmxlbmd0aDsgIXhjWy0ta107KTtcclxuXHJcbiAgICAgICAgICAvLyBFLmcuIFs0LCAxMSwgMTVdIGJlY29tZXMgNGJmLlxyXG4gICAgICAgICAgZm9yIChpID0gMCwgc3RyID0gJyc7IGkgPD0gazsgc3RyICs9IGFscGhhYmV0LmNoYXJBdCh4Y1tpKytdKSk7XHJcblxyXG4gICAgICAgICAgLy8gQWRkIGxlYWRpbmcgemVyb3MsIGRlY2ltYWwgcG9pbnQgYW5kIHRyYWlsaW5nIHplcm9zIGFzIHJlcXVpcmVkLlxyXG4gICAgICAgICAgc3RyID0gdG9GaXhlZFBvaW50KHN0ciwgZSwgYWxwaGFiZXQuY2hhckF0KDApKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRoZSBjYWxsZXIgd2lsbCBhZGQgdGhlIHNpZ24uXHJcbiAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgICAgfTtcclxuICAgIH0pKCk7XHJcblxyXG5cclxuICAgIC8vIFBlcmZvcm0gZGl2aXNpb24gaW4gdGhlIHNwZWNpZmllZCBiYXNlLiBDYWxsZWQgYnkgZGl2IGFuZCBjb252ZXJ0QmFzZS5cclxuICAgIGRpdiA9IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAvLyBBc3N1bWUgbm9uLXplcm8geCBhbmQgay5cclxuICAgICAgZnVuY3Rpb24gbXVsdGlwbHkoeCwgaywgYmFzZSkge1xyXG4gICAgICAgIHZhciBtLCB0ZW1wLCB4bG8sIHhoaSxcclxuICAgICAgICAgIGNhcnJ5ID0gMCxcclxuICAgICAgICAgIGkgPSB4Lmxlbmd0aCxcclxuICAgICAgICAgIGtsbyA9IGsgJSBTUVJUX0JBU0UsXHJcbiAgICAgICAgICBraGkgPSBrIC8gU1FSVF9CQVNFIHwgMDtcclxuXHJcbiAgICAgICAgZm9yICh4ID0geC5zbGljZSgpOyBpLS07KSB7XHJcbiAgICAgICAgICB4bG8gPSB4W2ldICUgU1FSVF9CQVNFO1xyXG4gICAgICAgICAgeGhpID0geFtpXSAvIFNRUlRfQkFTRSB8IDA7XHJcbiAgICAgICAgICBtID0ga2hpICogeGxvICsgeGhpICoga2xvO1xyXG4gICAgICAgICAgdGVtcCA9IGtsbyAqIHhsbyArICgobSAlIFNRUlRfQkFTRSkgKiBTUVJUX0JBU0UpICsgY2Fycnk7XHJcbiAgICAgICAgICBjYXJyeSA9ICh0ZW1wIC8gYmFzZSB8IDApICsgKG0gLyBTUVJUX0JBU0UgfCAwKSArIGtoaSAqIHhoaTtcclxuICAgICAgICAgIHhbaV0gPSB0ZW1wICUgYmFzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjYXJyeSkgeCA9IFtjYXJyeV0uY29uY2F0KHgpO1xyXG5cclxuICAgICAgICByZXR1cm4geDtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gY29tcGFyZShhLCBiLCBhTCwgYkwpIHtcclxuICAgICAgICB2YXIgaSwgY21wO1xyXG5cclxuICAgICAgICBpZiAoYUwgIT0gYkwpIHtcclxuICAgICAgICAgIGNtcCA9IGFMID4gYkwgPyAxIDogLTE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICBmb3IgKGkgPSBjbXAgPSAwOyBpIDwgYUw7IGkrKykge1xyXG5cclxuICAgICAgICAgICAgaWYgKGFbaV0gIT0gYltpXSkge1xyXG4gICAgICAgICAgICAgIGNtcCA9IGFbaV0gPiBiW2ldID8gMSA6IC0xO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY21wO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBzdWJ0cmFjdChhLCBiLCBhTCwgYmFzZSkge1xyXG4gICAgICAgIHZhciBpID0gMDtcclxuXHJcbiAgICAgICAgLy8gU3VidHJhY3QgYiBmcm9tIGEuXHJcbiAgICAgICAgZm9yICg7IGFMLS07KSB7XHJcbiAgICAgICAgICBhW2FMXSAtPSBpO1xyXG4gICAgICAgICAgaSA9IGFbYUxdIDwgYlthTF0gPyAxIDogMDtcclxuICAgICAgICAgIGFbYUxdID0gaSAqIGJhc2UgKyBhW2FMXSAtIGJbYUxdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgZm9yICg7ICFhWzBdICYmIGEubGVuZ3RoID4gMTsgYS5zcGxpY2UoMCwgMSkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB4OiBkaXZpZGVuZCwgeTogZGl2aXNvci5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4LCB5LCBkcCwgcm0sIGJhc2UpIHtcclxuICAgICAgICB2YXIgY21wLCBlLCBpLCBtb3JlLCBuLCBwcm9kLCBwcm9kTCwgcSwgcWMsIHJlbSwgcmVtTCwgcmVtMCwgeGksIHhMLCB5YzAsXHJcbiAgICAgICAgICB5TCwgeXosXHJcbiAgICAgICAgICBzID0geC5zID09IHkucyA/IDEgOiAtMSxcclxuICAgICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgICAgeWMgPSB5LmM7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciBOYU4sIEluZmluaXR5IG9yIDA/XHJcbiAgICAgICAgaWYgKCF4YyB8fCAheGNbMF0gfHwgIXljIHx8ICF5Y1swXSkge1xyXG5cclxuICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKFxyXG5cclxuICAgICAgICAgICAvLyBSZXR1cm4gTmFOIGlmIGVpdGhlciBOYU4sIG9yIGJvdGggSW5maW5pdHkgb3IgMC5cclxuICAgICAgICAgICAheC5zIHx8ICF5LnMgfHwgKHhjID8geWMgJiYgeGNbMF0gPT0geWNbMF0gOiAheWMpID8gTmFOIDpcclxuXHJcbiAgICAgICAgICAgIC8vIFJldHVybiDCsTAgaWYgeCBpcyDCsTAgb3IgeSBpcyDCsUluZmluaXR5LCBvciByZXR1cm4gwrFJbmZpbml0eSBhcyB5IGlzIMKxMC5cclxuICAgICAgICAgICAgeGMgJiYgeGNbMF0gPT0gMCB8fCAheWMgPyBzICogMCA6IHMgLyAwXHJcbiAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBxID0gbmV3IEJpZ051bWJlcihzKTtcclxuICAgICAgICBxYyA9IHEuYyA9IFtdO1xyXG4gICAgICAgIGUgPSB4LmUgLSB5LmU7XHJcbiAgICAgICAgcyA9IGRwICsgZSArIDE7XHJcblxyXG4gICAgICAgIGlmICghYmFzZSkge1xyXG4gICAgICAgICAgYmFzZSA9IEJBU0U7XHJcbiAgICAgICAgICBlID0gYml0Rmxvb3IoeC5lIC8gTE9HX0JBU0UpIC0gYml0Rmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xyXG4gICAgICAgICAgcyA9IHMgLyBMT0dfQkFTRSB8IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZXN1bHQgZXhwb25lbnQgbWF5IGJlIG9uZSBsZXNzIHRoZW4gdGhlIGN1cnJlbnQgdmFsdWUgb2YgZS5cclxuICAgICAgICAvLyBUaGUgY29lZmZpY2llbnRzIG9mIHRoZSBCaWdOdW1iZXJzIGZyb20gY29udmVydEJhc2UgbWF5IGhhdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgZm9yIChpID0gMDsgeWNbaV0gPT0gKHhjW2ldIHx8IDApOyBpKyspO1xyXG5cclxuICAgICAgICBpZiAoeWNbaV0gPiAoeGNbaV0gfHwgMCkpIGUtLTtcclxuXHJcbiAgICAgICAgaWYgKHMgPCAwKSB7XHJcbiAgICAgICAgICBxYy5wdXNoKDEpO1xyXG4gICAgICAgICAgbW9yZSA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHhMID0geGMubGVuZ3RoO1xyXG4gICAgICAgICAgeUwgPSB5Yy5sZW5ndGg7XHJcbiAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgIHMgKz0gMjtcclxuXHJcbiAgICAgICAgICAvLyBOb3JtYWxpc2UgeGMgYW5kIHljIHNvIGhpZ2hlc3Qgb3JkZXIgZGlnaXQgb2YgeWMgaXMgPj0gYmFzZSAvIDIuXHJcblxyXG4gICAgICAgICAgbiA9IG1hdGhmbG9vcihiYXNlIC8gKHljWzBdICsgMSkpO1xyXG5cclxuICAgICAgICAgIC8vIE5vdCBuZWNlc3NhcnksIGJ1dCB0byBoYW5kbGUgb2RkIGJhc2VzIHdoZXJlIHljWzBdID09IChiYXNlIC8gMikgLSAxLlxyXG4gICAgICAgICAgLy8gaWYgKG4gPiAxIHx8IG4rKyA9PSAxICYmIHljWzBdIDwgYmFzZSAvIDIpIHtcclxuICAgICAgICAgIGlmIChuID4gMSkge1xyXG4gICAgICAgICAgICB5YyA9IG11bHRpcGx5KHljLCBuLCBiYXNlKTtcclxuICAgICAgICAgICAgeGMgPSBtdWx0aXBseSh4YywgbiwgYmFzZSk7XHJcbiAgICAgICAgICAgIHlMID0geWMubGVuZ3RoO1xyXG4gICAgICAgICAgICB4TCA9IHhjLmxlbmd0aDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB4aSA9IHlMO1xyXG4gICAgICAgICAgcmVtID0geGMuc2xpY2UoMCwgeUwpO1xyXG4gICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgLy8gQWRkIHplcm9zIHRvIG1ha2UgcmVtYWluZGVyIGFzIGxvbmcgYXMgZGl2aXNvci5cclxuICAgICAgICAgIGZvciAoOyByZW1MIDwgeUw7IHJlbVtyZW1MKytdID0gMCk7XHJcbiAgICAgICAgICB5eiA9IHljLnNsaWNlKCk7XHJcbiAgICAgICAgICB5eiA9IFswXS5jb25jYXQoeXopO1xyXG4gICAgICAgICAgeWMwID0geWNbMF07XHJcbiAgICAgICAgICBpZiAoeWNbMV0gPj0gYmFzZSAvIDIpIHljMCsrO1xyXG4gICAgICAgICAgLy8gTm90IG5lY2Vzc2FyeSwgYnV0IHRvIHByZXZlbnQgdHJpYWwgZGlnaXQgbiA+IGJhc2UsIHdoZW4gdXNpbmcgYmFzZSAzLlxyXG4gICAgICAgICAgLy8gZWxzZSBpZiAoYmFzZSA9PSAzICYmIHljMCA9PSAxKSB5YzAgPSAxICsgMWUtMTU7XHJcblxyXG4gICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBuID0gMDtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbXBhcmUgZGl2aXNvciBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBjbXAgPSBjb21wYXJlKHljLCByZW0sIHlMLCByZW1MKTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIGRpdmlzb3IgPCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIGlmIChjbXAgPCAwKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0cmlhbCBkaWdpdCwgbi5cclxuXHJcbiAgICAgICAgICAgICAgcmVtMCA9IHJlbVswXTtcclxuICAgICAgICAgICAgICBpZiAoeUwgIT0gcmVtTCkgcmVtMCA9IHJlbTAgKiBiYXNlICsgKHJlbVsxXSB8fCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gbiBpcyBob3cgbWFueSB0aW1lcyB0aGUgZGl2aXNvciBnb2VzIGludG8gdGhlIGN1cnJlbnQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIG4gPSBtYXRoZmxvb3IocmVtMCAvIHljMCk7XHJcblxyXG4gICAgICAgICAgICAgIC8vICBBbGdvcml0aG06XHJcbiAgICAgICAgICAgICAgLy8gIHByb2R1Y3QgPSBkaXZpc29yIG11bHRpcGxpZWQgYnkgdHJpYWwgZGlnaXQgKG4pLlxyXG4gICAgICAgICAgICAgIC8vICBDb21wYXJlIHByb2R1Y3QgYW5kIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAvLyAgSWYgcHJvZHVjdCBpcyBncmVhdGVyIHRoYW4gcmVtYWluZGVyOlxyXG4gICAgICAgICAgICAgIC8vICAgIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSBwcm9kdWN0LCBkZWNyZW1lbnQgdHJpYWwgZGlnaXQuXHJcbiAgICAgICAgICAgICAgLy8gIFN1YnRyYWN0IHByb2R1Y3QgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgLy8gIElmIHByb2R1Y3Qgd2FzIGxlc3MgdGhhbiByZW1haW5kZXIgYXQgdGhlIGxhc3QgY29tcGFyZTpcclxuICAgICAgICAgICAgICAvLyAgICBDb21wYXJlIG5ldyByZW1haW5kZXIgYW5kIGRpdmlzb3IuXHJcbiAgICAgICAgICAgICAgLy8gICAgSWYgcmVtYWluZGVyIGlzIGdyZWF0ZXIgdGhhbiBkaXZpc29yOlxyXG4gICAgICAgICAgICAgIC8vICAgICAgU3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlciwgaW5jcmVtZW50IHRyaWFsIGRpZ2l0LlxyXG5cclxuICAgICAgICAgICAgICBpZiAobiA+IDEpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBuIG1heSBiZSA+IGJhc2Ugb25seSB3aGVuIGJhc2UgaXMgMy5cclxuICAgICAgICAgICAgICAgIGlmIChuID49IGJhc2UpIG4gPSBiYXNlIC0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBwcm9kdWN0ID0gZGl2aXNvciAqIHRyaWFsIGRpZ2l0LlxyXG4gICAgICAgICAgICAgICAgcHJvZCA9IG11bHRpcGx5KHljLCBuLCBiYXNlKTtcclxuICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb21wYXJlIHByb2R1Y3QgYW5kIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgIC8vIElmIHByb2R1Y3QgPiByZW1haW5kZXIgdGhlbiB0cmlhbCBkaWdpdCBuIHRvbyBoaWdoLlxyXG4gICAgICAgICAgICAgICAgLy8gbiBpcyAxIHRvbyBoaWdoIGFib3V0IDUlIG9mIHRoZSB0aW1lLCBhbmQgaXMgbm90IGtub3duIHRvIGhhdmVcclxuICAgICAgICAgICAgICAgIC8vIGV2ZXIgYmVlbiBtb3JlIHRoYW4gMSB0b28gaGlnaC5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKHByb2QsIHJlbSwgcHJvZEwsIHJlbUwpID09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgbi0tO1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gU3VidHJhY3QgZGl2aXNvciBmcm9tIHByb2R1Y3QuXHJcbiAgICAgICAgICAgICAgICAgIHN1YnRyYWN0KHByb2QsIHlMIDwgcHJvZEwgPyB5eiA6IHljLCBwcm9kTCwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgIGNtcCA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBuIGlzIDAgb3IgMSwgY21wIGlzIC0xLlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgbiBpcyAwLCB0aGVyZSBpcyBubyBuZWVkIHRvIGNvbXBhcmUgeWMgYW5kIHJlbSBhZ2FpbiBiZWxvdyxcclxuICAgICAgICAgICAgICAgIC8vIHNvIGNoYW5nZSBjbXAgdG8gMSB0byBhdm9pZCBpdC5cclxuICAgICAgICAgICAgICAgIC8vIElmIG4gaXMgMSwgbGVhdmUgY21wIGFzIC0xLCBzbyB5YyBhbmQgcmVtIGFyZSBjb21wYXJlZCBhZ2Fpbi5cclxuICAgICAgICAgICAgICAgIGlmIChuID09IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIGRpdmlzb3IgPCByZW1haW5kZXIsIHNvIG4gbXVzdCBiZSBhdCBsZWFzdCAxLlxyXG4gICAgICAgICAgICAgICAgICBjbXAgPSBuID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBwcm9kdWN0ID0gZGl2aXNvclxyXG4gICAgICAgICAgICAgICAgcHJvZCA9IHljLnNsaWNlKCk7XHJcbiAgICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgaWYgKHByb2RMIDwgcmVtTCkgcHJvZCA9IFswXS5jb25jYXQocHJvZCk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIFN1YnRyYWN0IHByb2R1Y3QgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgc3VidHJhY3QocmVtLCBwcm9kLCByZW1MLCBiYXNlKTtcclxuICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgIC8vIElmIHByb2R1Y3Qgd2FzIDwgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIGlmIChjbXAgPT0gLTEpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb21wYXJlIGRpdmlzb3IgYW5kIG5ldyByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBkaXZpc29yIDwgbmV3IHJlbWFpbmRlciwgc3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgIC8vIFRyaWFsIGRpZ2l0IG4gdG9vIGxvdy5cclxuICAgICAgICAgICAgICAgIC8vIG4gaXMgMSB0b28gbG93IGFib3V0IDUlIG9mIHRoZSB0aW1lLCBhbmQgdmVyeSByYXJlbHkgMiB0b28gbG93LlxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUoeWMsIHJlbSwgeUwsIHJlbUwpIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgICBuKys7XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgICBzdWJ0cmFjdChyZW0sIHlMIDwgcmVtTCA/IHl6IDogeWMsIHJlbUwsIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY21wID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgbisrO1xyXG4gICAgICAgICAgICAgIHJlbSA9IFswXTtcclxuICAgICAgICAgICAgfSAvLyBlbHNlIGNtcCA9PT0gMSBhbmQgbiB3aWxsIGJlIDBcclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgbmV4dCBkaWdpdCwgbiwgdG8gdGhlIHJlc3VsdCBhcnJheS5cclxuICAgICAgICAgICAgcWNbaSsrXSA9IG47XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgaWYgKHJlbVswXSkge1xyXG4gICAgICAgICAgICAgIHJlbVtyZW1MKytdID0geGNbeGldIHx8IDA7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgcmVtID0gW3hjW3hpXV07XHJcbiAgICAgICAgICAgICAgcmVtTCA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gd2hpbGUgKCh4aSsrIDwgeEwgfHwgcmVtWzBdICE9IG51bGwpICYmIHMtLSk7XHJcblxyXG4gICAgICAgICAgbW9yZSA9IHJlbVswXSAhPSBudWxsO1xyXG5cclxuICAgICAgICAgIC8vIExlYWRpbmcgemVybz9cclxuICAgICAgICAgIGlmICghcWNbMF0pIHFjLnNwbGljZSgwLCAxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChiYXNlID09IEJBU0UpIHtcclxuXHJcbiAgICAgICAgICAvLyBUbyBjYWxjdWxhdGUgcS5lLCBmaXJzdCBnZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgcWNbMF0uXHJcbiAgICAgICAgICBmb3IgKGkgPSAxLCBzID0gcWNbMF07IHMgPj0gMTA7IHMgLz0gMTAsIGkrKyk7XHJcblxyXG4gICAgICAgICAgcm91bmQocSwgZHAgKyAocS5lID0gaSArIGUgKiBMT0dfQkFTRSAtIDEpICsgMSwgcm0sIG1vcmUpO1xyXG5cclxuICAgICAgICAvLyBDYWxsZXIgaXMgY29udmVydEJhc2UuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHEuZSA9IGU7XHJcbiAgICAgICAgICBxLnIgPSArbW9yZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBxO1xyXG4gICAgICB9O1xyXG4gICAgfSkoKTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIEJpZ051bWJlciBuIGluIGZpeGVkLXBvaW50IG9yIGV4cG9uZW50aWFsXHJcbiAgICAgKiBub3RhdGlvbiByb3VuZGVkIHRvIHRoZSBzcGVjaWZpZWQgZGVjaW1hbCBwbGFjZXMgb3Igc2lnbmlmaWNhbnQgZGlnaXRzLlxyXG4gICAgICpcclxuICAgICAqIG46IGEgQmlnTnVtYmVyLlxyXG4gICAgICogaTogdGhlIGluZGV4IG9mIHRoZSBsYXN0IGRpZ2l0IHJlcXVpcmVkIChpLmUuIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwKS5cclxuICAgICAqIHJtOiB0aGUgcm91bmRpbmcgbW9kZS5cclxuICAgICAqIGlkOiAxICh0b0V4cG9uZW50aWFsKSBvciAyICh0b1ByZWNpc2lvbikuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZvcm1hdChuLCBpLCBybSwgaWQpIHtcclxuICAgICAgdmFyIGMwLCBlLCBuZSwgbGVuLCBzdHI7XHJcblxyXG4gICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuXHJcbiAgICAgIGlmICghbi5jKSByZXR1cm4gbi50b1N0cmluZygpO1xyXG5cclxuICAgICAgYzAgPSBuLmNbMF07XHJcbiAgICAgIG5lID0gbi5lO1xyXG5cclxuICAgICAgaWYgKGkgPT0gbnVsbCkge1xyXG4gICAgICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcobi5jKTtcclxuICAgICAgICBzdHIgPSBpZCA9PSAxIHx8IGlkID09IDIgJiYgKG5lIDw9IFRPX0VYUF9ORUcgfHwgbmUgPj0gVE9fRVhQX1BPUylcclxuICAgICAgICAgPyB0b0V4cG9uZW50aWFsKHN0ciwgbmUpXHJcbiAgICAgICAgIDogdG9GaXhlZFBvaW50KHN0ciwgbmUsICcwJyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbiA9IHJvdW5kKG5ldyBCaWdOdW1iZXIobiksIGksIHJtKTtcclxuXHJcbiAgICAgICAgLy8gbi5lIG1heSBoYXZlIGNoYW5nZWQgaWYgdGhlIHZhbHVlIHdhcyByb3VuZGVkIHVwLlxyXG4gICAgICAgIGUgPSBuLmU7XHJcblxyXG4gICAgICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcobi5jKTtcclxuICAgICAgICBsZW4gPSBzdHIubGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyB0b1ByZWNpc2lvbiByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uIGlmIHRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAgICAgICAgLy8gc3BlY2lmaWVkIGlzIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBpbnRlZ2VyXHJcbiAgICAgICAgLy8gcGFydCBvZiB0aGUgdmFsdWUgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24uXHJcblxyXG4gICAgICAgIC8vIEV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICAgIGlmIChpZCA9PSAxIHx8IGlkID09IDIgJiYgKGkgPD0gZSB8fCBlIDw9IFRPX0VYUF9ORUcpKSB7XHJcblxyXG4gICAgICAgICAgLy8gQXBwZW5kIHplcm9zP1xyXG4gICAgICAgICAgZm9yICg7IGxlbiA8IGk7IHN0ciArPSAnMCcsIGxlbisrKTtcclxuICAgICAgICAgIHN0ciA9IHRvRXhwb25lbnRpYWwoc3RyLCBlKTtcclxuXHJcbiAgICAgICAgLy8gRml4ZWQtcG9pbnQgbm90YXRpb24uXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGkgLT0gbmU7XHJcbiAgICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoc3RyLCBlLCAnMCcpO1xyXG5cclxuICAgICAgICAgIC8vIEFwcGVuZCB6ZXJvcz9cclxuICAgICAgICAgIGlmIChlICsgMSA+IGxlbikge1xyXG4gICAgICAgICAgICBpZiAoLS1pID4gMCkgZm9yIChzdHIgKz0gJy4nOyBpLS07IHN0ciArPSAnMCcpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaSArPSBlIC0gbGVuO1xyXG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcclxuICAgICAgICAgICAgICBpZiAoZSArIDEgPT0gbGVuKSBzdHIgKz0gJy4nO1xyXG4gICAgICAgICAgICAgIGZvciAoOyBpLS07IHN0ciArPSAnMCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbi5zIDwgMCAmJiBjMCA/ICctJyArIHN0ciA6IHN0cjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gSGFuZGxlIEJpZ051bWJlci5tYXggYW5kIEJpZ051bWJlci5taW4uXHJcbiAgICAvLyBJZiBhbnkgbnVtYmVyIGlzIE5hTiwgcmV0dXJuIE5hTi5cclxuICAgIGZ1bmN0aW9uIG1heE9yTWluKGFyZ3MsIG4pIHtcclxuICAgICAgdmFyIGssIHksXHJcbiAgICAgICAgaSA9IDEsXHJcbiAgICAgICAgeCA9IG5ldyBCaWdOdW1iZXIoYXJnc1swXSk7XHJcblxyXG4gICAgICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB5ID0gbmV3IEJpZ051bWJlcihhcmdzW2ldKTtcclxuICAgICAgICBpZiAoIXkucyB8fCAoayA9IGNvbXBhcmUoeCwgeSkpID09PSBuIHx8IGsgPT09IDAgJiYgeC5zID09PSBuKSB7XHJcbiAgICAgICAgICB4ID0geTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogU3RyaXAgdHJhaWxpbmcgemVyb3MsIGNhbGN1bGF0ZSBiYXNlIDEwIGV4cG9uZW50IGFuZCBjaGVjayBhZ2FpbnN0IE1JTl9FWFAgYW5kIE1BWF9FWFAuXHJcbiAgICAgKiBDYWxsZWQgYnkgbWludXMsIHBsdXMgYW5kIHRpbWVzLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBub3JtYWxpc2UobiwgYywgZSkge1xyXG4gICAgICB2YXIgaSA9IDEsXHJcbiAgICAgICAgaiA9IGMubGVuZ3RoO1xyXG5cclxuICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgZm9yICg7ICFjWy0tal07IGMucG9wKCkpO1xyXG5cclxuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBiYXNlIDEwIGV4cG9uZW50LiBGaXJzdCBnZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgY1swXS5cclxuICAgICAgZm9yIChqID0gY1swXTsgaiA+PSAxMDsgaiAvPSAxMCwgaSsrKTtcclxuXHJcbiAgICAgIC8vIE92ZXJmbG93P1xyXG4gICAgICBpZiAoKGUgPSBpICsgZSAqIExPR19CQVNFIC0gMSkgPiBNQVhfRVhQKSB7XHJcblxyXG4gICAgICAgIC8vIEluZmluaXR5LlxyXG4gICAgICAgIG4uYyA9IG4uZSA9IG51bGw7XHJcblxyXG4gICAgICAvLyBVbmRlcmZsb3c/XHJcbiAgICAgIH0gZWxzZSBpZiAoZSA8IE1JTl9FWFApIHtcclxuXHJcbiAgICAgICAgLy8gWmVyby5cclxuICAgICAgICBuLmMgPSBbbi5lID0gMF07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbi5lID0gZTtcclxuICAgICAgICBuLmMgPSBjO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gSGFuZGxlIHZhbHVlcyB0aGF0IGZhaWwgdGhlIHZhbGlkaXR5IHRlc3QgaW4gQmlnTnVtYmVyLlxyXG4gICAgcGFyc2VOdW1lcmljID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGJhc2VQcmVmaXggPSAvXigtPykwKFt4Ym9dKSg/PVxcd1tcXHcuXSokKS9pLFxyXG4gICAgICAgIGRvdEFmdGVyID0gL14oW14uXSspXFwuJC8sXHJcbiAgICAgICAgZG90QmVmb3JlID0gL15cXC4oW14uXSspJC8sXHJcbiAgICAgICAgaXNJbmZpbml0eU9yTmFOID0gL14tPyhJbmZpbml0eXxOYU4pJC8sXHJcbiAgICAgICAgd2hpdGVzcGFjZU9yUGx1cyA9IC9eXFxzKlxcKyg/PVtcXHcuXSl8Xlxccyt8XFxzKyQvZztcclxuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoeCwgc3RyLCBpc051bSwgYikge1xyXG4gICAgICAgIHZhciBiYXNlLFxyXG4gICAgICAgICAgcyA9IGlzTnVtID8gc3RyIDogc3RyLnJlcGxhY2Uod2hpdGVzcGFjZU9yUGx1cywgJycpO1xyXG5cclxuICAgICAgICAvLyBObyBleGNlcHRpb24gb24gwrFJbmZpbml0eSBvciBOYU4uXHJcbiAgICAgICAgaWYgKGlzSW5maW5pdHlPck5hTi50ZXN0KHMpKSB7XHJcbiAgICAgICAgICB4LnMgPSBpc05hTihzKSA/IG51bGwgOiBzIDwgMCA/IC0xIDogMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaWYgKCFpc051bSkge1xyXG5cclxuICAgICAgICAgICAgLy8gYmFzZVByZWZpeCA9IC9eKC0/KTAoW3hib10pKD89XFx3W1xcdy5dKiQpL2lcclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShiYXNlUHJlZml4LCBmdW5jdGlvbiAobSwgcDEsIHAyKSB7XHJcbiAgICAgICAgICAgICAgYmFzZSA9IChwMiA9IHAyLnRvTG93ZXJDYXNlKCkpID09ICd4JyA/IDE2IDogcDIgPT0gJ2InID8gMiA6IDg7XHJcbiAgICAgICAgICAgICAgcmV0dXJuICFiIHx8IGIgPT0gYmFzZSA/IHAxIDogbTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoYikge1xyXG4gICAgICAgICAgICAgIGJhc2UgPSBiO1xyXG5cclxuICAgICAgICAgICAgICAvLyBFLmcuICcxLicgdG8gJzEnLCAnLjEnIHRvICcwLjEnXHJcbiAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZShkb3RBZnRlciwgJyQxJykucmVwbGFjZShkb3RCZWZvcmUsICcwLiQxJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzdHIgIT0gcykgcmV0dXJuIG5ldyBCaWdOdW1iZXIocywgYmFzZSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE5vdCBhIG51bWJlcjoge259J1xyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE5vdCBhIGJhc2Uge2J9IG51bWJlcjoge259J1xyXG4gICAgICAgICAgaWYgKEJpZ051bWJlci5ERUJVRykge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdOb3QgYScgKyAoYiA/ICcgYmFzZSAnICsgYiA6ICcnKSArICcgbnVtYmVyOiAnICsgc3RyKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBOYU5cclxuICAgICAgICAgIHgucyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUm91bmQgeCB0byBzZCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBybS4gQ2hlY2sgZm9yIG92ZXIvdW5kZXItZmxvdy5cclxuICAgICAqIElmIHIgaXMgdHJ1dGh5LCBpdCBpcyBrbm93biB0aGF0IHRoZXJlIGFyZSBtb3JlIGRpZ2l0cyBhZnRlciB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHJvdW5kKHgsIHNkLCBybSwgcikge1xyXG4gICAgICB2YXIgZCwgaSwgaiwgaywgbiwgbmksIHJkLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHBvd3MxMCA9IFBPV1NfVEVOO1xyXG5cclxuICAgICAgLy8gaWYgeCBpcyBub3QgSW5maW5pdHkgb3IgTmFOLi4uXHJcbiAgICAgIGlmICh4Yykge1xyXG5cclxuICAgICAgICAvLyByZCBpcyB0aGUgcm91bmRpbmcgZGlnaXQsIGkuZS4gdGhlIGRpZ2l0IGFmdGVyIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwLlxyXG4gICAgICAgIC8vIG4gaXMgYSBiYXNlIDFlMTQgbnVtYmVyLCB0aGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgb2YgYXJyYXkgeC5jIGNvbnRhaW5pbmcgcmQuXHJcbiAgICAgICAgLy8gbmkgaXMgdGhlIGluZGV4IG9mIG4gd2l0aGluIHguYy5cclxuICAgICAgICAvLyBkIGlzIHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIG4uXHJcbiAgICAgICAgLy8gaSBpcyB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4gaW5jbHVkaW5nIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgLy8gaiBpcyB0aGUgYWN0dWFsIGluZGV4IG9mIHJkIHdpdGhpbiBuIChpZiA8IDAsIHJkIGlzIGEgbGVhZGluZyB6ZXJvKS5cclxuICAgICAgICBvdXQ6IHtcclxuXHJcbiAgICAgICAgICAvLyBHZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQgb2YgeGMuXHJcbiAgICAgICAgICBmb3IgKGQgPSAxLCBrID0geGNbMF07IGsgPj0gMTA7IGsgLz0gMTAsIGQrKyk7XHJcbiAgICAgICAgICBpID0gc2QgLSBkO1xyXG5cclxuICAgICAgICAgIC8vIElmIHRoZSByb3VuZGluZyBkaWdpdCBpcyBpbiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy4uLlxyXG4gICAgICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgICAgIGkgKz0gTE9HX0JBU0U7XHJcbiAgICAgICAgICAgIGogPSBzZDtcclxuICAgICAgICAgICAgbiA9IHhjW25pID0gMF07XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIHJvdW5kaW5nIGRpZ2l0IGF0IGluZGV4IGogb2Ygbi5cclxuICAgICAgICAgICAgcmQgPSBtYXRoZmxvb3IobiAvIHBvd3MxMFtkIC0gaiAtIDFdICUgMTApO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbmkgPSBtYXRoY2VpbCgoaSArIDEpIC8gTE9HX0JBU0UpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG5pID49IHhjLmxlbmd0aCkge1xyXG5cclxuICAgICAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIE5lZWRlZCBieSBzcXJ0LlxyXG4gICAgICAgICAgICAgICAgZm9yICg7IHhjLmxlbmd0aCA8PSBuaTsgeGMucHVzaCgwKSk7XHJcbiAgICAgICAgICAgICAgICBuID0gcmQgPSAwO1xyXG4gICAgICAgICAgICAgICAgZCA9IDE7XHJcbiAgICAgICAgICAgICAgICBpICU9IExPR19CQVNFO1xyXG4gICAgICAgICAgICAgICAgaiA9IGkgLSBMT0dfQkFTRSArIDE7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrIG91dDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgbiA9IGsgPSB4Y1tuaV07XHJcblxyXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBuLlxyXG4gICAgICAgICAgICAgIGZvciAoZCA9IDE7IGsgPj0gMTA7IGsgLz0gMTAsIGQrKyk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4uXHJcbiAgICAgICAgICAgICAgaSAlPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbiwgYWRqdXN0ZWQgZm9yIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgICAgICAgLy8gVGhlIG51bWJlciBvZiBsZWFkaW5nIHplcm9zIG9mIG4gaXMgZ2l2ZW4gYnkgTE9HX0JBU0UgLSBkLlxyXG4gICAgICAgICAgICAgIGogPSBpIC0gTE9HX0JBU0UgKyBkO1xyXG5cclxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIHJvdW5kaW5nIGRpZ2l0IGF0IGluZGV4IGogb2Ygbi5cclxuICAgICAgICAgICAgICByZCA9IGogPCAwID8gMCA6IG1hdGhmbG9vcihuIC8gcG93czEwW2QgLSBqIC0gMV0gJSAxMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByID0gciB8fCBzZCA8IDAgfHxcclxuXHJcbiAgICAgICAgICAvLyBBcmUgdGhlcmUgYW55IG5vbi16ZXJvIGRpZ2l0cyBhZnRlciB0aGUgcm91bmRpbmcgZGlnaXQ/XHJcbiAgICAgICAgICAvLyBUaGUgZXhwcmVzc2lvbiAgbiAlIHBvd3MxMFtkIC0gaiAtIDFdICByZXR1cm5zIGFsbCBkaWdpdHMgb2YgbiB0byB0aGUgcmlnaHRcclxuICAgICAgICAgIC8vIG9mIHRoZSBkaWdpdCBhdCBqLCBlLmcuIGlmIG4gaXMgOTA4NzE0IGFuZCBqIGlzIDIsIHRoZSBleHByZXNzaW9uIGdpdmVzIDcxNC5cclxuICAgICAgICAgICB4Y1tuaSArIDFdICE9IG51bGwgfHwgKGogPCAwID8gbiA6IG4gJSBwb3dzMTBbZCAtIGogLSAxXSk7XHJcblxyXG4gICAgICAgICAgciA9IHJtIDwgNFxyXG4gICAgICAgICAgID8gKHJkIHx8IHIpICYmIChybSA9PSAwIHx8IHJtID09ICh4LnMgPCAwID8gMyA6IDIpKVxyXG4gICAgICAgICAgIDogcmQgPiA1IHx8IHJkID09IDUgJiYgKHJtID09IDQgfHwgciB8fCBybSA9PSA2ICYmXHJcblxyXG4gICAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBkaWdpdCB0byB0aGUgbGVmdCBvZiB0aGUgcm91bmRpbmcgZGlnaXQgaXMgb2RkLlxyXG4gICAgICAgICAgICAoKGkgPiAwID8gaiA+IDAgPyBuIC8gcG93czEwW2QgLSBqXSA6IDAgOiB4Y1tuaSAtIDFdKSAlIDEwKSAmIDEgfHxcclxuICAgICAgICAgICAgIHJtID09ICh4LnMgPCAwID8gOCA6IDcpKTtcclxuXHJcbiAgICAgICAgICBpZiAoc2QgPCAxIHx8ICF4Y1swXSkge1xyXG4gICAgICAgICAgICB4Yy5sZW5ndGggPSAwO1xyXG5cclxuICAgICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQ29udmVydCBzZCB0byBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAgICAgICAgICBzZCAtPSB4LmUgKyAxO1xyXG5cclxuICAgICAgICAgICAgICAvLyAxLCAwLjEsIDAuMDEsIDAuMDAxLCAwLjAwMDEgZXRjLlxyXG4gICAgICAgICAgICAgIHhjWzBdID0gcG93czEwWyhMT0dfQkFTRSAtIHNkICUgTE9HX0JBU0UpICUgTE9HX0JBU0VdO1xyXG4gICAgICAgICAgICAgIHguZSA9IC1zZCB8fCAwO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgICAgICAgIHhjWzBdID0geC5lID0gMDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUmVtb3ZlIGV4Y2VzcyBkaWdpdHMuXHJcbiAgICAgICAgICBpZiAoaSA9PSAwKSB7XHJcbiAgICAgICAgICAgIHhjLmxlbmd0aCA9IG5pO1xyXG4gICAgICAgICAgICBrID0gMTtcclxuICAgICAgICAgICAgbmktLTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHhjLmxlbmd0aCA9IG5pICsgMTtcclxuICAgICAgICAgICAgayA9IHBvd3MxMFtMT0dfQkFTRSAtIGldO1xyXG5cclxuICAgICAgICAgICAgLy8gRS5nLiA1NjcwMCBiZWNvbWVzIDU2MDAwIGlmIDcgaXMgdGhlIHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgICAgICAvLyBqID4gMCBtZWFucyBpID4gbnVtYmVyIG9mIGxlYWRpbmcgemVyb3Mgb2Ygbi5cclxuICAgICAgICAgICAgeGNbbmldID0gaiA+IDAgPyBtYXRoZmxvb3IobiAvIHBvd3MxMFtkIC0gal0gJSBwb3dzMTBbal0pICogayA6IDA7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUm91bmQgdXA/XHJcbiAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgZm9yICg7IDspIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gSWYgdGhlIGRpZ2l0IHRvIGJlIHJvdW5kZWQgdXAgaXMgaW4gdGhlIGZpcnN0IGVsZW1lbnQgb2YgeGMuLi5cclxuICAgICAgICAgICAgICBpZiAobmkgPT0gMCkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGkgd2lsbCBiZSB0aGUgbGVuZ3RoIG9mIHhjWzBdIGJlZm9yZSBrIGlzIGFkZGVkLlxyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMSwgaiA9IHhjWzBdOyBqID49IDEwOyBqIC89IDEwLCBpKyspO1xyXG4gICAgICAgICAgICAgICAgaiA9IHhjWzBdICs9IGs7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGsgPSAxOyBqID49IDEwOyBqIC89IDEwLCBrKyspO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGlmIGkgIT0gayB0aGUgbGVuZ3RoIGhhcyBpbmNyZWFzZWQuXHJcbiAgICAgICAgICAgICAgICBpZiAoaSAhPSBrKSB7XHJcbiAgICAgICAgICAgICAgICAgIHguZSsrO1xyXG4gICAgICAgICAgICAgICAgICBpZiAoeGNbMF0gPT0gQkFTRSkgeGNbMF0gPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB4Y1tuaV0gKz0gaztcclxuICAgICAgICAgICAgICAgIGlmICh4Y1tuaV0gIT0gQkFTRSkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB4Y1tuaS0tXSA9IDA7XHJcbiAgICAgICAgICAgICAgICBrID0gMTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgICBmb3IgKGkgPSB4Yy5sZW5ndGg7IHhjWy0taV0gPT09IDA7IHhjLnBvcCgpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE92ZXJmbG93PyBJbmZpbml0eS5cclxuICAgICAgICBpZiAoeC5lID4gTUFYX0VYUCkge1xyXG4gICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gVW5kZXJmbG93PyBaZXJvLlxyXG4gICAgICAgIH0gZWxzZSBpZiAoeC5lIDwgTUlOX0VYUCkge1xyXG4gICAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHg7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIHZhbHVlT2Yobikge1xyXG4gICAgICB2YXIgc3RyLFxyXG4gICAgICAgIGUgPSBuLmU7XHJcblxyXG4gICAgICBpZiAoZSA9PT0gbnVsbCkgcmV0dXJuIG4udG9TdHJpbmcoKTtcclxuXHJcbiAgICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcobi5jKTtcclxuXHJcbiAgICAgIHN0ciA9IGUgPD0gVE9fRVhQX05FRyB8fCBlID49IFRPX0VYUF9QT1NcclxuICAgICAgICA/IHRvRXhwb25lbnRpYWwoc3RyLCBlKVxyXG4gICAgICAgIDogdG9GaXhlZFBvaW50KHN0ciwgZSwgJzAnKTtcclxuXHJcbiAgICAgIHJldHVybiBuLnMgPCAwID8gJy0nICsgc3RyIDogc3RyO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBQUk9UT1RZUEUvSU5TVEFOQ0UgTUVUSE9EU1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIuXHJcbiAgICAgKi9cclxuICAgIFAuYWJzb2x1dGVWYWx1ZSA9IFAuYWJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgeCA9IG5ldyBCaWdOdW1iZXIodGhpcyk7XHJcbiAgICAgIGlmICh4LnMgPCAwKSB4LnMgPSAxO1xyXG4gICAgICByZXR1cm4geDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm5cclxuICAgICAqICAgMSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiAgIC0xIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqICAgMCBpZiB0aGV5IGhhdmUgdGhlIHNhbWUgdmFsdWUsXHJcbiAgICAgKiAgIG9yIG51bGwgaWYgdGhlIHZhbHVlIG9mIGVpdGhlciBpcyBOYU4uXHJcbiAgICAgKi9cclxuICAgIFAuY29tcGFyZWRUbyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIElmIGRwIGlzIHVuZGVmaW5lZCBvciBudWxsIG9yIHRydWUgb3IgZmFsc2UsIHJldHVybiB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIG9mIHRoZVxyXG4gICAgICogdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIsIG9yIG51bGwgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIMKxSW5maW5pdHkgb3IgTmFOLlxyXG4gICAgICpcclxuICAgICAqIE90aGVyd2lzZSwgaWYgZHAgaXMgYSBudW1iZXIsIHJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgICAqIEJpZ051bWJlciByb3VuZGVkIHRvIGEgbWF4aW11bSBvZiBkcCBkZWNpbWFsIHBsYWNlcyB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvclxyXG4gICAgICogUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXM6IGludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC5kZWNpbWFsUGxhY2VzID0gUC5kcCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICAgICAgdmFyIGMsIG4sIHYsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICBpZiAoZHAgIT0gbnVsbCkge1xyXG4gICAgICAgIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG4gICAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcblxyXG4gICAgICAgIHJldHVybiByb3VuZChuZXcgQmlnTnVtYmVyKHgpLCBkcCArIHguZSArIDEsIHJtKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCEoYyA9IHguYykpIHJldHVybiBudWxsO1xyXG4gICAgICBuID0gKCh2ID0gYy5sZW5ndGggLSAxKSAtIGJpdEZsb29yKHRoaXMuZSAvIExPR19CQVNFKSkgKiBMT0dfQkFTRTtcclxuXHJcbiAgICAgIC8vIFN1YnRyYWN0IHRoZSBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3Mgb2YgdGhlIGxhc3QgbnVtYmVyLlxyXG4gICAgICBpZiAodiA9IGNbdl0pIGZvciAoOyB2ICUgMTAgPT0gMDsgdiAvPSAxMCwgbi0tKTtcclxuICAgICAgaWYgKG4gPCAwKSBuID0gMDtcclxuXHJcbiAgICAgIHJldHVybiBuO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBuIC8gMCA9IElcclxuICAgICAqICBuIC8gTiA9IE5cclxuICAgICAqICBuIC8gSSA9IDBcclxuICAgICAqICAwIC8gbiA9IDBcclxuICAgICAqICAwIC8gMCA9IE5cclxuICAgICAqICAwIC8gTiA9IE5cclxuICAgICAqICAwIC8gSSA9IDBcclxuICAgICAqICBOIC8gbiA9IE5cclxuICAgICAqICBOIC8gMCA9IE5cclxuICAgICAqICBOIC8gTiA9IE5cclxuICAgICAqICBOIC8gSSA9IE5cclxuICAgICAqICBJIC8gbiA9IElcclxuICAgICAqICBJIC8gMCA9IElcclxuICAgICAqICBJIC8gTiA9IE5cclxuICAgICAqICBJIC8gSSA9IE5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBkaXZpZGVkIGJ5IHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLCByb3VuZGVkIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cclxuICAgICAqL1xyXG4gICAgUC5kaXZpZGVkQnkgPSBQLmRpdiA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBkaXYodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSwgREVDSU1BTF9QTEFDRVMsIFJPVU5ESU5HX01PREUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIGludGVnZXIgcGFydCBvZiBkaXZpZGluZyB0aGUgdmFsdWUgb2YgdGhpc1xyXG4gICAgICogQmlnTnVtYmVyIGJ5IHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgKi9cclxuICAgIFAuZGl2aWRlZFRvSW50ZWdlckJ5ID0gUC5pZGl2ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGRpdih0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpLCAwLCAxKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGV4cG9uZW50aWF0ZWQgYnkgbi5cclxuICAgICAqXHJcbiAgICAgKiBJZiBtIGlzIHByZXNlbnQsIHJldHVybiB0aGUgcmVzdWx0IG1vZHVsbyBtLlxyXG4gICAgICogSWYgbiBpcyBuZWdhdGl2ZSByb3VuZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICAgKiBJZiBQT1dfUFJFQ0lTSU9OIGlzIG5vbi16ZXJvIGFuZCBtIGlzIG5vdCBwcmVzZW50LCByb3VuZCB0byBQT1dfUFJFQ0lTSU9OIHVzaW5nIFJPVU5ESU5HX01PREUuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIG1vZHVsYXIgcG93ZXIgb3BlcmF0aW9uIHdvcmtzIGVmZmljaWVudGx5IHdoZW4geCwgbiwgYW5kIG0gYXJlIGludGVnZXJzLCBvdGhlcndpc2UgaXRcclxuICAgICAqIGlzIGVxdWl2YWxlbnQgdG8gY2FsY3VsYXRpbmcgeC5leHBvbmVudGlhdGVkQnkobikubW9kdWxvKG0pIHdpdGggYSBQT1dfUFJFQ0lTSU9OIG9mIDAuXHJcbiAgICAgKlxyXG4gICAgICogbiB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IFRoZSBleHBvbmVudC4gQW4gaW50ZWdlci5cclxuICAgICAqIFttXSB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IFRoZSBtb2R1bHVzLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBFeHBvbmVudCBub3QgYW4gaW50ZWdlcjoge259J1xyXG4gICAgICovXHJcbiAgICBQLmV4cG9uZW50aWF0ZWRCeSA9IFAucG93ID0gZnVuY3Rpb24gKG4sIG0pIHtcclxuICAgICAgdmFyIGhhbGYsIGlzTW9kRXhwLCBpLCBrLCBtb3JlLCBuSXNCaWcsIG5Jc05lZywgbklzT2RkLCB5LFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgbiA9IG5ldyBCaWdOdW1iZXIobik7XHJcblxyXG4gICAgICAvLyBBbGxvdyBOYU4gYW5kIMKxSW5maW5pdHksIGJ1dCBub3Qgb3RoZXIgbm9uLWludGVnZXJzLlxyXG4gICAgICBpZiAobi5jICYmICFuLmlzSW50ZWdlcigpKSB7XHJcbiAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdFeHBvbmVudCBub3QgYW4gaW50ZWdlcjogJyArIHZhbHVlT2YobikpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobSAhPSBudWxsKSBtID0gbmV3IEJpZ051bWJlcihtKTtcclxuXHJcbiAgICAgIC8vIEV4cG9uZW50IG9mIE1BWF9TQUZFX0lOVEVHRVIgaXMgMTUuXHJcbiAgICAgIG5Jc0JpZyA9IG4uZSA+IDE0O1xyXG5cclxuICAgICAgLy8gSWYgeCBpcyBOYU4sIMKxSW5maW5pdHksIMKxMCBvciDCsTEsIG9yIG4gaXMgwrFJbmZpbml0eSwgTmFOIG9yIMKxMC5cclxuICAgICAgaWYgKCF4LmMgfHwgIXguY1swXSB8fCB4LmNbMF0gPT0gMSAmJiAheC5lICYmIHguYy5sZW5ndGggPT0gMSB8fCAhbi5jIHx8ICFuLmNbMF0pIHtcclxuXHJcbiAgICAgICAgLy8gVGhlIHNpZ24gb2YgdGhlIHJlc3VsdCBvZiBwb3cgd2hlbiB4IGlzIG5lZ2F0aXZlIGRlcGVuZHMgb24gdGhlIGV2ZW5uZXNzIG9mIG4uXHJcbiAgICAgICAgLy8gSWYgK24gb3ZlcmZsb3dzIHRvIMKxSW5maW5pdHksIHRoZSBldmVubmVzcyBvZiBuIHdvdWxkIGJlIG5vdCBiZSBrbm93bi5cclxuICAgICAgICB5ID0gbmV3IEJpZ051bWJlcihNYXRoLnBvdygrdmFsdWVPZih4KSwgbklzQmlnID8gbi5zICogKDIgLSBpc09kZChuKSkgOiArdmFsdWVPZihuKSkpO1xyXG4gICAgICAgIHJldHVybiBtID8geS5tb2QobSkgOiB5O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBuSXNOZWcgPSBuLnMgPCAwO1xyXG5cclxuICAgICAgaWYgKG0pIHtcclxuXHJcbiAgICAgICAgLy8geCAlIG0gcmV0dXJucyBOYU4gaWYgYWJzKG0pIGlzIHplcm8sIG9yIG0gaXMgTmFOLlxyXG4gICAgICAgIGlmIChtLmMgPyAhbS5jWzBdIDogIW0ucykgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgICAgaXNNb2RFeHAgPSAhbklzTmVnICYmIHguaXNJbnRlZ2VyKCkgJiYgbS5pc0ludGVnZXIoKTtcclxuXHJcbiAgICAgICAgaWYgKGlzTW9kRXhwKSB4ID0geC5tb2QobSk7XHJcblxyXG4gICAgICAvLyBPdmVyZmxvdyB0byDCsUluZmluaXR5OiA+PTIqKjFlMTAgb3IgPj0xLjAwMDAwMjQqKjFlMTUuXHJcbiAgICAgIC8vIFVuZGVyZmxvdyB0byDCsTA6IDw9MC43OSoqMWUxMCBvciA8PTAuOTk5OTk3NSoqMWUxNS5cclxuICAgICAgfSBlbHNlIGlmIChuLmUgPiA5ICYmICh4LmUgPiAwIHx8IHguZSA8IC0xIHx8ICh4LmUgPT0gMFxyXG4gICAgICAgIC8vIFsxLCAyNDAwMDAwMDBdXHJcbiAgICAgICAgPyB4LmNbMF0gPiAxIHx8IG5Jc0JpZyAmJiB4LmNbMV0gPj0gMjRlN1xyXG4gICAgICAgIC8vIFs4MDAwMDAwMDAwMDAwMF0gIFs5OTk5OTc1MDAwMDAwMF1cclxuICAgICAgICA6IHguY1swXSA8IDhlMTMgfHwgbklzQmlnICYmIHguY1swXSA8PSA5OTk5OTc1ZTcpKSkge1xyXG5cclxuICAgICAgICAvLyBJZiB4IGlzIG5lZ2F0aXZlIGFuZCBuIGlzIG9kZCwgayA9IC0wLCBlbHNlIGsgPSAwLlxyXG4gICAgICAgIGsgPSB4LnMgPCAwICYmIGlzT2RkKG4pID8gLTAgOiAwO1xyXG5cclxuICAgICAgICAvLyBJZiB4ID49IDEsIGsgPSDCsUluZmluaXR5LlxyXG4gICAgICAgIGlmICh4LmUgPiAtMSkgayA9IDEgLyBrO1xyXG5cclxuICAgICAgICAvLyBJZiBuIGlzIG5lZ2F0aXZlIHJldHVybiDCsTAsIGVsc2UgcmV0dXJuIMKxSW5maW5pdHkuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIobklzTmVnID8gMSAvIGsgOiBrKTtcclxuXHJcbiAgICAgIH0gZWxzZSBpZiAoUE9XX1BSRUNJU0lPTikge1xyXG5cclxuICAgICAgICAvLyBUcnVuY2F0aW5nIGVhY2ggY29lZmZpY2llbnQgYXJyYXkgdG8gYSBsZW5ndGggb2YgayBhZnRlciBlYWNoIG11bHRpcGxpY2F0aW9uXHJcbiAgICAgICAgLy8gZXF1YXRlcyB0byB0cnVuY2F0aW5nIHNpZ25pZmljYW50IGRpZ2l0cyB0byBQT1dfUFJFQ0lTSU9OICsgWzI4LCA0MV0sXHJcbiAgICAgICAgLy8gaS5lLiB0aGVyZSB3aWxsIGJlIGEgbWluaW11bSBvZiAyOCBndWFyZCBkaWdpdHMgcmV0YWluZWQuXHJcbiAgICAgICAgayA9IG1hdGhjZWlsKFBPV19QUkVDSVNJT04gLyBMT0dfQkFTRSArIDIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobklzQmlnKSB7XHJcbiAgICAgICAgaGFsZiA9IG5ldyBCaWdOdW1iZXIoMC41KTtcclxuICAgICAgICBpZiAobklzTmVnKSBuLnMgPSAxO1xyXG4gICAgICAgIG5Jc09kZCA9IGlzT2RkKG4pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGkgPSBNYXRoLmFicygrdmFsdWVPZihuKSk7XHJcbiAgICAgICAgbklzT2RkID0gaSAlIDI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcblxyXG4gICAgICAvLyBQZXJmb3JtcyA1NCBsb29wIGl0ZXJhdGlvbnMgZm9yIG4gb2YgOTAwNzE5OTI1NDc0MDk5MS5cclxuICAgICAgZm9yICg7IDspIHtcclxuXHJcbiAgICAgICAgaWYgKG5Jc09kZCkge1xyXG4gICAgICAgICAgeSA9IHkudGltZXMoeCk7XHJcbiAgICAgICAgICBpZiAoIXkuYykgYnJlYWs7XHJcblxyXG4gICAgICAgICAgaWYgKGspIHtcclxuICAgICAgICAgICAgaWYgKHkuYy5sZW5ndGggPiBrKSB5LmMubGVuZ3RoID0gaztcclxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNNb2RFeHApIHtcclxuICAgICAgICAgICAgeSA9IHkubW9kKG0pOyAgICAvL3kgPSB5Lm1pbnVzKGRpdih5LCBtLCAwLCBNT0RVTE9fTU9ERSkudGltZXMobSkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGkpIHtcclxuICAgICAgICAgIGkgPSBtYXRoZmxvb3IoaSAvIDIpO1xyXG4gICAgICAgICAgaWYgKGkgPT09IDApIGJyZWFrO1xyXG4gICAgICAgICAgbklzT2RkID0gaSAlIDI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG4gPSBuLnRpbWVzKGhhbGYpO1xyXG4gICAgICAgICAgcm91bmQobiwgbi5lICsgMSwgMSk7XHJcblxyXG4gICAgICAgICAgaWYgKG4uZSA+IDE0KSB7XHJcbiAgICAgICAgICAgIG5Jc09kZCA9IGlzT2RkKG4pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaSA9ICt2YWx1ZU9mKG4pO1xyXG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkgYnJlYWs7XHJcbiAgICAgICAgICAgIG5Jc09kZCA9IGkgJSAyO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeCA9IHgudGltZXMoeCk7XHJcblxyXG4gICAgICAgIGlmIChrKSB7XHJcbiAgICAgICAgICBpZiAoeC5jICYmIHguYy5sZW5ndGggPiBrKSB4LmMubGVuZ3RoID0gaztcclxuICAgICAgICB9IGVsc2UgaWYgKGlzTW9kRXhwKSB7XHJcbiAgICAgICAgICB4ID0geC5tb2QobSk7ICAgIC8veCA9IHgubWludXMoZGl2KHgsIG0sIDAsIE1PRFVMT19NT0RFKS50aW1lcyhtKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaXNNb2RFeHApIHJldHVybiB5O1xyXG4gICAgICBpZiAobklzTmVnKSB5ID0gT05FLmRpdih5KTtcclxuXHJcbiAgICAgIHJldHVybiBtID8geS5tb2QobSkgOiBrID8gcm91bmQoeSwgUE9XX1BSRUNJU0lPTiwgUk9VTkRJTkdfTU9ERSwgbW9yZSkgOiB5O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJvdW5kZWQgdG8gYW4gaW50ZWdlclxyXG4gICAgICogdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3IgUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3JtfSdcclxuICAgICAqL1xyXG4gICAgUC5pbnRlZ2VyVmFsdWUgPSBmdW5jdGlvbiAocm0pIHtcclxuICAgICAgdmFyIG4gPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuICAgICAgcmV0dXJuIHJvdW5kKG4sIG4uZSArIDEsIHJtKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZXF1YWwgdG8gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNFcXVhbFRvID0gUC5lcSA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpID09PSAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBhIGZpbml0ZSBudW1iZXIsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNGaW5pdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAhIXRoaXMuYztcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzR3JlYXRlclRoYW4gPSBQLmd0ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkgPiAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYiksIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNHcmVhdGVyVGhhbk9yRXF1YWxUbyA9IFAuZ3RlID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIChiID0gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSkgPT09IDEgfHwgYiA9PT0gMDtcclxuXHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGFuIGludGVnZXIsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNJbnRlZ2VyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gISF0aGlzLmMgJiYgYml0Rmxvb3IodGhpcy5lIC8gTE9HX0JBU0UpID4gdGhpcy5jLmxlbmd0aCAtIDI7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0xlc3NUaGFuID0gUC5sdCA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpIDwgMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzTGVzc1RoYW5PckVxdWFsVG8gPSBQLmx0ZSA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiAoYiA9IGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkpID09PSAtMSB8fCBiID09PSAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBOYU4sIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNOYU4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAhdGhpcy5zO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBuZWdhdGl2ZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc05lZ2F0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5zIDwgMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgcG9zaXRpdmUsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNQb3NpdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucyA+IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIDAgb3IgLTAsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gISF0aGlzLmMgJiYgdGhpcy5jWzBdID09IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIG4gLSAwID0gblxyXG4gICAgICogIG4gLSBOID0gTlxyXG4gICAgICogIG4gLSBJID0gLUlcclxuICAgICAqICAwIC0gbiA9IC1uXHJcbiAgICAgKiAgMCAtIDAgPSAwXHJcbiAgICAgKiAgMCAtIE4gPSBOXHJcbiAgICAgKiAgMCAtIEkgPSAtSVxyXG4gICAgICogIE4gLSBuID0gTlxyXG4gICAgICogIE4gLSAwID0gTlxyXG4gICAgICogIE4gLSBOID0gTlxyXG4gICAgICogIE4gLSBJID0gTlxyXG4gICAgICogIEkgLSBuID0gSVxyXG4gICAgICogIEkgLSAwID0gSVxyXG4gICAgICogIEkgLSBOID0gTlxyXG4gICAgICogIEkgLSBJID0gTlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG1pbnVzIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICovXHJcbiAgICBQLm1pbnVzID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgdmFyIGksIGosIHQsIHhMVHksXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgYSA9IHgucztcclxuXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpO1xyXG4gICAgICBiID0geS5zO1xyXG5cclxuICAgICAgLy8gRWl0aGVyIE5hTj9cclxuICAgICAgaWYgKCFhIHx8ICFiKSByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgICBpZiAoYSAhPSBiKSB7XHJcbiAgICAgICAgeS5zID0gLWI7XHJcbiAgICAgICAgcmV0dXJuIHgucGx1cyh5KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHhlID0geC5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgeWUgPSB5LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICB5YyA9IHkuYztcclxuXHJcbiAgICAgIGlmICgheGUgfHwgIXllKSB7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciBJbmZpbml0eT9cclxuICAgICAgICBpZiAoIXhjIHx8ICF5YykgcmV0dXJuIHhjID8gKHkucyA9IC1iLCB5KSA6IG5ldyBCaWdOdW1iZXIoeWMgPyB4IDogTmFOKTtcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICAgICAgaWYgKCF4Y1swXSB8fCAheWNbMF0pIHtcclxuXHJcbiAgICAgICAgICAvLyBSZXR1cm4geSBpZiB5IGlzIG5vbi16ZXJvLCB4IGlmIHggaXMgbm9uLXplcm8sIG9yIHplcm8gaWYgYm90aCBhcmUgemVyby5cclxuICAgICAgICAgIHJldHVybiB5Y1swXSA/ICh5LnMgPSAtYiwgeSkgOiBuZXcgQmlnTnVtYmVyKHhjWzBdID8geCA6XHJcblxyXG4gICAgICAgICAgIC8vIElFRUUgNzU0ICgyMDA4KSA2LjM6IG4gLSBuID0gLTAgd2hlbiByb3VuZGluZyB0byAtSW5maW5pdHlcclxuICAgICAgICAgICBST1VORElOR19NT0RFID09IDMgPyAtMCA6IDApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgeGUgPSBiaXRGbG9vcih4ZSk7XHJcbiAgICAgIHllID0gYml0Rmxvb3IoeWUpO1xyXG4gICAgICB4YyA9IHhjLnNsaWNlKCk7XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggaXMgdGhlIGJpZ2dlciBudW1iZXIuXHJcbiAgICAgIGlmIChhID0geGUgLSB5ZSkge1xyXG5cclxuICAgICAgICBpZiAoeExUeSA9IGEgPCAwKSB7XHJcbiAgICAgICAgICBhID0gLWE7XHJcbiAgICAgICAgICB0ID0geGM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHllID0geGU7XHJcbiAgICAgICAgICB0ID0geWM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuXHJcbiAgICAgICAgLy8gUHJlcGVuZCB6ZXJvcyB0byBlcXVhbGlzZSBleHBvbmVudHMuXHJcbiAgICAgICAgZm9yIChiID0gYTsgYi0tOyB0LnB1c2goMCkpO1xyXG4gICAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBFeHBvbmVudHMgZXF1YWwuIENoZWNrIGRpZ2l0IGJ5IGRpZ2l0LlxyXG4gICAgICAgIGogPSAoeExUeSA9IChhID0geGMubGVuZ3RoKSA8IChiID0geWMubGVuZ3RoKSkgPyBhIDogYjtcclxuXHJcbiAgICAgICAgZm9yIChhID0gYiA9IDA7IGIgPCBqOyBiKyspIHtcclxuXHJcbiAgICAgICAgICBpZiAoeGNbYl0gIT0geWNbYl0pIHtcclxuICAgICAgICAgICAgeExUeSA9IHhjW2JdIDwgeWNbYl07XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8geCA8IHk/IFBvaW50IHhjIHRvIHRoZSBhcnJheSBvZiB0aGUgYmlnZ2VyIG51bWJlci5cclxuICAgICAgaWYgKHhMVHkpIHtcclxuICAgICAgICB0ID0geGM7XHJcbiAgICAgICAgeGMgPSB5YztcclxuICAgICAgICB5YyA9IHQ7XHJcbiAgICAgICAgeS5zID0gLXkucztcclxuICAgICAgfVxyXG5cclxuICAgICAgYiA9IChqID0geWMubGVuZ3RoKSAtIChpID0geGMubGVuZ3RoKTtcclxuXHJcbiAgICAgIC8vIEFwcGVuZCB6ZXJvcyB0byB4YyBpZiBzaG9ydGVyLlxyXG4gICAgICAvLyBObyBuZWVkIHRvIGFkZCB6ZXJvcyB0byB5YyBpZiBzaG9ydGVyIGFzIHN1YnRyYWN0IG9ubHkgbmVlZHMgdG8gc3RhcnQgYXQgeWMubGVuZ3RoLlxyXG4gICAgICBpZiAoYiA+IDApIGZvciAoOyBiLS07IHhjW2krK10gPSAwKTtcclxuICAgICAgYiA9IEJBU0UgLSAxO1xyXG5cclxuICAgICAgLy8gU3VidHJhY3QgeWMgZnJvbSB4Yy5cclxuICAgICAgZm9yICg7IGogPiBhOykge1xyXG5cclxuICAgICAgICBpZiAoeGNbLS1qXSA8IHljW2pdKSB7XHJcbiAgICAgICAgICBmb3IgKGkgPSBqOyBpICYmICF4Y1stLWldOyB4Y1tpXSA9IGIpO1xyXG4gICAgICAgICAgLS14Y1tpXTtcclxuICAgICAgICAgIHhjW2pdICs9IEJBU0U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4Y1tqXSAtPSB5Y1tqXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgemVyb3MgYW5kIGFkanVzdCBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICAgICAgZm9yICg7IHhjWzBdID09IDA7IHhjLnNwbGljZSgwLCAxKSwgLS15ZSk7XHJcblxyXG4gICAgICAvLyBaZXJvP1xyXG4gICAgICBpZiAoIXhjWzBdKSB7XHJcblxyXG4gICAgICAgIC8vIEZvbGxvd2luZyBJRUVFIDc1NCAoMjAwOCkgNi4zLFxyXG4gICAgICAgIC8vIG4gLSBuID0gKzAgIGJ1dCAgbiAtIG4gPSAtMCAgd2hlbiByb3VuZGluZyB0b3dhcmRzIC1JbmZpbml0eS5cclxuICAgICAgICB5LnMgPSBST1VORElOR19NT0RFID09IDMgPyAtMSA6IDE7XHJcbiAgICAgICAgeS5jID0gW3kuZSA9IDBdO1xyXG4gICAgICAgIHJldHVybiB5O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIGZvciBJbmZpbml0eSBhcyAreCAtICt5ICE9IEluZmluaXR5ICYmIC14IC0gLXkgIT0gSW5maW5pdHlcclxuICAgICAgLy8gZm9yIGZpbml0ZSB4IGFuZCB5LlxyXG4gICAgICByZXR1cm4gbm9ybWFsaXNlKHksIHhjLCB5ZSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogICBuICUgMCA9ICBOXHJcbiAgICAgKiAgIG4gJSBOID0gIE5cclxuICAgICAqICAgbiAlIEkgPSAgblxyXG4gICAgICogICAwICUgbiA9ICAwXHJcbiAgICAgKiAgLTAgJSBuID0gLTBcclxuICAgICAqICAgMCAlIDAgPSAgTlxyXG4gICAgICogICAwICUgTiA9ICBOXHJcbiAgICAgKiAgIDAgJSBJID0gIDBcclxuICAgICAqICAgTiAlIG4gPSAgTlxyXG4gICAgICogICBOICUgMCA9ICBOXHJcbiAgICAgKiAgIE4gJSBOID0gIE5cclxuICAgICAqICAgTiAlIEkgPSAgTlxyXG4gICAgICogICBJICUgbiA9ICBOXHJcbiAgICAgKiAgIEkgJSAwID0gIE5cclxuICAgICAqICAgSSAlIE4gPSAgTlxyXG4gICAgICogICBJICUgSSA9ICBOXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbW9kdWxvIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLiBUaGUgcmVzdWx0IGRlcGVuZHMgb24gdGhlIHZhbHVlIG9mIE1PRFVMT19NT0RFLlxyXG4gICAgICovXHJcbiAgICBQLm1vZHVsbyA9IFAubW9kID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgdmFyIHEsIHMsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICB5ID0gbmV3IEJpZ051bWJlcih5LCBiKTtcclxuXHJcbiAgICAgIC8vIFJldHVybiBOYU4gaWYgeCBpcyBJbmZpbml0eSBvciBOYU4sIG9yIHkgaXMgTmFOIG9yIHplcm8uXHJcbiAgICAgIGlmICgheC5jIHx8ICF5LnMgfHwgeS5jICYmICF5LmNbMF0pIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgLy8gUmV0dXJuIHggaWYgeSBpcyBJbmZpbml0eSBvciB4IGlzIHplcm8uXHJcbiAgICAgIH0gZWxzZSBpZiAoIXkuYyB8fCB4LmMgJiYgIXguY1swXSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoTU9EVUxPX01PREUgPT0gOSkge1xyXG5cclxuICAgICAgICAvLyBFdWNsaWRpYW4gZGl2aXNpb246IHEgPSBzaWduKHkpICogZmxvb3IoeCAvIGFicyh5KSlcclxuICAgICAgICAvLyByID0geCAtIHF5ICAgIHdoZXJlICAwIDw9IHIgPCBhYnMoeSlcclxuICAgICAgICBzID0geS5zO1xyXG4gICAgICAgIHkucyA9IDE7XHJcbiAgICAgICAgcSA9IGRpdih4LCB5LCAwLCAzKTtcclxuICAgICAgICB5LnMgPSBzO1xyXG4gICAgICAgIHEucyAqPSBzO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHEgPSBkaXYoeCwgeSwgMCwgTU9EVUxPX01PREUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB5ID0geC5taW51cyhxLnRpbWVzKHkpKTtcclxuXHJcbiAgICAgIC8vIFRvIG1hdGNoIEphdmFTY3JpcHQgJSwgZW5zdXJlIHNpZ24gb2YgemVybyBpcyBzaWduIG9mIGRpdmlkZW5kLlxyXG4gICAgICBpZiAoIXkuY1swXSAmJiBNT0RVTE9fTU9ERSA9PSAxKSB5LnMgPSB4LnM7XHJcblxyXG4gICAgICByZXR1cm4geTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiAqIDAgPSAwXHJcbiAgICAgKiAgbiAqIE4gPSBOXHJcbiAgICAgKiAgbiAqIEkgPSBJXHJcbiAgICAgKiAgMCAqIG4gPSAwXHJcbiAgICAgKiAgMCAqIDAgPSAwXHJcbiAgICAgKiAgMCAqIE4gPSBOXHJcbiAgICAgKiAgMCAqIEkgPSBOXHJcbiAgICAgKiAgTiAqIG4gPSBOXHJcbiAgICAgKiAgTiAqIDAgPSBOXHJcbiAgICAgKiAgTiAqIE4gPSBOXHJcbiAgICAgKiAgTiAqIEkgPSBOXHJcbiAgICAgKiAgSSAqIG4gPSBJXHJcbiAgICAgKiAgSSAqIDAgPSBOXHJcbiAgICAgKiAgSSAqIE4gPSBOXHJcbiAgICAgKiAgSSAqIEkgPSBJXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbXVsdGlwbGllZCBieSB0aGUgdmFsdWVcclxuICAgICAqIG9mIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAqL1xyXG4gICAgUC5tdWx0aXBsaWVkQnkgPSBQLnRpbWVzID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgdmFyIGMsIGUsIGksIGosIGssIG0sIHhjTCwgeGxvLCB4aGksIHljTCwgeWxvLCB5aGksIHpjLFxyXG4gICAgICAgIGJhc2UsIHNxcnRCYXNlLFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHljID0gKHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpKS5jO1xyXG5cclxuICAgICAgLy8gRWl0aGVyIE5hTiwgwrFJbmZpbml0eSBvciDCsTA/XHJcbiAgICAgIGlmICgheGMgfHwgIXljIHx8ICF4Y1swXSB8fCAheWNbMF0pIHtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIE5hTiBpZiBlaXRoZXIgaXMgTmFOLCBvciBvbmUgaXMgMCBhbmQgdGhlIG90aGVyIGlzIEluZmluaXR5LlxyXG4gICAgICAgIGlmICgheC5zIHx8ICF5LnMgfHwgeGMgJiYgIXhjWzBdICYmICF5YyB8fCB5YyAmJiAheWNbMF0gJiYgIXhjKSB7XHJcbiAgICAgICAgICB5LmMgPSB5LmUgPSB5LnMgPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB5LnMgKj0geC5zO1xyXG5cclxuICAgICAgICAgIC8vIFJldHVybiDCsUluZmluaXR5IGlmIGVpdGhlciBpcyDCsUluZmluaXR5LlxyXG4gICAgICAgICAgaWYgKCF4YyB8fCAheWMpIHtcclxuICAgICAgICAgICAgeS5jID0geS5lID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAvLyBSZXR1cm4gwrEwIGlmIGVpdGhlciBpcyDCsTAuXHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB5LmMgPSBbMF07XHJcbiAgICAgICAgICAgIHkuZSA9IDA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4geTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZSA9IGJpdEZsb29yKHguZSAvIExPR19CQVNFKSArIGJpdEZsb29yKHkuZSAvIExPR19CQVNFKTtcclxuICAgICAgeS5zICo9IHgucztcclxuICAgICAgeGNMID0geGMubGVuZ3RoO1xyXG4gICAgICB5Y0wgPSB5Yy5sZW5ndGg7XHJcblxyXG4gICAgICAvLyBFbnN1cmUgeGMgcG9pbnRzIHRvIGxvbmdlciBhcnJheSBhbmQgeGNMIHRvIGl0cyBsZW5ndGguXHJcbiAgICAgIGlmICh4Y0wgPCB5Y0wpIHtcclxuICAgICAgICB6YyA9IHhjO1xyXG4gICAgICAgIHhjID0geWM7XHJcbiAgICAgICAgeWMgPSB6YztcclxuICAgICAgICBpID0geGNMO1xyXG4gICAgICAgIHhjTCA9IHljTDtcclxuICAgICAgICB5Y0wgPSBpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJbml0aWFsaXNlIHRoZSByZXN1bHQgYXJyYXkgd2l0aCB6ZXJvcy5cclxuICAgICAgZm9yIChpID0geGNMICsgeWNMLCB6YyA9IFtdOyBpLS07IHpjLnB1c2goMCkpO1xyXG5cclxuICAgICAgYmFzZSA9IEJBU0U7XHJcbiAgICAgIHNxcnRCYXNlID0gU1FSVF9CQVNFO1xyXG5cclxuICAgICAgZm9yIChpID0geWNMOyAtLWkgPj0gMDspIHtcclxuICAgICAgICBjID0gMDtcclxuICAgICAgICB5bG8gPSB5Y1tpXSAlIHNxcnRCYXNlO1xyXG4gICAgICAgIHloaSA9IHljW2ldIC8gc3FydEJhc2UgfCAwO1xyXG5cclxuICAgICAgICBmb3IgKGsgPSB4Y0wsIGogPSBpICsgazsgaiA+IGk7KSB7XHJcbiAgICAgICAgICB4bG8gPSB4Y1stLWtdICUgc3FydEJhc2U7XHJcbiAgICAgICAgICB4aGkgPSB4Y1trXSAvIHNxcnRCYXNlIHwgMDtcclxuICAgICAgICAgIG0gPSB5aGkgKiB4bG8gKyB4aGkgKiB5bG87XHJcbiAgICAgICAgICB4bG8gPSB5bG8gKiB4bG8gKyAoKG0gJSBzcXJ0QmFzZSkgKiBzcXJ0QmFzZSkgKyB6Y1tqXSArIGM7XHJcbiAgICAgICAgICBjID0gKHhsbyAvIGJhc2UgfCAwKSArIChtIC8gc3FydEJhc2UgfCAwKSArIHloaSAqIHhoaTtcclxuICAgICAgICAgIHpjW2otLV0gPSB4bG8gJSBiYXNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgemNbal0gPSBjO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoYykge1xyXG4gICAgICAgICsrZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB6Yy5zcGxpY2UoMCwgMSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBub3JtYWxpc2UoeSwgemMsIGUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG5lZ2F0ZWQsXHJcbiAgICAgKiBpLmUuIG11bHRpcGxpZWQgYnkgLTEuXHJcbiAgICAgKi9cclxuICAgIFAubmVnYXRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHggPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgICB4LnMgPSAteC5zIHx8IG51bGw7XHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBuICsgMCA9IG5cclxuICAgICAqICBuICsgTiA9IE5cclxuICAgICAqICBuICsgSSA9IElcclxuICAgICAqICAwICsgbiA9IG5cclxuICAgICAqICAwICsgMCA9IDBcclxuICAgICAqICAwICsgTiA9IE5cclxuICAgICAqICAwICsgSSA9IElcclxuICAgICAqICBOICsgbiA9IE5cclxuICAgICAqICBOICsgMCA9IE5cclxuICAgICAqICBOICsgTiA9IE5cclxuICAgICAqICBOICsgSSA9IE5cclxuICAgICAqICBJICsgbiA9IElcclxuICAgICAqICBJICsgMCA9IElcclxuICAgICAqICBJICsgTiA9IE5cclxuICAgICAqICBJICsgSSA9IElcclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBwbHVzIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICovXHJcbiAgICBQLnBsdXMgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICB2YXIgdCxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICBhID0geC5zO1xyXG5cclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoeSwgYik7XHJcbiAgICAgIGIgPSB5LnM7XHJcblxyXG4gICAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgICBpZiAoIWEgfHwgIWIpIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICAgICBpZiAoYSAhPSBiKSB7XHJcbiAgICAgICAgeS5zID0gLWI7XHJcbiAgICAgICAgcmV0dXJuIHgubWludXMoeSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciB4ZSA9IHguZSAvIExPR19CQVNFLFxyXG4gICAgICAgIHllID0geS5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgeWMgPSB5LmM7XHJcblxyXG4gICAgICBpZiAoIXhlIHx8ICF5ZSkge1xyXG5cclxuICAgICAgICAvLyBSZXR1cm4gwrFJbmZpbml0eSBpZiBlaXRoZXIgwrFJbmZpbml0eS5cclxuICAgICAgICBpZiAoIXhjIHx8ICF5YykgcmV0dXJuIG5ldyBCaWdOdW1iZXIoYSAvIDApO1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgemVybz9cclxuICAgICAgICAvLyBSZXR1cm4geSBpZiB5IGlzIG5vbi16ZXJvLCB4IGlmIHggaXMgbm9uLXplcm8sIG9yIHplcm8gaWYgYm90aCBhcmUgemVyby5cclxuICAgICAgICBpZiAoIXhjWzBdIHx8ICF5Y1swXSkgcmV0dXJuIHljWzBdID8geSA6IG5ldyBCaWdOdW1iZXIoeGNbMF0gPyB4IDogYSAqIDApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB4ZSA9IGJpdEZsb29yKHhlKTtcclxuICAgICAgeWUgPSBiaXRGbG9vcih5ZSk7XHJcbiAgICAgIHhjID0geGMuc2xpY2UoKTtcclxuXHJcbiAgICAgIC8vIFByZXBlbmQgemVyb3MgdG8gZXF1YWxpc2UgZXhwb25lbnRzLiBGYXN0ZXIgdG8gdXNlIHJldmVyc2UgdGhlbiBkbyB1bnNoaWZ0cy5cclxuICAgICAgaWYgKGEgPSB4ZSAtIHllKSB7XHJcbiAgICAgICAgaWYgKGEgPiAwKSB7XHJcbiAgICAgICAgICB5ZSA9IHhlO1xyXG4gICAgICAgICAgdCA9IHljO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBhID0gLWE7XHJcbiAgICAgICAgICB0ID0geGM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuICAgICAgICBmb3IgKDsgYS0tOyB0LnB1c2goMCkpO1xyXG4gICAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhID0geGMubGVuZ3RoO1xyXG4gICAgICBiID0geWMubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gUG9pbnQgeGMgdG8gdGhlIGxvbmdlciBhcnJheSwgYW5kIGIgdG8gdGhlIHNob3J0ZXIgbGVuZ3RoLlxyXG4gICAgICBpZiAoYSAtIGIgPCAwKSB7XHJcbiAgICAgICAgdCA9IHljO1xyXG4gICAgICAgIHljID0geGM7XHJcbiAgICAgICAgeGMgPSB0O1xyXG4gICAgICAgIGIgPSBhO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBPbmx5IHN0YXJ0IGFkZGluZyBhdCB5Yy5sZW5ndGggLSAxIGFzIHRoZSBmdXJ0aGVyIGRpZ2l0cyBvZiB4YyBjYW4gYmUgaWdub3JlZC5cclxuICAgICAgZm9yIChhID0gMDsgYjspIHtcclxuICAgICAgICBhID0gKHhjWy0tYl0gPSB4Y1tiXSArIHljW2JdICsgYSkgLyBCQVNFIHwgMDtcclxuICAgICAgICB4Y1tiXSA9IEJBU0UgPT09IHhjW2JdID8gMCA6IHhjW2JdICUgQkFTRTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGEpIHtcclxuICAgICAgICB4YyA9IFthXS5jb25jYXQoeGMpO1xyXG4gICAgICAgICsreWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgZm9yIHplcm8sIGFzICt4ICsgK3kgIT0gMCAmJiAteCArIC15ICE9IDBcclxuICAgICAgLy8geWUgPSBNQVhfRVhQICsgMSBwb3NzaWJsZVxyXG4gICAgICByZXR1cm4gbm9ybWFsaXNlKHksIHhjLCB5ZSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogSWYgc2QgaXMgdW5kZWZpbmVkIG9yIG51bGwgb3IgdHJ1ZSBvciBmYWxzZSwgcmV0dXJuIHRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIG9mXHJcbiAgICAgKiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIsIG9yIG51bGwgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIMKxSW5maW5pdHkgb3IgTmFOLlxyXG4gICAgICogSWYgc2QgaXMgdHJ1ZSBpbmNsdWRlIGludGVnZXItcGFydCB0cmFpbGluZyB6ZXJvcyBpbiB0aGUgY291bnQuXHJcbiAgICAgKlxyXG4gICAgICogT3RoZXJ3aXNlLCBpZiBzZCBpcyBhIG51bWJlciwgcmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpc1xyXG4gICAgICogQmlnTnVtYmVyIHJvdW5kZWQgdG8gYSBtYXhpbXVtIG9mIHNkIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvclxyXG4gICAgICogUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIHNkIHtudW1iZXJ8Ym9vbGVhbn0gbnVtYmVyOiBzaWduaWZpY2FudCBkaWdpdHM6IGludGVnZXIsIDEgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgYm9vbGVhbjogd2hldGhlciB0byBjb3VudCBpbnRlZ2VyLXBhcnQgdHJhaWxpbmcgemVyb3M6IHRydWUgb3IgZmFsc2UuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtzZHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAucHJlY2lzaW9uID0gUC5zZCA9IGZ1bmN0aW9uIChzZCwgcm0pIHtcclxuICAgICAgdmFyIGMsIG4sIHYsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICBpZiAoc2QgIT0gbnVsbCAmJiBzZCAhPT0gISFzZCkge1xyXG4gICAgICAgIGludENoZWNrKHNkLCAxLCBNQVgpO1xyXG4gICAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcblxyXG4gICAgICAgIHJldHVybiByb3VuZChuZXcgQmlnTnVtYmVyKHgpLCBzZCwgcm0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIShjID0geC5jKSkgcmV0dXJuIG51bGw7XHJcbiAgICAgIHYgPSBjLmxlbmd0aCAtIDE7XHJcbiAgICAgIG4gPSB2ICogTE9HX0JBU0UgKyAxO1xyXG5cclxuICAgICAgaWYgKHYgPSBjW3ZdKSB7XHJcblxyXG4gICAgICAgIC8vIFN1YnRyYWN0IHRoZSBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3Mgb2YgdGhlIGxhc3QgZWxlbWVudC5cclxuICAgICAgICBmb3IgKDsgdiAlIDEwID09IDA7IHYgLz0gMTAsIG4tLSk7XHJcblxyXG4gICAgICAgIC8vIEFkZCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiB0aGUgZmlyc3QgZWxlbWVudC5cclxuICAgICAgICBmb3IgKHYgPSBjWzBdOyB2ID49IDEwOyB2IC89IDEwLCBuKyspO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc2QgJiYgeC5lICsgMSA+IG4pIG4gPSB4LmUgKyAxO1xyXG5cclxuICAgICAgcmV0dXJuIG47XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgc2hpZnRlZCBieSBrIHBsYWNlc1xyXG4gICAgICogKHBvd2VycyBvZiAxMCkuIFNoaWZ0IHRvIHRoZSByaWdodCBpZiBuID4gMCwgYW5kIHRvIHRoZSBsZWZ0IGlmIG4gPCAwLlxyXG4gICAgICpcclxuICAgICAqIGsge251bWJlcn0gSW50ZWdlciwgLU1BWF9TQUZFX0lOVEVHRVIgdG8gTUFYX1NBRkVfSU5URUdFUiBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtrfSdcclxuICAgICAqL1xyXG4gICAgUC5zaGlmdGVkQnkgPSBmdW5jdGlvbiAoaykge1xyXG4gICAgICBpbnRDaGVjayhrLCAtTUFYX1NBRkVfSU5URUdFUiwgTUFYX1NBRkVfSU5URUdFUik7XHJcbiAgICAgIHJldHVybiB0aGlzLnRpbWVzKCcxZScgKyBrKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgc3FydCgtbikgPSAgTlxyXG4gICAgICogIHNxcnQoTikgPSAgTlxyXG4gICAgICogIHNxcnQoLUkpID0gIE5cclxuICAgICAqICBzcXJ0KEkpID0gIElcclxuICAgICAqICBzcXJ0KDApID0gIDBcclxuICAgICAqICBzcXJ0KC0wKSA9IC0wXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgc3F1YXJlIHJvb3Qgb2YgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLFxyXG4gICAgICogcm91bmRlZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICAgKi9cclxuICAgIFAuc3F1YXJlUm9vdCA9IFAuc3FydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIG0sIG4sIHIsIHJlcCwgdCxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICBjID0geC5jLFxyXG4gICAgICAgIHMgPSB4LnMsXHJcbiAgICAgICAgZSA9IHguZSxcclxuICAgICAgICBkcCA9IERFQ0lNQUxfUExBQ0VTICsgNCxcclxuICAgICAgICBoYWxmID0gbmV3IEJpZ051bWJlcignMC41Jyk7XHJcblxyXG4gICAgICAvLyBOZWdhdGl2ZS9OYU4vSW5maW5pdHkvemVybz9cclxuICAgICAgaWYgKHMgIT09IDEgfHwgIWMgfHwgIWNbMF0pIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcighcyB8fCBzIDwgMCAmJiAoIWMgfHwgY1swXSkgPyBOYU4gOiBjID8geCA6IDEgLyAwKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSW5pdGlhbCBlc3RpbWF0ZS5cclxuICAgICAgcyA9IE1hdGguc3FydCgrdmFsdWVPZih4KSk7XHJcblxyXG4gICAgICAvLyBNYXRoLnNxcnQgdW5kZXJmbG93L292ZXJmbG93P1xyXG4gICAgICAvLyBQYXNzIHggdG8gTWF0aC5zcXJ0IGFzIGludGVnZXIsIHRoZW4gYWRqdXN0IHRoZSBleHBvbmVudCBvZiB0aGUgcmVzdWx0LlxyXG4gICAgICBpZiAocyA9PSAwIHx8IHMgPT0gMSAvIDApIHtcclxuICAgICAgICBuID0gY29lZmZUb1N0cmluZyhjKTtcclxuICAgICAgICBpZiAoKG4ubGVuZ3RoICsgZSkgJSAyID09IDApIG4gKz0gJzAnO1xyXG4gICAgICAgIHMgPSBNYXRoLnNxcnQoK24pO1xyXG4gICAgICAgIGUgPSBiaXRGbG9vcigoZSArIDEpIC8gMikgLSAoZSA8IDAgfHwgZSAlIDIpO1xyXG5cclxuICAgICAgICBpZiAocyA9PSAxIC8gMCkge1xyXG4gICAgICAgICAgbiA9ICc1ZScgKyBlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuID0gcy50b0V4cG9uZW50aWFsKCk7XHJcbiAgICAgICAgICBuID0gbi5zbGljZSgwLCBuLmluZGV4T2YoJ2UnKSArIDEpICsgZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHIgPSBuZXcgQmlnTnVtYmVyKG4pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHIgPSBuZXcgQmlnTnVtYmVyKHMgKyAnJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENoZWNrIGZvciB6ZXJvLlxyXG4gICAgICAvLyByIGNvdWxkIGJlIHplcm8gaWYgTUlOX0VYUCBpcyBjaGFuZ2VkIGFmdGVyIHRoZSB0aGlzIHZhbHVlIHdhcyBjcmVhdGVkLlxyXG4gICAgICAvLyBUaGlzIHdvdWxkIGNhdXNlIGEgZGl2aXNpb24gYnkgemVybyAoeC90KSBhbmQgaGVuY2UgSW5maW5pdHkgYmVsb3csIHdoaWNoIHdvdWxkIGNhdXNlXHJcbiAgICAgIC8vIGNvZWZmVG9TdHJpbmcgdG8gdGhyb3cuXHJcbiAgICAgIGlmIChyLmNbMF0pIHtcclxuICAgICAgICBlID0gci5lO1xyXG4gICAgICAgIHMgPSBlICsgZHA7XHJcbiAgICAgICAgaWYgKHMgPCAzKSBzID0gMDtcclxuXHJcbiAgICAgICAgLy8gTmV3dG9uLVJhcGhzb24gaXRlcmF0aW9uLlxyXG4gICAgICAgIGZvciAoOyA7KSB7XHJcbiAgICAgICAgICB0ID0gcjtcclxuICAgICAgICAgIHIgPSBoYWxmLnRpbWVzKHQucGx1cyhkaXYoeCwgdCwgZHAsIDEpKSk7XHJcblxyXG4gICAgICAgICAgaWYgKGNvZWZmVG9TdHJpbmcodC5jKS5zbGljZSgwLCBzKSA9PT0gKG4gPSBjb2VmZlRvU3RyaW5nKHIuYykpLnNsaWNlKDAsIHMpKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgZXhwb25lbnQgb2YgciBtYXkgaGVyZSBiZSBvbmUgbGVzcyB0aGFuIHRoZSBmaW5hbCByZXN1bHQgZXhwb25lbnQsXHJcbiAgICAgICAgICAgIC8vIGUuZyAwLjAwMDk5OTkgKGUtNCkgLS0+IDAuMDAxIChlLTMpLCBzbyBhZGp1c3QgcyBzbyB0aGUgcm91bmRpbmcgZGlnaXRzXHJcbiAgICAgICAgICAgIC8vIGFyZSBpbmRleGVkIGNvcnJlY3RseS5cclxuICAgICAgICAgICAgaWYgKHIuZSA8IGUpIC0tcztcclxuICAgICAgICAgICAgbiA9IG4uc2xpY2UocyAtIDMsIHMgKyAxKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSA0dGggcm91bmRpbmcgZGlnaXQgbWF5IGJlIGluIGVycm9yIGJ5IC0xIHNvIGlmIHRoZSA0IHJvdW5kaW5nIGRpZ2l0c1xyXG4gICAgICAgICAgICAvLyBhcmUgOTk5OSBvciA0OTk5IChpLmUuIGFwcHJvYWNoaW5nIGEgcm91bmRpbmcgYm91bmRhcnkpIGNvbnRpbnVlIHRoZVxyXG4gICAgICAgICAgICAvLyBpdGVyYXRpb24uXHJcbiAgICAgICAgICAgIGlmIChuID09ICc5OTk5JyB8fCAhcmVwICYmIG4gPT0gJzQ5OTknKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIE9uIHRoZSBmaXJzdCBpdGVyYXRpb24gb25seSwgY2hlY2sgdG8gc2VlIGlmIHJvdW5kaW5nIHVwIGdpdmVzIHRoZVxyXG4gICAgICAgICAgICAgIC8vIGV4YWN0IHJlc3VsdCBhcyB0aGUgbmluZXMgbWF5IGluZmluaXRlbHkgcmVwZWF0LlxyXG4gICAgICAgICAgICAgIGlmICghcmVwKSB7XHJcbiAgICAgICAgICAgICAgICByb3VuZCh0LCB0LmUgKyBERUNJTUFMX1BMQUNFUyArIDIsIDApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0LnRpbWVzKHQpLmVxKHgpKSB7XHJcbiAgICAgICAgICAgICAgICAgIHIgPSB0O1xyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGRwICs9IDQ7XHJcbiAgICAgICAgICAgICAgcyArPSA0O1xyXG4gICAgICAgICAgICAgIHJlcCA9IDE7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIElmIHJvdW5kaW5nIGRpZ2l0cyBhcmUgbnVsbCwgMHswLDR9IG9yIDUwezAsM30sIGNoZWNrIGZvciBleGFjdFxyXG4gICAgICAgICAgICAgIC8vIHJlc3VsdC4gSWYgbm90LCB0aGVuIHRoZXJlIGFyZSBmdXJ0aGVyIGRpZ2l0cyBhbmQgbSB3aWxsIGJlIHRydXRoeS5cclxuICAgICAgICAgICAgICBpZiAoIStuIHx8ICErbi5zbGljZSgxKSAmJiBuLmNoYXJBdCgwKSA9PSAnNScpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUcnVuY2F0ZSB0byB0aGUgZmlyc3Qgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgICAgICAgICByb3VuZChyLCByLmUgKyBERUNJTUFMX1BMQUNFUyArIDIsIDEpO1xyXG4gICAgICAgICAgICAgICAgbSA9ICFyLnRpbWVzKHIpLmVxKHgpO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiByb3VuZChyLCByLmUgKyBERUNJTUFMX1BMQUNFUyArIDEsIFJPVU5ESU5HX01PREUsIG0pO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGV4cG9uZW50aWFsIG5vdGF0aW9uIGFuZFxyXG4gICAgICogcm91bmRlZCB1c2luZyBST1VORElOR19NT0RFIHRvIGRwIGZpeGVkIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC50b0V4cG9uZW50aWFsID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gICAgICBpZiAoZHAgIT0gbnVsbCkge1xyXG4gICAgICAgIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG4gICAgICAgIGRwKys7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZvcm1hdCh0aGlzLCBkcCwgcm0sIDEpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uIHJvdW5kaW5nXHJcbiAgICAgKiB0byBkcCBmaXhlZCBkZWNpbWFsIHBsYWNlcyB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvciBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogTm90ZTogYXMgd2l0aCBKYXZhU2NyaXB0J3MgbnVtYmVyIHR5cGUsICgtMCkudG9GaXhlZCgwKSBpcyAnMCcsXHJcbiAgICAgKiBidXQgZS5nLiAoLTAuMDAwMDEpLnRvRml4ZWQoMCkgaXMgJy0wJy5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAudG9GaXhlZCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICAgICAgaWYgKGRwICE9IG51bGwpIHtcclxuICAgICAgICBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuICAgICAgICBkcCA9IGRwICsgdGhpcy5lICsgMTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZm9ybWF0KHRoaXMsIGRwLCBybSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24gcm91bmRlZFxyXG4gICAgICogdXNpbmcgcm0gb3IgUk9VTkRJTkdfTU9ERSB0byBkcCBkZWNpbWFsIHBsYWNlcywgYW5kIGZvcm1hdHRlZCBhY2NvcmRpbmcgdG8gdGhlIHByb3BlcnRpZXNcclxuICAgICAqIG9mIHRoZSBmb3JtYXQgb3IgRk9STUFUIG9iamVjdCAoc2VlIEJpZ051bWJlci5zZXQpLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBmb3JtYXR0aW5nIG9iamVjdCBtYXkgY29udGFpbiBzb21lIG9yIGFsbCBvZiB0aGUgcHJvcGVydGllcyBzaG93biBiZWxvdy5cclxuICAgICAqXHJcbiAgICAgKiBGT1JNQVQgPSB7XHJcbiAgICAgKiAgIHByZWZpeDogJycsXHJcbiAgICAgKiAgIGdyb3VwU2l6ZTogMyxcclxuICAgICAqICAgc2Vjb25kYXJ5R3JvdXBTaXplOiAwLFxyXG4gICAgICogICBncm91cFNlcGFyYXRvcjogJywnLFxyXG4gICAgICogICBkZWNpbWFsU2VwYXJhdG9yOiAnLicsXHJcbiAgICAgKiAgIGZyYWN0aW9uR3JvdXBTaXplOiAwLFxyXG4gICAgICogICBmcmFjdGlvbkdyb3VwU2VwYXJhdG9yOiAnXFx4QTAnLCAgICAgIC8vIG5vbi1icmVha2luZyBzcGFjZVxyXG4gICAgICogICBzdWZmaXg6ICcnXHJcbiAgICAgKiB9O1xyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqIFtmb3JtYXRdIHtvYmplY3R9IEZvcm1hdHRpbmcgb3B0aW9ucy4gU2VlIEZPUk1BVCBwYmplY3QgYWJvdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQgbm90IGFuIG9iamVjdDoge2Zvcm1hdH0nXHJcbiAgICAgKi9cclxuICAgIFAudG9Gb3JtYXQgPSBmdW5jdGlvbiAoZHAsIHJtLCBmb3JtYXQpIHtcclxuICAgICAgdmFyIHN0cixcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xyXG4gICAgICAgIGlmIChkcCAhPSBudWxsICYmIHJtICYmIHR5cGVvZiBybSA9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgZm9ybWF0ID0gcm07XHJcbiAgICAgICAgICBybSA9IG51bGw7XHJcbiAgICAgICAgfSBlbHNlIGlmIChkcCAmJiB0eXBlb2YgZHAgPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgIGZvcm1hdCA9IGRwO1xyXG4gICAgICAgICAgZHAgPSBybSA9IG51bGw7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGZvcm1hdCA9IEZPUk1BVDtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZvcm1hdCAhPSAnb2JqZWN0Jykge1xyXG4gICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnQXJndW1lbnQgbm90IGFuIG9iamVjdDogJyArIGZvcm1hdCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHN0ciA9IHgudG9GaXhlZChkcCwgcm0pO1xyXG5cclxuICAgICAgaWYgKHguYykge1xyXG4gICAgICAgIHZhciBpLFxyXG4gICAgICAgICAgYXJyID0gc3RyLnNwbGl0KCcuJyksXHJcbiAgICAgICAgICBnMSA9ICtmb3JtYXQuZ3JvdXBTaXplLFxyXG4gICAgICAgICAgZzIgPSArZm9ybWF0LnNlY29uZGFyeUdyb3VwU2l6ZSxcclxuICAgICAgICAgIGdyb3VwU2VwYXJhdG9yID0gZm9ybWF0Lmdyb3VwU2VwYXJhdG9yIHx8ICcnLFxyXG4gICAgICAgICAgaW50UGFydCA9IGFyclswXSxcclxuICAgICAgICAgIGZyYWN0aW9uUGFydCA9IGFyclsxXSxcclxuICAgICAgICAgIGlzTmVnID0geC5zIDwgMCxcclxuICAgICAgICAgIGludERpZ2l0cyA9IGlzTmVnID8gaW50UGFydC5zbGljZSgxKSA6IGludFBhcnQsXHJcbiAgICAgICAgICBsZW4gPSBpbnREaWdpdHMubGVuZ3RoO1xyXG5cclxuICAgICAgICBpZiAoZzIpIHtcclxuICAgICAgICAgIGkgPSBnMTtcclxuICAgICAgICAgIGcxID0gZzI7XHJcbiAgICAgICAgICBnMiA9IGk7XHJcbiAgICAgICAgICBsZW4gLT0gaTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChnMSA+IDAgJiYgbGVuID4gMCkge1xyXG4gICAgICAgICAgaSA9IGxlbiAlIGcxIHx8IGcxO1xyXG4gICAgICAgICAgaW50UGFydCA9IGludERpZ2l0cy5zdWJzdHIoMCwgaSk7XHJcbiAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSArPSBnMSkgaW50UGFydCArPSBncm91cFNlcGFyYXRvciArIGludERpZ2l0cy5zdWJzdHIoaSwgZzEpO1xyXG4gICAgICAgICAgaWYgKGcyID4gMCkgaW50UGFydCArPSBncm91cFNlcGFyYXRvciArIGludERpZ2l0cy5zbGljZShpKTtcclxuICAgICAgICAgIGlmIChpc05lZykgaW50UGFydCA9ICctJyArIGludFBhcnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdHIgPSBmcmFjdGlvblBhcnRcclxuICAgICAgICAgPyBpbnRQYXJ0ICsgKGZvcm1hdC5kZWNpbWFsU2VwYXJhdG9yIHx8ICcnKSArICgoZzIgPSArZm9ybWF0LmZyYWN0aW9uR3JvdXBTaXplKVxyXG4gICAgICAgICAgPyBmcmFjdGlvblBhcnQucmVwbGFjZShuZXcgUmVnRXhwKCdcXFxcZHsnICsgZzIgKyAnfVxcXFxCJywgJ2cnKSxcclxuICAgICAgICAgICAnJCYnICsgKGZvcm1hdC5mcmFjdGlvbkdyb3VwU2VwYXJhdG9yIHx8ICcnKSlcclxuICAgICAgICAgIDogZnJhY3Rpb25QYXJ0KVxyXG4gICAgICAgICA6IGludFBhcnQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiAoZm9ybWF0LnByZWZpeCB8fCAnJykgKyBzdHIgKyAoZm9ybWF0LnN1ZmZpeCB8fCAnJyk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGFuIGFycmF5IG9mIHR3byBCaWdOdW1iZXJzIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgYXMgYSBzaW1wbGVcclxuICAgICAqIGZyYWN0aW9uIHdpdGggYW4gaW50ZWdlciBudW1lcmF0b3IgYW5kIGFuIGludGVnZXIgZGVub21pbmF0b3IuXHJcbiAgICAgKiBUaGUgZGVub21pbmF0b3Igd2lsbCBiZSBhIHBvc2l0aXZlIG5vbi16ZXJvIHZhbHVlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgc3BlY2lmaWVkXHJcbiAgICAgKiBtYXhpbXVtIGRlbm9taW5hdG9yLiBJZiBhIG1heGltdW0gZGVub21pbmF0b3IgaXMgbm90IHNwZWNpZmllZCwgdGhlIGRlbm9taW5hdG9yIHdpbGwgYmVcclxuICAgICAqIHRoZSBsb3dlc3QgdmFsdWUgbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgbnVtYmVyIGV4YWN0bHkuXHJcbiAgICAgKlxyXG4gICAgICogW21kXSB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IEludGVnZXIgPj0gMSwgb3IgSW5maW5pdHkuIFRoZSBtYXhpbXVtIGRlbm9taW5hdG9yLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfSA6IHttZH0nXHJcbiAgICAgKi9cclxuICAgIFAudG9GcmFjdGlvbiA9IGZ1bmN0aW9uIChtZCkge1xyXG4gICAgICB2YXIgZCwgZDAsIGQxLCBkMiwgZSwgZXhwLCBuLCBuMCwgbjEsIHEsIHIsIHMsXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgeGMgPSB4LmM7XHJcblxyXG4gICAgICBpZiAobWQgIT0gbnVsbCkge1xyXG4gICAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKG1kKTtcclxuXHJcbiAgICAgICAgLy8gVGhyb3cgaWYgbWQgaXMgbGVzcyB0aGFuIG9uZSBvciBpcyBub3QgYW4gaW50ZWdlciwgdW5sZXNzIGl0IGlzIEluZmluaXR5LlxyXG4gICAgICAgIGlmICghbi5pc0ludGVnZXIoKSAmJiAobi5jIHx8IG4ucyAhPT0gMSkgfHwgbi5sdChPTkUpKSB7XHJcbiAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnQXJndW1lbnQgJyArXHJcbiAgICAgICAgICAgICAgKG4uaXNJbnRlZ2VyKCkgPyAnb3V0IG9mIHJhbmdlOiAnIDogJ25vdCBhbiBpbnRlZ2VyOiAnKSArIHZhbHVlT2YobikpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCF4YykgcmV0dXJuIG5ldyBCaWdOdW1iZXIoeCk7XHJcblxyXG4gICAgICBkID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG4gICAgICBuMSA9IGQwID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG4gICAgICBkMSA9IG4wID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG4gICAgICBzID0gY29lZmZUb1N0cmluZyh4Yyk7XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgaW5pdGlhbCBkZW5vbWluYXRvci5cclxuICAgICAgLy8gZCBpcyBhIHBvd2VyIG9mIDEwIGFuZCB0aGUgbWluaW11bSBtYXggZGVub21pbmF0b3IgdGhhdCBzcGVjaWZpZXMgdGhlIHZhbHVlIGV4YWN0bHkuXHJcbiAgICAgIGUgPSBkLmUgPSBzLmxlbmd0aCAtIHguZSAtIDE7XHJcbiAgICAgIGQuY1swXSA9IFBPV1NfVEVOWyhleHAgPSBlICUgTE9HX0JBU0UpIDwgMCA/IExPR19CQVNFICsgZXhwIDogZXhwXTtcclxuICAgICAgbWQgPSAhbWQgfHwgbi5jb21wYXJlZFRvKGQpID4gMCA/IChlID4gMCA/IGQgOiBuMSkgOiBuO1xyXG5cclxuICAgICAgZXhwID0gTUFYX0VYUDtcclxuICAgICAgTUFYX0VYUCA9IDEgLyAwO1xyXG4gICAgICBuID0gbmV3IEJpZ051bWJlcihzKTtcclxuXHJcbiAgICAgIC8vIG4wID0gZDEgPSAwXHJcbiAgICAgIG4wLmNbMF0gPSAwO1xyXG5cclxuICAgICAgZm9yICg7IDspICB7XHJcbiAgICAgICAgcSA9IGRpdihuLCBkLCAwLCAxKTtcclxuICAgICAgICBkMiA9IGQwLnBsdXMocS50aW1lcyhkMSkpO1xyXG4gICAgICAgIGlmIChkMi5jb21wYXJlZFRvKG1kKSA9PSAxKSBicmVhaztcclxuICAgICAgICBkMCA9IGQxO1xyXG4gICAgICAgIGQxID0gZDI7XHJcbiAgICAgICAgbjEgPSBuMC5wbHVzKHEudGltZXMoZDIgPSBuMSkpO1xyXG4gICAgICAgIG4wID0gZDI7XHJcbiAgICAgICAgZCA9IG4ubWludXMocS50aW1lcyhkMiA9IGQpKTtcclxuICAgICAgICBuID0gZDI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGQyID0gZGl2KG1kLm1pbnVzKGQwKSwgZDEsIDAsIDEpO1xyXG4gICAgICBuMCA9IG4wLnBsdXMoZDIudGltZXMobjEpKTtcclxuICAgICAgZDAgPSBkMC5wbHVzKGQyLnRpbWVzKGQxKSk7XHJcbiAgICAgIG4wLnMgPSBuMS5zID0geC5zO1xyXG4gICAgICBlID0gZSAqIDI7XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggZnJhY3Rpb24gaXMgY2xvc2VyIHRvIHgsIG4wL2QwIG9yIG4xL2QxXHJcbiAgICAgIHIgPSBkaXYobjEsIGQxLCBlLCBST1VORElOR19NT0RFKS5taW51cyh4KS5hYnMoKS5jb21wYXJlZFRvKFxyXG4gICAgICAgICAgZGl2KG4wLCBkMCwgZSwgUk9VTkRJTkdfTU9ERSkubWludXMoeCkuYWJzKCkpIDwgMSA/IFtuMSwgZDFdIDogW24wLCBkMF07XHJcblxyXG4gICAgICBNQVhfRVhQID0gZXhwO1xyXG5cclxuICAgICAgcmV0dXJuIHI7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBjb252ZXJ0ZWQgdG8gYSBudW1iZXIgcHJpbWl0aXZlLlxyXG4gICAgICovXHJcbiAgICBQLnRvTnVtYmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gK3ZhbHVlT2YodGhpcyk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcm91bmRlZCB0byBzZCBzaWduaWZpY2FudCBkaWdpdHNcclxuICAgICAqIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0gb3IgUk9VTkRJTkdfTU9ERS4gSWYgc2QgaXMgbGVzcyB0aGFuIHRoZSBudW1iZXIgb2YgZGlnaXRzXHJcbiAgICAgKiBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBpbnRlZ2VyIHBhcnQgb2YgdGhlIHZhbHVlIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uLCB0aGVuIHVzZVxyXG4gICAgICogZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogW3NkXSB7bnVtYmVyfSBTaWduaWZpY2FudCBkaWdpdHMuIEludGVnZXIsIDEgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3NkfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC50b1ByZWNpc2lvbiA9IGZ1bmN0aW9uIChzZCwgcm0pIHtcclxuICAgICAgaWYgKHNkICE9IG51bGwpIGludENoZWNrKHNkLCAxLCBNQVgpO1xyXG4gICAgICByZXR1cm4gZm9ybWF0KHRoaXMsIHNkLCBybSwgMik7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gYmFzZSBiLCBvciBiYXNlIDEwIGlmIGIgaXNcclxuICAgICAqIG9taXR0ZWQuIElmIGEgYmFzZSBpcyBzcGVjaWZpZWQsIGluY2x1ZGluZyBiYXNlIDEwLCByb3VuZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kXHJcbiAgICAgKiBST1VORElOR19NT0RFLiBJZiBhIGJhc2UgaXMgbm90IHNwZWNpZmllZCwgYW5kIHRoaXMgQmlnTnVtYmVyIGhhcyBhIHBvc2l0aXZlIGV4cG9uZW50XHJcbiAgICAgKiB0aGF0IGlzIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiBUT19FWFBfUE9TLCBvciBhIG5lZ2F0aXZlIGV4cG9uZW50IGVxdWFsIHRvIG9yIGxlc3MgdGhhblxyXG4gICAgICogVE9fRVhQX05FRywgcmV0dXJuIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIFtiXSB7bnVtYmVyfSBJbnRlZ2VyLCAyIHRvIEFMUEhBQkVULmxlbmd0aCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEJhc2Uge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2J9J1xyXG4gICAgICovXHJcbiAgICBQLnRvU3RyaW5nID0gZnVuY3Rpb24gKGIpIHtcclxuICAgICAgdmFyIHN0cixcclxuICAgICAgICBuID0gdGhpcyxcclxuICAgICAgICBzID0gbi5zLFxyXG4gICAgICAgIGUgPSBuLmU7XHJcblxyXG4gICAgICAvLyBJbmZpbml0eSBvciBOYU4/XHJcbiAgICAgIGlmIChlID09PSBudWxsKSB7XHJcbiAgICAgICAgaWYgKHMpIHtcclxuICAgICAgICAgIHN0ciA9ICdJbmZpbml0eSc7XHJcbiAgICAgICAgICBpZiAocyA8IDApIHN0ciA9ICctJyArIHN0cjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgc3RyID0gJ05hTic7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChiID09IG51bGwpIHtcclxuICAgICAgICAgIHN0ciA9IGUgPD0gVE9fRVhQX05FRyB8fCBlID49IFRPX0VYUF9QT1NcclxuICAgICAgICAgICA/IHRvRXhwb25lbnRpYWwoY29lZmZUb1N0cmluZyhuLmMpLCBlKVxyXG4gICAgICAgICAgIDogdG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcobi5jKSwgZSwgJzAnKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDEwICYmIGFscGhhYmV0SGFzTm9ybWFsRGVjaW1hbERpZ2l0cykge1xyXG4gICAgICAgICAgbiA9IHJvdW5kKG5ldyBCaWdOdW1iZXIobiksIERFQ0lNQUxfUExBQ0VTICsgZSArIDEsIFJPVU5ESU5HX01PREUpO1xyXG4gICAgICAgICAgc3RyID0gdG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcobi5jKSwgbi5lLCAnMCcpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpbnRDaGVjayhiLCAyLCBBTFBIQUJFVC5sZW5ndGgsICdCYXNlJyk7XHJcbiAgICAgICAgICBzdHIgPSBjb252ZXJ0QmFzZSh0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyhuLmMpLCBlLCAnMCcpLCAxMCwgYiwgcywgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocyA8IDAgJiYgbi5jWzBdKSBzdHIgPSAnLScgKyBzdHI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBzdHI7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGFzIHRvU3RyaW5nLCBidXQgZG8gbm90IGFjY2VwdCBhIGJhc2UgYXJndW1lbnQsIGFuZCBpbmNsdWRlIHRoZSBtaW51cyBzaWduIGZvclxyXG4gICAgICogbmVnYXRpdmUgemVyby5cclxuICAgICAqL1xyXG4gICAgUC52YWx1ZU9mID0gUC50b0pTT04gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZU9mKHRoaXMpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgUC5faXNCaWdOdW1iZXIgPSB0cnVlO1xyXG5cclxuICAgIGlmIChjb25maWdPYmplY3QgIT0gbnVsbCkgQmlnTnVtYmVyLnNldChjb25maWdPYmplY3QpO1xyXG5cclxuICAgIHJldHVybiBCaWdOdW1iZXI7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gUFJJVkFURSBIRUxQRVIgRlVOQ1RJT05TXHJcblxyXG4gIC8vIFRoZXNlIGZ1bmN0aW9ucyBkb24ndCBuZWVkIGFjY2VzcyB0byB2YXJpYWJsZXMsXHJcbiAgLy8gZS5nLiBERUNJTUFMX1BMQUNFUywgaW4gdGhlIHNjb3BlIG9mIHRoZSBgY2xvbmVgIGZ1bmN0aW9uIGFib3ZlLlxyXG5cclxuXHJcbiAgZnVuY3Rpb24gYml0Rmxvb3Iobikge1xyXG4gICAgdmFyIGkgPSBuIHwgMDtcclxuICAgIHJldHVybiBuID4gMCB8fCBuID09PSBpID8gaSA6IGkgLSAxO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIFJldHVybiBhIGNvZWZmaWNpZW50IGFycmF5IGFzIGEgc3RyaW5nIG9mIGJhc2UgMTAgZGlnaXRzLlxyXG4gIGZ1bmN0aW9uIGNvZWZmVG9TdHJpbmcoYSkge1xyXG4gICAgdmFyIHMsIHosXHJcbiAgICAgIGkgPSAxLFxyXG4gICAgICBqID0gYS5sZW5ndGgsXHJcbiAgICAgIHIgPSBhWzBdICsgJyc7XHJcblxyXG4gICAgZm9yICg7IGkgPCBqOykge1xyXG4gICAgICBzID0gYVtpKytdICsgJyc7XHJcbiAgICAgIHogPSBMT0dfQkFTRSAtIHMubGVuZ3RoO1xyXG4gICAgICBmb3IgKDsgei0tOyBzID0gJzAnICsgcyk7XHJcbiAgICAgIHIgKz0gcztcclxuICAgIH1cclxuXHJcbiAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICBmb3IgKGogPSByLmxlbmd0aDsgci5jaGFyQ29kZUF0KC0taikgPT09IDQ4Oyk7XHJcblxyXG4gICAgcmV0dXJuIHIuc2xpY2UoMCwgaiArIDEgfHwgMSk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gQ29tcGFyZSB0aGUgdmFsdWUgb2YgQmlnTnVtYmVycyB4IGFuZCB5LlxyXG4gIGZ1bmN0aW9uIGNvbXBhcmUoeCwgeSkge1xyXG4gICAgdmFyIGEsIGIsXHJcbiAgICAgIHhjID0geC5jLFxyXG4gICAgICB5YyA9IHkuYyxcclxuICAgICAgaSA9IHgucyxcclxuICAgICAgaiA9IHkucyxcclxuICAgICAgayA9IHguZSxcclxuICAgICAgbCA9IHkuZTtcclxuXHJcbiAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgaWYgKCFpIHx8ICFqKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICBhID0geGMgJiYgIXhjWzBdO1xyXG4gICAgYiA9IHljICYmICF5Y1swXTtcclxuXHJcbiAgICAvLyBFaXRoZXIgemVybz9cclxuICAgIGlmIChhIHx8IGIpIHJldHVybiBhID8gYiA/IDAgOiAtaiA6IGk7XHJcblxyXG4gICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgaWYgKGkgIT0gaikgcmV0dXJuIGk7XHJcblxyXG4gICAgYSA9IGkgPCAwO1xyXG4gICAgYiA9IGsgPT0gbDtcclxuXHJcbiAgICAvLyBFaXRoZXIgSW5maW5pdHk/XHJcbiAgICBpZiAoIXhjIHx8ICF5YykgcmV0dXJuIGIgPyAwIDogIXhjIF4gYSA/IDEgOiAtMTtcclxuXHJcbiAgICAvLyBDb21wYXJlIGV4cG9uZW50cy5cclxuICAgIGlmICghYikgcmV0dXJuIGsgPiBsIF4gYSA/IDEgOiAtMTtcclxuXHJcbiAgICBqID0gKGsgPSB4Yy5sZW5ndGgpIDwgKGwgPSB5Yy5sZW5ndGgpID8gayA6IGw7XHJcblxyXG4gICAgLy8gQ29tcGFyZSBkaWdpdCBieSBkaWdpdC5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBqOyBpKyspIGlmICh4Y1tpXSAhPSB5Y1tpXSkgcmV0dXJuIHhjW2ldID4geWNbaV0gXiBhID8gMSA6IC0xO1xyXG5cclxuICAgIC8vIENvbXBhcmUgbGVuZ3Rocy5cclxuICAgIHJldHVybiBrID09IGwgPyAwIDogayA+IGwgXiBhID8gMSA6IC0xO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogQ2hlY2sgdGhhdCBuIGlzIGEgcHJpbWl0aXZlIG51bWJlciwgYW4gaW50ZWdlciwgYW5kIGluIHJhbmdlLCBvdGhlcndpc2UgdGhyb3cuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gaW50Q2hlY2sobiwgbWluLCBtYXgsIG5hbWUpIHtcclxuICAgIGlmIChuIDwgbWluIHx8IG4gPiBtYXggfHwgbiAhPT0gbWF0aGZsb29yKG4pKSB7XHJcbiAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAobmFtZSB8fCAnQXJndW1lbnQnKSArICh0eXBlb2YgbiA9PSAnbnVtYmVyJ1xyXG4gICAgICAgICA/IG4gPCBtaW4gfHwgbiA+IG1heCA/ICcgb3V0IG9mIHJhbmdlOiAnIDogJyBub3QgYW4gaW50ZWdlcjogJ1xyXG4gICAgICAgICA6ICcgbm90IGEgcHJpbWl0aXZlIG51bWJlcjogJykgKyBTdHJpbmcobikpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG4gIC8vIEFzc3VtZXMgZmluaXRlIG4uXHJcbiAgZnVuY3Rpb24gaXNPZGQobikge1xyXG4gICAgdmFyIGsgPSBuLmMubGVuZ3RoIC0gMTtcclxuICAgIHJldHVybiBiaXRGbG9vcihuLmUgLyBMT0dfQkFTRSkgPT0gayAmJiBuLmNba10gJSAyICE9IDA7XHJcbiAgfVxyXG5cclxuXHJcbiAgZnVuY3Rpb24gdG9FeHBvbmVudGlhbChzdHIsIGUpIHtcclxuICAgIHJldHVybiAoc3RyLmxlbmd0aCA+IDEgPyBzdHIuY2hhckF0KDApICsgJy4nICsgc3RyLnNsaWNlKDEpIDogc3RyKSArXHJcbiAgICAgKGUgPCAwID8gJ2UnIDogJ2UrJykgKyBlO1xyXG4gIH1cclxuXHJcblxyXG4gIGZ1bmN0aW9uIHRvRml4ZWRQb2ludChzdHIsIGUsIHopIHtcclxuICAgIHZhciBsZW4sIHpzO1xyXG5cclxuICAgIC8vIE5lZ2F0aXZlIGV4cG9uZW50P1xyXG4gICAgaWYgKGUgPCAwKSB7XHJcblxyXG4gICAgICAvLyBQcmVwZW5kIHplcm9zLlxyXG4gICAgICBmb3IgKHpzID0geiArICcuJzsgKytlOyB6cyArPSB6KTtcclxuICAgICAgc3RyID0genMgKyBzdHI7XHJcblxyXG4gICAgLy8gUG9zaXRpdmUgZXhwb25lbnRcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAvLyBBcHBlbmQgemVyb3MuXHJcbiAgICAgIGlmICgrK2UgPiBsZW4pIHtcclxuICAgICAgICBmb3IgKHpzID0geiwgZSAtPSBsZW47IC0tZTsgenMgKz0geik7XHJcbiAgICAgICAgc3RyICs9IHpzO1xyXG4gICAgICB9IGVsc2UgaWYgKGUgPCBsZW4pIHtcclxuICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMCwgZSkgKyAnLicgKyBzdHIuc2xpY2UoZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc3RyO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIEVYUE9SVFxyXG5cclxuXHJcbiAgQmlnTnVtYmVyID0gY2xvbmUoKTtcclxuICBCaWdOdW1iZXJbJ2RlZmF1bHQnXSA9IEJpZ051bWJlci5CaWdOdW1iZXIgPSBCaWdOdW1iZXI7XHJcblxyXG4gIC8vIEFNRC5cclxuICBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcclxuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7IHJldHVybiBCaWdOdW1iZXI7IH0pO1xyXG5cclxuICAvLyBOb2RlLmpzIGFuZCBvdGhlciBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLlxyXG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBCaWdOdW1iZXI7XHJcblxyXG4gIC8vIEJyb3dzZXIuXHJcbiAgfSBlbHNlIHtcclxuICAgIGlmICghZ2xvYmFsT2JqZWN0KSB7XHJcbiAgICAgIGdsb2JhbE9iamVjdCA9IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYgPyBzZWxmIDogd2luZG93O1xyXG4gICAgfVxyXG5cclxuICAgIGdsb2JhbE9iamVjdC5CaWdOdW1iZXIgPSBCaWdOdW1iZXI7XHJcbiAgfVxyXG59KSh0aGlzKTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/bignumber.js/bignumber.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/borc/node_modules/buffer/index.js":
/*!************************************************************!*\
  !*** ../../node_modules/borc/node_modules/buffer/index.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"(app-pages-browser)/../../node_modules/base64-js/index.js\")\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"(app-pages-browser)/../../node_modules/ieee754/index.js\")\nvar customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    var proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  var valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  var b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(\n      value[Symbol.toPrimitive]('string'), encodingOrOffset, length\n    )\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    var copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        Buffer.from(buf).copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  var len = string.length\n  var mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  var strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (var i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    var len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nvar hexSliceLookupTable = (function () {\n  var alphabet = '0123456789abcdef'\n  var table = new Array(256)\n  for (var i = 0; i < 16; ++i) {\n    var i16 = i * 16\n    for (var j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYm9yYy9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVZOztBQUVaLGFBQWEsbUJBQU8sQ0FBQyw0RUFBVztBQUNoQyxjQUFjLG1CQUFPLENBQUMsd0VBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkLGtCQUFrQjtBQUNsQix5QkFBeUI7O0FBRXpCO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsRUFBRTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixlQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsWUFBWTtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvYm9yYy9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzP2RhYmUiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGN1c3RvbUluc3BlY3RTeW1ib2wgPVxuICAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sWydmb3InXSA9PT0gJ2Z1bmN0aW9uJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICA/IFN5bWJvbFsnZm9yJ10oJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICA6IG51bGxcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG52YXIgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZlxuZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3RcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxuICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YFxuICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydFxuICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5pZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnICtcbiAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nXG4gIClcbn1cblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgdmFyIHByb3RvID0geyBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH0gfVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihwcm90bywgVWludDhBcnJheS5wcm90b3R5cGUpXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGFyciwgcHJvdG8pXG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAncGFyZW50Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ1ZmZlclxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGxlbmd0aCArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG5mdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlWaWV3KHZhbHVlKVxuICB9XG5cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICAgIClcbiAgfVxuXG4gIGlmIChpc0luc3RhbmNlKHZhbHVlLCBBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgQXJyYXlCdWZmZXIpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAoaXNJbnN0YW5jZSh2YWx1ZSwgU2hhcmVkQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIFNoYXJlZEFycmF5QnVmZmVyKSkpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgIClcbiAgfVxuXG4gIHZhciB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZiAmJiB2YWx1ZS52YWx1ZU9mKClcbiAgaWYgKHZhbHVlT2YgIT0gbnVsbCAmJiB2YWx1ZU9mICE9PSB2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZU9mLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICB2YXIgYiA9IGZyb21PYmplY3QodmFsdWUpXG4gIGlmIChiKSByZXR1cm4gYlxuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9QcmltaXRpdmUgIT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oXG4gICAgICB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCdzdHJpbmcnKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoXG4gICAgKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICApXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIucHJvdG90eXBlLCBVaW50OEFycmF5LnByb3RvdHlwZSlcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIsIFVpbnQ4QXJyYXkpXG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBzaXplICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheVZpZXcgKGFycmF5Vmlldykge1xuICBpZiAoaXNJbnN0YW5jZShhcnJheVZpZXcsIFVpbnQ4QXJyYXkpKSB7XG4gICAgdmFyIGNvcHkgPSBuZXcgVWludDhBcnJheShhcnJheVZpZXcpXG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcihjb3B5LmJ1ZmZlciwgY29weS5ieXRlT2Zmc2V0LCBjb3B5LmJ5dGVMZW5ndGgpXG4gIH1cbiAgcmV0dXJuIGZyb21BcnJheUxpa2UoYXJyYXlWaWV3KVxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgdmFyIGJ1ZlxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyLnByb3RvdHlwZSlcblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICB9XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICB9XG5cbiAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZSAmJlxuICAgIGIgIT09IEJ1ZmZlci5wcm90b3R5cGUgLy8gc28gQnVmZmVyLmlzQnVmZmVyKEJ1ZmZlci5wcm90b3R5cGUpIHdpbGwgYmUgZmFsc2Vcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKSBhID0gQnVmZmVyLmZyb20oYSwgYS5vZmZzZXQsIGEuYnl0ZUxlbmd0aClcbiAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpIGIgPSBCdWZmZXIuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5J1xuICAgIClcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHtcbiAgICAgIGlmIChwb3MgKyBidWYubGVuZ3RoID4gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICBCdWZmZXIuZnJvbShidWYpLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgYnVmLFxuICAgICAgICAgIHBvc1xuICAgICAgICApXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIH1cbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBpc0luc3RhbmNlKHN0cmluZywgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHN0cmluZ1xuICAgIClcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBtdXN0TWF0Y2ggPSAoYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdID09PSB0cnVlKVxuICBpZiAoIW11c3RNYXRjaCAmJiBsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHtcbiAgICAgICAgICByZXR1cm4gbXVzdE1hdGNoID8gLTEgOiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICB9XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcmNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIChhbmQgdGhlIGBpcy1idWZmZXJgIG5wbSBwYWNrYWdlKVxuLy8gdG8gZGV0ZWN0IGEgQnVmZmVyIGluc3RhbmNlLiBJdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgYGluc3RhbmNlb2YgQnVmZmVyYFxuLy8gcmVsaWFibHkgaW4gYSBicm93c2VyaWZ5IGNvbnRleHQgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBkaWZmZXJlbnRcbi8vIGNvcGllcyBvZiB0aGUgJ2J1ZmZlcicgcGFja2FnZSBpbiB1c2UuIFRoaXMgbWV0aG9kIHdvcmtzIGV2ZW4gZm9yIEJ1ZmZlclxuLy8gaW5zdGFuY2VzIHRoYXQgd2VyZSBjcmVhdGVkIGZyb20gYW5vdGhlciBjb3B5IG9mIHRoZSBgYnVmZmVyYCBwYWNrYWdlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTU0XG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZ1xuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLnJlcGxhY2UoLyguezJ9KS9nLCAnJDEgJykudHJpbSgpXG4gIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cbmlmIChjdXN0b21JbnNwZWN0U3ltYm9sKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGVbY3VzdG9tSW5zcGVjdFN5bWJvbF0gPSBCdWZmZXIucHJvdG90eXBlLmluc3BlY3Rcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKGlzSW5zdGFuY2UodGFyZ2V0LCBVaW50OEFycmF5KSkge1xuICAgIHRhcmdldCA9IEJ1ZmZlci5mcm9tKHRhcmdldCwgdGFyZ2V0Lm9mZnNldCwgdGFyZ2V0LmJ5dGVMZW5ndGgpXG4gIH1cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB0YXJnZXQpXG4gICAgKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbdmFsXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKVxuICAgICAgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKVxuICAgICAgICAgID8gM1xuICAgICAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpXG4gICAgICAgICAgICAgID8gMlxuICAgICAgICAgICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gaGV4U2xpY2VMb29rdXBUYWJsZVtidWZbaV1dXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIC8vIElmIGJ5dGVzLmxlbmd0aCBpcyBvZGQsIHRoZSBsYXN0IDggYml0cyBtdXN0IGJlIGlnbm9yZWQgKHNhbWUgYXMgbm9kZS5qcylcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGggLSAxOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihuZXdCdWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludExFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50QkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDggPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDE2TEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MTZCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQzMkxFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDMyQkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludExFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludEJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDggPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MTZMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDE2QkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQzMkxFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MzJCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyJylcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVc2UgYnVpbHQtaW4gd2hlbiBhdmFpbGFibGUsIG1pc3NpbmcgZnJvbSBJRTExXG4gICAgdGhpcy5jb3B5V2l0aGluKHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmICgoZW5jb2RpbmcgPT09ICd1dGY4JyAmJiBjb2RlIDwgMTI4KSB8fFxuICAgICAgICAgIGVuY29kaW5nID09PSAnbGF0aW4xJykge1xuICAgICAgICAvLyBGYXN0IHBhdGg6IElmIGB2YWxgIGZpdHMgaW50byBhIHNpbmdsZSBieXRlLCB1c2UgdGhhdCBudW1lcmljIHZhbHVlLlxuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgdmFsID0gTnVtYmVyKHZhbClcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInICsgdmFsICtcbiAgICAgICAgJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpXG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgdGFrZXMgZXF1YWwgc2lnbnMgYXMgZW5kIG9mIHRoZSBCYXNlNjQgZW5jb2RpbmdcbiAgc3RyID0gc3RyLnNwbGl0KCc9JylbMF1cbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSBvYmplY3RzIGZyb20gb3RoZXIgY29udGV4dHMgKGkuZS4gaWZyYW1lcykgZG8gbm90IHBhc3Ncbi8vIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2sgYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgb2YgdGhhdCB0eXBlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5mdW5jdGlvbiBpc0luc3RhbmNlIChvYmosIHR5cGUpIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHR5cGUgfHxcbiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZSlcbn1cbmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcbiAgLy8gRm9yIElFMTEgc3VwcG9ydFxuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuLy8gQ3JlYXRlIGxvb2t1cCB0YWJsZSBmb3IgYHRvU3RyaW5nKCdoZXgnKWBcbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzIxOVxudmFyIGhleFNsaWNlTG9va3VwVGFibGUgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgYWxwaGFiZXQgPSAnMDEyMzQ1Njc4OWFiY2RlZidcbiAgdmFyIHRhYmxlID0gbmV3IEFycmF5KDI1NilcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgdmFyIGkxNiA9IGkgKiAxNlxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgMTY7ICsraikge1xuICAgICAgdGFibGVbaTE2ICsgal0gPSBhbHBoYWJldFtpXSArIGFscGhhYmV0W2pdXG4gICAgfVxuICB9XG4gIHJldHVybiB0YWJsZVxufSkoKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/borc/node_modules/buffer/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/borc/src/constants.js":
/*!************************************************!*\
  !*** ../../node_modules/borc/src/constants.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nconst Bignumber = (__webpack_require__(/*! bignumber.js */ \"(app-pages-browser)/../../node_modules/bignumber.js/bignumber.js\").BigNumber)\n\nexports.MT = {\n  POS_INT: 0,\n  NEG_INT: 1,\n  BYTE_STRING: 2,\n  UTF8_STRING: 3,\n  ARRAY: 4,\n  MAP: 5,\n  TAG: 6,\n  SIMPLE_FLOAT: 7\n}\n\nexports.TAG = {\n  DATE_STRING: 0,\n  DATE_EPOCH: 1,\n  POS_BIGINT: 2,\n  NEG_BIGINT: 3,\n  DECIMAL_FRAC: 4,\n  BIGFLOAT: 5,\n  BASE64URL_EXPECTED: 21,\n  BASE64_EXPECTED: 22,\n  BASE16_EXPECTED: 23,\n  CBOR: 24,\n  URI: 32,\n  BASE64URL: 33,\n  BASE64: 34,\n  REGEXP: 35,\n  MIME: 36\n}\n\nexports.NUMBYTES = {\n  ZERO: 0,\n  ONE: 24,\n  TWO: 25,\n  FOUR: 26,\n  EIGHT: 27,\n  INDEFINITE: 31\n}\n\nexports.SIMPLE = {\n  FALSE: 20,\n  TRUE: 21,\n  NULL: 22,\n  UNDEFINED: 23\n}\n\nexports.SYMS = {\n  NULL: Symbol('null'),\n  UNDEFINED: Symbol('undef'),\n  PARENT: Symbol('parent'),\n  BREAK: Symbol('break'),\n  STREAM: Symbol('stream')\n}\n\nexports.SHIFT32 = Math.pow(2, 32)\nexports.SHIFT16 = Math.pow(2, 16)\n\nexports.MAX_SAFE_HIGH = 0x1fffff\nexports.NEG_ONE = new Bignumber(-1)\nexports.TEN = new Bignumber(10)\nexports.TWO = new Bignumber(2)\n\nexports.PARENT = {\n  ARRAY: 0,\n  OBJECT: 1,\n  MAP: 2,\n  TAG: 3,\n  BYTE_STRING: 4,\n  UTF8_STRING: 5\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYm9yYy9zcmMvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGtCQUFrQix1SEFBaUM7O0FBRW5ELFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWU7QUFDZixlQUFlOztBQUVmLHFCQUFxQjtBQUNyQixlQUFlO0FBQ2YsV0FBVztBQUNYLFdBQVc7O0FBRVgsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvYm9yYy9zcmMvY29uc3RhbnRzLmpzPzI1NzAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEJpZ251bWJlciA9IHJlcXVpcmUoJ2JpZ251bWJlci5qcycpLkJpZ051bWJlclxuXG5leHBvcnRzLk1UID0ge1xuICBQT1NfSU5UOiAwLFxuICBORUdfSU5UOiAxLFxuICBCWVRFX1NUUklORzogMixcbiAgVVRGOF9TVFJJTkc6IDMsXG4gIEFSUkFZOiA0LFxuICBNQVA6IDUsXG4gIFRBRzogNixcbiAgU0lNUExFX0ZMT0FUOiA3XG59XG5cbmV4cG9ydHMuVEFHID0ge1xuICBEQVRFX1NUUklORzogMCxcbiAgREFURV9FUE9DSDogMSxcbiAgUE9TX0JJR0lOVDogMixcbiAgTkVHX0JJR0lOVDogMyxcbiAgREVDSU1BTF9GUkFDOiA0LFxuICBCSUdGTE9BVDogNSxcbiAgQkFTRTY0VVJMX0VYUEVDVEVEOiAyMSxcbiAgQkFTRTY0X0VYUEVDVEVEOiAyMixcbiAgQkFTRTE2X0VYUEVDVEVEOiAyMyxcbiAgQ0JPUjogMjQsXG4gIFVSSTogMzIsXG4gIEJBU0U2NFVSTDogMzMsXG4gIEJBU0U2NDogMzQsXG4gIFJFR0VYUDogMzUsXG4gIE1JTUU6IDM2XG59XG5cbmV4cG9ydHMuTlVNQllURVMgPSB7XG4gIFpFUk86IDAsXG4gIE9ORTogMjQsXG4gIFRXTzogMjUsXG4gIEZPVVI6IDI2LFxuICBFSUdIVDogMjcsXG4gIElOREVGSU5JVEU6IDMxXG59XG5cbmV4cG9ydHMuU0lNUExFID0ge1xuICBGQUxTRTogMjAsXG4gIFRSVUU6IDIxLFxuICBOVUxMOiAyMixcbiAgVU5ERUZJTkVEOiAyM1xufVxuXG5leHBvcnRzLlNZTVMgPSB7XG4gIE5VTEw6IFN5bWJvbCgnbnVsbCcpLFxuICBVTkRFRklORUQ6IFN5bWJvbCgndW5kZWYnKSxcbiAgUEFSRU5UOiBTeW1ib2woJ3BhcmVudCcpLFxuICBCUkVBSzogU3ltYm9sKCdicmVhaycpLFxuICBTVFJFQU06IFN5bWJvbCgnc3RyZWFtJylcbn1cblxuZXhwb3J0cy5TSElGVDMyID0gTWF0aC5wb3coMiwgMzIpXG5leHBvcnRzLlNISUZUMTYgPSBNYXRoLnBvdygyLCAxNilcblxuZXhwb3J0cy5NQVhfU0FGRV9ISUdIID0gMHgxZmZmZmZcbmV4cG9ydHMuTkVHX09ORSA9IG5ldyBCaWdudW1iZXIoLTEpXG5leHBvcnRzLlRFTiA9IG5ldyBCaWdudW1iZXIoMTApXG5leHBvcnRzLlRXTyA9IG5ldyBCaWdudW1iZXIoMilcblxuZXhwb3J0cy5QQVJFTlQgPSB7XG4gIEFSUkFZOiAwLFxuICBPQkpFQ1Q6IDEsXG4gIE1BUDogMixcbiAgVEFHOiAzLFxuICBCWVRFX1NUUklORzogNCxcbiAgVVRGOF9TVFJJTkc6IDVcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/borc/src/constants.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/borc/src/decoder.asm.js":
/*!**************************************************!*\
  !*** ../../node_modules/borc/src/decoder.asm.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/* eslint-disable */\n\nmodule.exports = function decodeAsm (stdlib, foreign, buffer) {\n  'use asm'\n\n  // -- Imports\n\n  var heap = new stdlib.Uint8Array(buffer)\n  // var log = foreign.log\n  var pushInt = foreign.pushInt\n  var pushInt32 = foreign.pushInt32\n  var pushInt32Neg = foreign.pushInt32Neg\n  var pushInt64 = foreign.pushInt64\n  var pushInt64Neg = foreign.pushInt64Neg\n  var pushFloat = foreign.pushFloat\n  var pushFloatSingle = foreign.pushFloatSingle\n  var pushFloatDouble = foreign.pushFloatDouble\n  var pushTrue = foreign.pushTrue\n  var pushFalse = foreign.pushFalse\n  var pushUndefined = foreign.pushUndefined\n  var pushNull = foreign.pushNull\n  var pushInfinity = foreign.pushInfinity\n  var pushInfinityNeg = foreign.pushInfinityNeg\n  var pushNaN = foreign.pushNaN\n  var pushNaNNeg = foreign.pushNaNNeg\n\n  var pushArrayStart = foreign.pushArrayStart\n  var pushArrayStartFixed = foreign.pushArrayStartFixed\n  var pushArrayStartFixed32 = foreign.pushArrayStartFixed32\n  var pushArrayStartFixed64 = foreign.pushArrayStartFixed64\n  var pushObjectStart = foreign.pushObjectStart\n  var pushObjectStartFixed = foreign.pushObjectStartFixed\n  var pushObjectStartFixed32 = foreign.pushObjectStartFixed32\n  var pushObjectStartFixed64 = foreign.pushObjectStartFixed64\n\n  var pushByteString = foreign.pushByteString\n  var pushByteStringStart = foreign.pushByteStringStart\n  var pushUtf8String = foreign.pushUtf8String\n  var pushUtf8StringStart = foreign.pushUtf8StringStart\n\n  var pushSimpleUnassigned = foreign.pushSimpleUnassigned\n\n  var pushTagStart = foreign.pushTagStart\n  var pushTagStart4 = foreign.pushTagStart4\n  var pushTagStart8 = foreign.pushTagStart8\n  var pushTagUnassigned = foreign.pushTagUnassigned\n\n  var pushBreak = foreign.pushBreak\n\n  var pow = stdlib.Math.pow\n\n  // -- Constants\n\n\n  // -- Mutable Variables\n\n  var offset = 0\n  var inputLength = 0\n  var code = 0\n\n  // Decode a cbor string represented as Uint8Array\n  // which is allocated on the heap from 0 to inputLength\n  //\n  // input - Int\n  //\n  // Returns Code - Int,\n  // Success = 0\n  // Error > 0\n  function parse (input) {\n    input = input | 0\n\n    offset = 0\n    inputLength = input\n\n    while ((offset | 0) < (inputLength | 0)) {\n      code = jumpTable[heap[offset] & 255](heap[offset] | 0) | 0\n\n      if ((code | 0) > 0) {\n        break\n      }\n    }\n\n    return code | 0\n  }\n\n  // -- Helper Function\n\n  function checkOffset (n) {\n    n = n | 0\n\n    if ((((offset | 0) + (n | 0)) | 0) < (inputLength | 0)) {\n      return 0\n    }\n\n    return 1\n  }\n\n  function readUInt16 (n) {\n    n = n | 0\n\n    return (\n      (heap[n | 0] << 8) | heap[(n + 1) | 0]\n    ) | 0\n  }\n\n  function readUInt32 (n) {\n    n = n | 0\n\n    return (\n      (heap[n | 0] << 24) | (heap[(n + 1) | 0] << 16) | (heap[(n + 2) | 0] << 8) | heap[(n + 3) | 0]\n    ) | 0\n  }\n\n  // -- Initial Byte Handlers\n\n  function INT_P (octet) {\n    octet = octet | 0\n\n    pushInt(octet | 0)\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function UINT_P_8 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(1) | 0) {\n      return 1\n    }\n\n    pushInt(heap[(offset + 1) | 0] | 0)\n\n    offset = (offset + 2) | 0\n\n    return 0\n  }\n\n  function UINT_P_16 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(2) | 0) {\n      return 1\n    }\n\n    pushInt(\n      readUInt16((offset + 1) | 0) | 0\n    )\n\n    offset = (offset + 3) | 0\n\n    return 0\n  }\n\n  function UINT_P_32 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(4) | 0) {\n      return 1\n    }\n\n    pushInt32(\n      readUInt16((offset + 1) | 0) | 0,\n      readUInt16((offset + 3) | 0) | 0\n    )\n\n    offset = (offset + 5) | 0\n\n    return 0\n  }\n\n  function UINT_P_64 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(8) | 0) {\n      return 1\n    }\n\n    pushInt64(\n      readUInt16((offset + 1) | 0) | 0,\n      readUInt16((offset + 3) | 0) | 0,\n      readUInt16((offset + 5) | 0) | 0,\n      readUInt16((offset + 7) | 0) | 0\n    )\n\n    offset = (offset + 9) | 0\n\n    return 0\n  }\n\n  function INT_N (octet) {\n    octet = octet | 0\n\n    pushInt((-1 - ((octet - 32) | 0)) | 0)\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function UINT_N_8 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(1) | 0) {\n      return 1\n    }\n\n    pushInt(\n      (-1 - (heap[(offset + 1) | 0] | 0)) | 0\n    )\n\n    offset = (offset + 2) | 0\n\n    return 0\n  }\n\n  function UINT_N_16 (octet) {\n    octet = octet | 0\n\n    var val = 0\n\n    if (checkOffset(2) | 0) {\n      return 1\n    }\n\n    val = readUInt16((offset + 1) | 0) | 0\n    pushInt((-1 - (val | 0)) | 0)\n\n    offset = (offset + 3) | 0\n\n    return 0\n  }\n\n  function UINT_N_32 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(4) | 0) {\n      return 1\n    }\n\n    pushInt32Neg(\n      readUInt16((offset + 1) | 0) | 0,\n      readUInt16((offset + 3) | 0) | 0\n    )\n\n    offset = (offset + 5) | 0\n\n    return 0\n  }\n\n  function UINT_N_64 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(8) | 0) {\n      return 1\n    }\n\n    pushInt64Neg(\n      readUInt16((offset + 1) | 0) | 0,\n      readUInt16((offset + 3) | 0) | 0,\n      readUInt16((offset + 5) | 0) | 0,\n      readUInt16((offset + 7) | 0) | 0\n    )\n\n    offset = (offset + 9) | 0\n\n    return 0\n  }\n\n  function BYTE_STRING (octet) {\n    octet = octet | 0\n\n    var start = 0\n    var end = 0\n    var step = 0\n\n    step = (octet - 64) | 0\n    if (checkOffset(step | 0) | 0) {\n      return 1\n    }\n\n    start = (offset + 1) | 0\n    end = (((offset + 1) | 0) + (step | 0)) | 0\n\n    pushByteString(start | 0, end | 0)\n\n    offset = end | 0\n\n    return 0\n  }\n\n  function BYTE_STRING_8 (octet) {\n    octet = octet | 0\n\n    var start = 0\n    var end = 0\n    var length = 0\n\n    if (checkOffset(1) | 0) {\n      return 1\n    }\n\n    length = heap[(offset + 1) | 0] | 0\n    start = (offset + 2) | 0\n    end = (((offset + 2) | 0) + (length | 0)) | 0\n\n    if (checkOffset((length + 1) | 0) | 0) {\n      return 1\n    }\n\n    pushByteString(start | 0, end | 0)\n\n    offset = end | 0\n\n    return 0\n  }\n\n  function BYTE_STRING_16 (octet) {\n    octet = octet | 0\n\n    var start = 0\n    var end = 0\n    var length = 0\n\n    if (checkOffset(2) | 0) {\n      return 1\n    }\n\n    length = readUInt16((offset + 1) | 0) | 0\n    start = (offset + 3) | 0\n    end = (((offset + 3) | 0) + (length | 0)) | 0\n\n\n    if (checkOffset((length + 2) | 0) | 0) {\n      return 1\n    }\n\n    pushByteString(start | 0, end | 0)\n\n    offset = end | 0\n\n    return 0\n  }\n\n  function BYTE_STRING_32 (octet) {\n    octet = octet | 0\n\n    var start = 0\n    var end = 0\n    var length = 0\n\n    if (checkOffset(4) | 0) {\n      return 1\n    }\n\n    length = readUInt32((offset + 1) | 0) | 0\n    start = (offset + 5) | 0\n    end = (((offset + 5) | 0) + (length | 0)) | 0\n\n\n    if (checkOffset((length + 4) | 0) | 0) {\n      return 1\n    }\n\n    pushByteString(start | 0, end | 0)\n\n    offset = end | 0\n\n    return 0\n  }\n\n  function BYTE_STRING_64 (octet) {\n    // NOT IMPLEMENTED\n    octet = octet | 0\n\n    return 1\n  }\n\n  function BYTE_STRING_BREAK (octet) {\n    octet = octet | 0\n\n    pushByteStringStart()\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function UTF8_STRING (octet) {\n    octet = octet | 0\n\n    var start = 0\n    var end = 0\n    var step = 0\n\n    step = (octet - 96) | 0\n\n    if (checkOffset(step | 0) | 0) {\n      return 1\n    }\n\n    start = (offset + 1) | 0\n    end = (((offset + 1) | 0) + (step | 0)) | 0\n\n    pushUtf8String(start | 0, end | 0)\n\n    offset = end | 0\n\n    return 0\n  }\n\n  function UTF8_STRING_8 (octet) {\n    octet = octet | 0\n\n    var start = 0\n    var end = 0\n    var length = 0\n\n    if (checkOffset(1) | 0) {\n      return 1\n    }\n\n    length = heap[(offset + 1) | 0] | 0\n    start = (offset + 2) | 0\n    end = (((offset + 2) | 0) + (length | 0)) | 0\n\n    if (checkOffset((length + 1) | 0) | 0) {\n      return 1\n    }\n\n    pushUtf8String(start | 0, end | 0)\n\n    offset = end | 0\n\n    return 0\n  }\n\n  function UTF8_STRING_16 (octet) {\n    octet = octet | 0\n\n    var start = 0\n    var end = 0\n    var length = 0\n\n    if (checkOffset(2) | 0) {\n      return 1\n    }\n\n    length = readUInt16((offset + 1) | 0) | 0\n    start = (offset + 3) | 0\n    end = (((offset + 3) | 0) + (length | 0)) | 0\n\n    if (checkOffset((length + 2) | 0) | 0) {\n      return 1\n    }\n\n    pushUtf8String(start | 0, end | 0)\n\n    offset = end | 0\n\n    return 0\n  }\n\n  function UTF8_STRING_32 (octet) {\n    octet = octet | 0\n\n    var start = 0\n    var end = 0\n    var length = 0\n\n    if (checkOffset(4) | 0) {\n      return 1\n    }\n\n    length = readUInt32((offset + 1) | 0) | 0\n    start = (offset + 5) | 0\n    end = (((offset + 5) | 0) + (length | 0)) | 0\n\n    if (checkOffset((length + 4) | 0) | 0) {\n      return 1\n    }\n\n    pushUtf8String(start | 0, end | 0)\n\n    offset = end | 0\n\n    return 0\n  }\n\n  function UTF8_STRING_64 (octet) {\n    // NOT IMPLEMENTED\n    octet = octet | 0\n\n    return 1\n  }\n\n  function UTF8_STRING_BREAK (octet) {\n    octet = octet | 0\n\n    pushUtf8StringStart()\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function ARRAY (octet) {\n    octet = octet | 0\n\n    pushArrayStartFixed((octet - 128) | 0)\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function ARRAY_8 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(1) | 0) {\n      return 1\n    }\n\n    pushArrayStartFixed(heap[(offset + 1) | 0] | 0)\n\n    offset = (offset + 2) | 0\n\n    return 0\n  }\n\n  function ARRAY_16 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(2) | 0) {\n      return 1\n    }\n\n    pushArrayStartFixed(\n      readUInt16((offset + 1) | 0) | 0\n    )\n\n    offset = (offset + 3) | 0\n\n    return 0\n  }\n\n  function ARRAY_32 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(4) | 0) {\n      return 1\n    }\n\n    pushArrayStartFixed32(\n      readUInt16((offset + 1) | 0) | 0,\n      readUInt16((offset + 3) | 0) | 0\n    )\n\n    offset = (offset + 5) | 0\n\n    return 0\n  }\n\n  function ARRAY_64 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(8) | 0) {\n      return 1\n    }\n\n    pushArrayStartFixed64(\n      readUInt16((offset + 1) | 0) | 0,\n      readUInt16((offset + 3) | 0) | 0,\n      readUInt16((offset + 5) | 0) | 0,\n      readUInt16((offset + 7) | 0) | 0\n    )\n\n    offset = (offset + 9) | 0\n\n    return 0\n  }\n\n  function ARRAY_BREAK (octet) {\n    octet = octet | 0\n\n    pushArrayStart()\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function MAP (octet) {\n    octet = octet | 0\n\n    var step = 0\n\n    step = (octet - 160) | 0\n\n    if (checkOffset(step | 0) | 0) {\n      return 1\n    }\n\n    pushObjectStartFixed(step | 0)\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function MAP_8 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(1) | 0) {\n      return 1\n    }\n\n    pushObjectStartFixed(heap[(offset + 1) | 0] | 0)\n\n    offset = (offset + 2) | 0\n\n    return 0\n  }\n\n  function MAP_16 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(2) | 0) {\n      return 1\n    }\n\n    pushObjectStartFixed(\n      readUInt16((offset + 1) | 0) | 0\n    )\n\n    offset = (offset + 3) | 0\n\n    return 0\n  }\n\n  function MAP_32 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(4) | 0) {\n      return 1\n    }\n\n    pushObjectStartFixed32(\n      readUInt16((offset + 1) | 0) | 0,\n      readUInt16((offset + 3) | 0) | 0\n    )\n\n    offset = (offset + 5) | 0\n\n    return 0\n  }\n\n  function MAP_64 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(8) | 0) {\n      return 1\n    }\n\n    pushObjectStartFixed64(\n      readUInt16((offset + 1) | 0) | 0,\n      readUInt16((offset + 3) | 0) | 0,\n      readUInt16((offset + 5) | 0) | 0,\n      readUInt16((offset + 7) | 0) | 0\n    )\n\n    offset = (offset + 9) | 0\n\n    return 0\n  }\n\n  function MAP_BREAK (octet) {\n    octet = octet | 0\n\n    pushObjectStart()\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function TAG_KNOWN (octet) {\n    octet = octet | 0\n\n    pushTagStart((octet - 192| 0) | 0)\n\n    offset = (offset + 1 | 0)\n\n    return 0\n  }\n\n  function TAG_BIGNUM_POS (octet) {\n    octet = octet | 0\n\n    pushTagStart(octet | 0)\n\n    offset = (offset + 1 | 0)\n\n    return 0\n  }\n\n  function TAG_BIGNUM_NEG (octet) {\n    octet = octet | 0\n\n    pushTagStart(octet | 0)\n\n    offset = (offset + 1 | 0)\n\n    return 0\n  }\n\n  function TAG_FRAC (octet) {\n    octet = octet | 0\n\n    pushTagStart(octet | 0)\n\n    offset = (offset + 1 | 0)\n\n    return 0\n  }\n\n  function TAG_BIGNUM_FLOAT (octet) {\n    octet = octet | 0\n\n    pushTagStart(octet | 0)\n\n    offset = (offset + 1 | 0)\n\n    return 0\n  }\n\n  function TAG_UNASSIGNED (octet) {\n    octet = octet | 0\n\n    pushTagStart((octet - 192| 0) | 0)\n\n    offset = (offset + 1 | 0)\n\n    return 0\n  }\n\n  function TAG_BASE64_URL (octet) {\n    octet = octet | 0\n\n    pushTagStart(octet | 0)\n\n    offset = (offset + 1 | 0)\n\n    return 0\n  }\n\n  function TAG_BASE64 (octet) {\n    octet = octet | 0\n\n    pushTagStart(octet | 0)\n\n    offset = (offset + 1 | 0)\n\n    return 0\n  }\n\n  function TAG_BASE16 (octet) {\n    octet = octet | 0\n\n    pushTagStart(octet | 0)\n\n    offset = (offset + 1 | 0)\n\n    return 0\n  }\n\n  function TAG_MORE_1 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(1) | 0) {\n      return 1\n    }\n\n    pushTagStart(heap[(offset + 1) | 0] | 0)\n\n    offset = (offset + 2 | 0)\n\n    return 0\n  }\n\n  function TAG_MORE_2 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(2) | 0) {\n      return 1\n    }\n\n    pushTagStart(\n      readUInt16((offset + 1) | 0) | 0\n    )\n\n    offset = (offset + 3 | 0)\n\n    return 0\n  }\n\n  function TAG_MORE_4 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(4) | 0) {\n      return 1\n    }\n\n    pushTagStart4(\n      readUInt16((offset + 1) | 0) | 0,\n      readUInt16((offset + 3) | 0) | 0\n    )\n\n    offset = (offset + 5 | 0)\n\n    return 0\n  }\n\n  function TAG_MORE_8 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(8) | 0) {\n      return 1\n    }\n\n    pushTagStart8(\n      readUInt16((offset + 1) | 0) | 0,\n      readUInt16((offset + 3) | 0) | 0,\n      readUInt16((offset + 5) | 0) | 0,\n      readUInt16((offset + 7) | 0) | 0\n    )\n\n    offset = (offset + 9 | 0)\n\n    return 0\n  }\n\n  function SIMPLE_UNASSIGNED (octet) {\n    octet = octet | 0\n\n    pushSimpleUnassigned(((octet | 0) - 224) | 0)\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function SIMPLE_FALSE (octet) {\n    octet = octet | 0\n\n    pushFalse()\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function SIMPLE_TRUE (octet) {\n    octet = octet | 0\n\n    pushTrue()\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function SIMPLE_NULL (octet) {\n    octet = octet | 0\n\n    pushNull()\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function SIMPLE_UNDEFINED (octet) {\n    octet = octet | 0\n\n    pushUndefined()\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function SIMPLE_BYTE (octet) {\n    octet = octet | 0\n\n    if (checkOffset(1) | 0) {\n      return 1\n    }\n\n    pushSimpleUnassigned(heap[(offset + 1) | 0] | 0)\n\n    offset = (offset + 2)  | 0\n\n    return 0\n  }\n\n  function SIMPLE_FLOAT_HALF (octet) {\n    octet = octet | 0\n\n    var f = 0\n    var g = 0\n    var sign = 1.0\n    var exp = 0.0\n    var mant = 0.0\n    var r = 0.0\n    if (checkOffset(2) | 0) {\n      return 1\n    }\n\n    f = heap[(offset + 1) | 0] | 0\n    g = heap[(offset + 2) | 0] | 0\n\n    if ((f | 0) & 0x80) {\n      sign = -1.0\n    }\n\n    exp = +(((f | 0) & 0x7C) >> 2)\n    mant = +((((f | 0) & 0x03) << 8) | g)\n\n    if (+exp == 0.0) {\n      pushFloat(+(\n        (+sign) * +5.9604644775390625e-8 * (+mant)\n      ))\n    } else if (+exp == 31.0) {\n      if (+sign == 1.0) {\n        if (+mant > 0.0) {\n          pushNaN()\n        } else {\n          pushInfinity()\n        }\n      } else {\n        if (+mant > 0.0) {\n          pushNaNNeg()\n        } else {\n          pushInfinityNeg()\n        }\n      }\n    } else {\n      pushFloat(+(\n        +sign * pow(+2, +(+exp - 25.0)) * +(1024.0 + mant)\n      ))\n    }\n\n    offset = (offset + 3) | 0\n\n    return 0\n  }\n\n  function SIMPLE_FLOAT_SINGLE (octet) {\n    octet = octet | 0\n\n    if (checkOffset(4) | 0) {\n      return 1\n    }\n\n    pushFloatSingle(\n      heap[(offset + 1) | 0] | 0,\n      heap[(offset + 2) | 0] | 0,\n      heap[(offset + 3) | 0] | 0,\n      heap[(offset + 4) | 0] | 0\n    )\n\n    offset = (offset + 5) | 0\n\n    return 0\n  }\n\n  function SIMPLE_FLOAT_DOUBLE (octet) {\n    octet = octet | 0\n\n    if (checkOffset(8) | 0) {\n      return 1\n    }\n\n    pushFloatDouble(\n      heap[(offset + 1) | 0] | 0,\n      heap[(offset + 2) | 0] | 0,\n      heap[(offset + 3) | 0] | 0,\n      heap[(offset + 4) | 0] | 0,\n      heap[(offset + 5) | 0] | 0,\n      heap[(offset + 6) | 0] | 0,\n      heap[(offset + 7) | 0] | 0,\n      heap[(offset + 8) | 0] | 0\n    )\n\n    offset = (offset + 9) | 0\n\n    return 0\n  }\n\n  function ERROR (octet) {\n    octet = octet | 0\n\n    return 1\n  }\n\n  function BREAK (octet) {\n    octet = octet | 0\n\n    pushBreak()\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  // -- Jump Table\n\n  var jumpTable = [\n    // Integer 0x00..0x17 (0..23)\n    INT_P, // 0x00\n    INT_P, // 0x01\n    INT_P, // 0x02\n    INT_P, // 0x03\n    INT_P, // 0x04\n    INT_P, // 0x05\n    INT_P, // 0x06\n    INT_P, // 0x07\n    INT_P, // 0x08\n    INT_P, // 0x09\n    INT_P, // 0x0A\n    INT_P, // 0x0B\n    INT_P, // 0x0C\n    INT_P, // 0x0D\n    INT_P, // 0x0E\n    INT_P, // 0x0F\n    INT_P, // 0x10\n    INT_P, // 0x11\n    INT_P, // 0x12\n    INT_P, // 0x13\n    INT_P, // 0x14\n    INT_P, // 0x15\n    INT_P, // 0x16\n    INT_P, // 0x17\n    // Unsigned integer (one-byte uint8_t follows)\n    UINT_P_8, // 0x18\n    // Unsigned integer (two-byte uint16_t follows)\n    UINT_P_16, // 0x19\n    // Unsigned integer (four-byte uint32_t follows)\n    UINT_P_32, // 0x1a\n    // Unsigned integer (eight-byte uint64_t follows)\n    UINT_P_64, // 0x1b\n    ERROR, // 0x1c\n    ERROR, // 0x1d\n    ERROR, // 0x1e\n    ERROR, // 0x1f\n    // Negative integer -1-0x00..-1-0x17 (-1..-24)\n    INT_N, // 0x20\n    INT_N, // 0x21\n    INT_N, // 0x22\n    INT_N, // 0x23\n    INT_N, // 0x24\n    INT_N, // 0x25\n    INT_N, // 0x26\n    INT_N, // 0x27\n    INT_N, // 0x28\n    INT_N, // 0x29\n    INT_N, // 0x2A\n    INT_N, // 0x2B\n    INT_N, // 0x2C\n    INT_N, // 0x2D\n    INT_N, // 0x2E\n    INT_N, // 0x2F\n    INT_N, // 0x30\n    INT_N, // 0x31\n    INT_N, // 0x32\n    INT_N, // 0x33\n    INT_N, // 0x34\n    INT_N, // 0x35\n    INT_N, // 0x36\n    INT_N, // 0x37\n    // Negative integer -1-n (one-byte uint8_t for n follows)\n    UINT_N_8, // 0x38\n    // Negative integer -1-n (two-byte uint16_t for n follows)\n    UINT_N_16, // 0x39\n    // Negative integer -1-n (four-byte uint32_t for nfollows)\n    UINT_N_32, // 0x3a\n    // Negative integer -1-n (eight-byte uint64_t for n follows)\n    UINT_N_64, // 0x3b\n    ERROR, // 0x3c\n    ERROR, // 0x3d\n    ERROR, // 0x3e\n    ERROR, // 0x3f\n    // byte string (0x00..0x17 bytes follow)\n    BYTE_STRING, // 0x40\n    BYTE_STRING, // 0x41\n    BYTE_STRING, // 0x42\n    BYTE_STRING, // 0x43\n    BYTE_STRING, // 0x44\n    BYTE_STRING, // 0x45\n    BYTE_STRING, // 0x46\n    BYTE_STRING, // 0x47\n    BYTE_STRING, // 0x48\n    BYTE_STRING, // 0x49\n    BYTE_STRING, // 0x4A\n    BYTE_STRING, // 0x4B\n    BYTE_STRING, // 0x4C\n    BYTE_STRING, // 0x4D\n    BYTE_STRING, // 0x4E\n    BYTE_STRING, // 0x4F\n    BYTE_STRING, // 0x50\n    BYTE_STRING, // 0x51\n    BYTE_STRING, // 0x52\n    BYTE_STRING, // 0x53\n    BYTE_STRING, // 0x54\n    BYTE_STRING, // 0x55\n    BYTE_STRING, // 0x56\n    BYTE_STRING, // 0x57\n    // byte string (one-byte uint8_t for n, and then n bytes follow)\n    BYTE_STRING_8, // 0x58\n    // byte string (two-byte uint16_t for n, and then n bytes follow)\n    BYTE_STRING_16, // 0x59\n    // byte string (four-byte uint32_t for n, and then n bytes follow)\n    BYTE_STRING_32, // 0x5a\n    // byte string (eight-byte uint64_t for n, and then n bytes follow)\n    BYTE_STRING_64, // 0x5b\n    ERROR, // 0x5c\n    ERROR, // 0x5d\n    ERROR, // 0x5e\n    // byte string, byte strings follow, terminated by \"break\"\n    BYTE_STRING_BREAK, // 0x5f\n    // UTF-8 string (0x00..0x17 bytes follow)\n    UTF8_STRING, // 0x60\n    UTF8_STRING, // 0x61\n    UTF8_STRING, // 0x62\n    UTF8_STRING, // 0x63\n    UTF8_STRING, // 0x64\n    UTF8_STRING, // 0x65\n    UTF8_STRING, // 0x66\n    UTF8_STRING, // 0x67\n    UTF8_STRING, // 0x68\n    UTF8_STRING, // 0x69\n    UTF8_STRING, // 0x6A\n    UTF8_STRING, // 0x6B\n    UTF8_STRING, // 0x6C\n    UTF8_STRING, // 0x6D\n    UTF8_STRING, // 0x6E\n    UTF8_STRING, // 0x6F\n    UTF8_STRING, // 0x70\n    UTF8_STRING, // 0x71\n    UTF8_STRING, // 0x72\n    UTF8_STRING, // 0x73\n    UTF8_STRING, // 0x74\n    UTF8_STRING, // 0x75\n    UTF8_STRING, // 0x76\n    UTF8_STRING, // 0x77\n    // UTF-8 string (one-byte uint8_t for n, and then n bytes follow)\n    UTF8_STRING_8, // 0x78\n    // UTF-8 string (two-byte uint16_t for n, and then n bytes follow)\n    UTF8_STRING_16, // 0x79\n    // UTF-8 string (four-byte uint32_t for n, and then n bytes follow)\n    UTF8_STRING_32, // 0x7a\n    // UTF-8 string (eight-byte uint64_t for n, and then n bytes follow)\n    UTF8_STRING_64, // 0x7b\n    // UTF-8 string, UTF-8 strings follow, terminated by \"break\"\n    ERROR, // 0x7c\n    ERROR, // 0x7d\n    ERROR, // 0x7e\n    UTF8_STRING_BREAK, // 0x7f\n    // array (0x00..0x17 data items follow)\n    ARRAY, // 0x80\n    ARRAY, // 0x81\n    ARRAY, // 0x82\n    ARRAY, // 0x83\n    ARRAY, // 0x84\n    ARRAY, // 0x85\n    ARRAY, // 0x86\n    ARRAY, // 0x87\n    ARRAY, // 0x88\n    ARRAY, // 0x89\n    ARRAY, // 0x8A\n    ARRAY, // 0x8B\n    ARRAY, // 0x8C\n    ARRAY, // 0x8D\n    ARRAY, // 0x8E\n    ARRAY, // 0x8F\n    ARRAY, // 0x90\n    ARRAY, // 0x91\n    ARRAY, // 0x92\n    ARRAY, // 0x93\n    ARRAY, // 0x94\n    ARRAY, // 0x95\n    ARRAY, // 0x96\n    ARRAY, // 0x97\n    // array (one-byte uint8_t fo, and then n data items follow)\n    ARRAY_8, // 0x98\n    // array (two-byte uint16_t for n, and then n data items follow)\n    ARRAY_16, // 0x99\n    // array (four-byte uint32_t for n, and then n data items follow)\n    ARRAY_32, // 0x9a\n    // array (eight-byte uint64_t for n, and then n data items follow)\n    ARRAY_64, // 0x9b\n    // array, data items follow, terminated by \"break\"\n    ERROR, // 0x9c\n    ERROR, // 0x9d\n    ERROR, // 0x9e\n    ARRAY_BREAK, // 0x9f\n    // map (0x00..0x17 pairs of data items follow)\n    MAP, // 0xa0\n    MAP, // 0xa1\n    MAP, // 0xa2\n    MAP, // 0xa3\n    MAP, // 0xa4\n    MAP, // 0xa5\n    MAP, // 0xa6\n    MAP, // 0xa7\n    MAP, // 0xa8\n    MAP, // 0xa9\n    MAP, // 0xaA\n    MAP, // 0xaB\n    MAP, // 0xaC\n    MAP, // 0xaD\n    MAP, // 0xaE\n    MAP, // 0xaF\n    MAP, // 0xb0\n    MAP, // 0xb1\n    MAP, // 0xb2\n    MAP, // 0xb3\n    MAP, // 0xb4\n    MAP, // 0xb5\n    MAP, // 0xb6\n    MAP, // 0xb7\n    // map (one-byte uint8_t for n, and then n pairs of data items follow)\n    MAP_8, // 0xb8\n    // map (two-byte uint16_t for n, and then n pairs of data items follow)\n    MAP_16, // 0xb9\n    // map (four-byte uint32_t for n, and then n pairs of data items follow)\n    MAP_32, // 0xba\n    // map (eight-byte uint64_t for n, and then n pairs of data items follow)\n    MAP_64, // 0xbb\n    ERROR, // 0xbc\n    ERROR, // 0xbd\n    ERROR, // 0xbe\n    // map, pairs of data items follow, terminated by \"break\"\n    MAP_BREAK, // 0xbf\n    // Text-based date/time (data item follows; see Section 2.4.1)\n    TAG_KNOWN, // 0xc0\n    // Epoch-based date/time (data item follows; see Section 2.4.1)\n    TAG_KNOWN, // 0xc1\n    // Positive bignum (data item \"byte string\" follows)\n    TAG_KNOWN, // 0xc2\n    // Negative bignum (data item \"byte string\" follows)\n    TAG_KNOWN, // 0xc3\n    // Decimal Fraction (data item \"array\" follows; see Section 2.4.3)\n    TAG_KNOWN, // 0xc4\n    // Bigfloat (data item \"array\" follows; see Section 2.4.3)\n    TAG_KNOWN, // 0xc5\n    // (tagged item)\n    TAG_UNASSIGNED, // 0xc6\n    TAG_UNASSIGNED, // 0xc7\n    TAG_UNASSIGNED, // 0xc8\n    TAG_UNASSIGNED, // 0xc9\n    TAG_UNASSIGNED, // 0xca\n    TAG_UNASSIGNED, // 0xcb\n    TAG_UNASSIGNED, // 0xcc\n    TAG_UNASSIGNED, // 0xcd\n    TAG_UNASSIGNED, // 0xce\n    TAG_UNASSIGNED, // 0xcf\n    TAG_UNASSIGNED, // 0xd0\n    TAG_UNASSIGNED, // 0xd1\n    TAG_UNASSIGNED, // 0xd2\n    TAG_UNASSIGNED, // 0xd3\n    TAG_UNASSIGNED, // 0xd4\n    // Expected Conversion (data item follows; see Section 2.4.4.2)\n    TAG_UNASSIGNED, // 0xd5\n    TAG_UNASSIGNED, // 0xd6\n    TAG_UNASSIGNED, // 0xd7\n    // (more tagged items, 1/2/4/8 bytes and then a data item follow)\n    TAG_MORE_1, // 0xd8\n    TAG_MORE_2, // 0xd9\n    TAG_MORE_4, // 0xda\n    TAG_MORE_8, // 0xdb\n    ERROR, // 0xdc\n    ERROR, // 0xdd\n    ERROR, // 0xde\n    ERROR, // 0xdf\n    // (simple value)\n    SIMPLE_UNASSIGNED, // 0xe0\n    SIMPLE_UNASSIGNED, // 0xe1\n    SIMPLE_UNASSIGNED, // 0xe2\n    SIMPLE_UNASSIGNED, // 0xe3\n    SIMPLE_UNASSIGNED, // 0xe4\n    SIMPLE_UNASSIGNED, // 0xe5\n    SIMPLE_UNASSIGNED, // 0xe6\n    SIMPLE_UNASSIGNED, // 0xe7\n    SIMPLE_UNASSIGNED, // 0xe8\n    SIMPLE_UNASSIGNED, // 0xe9\n    SIMPLE_UNASSIGNED, // 0xea\n    SIMPLE_UNASSIGNED, // 0xeb\n    SIMPLE_UNASSIGNED, // 0xec\n    SIMPLE_UNASSIGNED, // 0xed\n    SIMPLE_UNASSIGNED, // 0xee\n    SIMPLE_UNASSIGNED, // 0xef\n    SIMPLE_UNASSIGNED, // 0xf0\n    SIMPLE_UNASSIGNED, // 0xf1\n    SIMPLE_UNASSIGNED, // 0xf2\n    SIMPLE_UNASSIGNED, // 0xf3\n    // False\n    SIMPLE_FALSE, // 0xf4\n    // True\n    SIMPLE_TRUE, // 0xf5\n    // Null\n    SIMPLE_NULL, // 0xf6\n    // Undefined\n    SIMPLE_UNDEFINED, // 0xf7\n    // (simple value, one byte follows)\n    SIMPLE_BYTE, // 0xf8\n    // Half-Precision Float (two-byte IEEE 754)\n    SIMPLE_FLOAT_HALF, // 0xf9\n    // Single-Precision Float (four-byte IEEE 754)\n    SIMPLE_FLOAT_SINGLE, // 0xfa\n    // Double-Precision Float (eight-byte IEEE 754)\n    SIMPLE_FLOAT_DOUBLE, // 0xfb\n    ERROR, // 0xfc\n    ERROR, // 0xfd\n    ERROR, // 0xfe\n    // \"break\" stop code\n    BREAK // 0xff\n  ]\n\n  // --\n\n  return {\n    parse: parse\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYm9yYy9zcmMvZGVjb2Rlci5hc20uanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvYm9yYy9zcmMvZGVjb2Rlci5hc20uanM/MDE0ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlY29kZUFzbSAoc3RkbGliLCBmb3JlaWduLCBidWZmZXIpIHtcbiAgJ3VzZSBhc20nXG5cbiAgLy8gLS0gSW1wb3J0c1xuXG4gIHZhciBoZWFwID0gbmV3IHN0ZGxpYi5VaW50OEFycmF5KGJ1ZmZlcilcbiAgLy8gdmFyIGxvZyA9IGZvcmVpZ24ubG9nXG4gIHZhciBwdXNoSW50ID0gZm9yZWlnbi5wdXNoSW50XG4gIHZhciBwdXNoSW50MzIgPSBmb3JlaWduLnB1c2hJbnQzMlxuICB2YXIgcHVzaEludDMyTmVnID0gZm9yZWlnbi5wdXNoSW50MzJOZWdcbiAgdmFyIHB1c2hJbnQ2NCA9IGZvcmVpZ24ucHVzaEludDY0XG4gIHZhciBwdXNoSW50NjROZWcgPSBmb3JlaWduLnB1c2hJbnQ2NE5lZ1xuICB2YXIgcHVzaEZsb2F0ID0gZm9yZWlnbi5wdXNoRmxvYXRcbiAgdmFyIHB1c2hGbG9hdFNpbmdsZSA9IGZvcmVpZ24ucHVzaEZsb2F0U2luZ2xlXG4gIHZhciBwdXNoRmxvYXREb3VibGUgPSBmb3JlaWduLnB1c2hGbG9hdERvdWJsZVxuICB2YXIgcHVzaFRydWUgPSBmb3JlaWduLnB1c2hUcnVlXG4gIHZhciBwdXNoRmFsc2UgPSBmb3JlaWduLnB1c2hGYWxzZVxuICB2YXIgcHVzaFVuZGVmaW5lZCA9IGZvcmVpZ24ucHVzaFVuZGVmaW5lZFxuICB2YXIgcHVzaE51bGwgPSBmb3JlaWduLnB1c2hOdWxsXG4gIHZhciBwdXNoSW5maW5pdHkgPSBmb3JlaWduLnB1c2hJbmZpbml0eVxuICB2YXIgcHVzaEluZmluaXR5TmVnID0gZm9yZWlnbi5wdXNoSW5maW5pdHlOZWdcbiAgdmFyIHB1c2hOYU4gPSBmb3JlaWduLnB1c2hOYU5cbiAgdmFyIHB1c2hOYU5OZWcgPSBmb3JlaWduLnB1c2hOYU5OZWdcblxuICB2YXIgcHVzaEFycmF5U3RhcnQgPSBmb3JlaWduLnB1c2hBcnJheVN0YXJ0XG4gIHZhciBwdXNoQXJyYXlTdGFydEZpeGVkID0gZm9yZWlnbi5wdXNoQXJyYXlTdGFydEZpeGVkXG4gIHZhciBwdXNoQXJyYXlTdGFydEZpeGVkMzIgPSBmb3JlaWduLnB1c2hBcnJheVN0YXJ0Rml4ZWQzMlxuICB2YXIgcHVzaEFycmF5U3RhcnRGaXhlZDY0ID0gZm9yZWlnbi5wdXNoQXJyYXlTdGFydEZpeGVkNjRcbiAgdmFyIHB1c2hPYmplY3RTdGFydCA9IGZvcmVpZ24ucHVzaE9iamVjdFN0YXJ0XG4gIHZhciBwdXNoT2JqZWN0U3RhcnRGaXhlZCA9IGZvcmVpZ24ucHVzaE9iamVjdFN0YXJ0Rml4ZWRcbiAgdmFyIHB1c2hPYmplY3RTdGFydEZpeGVkMzIgPSBmb3JlaWduLnB1c2hPYmplY3RTdGFydEZpeGVkMzJcbiAgdmFyIHB1c2hPYmplY3RTdGFydEZpeGVkNjQgPSBmb3JlaWduLnB1c2hPYmplY3RTdGFydEZpeGVkNjRcblxuICB2YXIgcHVzaEJ5dGVTdHJpbmcgPSBmb3JlaWduLnB1c2hCeXRlU3RyaW5nXG4gIHZhciBwdXNoQnl0ZVN0cmluZ1N0YXJ0ID0gZm9yZWlnbi5wdXNoQnl0ZVN0cmluZ1N0YXJ0XG4gIHZhciBwdXNoVXRmOFN0cmluZyA9IGZvcmVpZ24ucHVzaFV0ZjhTdHJpbmdcbiAgdmFyIHB1c2hVdGY4U3RyaW5nU3RhcnQgPSBmb3JlaWduLnB1c2hVdGY4U3RyaW5nU3RhcnRcblxuICB2YXIgcHVzaFNpbXBsZVVuYXNzaWduZWQgPSBmb3JlaWduLnB1c2hTaW1wbGVVbmFzc2lnbmVkXG5cbiAgdmFyIHB1c2hUYWdTdGFydCA9IGZvcmVpZ24ucHVzaFRhZ1N0YXJ0XG4gIHZhciBwdXNoVGFnU3RhcnQ0ID0gZm9yZWlnbi5wdXNoVGFnU3RhcnQ0XG4gIHZhciBwdXNoVGFnU3RhcnQ4ID0gZm9yZWlnbi5wdXNoVGFnU3RhcnQ4XG4gIHZhciBwdXNoVGFnVW5hc3NpZ25lZCA9IGZvcmVpZ24ucHVzaFRhZ1VuYXNzaWduZWRcblxuICB2YXIgcHVzaEJyZWFrID0gZm9yZWlnbi5wdXNoQnJlYWtcblxuICB2YXIgcG93ID0gc3RkbGliLk1hdGgucG93XG5cbiAgLy8gLS0gQ29uc3RhbnRzXG5cblxuICAvLyAtLSBNdXRhYmxlIFZhcmlhYmxlc1xuXG4gIHZhciBvZmZzZXQgPSAwXG4gIHZhciBpbnB1dExlbmd0aCA9IDBcbiAgdmFyIGNvZGUgPSAwXG5cbiAgLy8gRGVjb2RlIGEgY2JvciBzdHJpbmcgcmVwcmVzZW50ZWQgYXMgVWludDhBcnJheVxuICAvLyB3aGljaCBpcyBhbGxvY2F0ZWQgb24gdGhlIGhlYXAgZnJvbSAwIHRvIGlucHV0TGVuZ3RoXG4gIC8vXG4gIC8vIGlucHV0IC0gSW50XG4gIC8vXG4gIC8vIFJldHVybnMgQ29kZSAtIEludCxcbiAgLy8gU3VjY2VzcyA9IDBcbiAgLy8gRXJyb3IgPiAwXG4gIGZ1bmN0aW9uIHBhcnNlIChpbnB1dCkge1xuICAgIGlucHV0ID0gaW5wdXQgfCAwXG5cbiAgICBvZmZzZXQgPSAwXG4gICAgaW5wdXRMZW5ndGggPSBpbnB1dFxuXG4gICAgd2hpbGUgKChvZmZzZXQgfCAwKSA8IChpbnB1dExlbmd0aCB8IDApKSB7XG4gICAgICBjb2RlID0ganVtcFRhYmxlW2hlYXBbb2Zmc2V0XSAmIDI1NV0oaGVhcFtvZmZzZXRdIHwgMCkgfCAwXG5cbiAgICAgIGlmICgoY29kZSB8IDApID4gMCkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb2RlIHwgMFxuICB9XG5cbiAgLy8gLS0gSGVscGVyIEZ1bmN0aW9uXG5cbiAgZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG4pIHtcbiAgICBuID0gbiB8IDBcblxuICAgIGlmICgoKChvZmZzZXQgfCAwKSArIChuIHwgMCkpIHwgMCkgPCAoaW5wdXRMZW5ndGggfCAwKSkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG5cbiAgICByZXR1cm4gMVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFVJbnQxNiAobikge1xuICAgIG4gPSBuIHwgMFxuXG4gICAgcmV0dXJuIChcbiAgICAgIChoZWFwW24gfCAwXSA8PCA4KSB8IGhlYXBbKG4gKyAxKSB8IDBdXG4gICAgKSB8IDBcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRVSW50MzIgKG4pIHtcbiAgICBuID0gbiB8IDBcblxuICAgIHJldHVybiAoXG4gICAgICAoaGVhcFtuIHwgMF0gPDwgMjQpIHwgKGhlYXBbKG4gKyAxKSB8IDBdIDw8IDE2KSB8IChoZWFwWyhuICsgMikgfCAwXSA8PCA4KSB8IGhlYXBbKG4gKyAzKSB8IDBdXG4gICAgKSB8IDBcbiAgfVxuXG4gIC8vIC0tIEluaXRpYWwgQnl0ZSBIYW5kbGVyc1xuXG4gIGZ1bmN0aW9uIElOVF9QIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBwdXNoSW50KG9jdGV0IHwgMClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAxKSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBVSU5UX1BfOCAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDEpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoSW50KGhlYXBbKG9mZnNldCArIDEpIHwgMF0gfCAwKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDIpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFVJTlRfUF8xNiAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDIpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoSW50KFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMSkgfCAwKSB8IDBcbiAgICApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMykgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVUlOVF9QXzMyIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoNCkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hJbnQzMihcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDEpIHwgMCkgfCAwLFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMykgfCAwKSB8IDBcbiAgICApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgNSkgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVUlOVF9QXzY0IChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoOCkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hJbnQ2NChcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDEpIHwgMCkgfCAwLFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMykgfCAwKSB8IDAsXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyA1KSB8IDApIHwgMCxcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDcpIHwgMCkgfCAwXG4gICAgKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDkpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIElOVF9OIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBwdXNoSW50KCgtMSAtICgob2N0ZXQgLSAzMikgfCAwKSkgfCAwKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDEpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFVJTlRfTl84IChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoMSkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hJbnQoXG4gICAgICAoLTEgLSAoaGVhcFsob2Zmc2V0ICsgMSkgfCAwXSB8IDApKSB8IDBcbiAgICApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMikgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVUlOVF9OXzE2IChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICB2YXIgdmFsID0gMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDIpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICB2YWwgPSByZWFkVUludDE2KChvZmZzZXQgKyAxKSB8IDApIHwgMFxuICAgIHB1c2hJbnQoKC0xIC0gKHZhbCB8IDApKSB8IDApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMykgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVUlOVF9OXzMyIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoNCkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hJbnQzMk5lZyhcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDEpIHwgMCkgfCAwLFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMykgfCAwKSB8IDBcbiAgICApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgNSkgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVUlOVF9OXzY0IChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoOCkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hJbnQ2NE5lZyhcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDEpIHwgMCkgfCAwLFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMykgfCAwKSB8IDAsXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyA1KSB8IDApIHwgMCxcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDcpIHwgMCkgfCAwXG4gICAgKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDkpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIEJZVEVfU1RSSU5HIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICB2YXIgc3RhcnQgPSAwXG4gICAgdmFyIGVuZCA9IDBcbiAgICB2YXIgc3RlcCA9IDBcblxuICAgIHN0ZXAgPSAob2N0ZXQgLSA2NCkgfCAwXG4gICAgaWYgKGNoZWNrT2Zmc2V0KHN0ZXAgfCAwKSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgc3RhcnQgPSAob2Zmc2V0ICsgMSkgfCAwXG4gICAgZW5kID0gKCgob2Zmc2V0ICsgMSkgfCAwKSArIChzdGVwIHwgMCkpIHwgMFxuXG4gICAgcHVzaEJ5dGVTdHJpbmcoc3RhcnQgfCAwLCBlbmQgfCAwKVxuXG4gICAgb2Zmc2V0ID0gZW5kIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIEJZVEVfU1RSSU5HXzggKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHZhciBzdGFydCA9IDBcbiAgICB2YXIgZW5kID0gMFxuICAgIHZhciBsZW5ndGggPSAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoMSkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIGxlbmd0aCA9IGhlYXBbKG9mZnNldCArIDEpIHwgMF0gfCAwXG4gICAgc3RhcnQgPSAob2Zmc2V0ICsgMikgfCAwXG4gICAgZW5kID0gKCgob2Zmc2V0ICsgMikgfCAwKSArIChsZW5ndGggfCAwKSkgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoKGxlbmd0aCArIDEpIHwgMCkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hCeXRlU3RyaW5nKHN0YXJ0IHwgMCwgZW5kIHwgMClcblxuICAgIG9mZnNldCA9IGVuZCB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBCWVRFX1NUUklOR18xNiAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgdmFyIHN0YXJ0ID0gMFxuICAgIHZhciBlbmQgPSAwXG4gICAgdmFyIGxlbmd0aCA9IDBcblxuICAgIGlmIChjaGVja09mZnNldCgyKSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgbGVuZ3RoID0gcmVhZFVJbnQxNigob2Zmc2V0ICsgMSkgfCAwKSB8IDBcbiAgICBzdGFydCA9IChvZmZzZXQgKyAzKSB8IDBcbiAgICBlbmQgPSAoKChvZmZzZXQgKyAzKSB8IDApICsgKGxlbmd0aCB8IDApKSB8IDBcblxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KChsZW5ndGggKyAyKSB8IDApIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoQnl0ZVN0cmluZyhzdGFydCB8IDAsIGVuZCB8IDApXG5cbiAgICBvZmZzZXQgPSBlbmQgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gQllURV9TVFJJTkdfMzIgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHZhciBzdGFydCA9IDBcbiAgICB2YXIgZW5kID0gMFxuICAgIHZhciBsZW5ndGggPSAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoNCkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIGxlbmd0aCA9IHJlYWRVSW50MzIoKG9mZnNldCArIDEpIHwgMCkgfCAwXG4gICAgc3RhcnQgPSAob2Zmc2V0ICsgNSkgfCAwXG4gICAgZW5kID0gKCgob2Zmc2V0ICsgNSkgfCAwKSArIChsZW5ndGggfCAwKSkgfCAwXG5cblxuICAgIGlmIChjaGVja09mZnNldCgobGVuZ3RoICsgNCkgfCAwKSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaEJ5dGVTdHJpbmcoc3RhcnQgfCAwLCBlbmQgfCAwKVxuXG4gICAgb2Zmc2V0ID0gZW5kIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIEJZVEVfU1RSSU5HXzY0IChvY3RldCkge1xuICAgIC8vIE5PVCBJTVBMRU1FTlRFRFxuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICByZXR1cm4gMVxuICB9XG5cbiAgZnVuY3Rpb24gQllURV9TVFJJTkdfQlJFQUsgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHB1c2hCeXRlU3RyaW5nU3RhcnQoKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDEpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFVURjhfU1RSSU5HIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICB2YXIgc3RhcnQgPSAwXG4gICAgdmFyIGVuZCA9IDBcbiAgICB2YXIgc3RlcCA9IDBcblxuICAgIHN0ZXAgPSAob2N0ZXQgLSA5NikgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoc3RlcCB8IDApIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBzdGFydCA9IChvZmZzZXQgKyAxKSB8IDBcbiAgICBlbmQgPSAoKChvZmZzZXQgKyAxKSB8IDApICsgKHN0ZXAgfCAwKSkgfCAwXG5cbiAgICBwdXNoVXRmOFN0cmluZyhzdGFydCB8IDAsIGVuZCB8IDApXG5cbiAgICBvZmZzZXQgPSBlbmQgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVVRGOF9TVFJJTkdfOCAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgdmFyIHN0YXJ0ID0gMFxuICAgIHZhciBlbmQgPSAwXG4gICAgdmFyIGxlbmd0aCA9IDBcblxuICAgIGlmIChjaGVja09mZnNldCgxKSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgbGVuZ3RoID0gaGVhcFsob2Zmc2V0ICsgMSkgfCAwXSB8IDBcbiAgICBzdGFydCA9IChvZmZzZXQgKyAyKSB8IDBcbiAgICBlbmQgPSAoKChvZmZzZXQgKyAyKSB8IDApICsgKGxlbmd0aCB8IDApKSB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCgobGVuZ3RoICsgMSkgfCAwKSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaFV0ZjhTdHJpbmcoc3RhcnQgfCAwLCBlbmQgfCAwKVxuXG4gICAgb2Zmc2V0ID0gZW5kIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFVURjhfU1RSSU5HXzE2IChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICB2YXIgc3RhcnQgPSAwXG4gICAgdmFyIGVuZCA9IDBcbiAgICB2YXIgbGVuZ3RoID0gMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDIpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBsZW5ndGggPSByZWFkVUludDE2KChvZmZzZXQgKyAxKSB8IDApIHwgMFxuICAgIHN0YXJ0ID0gKG9mZnNldCArIDMpIHwgMFxuICAgIGVuZCA9ICgoKG9mZnNldCArIDMpIHwgMCkgKyAobGVuZ3RoIHwgMCkpIHwgMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KChsZW5ndGggKyAyKSB8IDApIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoVXRmOFN0cmluZyhzdGFydCB8IDAsIGVuZCB8IDApXG5cbiAgICBvZmZzZXQgPSBlbmQgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVVRGOF9TVFJJTkdfMzIgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHZhciBzdGFydCA9IDBcbiAgICB2YXIgZW5kID0gMFxuICAgIHZhciBsZW5ndGggPSAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoNCkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIGxlbmd0aCA9IHJlYWRVSW50MzIoKG9mZnNldCArIDEpIHwgMCkgfCAwXG4gICAgc3RhcnQgPSAob2Zmc2V0ICsgNSkgfCAwXG4gICAgZW5kID0gKCgob2Zmc2V0ICsgNSkgfCAwKSArIChsZW5ndGggfCAwKSkgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoKGxlbmd0aCArIDQpIHwgMCkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hVdGY4U3RyaW5nKHN0YXJ0IHwgMCwgZW5kIHwgMClcblxuICAgIG9mZnNldCA9IGVuZCB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBVVEY4X1NUUklOR182NCAob2N0ZXQpIHtcbiAgICAvLyBOT1QgSU1QTEVNRU5URURcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIGZ1bmN0aW9uIFVURjhfU1RSSU5HX0JSRUFLIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBwdXNoVXRmOFN0cmluZ1N0YXJ0KClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAxKSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBBUlJBWSAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgcHVzaEFycmF5U3RhcnRGaXhlZCgob2N0ZXQgLSAxMjgpIHwgMClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAxKSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBBUlJBWV84IChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoMSkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hBcnJheVN0YXJ0Rml4ZWQoaGVhcFsob2Zmc2V0ICsgMSkgfCAwXSB8IDApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMikgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gQVJSQVlfMTYgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCgyKSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaEFycmF5U3RhcnRGaXhlZChcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDEpIHwgMCkgfCAwXG4gICAgKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDMpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIEFSUkFZXzMyIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoNCkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hBcnJheVN0YXJ0Rml4ZWQzMihcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDEpIHwgMCkgfCAwLFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMykgfCAwKSB8IDBcbiAgICApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgNSkgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gQVJSQVlfNjQgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCg4KSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaEFycmF5U3RhcnRGaXhlZDY0KFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMSkgfCAwKSB8IDAsXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyAzKSB8IDApIHwgMCxcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDUpIHwgMCkgfCAwLFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgNykgfCAwKSB8IDBcbiAgICApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgOSkgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gQVJSQVlfQlJFQUsgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHB1c2hBcnJheVN0YXJ0KClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAxKSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBNQVAgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHZhciBzdGVwID0gMFxuXG4gICAgc3RlcCA9IChvY3RldCAtIDE2MCkgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoc3RlcCB8IDApIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoT2JqZWN0U3RhcnRGaXhlZChzdGVwIHwgMClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAxKSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBNQVBfOCAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDEpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoT2JqZWN0U3RhcnRGaXhlZChoZWFwWyhvZmZzZXQgKyAxKSB8IDBdIHwgMClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAyKSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBNQVBfMTYgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCgyKSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaE9iamVjdFN0YXJ0Rml4ZWQoXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyAxKSB8IDApIHwgMFxuICAgIClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAzKSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBNQVBfMzIgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCg0KSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaE9iamVjdFN0YXJ0Rml4ZWQzMihcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDEpIHwgMCkgfCAwLFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMykgfCAwKSB8IDBcbiAgICApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgNSkgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gTUFQXzY0IChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoOCkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hPYmplY3RTdGFydEZpeGVkNjQoXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyAxKSB8IDApIHwgMCxcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDMpIHwgMCkgfCAwLFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgNSkgfCAwKSB8IDAsXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyA3KSB8IDApIHwgMFxuICAgIClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyA5KSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBNQVBfQlJFQUsgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHB1c2hPYmplY3RTdGFydCgpXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMSkgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVEFHX0tOT1dOIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBwdXNoVGFnU3RhcnQoKG9jdGV0IC0gMTkyfCAwKSB8IDApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMSB8IDApXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVEFHX0JJR05VTV9QT1MgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHB1c2hUYWdTdGFydChvY3RldCB8IDApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMSB8IDApXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVEFHX0JJR05VTV9ORUcgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHB1c2hUYWdTdGFydChvY3RldCB8IDApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMSB8IDApXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVEFHX0ZSQUMgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHB1c2hUYWdTdGFydChvY3RldCB8IDApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMSB8IDApXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVEFHX0JJR05VTV9GTE9BVCAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgcHVzaFRhZ1N0YXJ0KG9jdGV0IHwgMClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAxIHwgMClcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBUQUdfVU5BU1NJR05FRCAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgcHVzaFRhZ1N0YXJ0KChvY3RldCAtIDE5MnwgMCkgfCAwKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDEgfCAwKVxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFRBR19CQVNFNjRfVVJMIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBwdXNoVGFnU3RhcnQob2N0ZXQgfCAwKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDEgfCAwKVxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFRBR19CQVNFNjQgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHB1c2hUYWdTdGFydChvY3RldCB8IDApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMSB8IDApXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVEFHX0JBU0UxNiAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgcHVzaFRhZ1N0YXJ0KG9jdGV0IHwgMClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAxIHwgMClcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBUQUdfTU9SRV8xIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoMSkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hUYWdTdGFydChoZWFwWyhvZmZzZXQgKyAxKSB8IDBdIHwgMClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAyIHwgMClcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBUQUdfTU9SRV8yIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoMikgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hUYWdTdGFydChcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDEpIHwgMCkgfCAwXG4gICAgKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDMgfCAwKVxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFRBR19NT1JFXzQgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCg0KSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaFRhZ1N0YXJ0NChcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDEpIHwgMCkgfCAwLFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMykgfCAwKSB8IDBcbiAgICApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgNSB8IDApXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVEFHX01PUkVfOCAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDgpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoVGFnU3RhcnQ4KFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMSkgfCAwKSB8IDAsXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyAzKSB8IDApIHwgMCxcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDUpIHwgMCkgfCAwLFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgNykgfCAwKSB8IDBcbiAgICApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgOSB8IDApXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gU0lNUExFX1VOQVNTSUdORUQgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHB1c2hTaW1wbGVVbmFzc2lnbmVkKCgob2N0ZXQgfCAwKSAtIDIyNCkgfCAwKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDEpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFNJTVBMRV9GQUxTRSAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgcHVzaEZhbHNlKClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAxKSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBTSU1QTEVfVFJVRSAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgcHVzaFRydWUoKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDEpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFNJTVBMRV9OVUxMIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBwdXNoTnVsbCgpXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMSkgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gU0lNUExFX1VOREVGSU5FRCAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgcHVzaFVuZGVmaW5lZCgpXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMSkgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gU0lNUExFX0JZVEUgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCgxKSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaFNpbXBsZVVuYXNzaWduZWQoaGVhcFsob2Zmc2V0ICsgMSkgfCAwXSB8IDApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMikgIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFNJTVBMRV9GTE9BVF9IQUxGIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICB2YXIgZiA9IDBcbiAgICB2YXIgZyA9IDBcbiAgICB2YXIgc2lnbiA9IDEuMFxuICAgIHZhciBleHAgPSAwLjBcbiAgICB2YXIgbWFudCA9IDAuMFxuICAgIHZhciByID0gMC4wXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDIpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBmID0gaGVhcFsob2Zmc2V0ICsgMSkgfCAwXSB8IDBcbiAgICBnID0gaGVhcFsob2Zmc2V0ICsgMikgfCAwXSB8IDBcblxuICAgIGlmICgoZiB8IDApICYgMHg4MCkge1xuICAgICAgc2lnbiA9IC0xLjBcbiAgICB9XG5cbiAgICBleHAgPSArKCgoZiB8IDApICYgMHg3QykgPj4gMilcbiAgICBtYW50ID0gKygoKChmIHwgMCkgJiAweDAzKSA8PCA4KSB8IGcpXG5cbiAgICBpZiAoK2V4cCA9PSAwLjApIHtcbiAgICAgIHB1c2hGbG9hdCgrKFxuICAgICAgICAoK3NpZ24pICogKzUuOTYwNDY0NDc3NTM5MDYyNWUtOCAqICgrbWFudClcbiAgICAgICkpXG4gICAgfSBlbHNlIGlmICgrZXhwID09IDMxLjApIHtcbiAgICAgIGlmICgrc2lnbiA9PSAxLjApIHtcbiAgICAgICAgaWYgKCttYW50ID4gMC4wKSB7XG4gICAgICAgICAgcHVzaE5hTigpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHVzaEluZmluaXR5KClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCttYW50ID4gMC4wKSB7XG4gICAgICAgICAgcHVzaE5hTk5lZygpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHVzaEluZmluaXR5TmVnKClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwdXNoRmxvYXQoKyhcbiAgICAgICAgK3NpZ24gKiBwb3coKzIsICsoK2V4cCAtIDI1LjApKSAqICsoMTAyNC4wICsgbWFudClcbiAgICAgICkpXG4gICAgfVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDMpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFNJTVBMRV9GTE9BVF9TSU5HTEUgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCg0KSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaEZsb2F0U2luZ2xlKFxuICAgICAgaGVhcFsob2Zmc2V0ICsgMSkgfCAwXSB8IDAsXG4gICAgICBoZWFwWyhvZmZzZXQgKyAyKSB8IDBdIHwgMCxcbiAgICAgIGhlYXBbKG9mZnNldCArIDMpIHwgMF0gfCAwLFxuICAgICAgaGVhcFsob2Zmc2V0ICsgNCkgfCAwXSB8IDBcbiAgICApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgNSkgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gU0lNUExFX0ZMT0FUX0RPVUJMRSAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDgpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoRmxvYXREb3VibGUoXG4gICAgICBoZWFwWyhvZmZzZXQgKyAxKSB8IDBdIHwgMCxcbiAgICAgIGhlYXBbKG9mZnNldCArIDIpIHwgMF0gfCAwLFxuICAgICAgaGVhcFsob2Zmc2V0ICsgMykgfCAwXSB8IDAsXG4gICAgICBoZWFwWyhvZmZzZXQgKyA0KSB8IDBdIHwgMCxcbiAgICAgIGhlYXBbKG9mZnNldCArIDUpIHwgMF0gfCAwLFxuICAgICAgaGVhcFsob2Zmc2V0ICsgNikgfCAwXSB8IDAsXG4gICAgICBoZWFwWyhvZmZzZXQgKyA3KSB8IDBdIHwgMCxcbiAgICAgIGhlYXBbKG9mZnNldCArIDgpIHwgMF0gfCAwXG4gICAgKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDkpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIEVSUk9SIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICByZXR1cm4gMVxuICB9XG5cbiAgZnVuY3Rpb24gQlJFQUsgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHB1c2hCcmVhaygpXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMSkgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgLy8gLS0gSnVtcCBUYWJsZVxuXG4gIHZhciBqdW1wVGFibGUgPSBbXG4gICAgLy8gSW50ZWdlciAweDAwLi4weDE3ICgwLi4yMylcbiAgICBJTlRfUCwgLy8gMHgwMFxuICAgIElOVF9QLCAvLyAweDAxXG4gICAgSU5UX1AsIC8vIDB4MDJcbiAgICBJTlRfUCwgLy8gMHgwM1xuICAgIElOVF9QLCAvLyAweDA0XG4gICAgSU5UX1AsIC8vIDB4MDVcbiAgICBJTlRfUCwgLy8gMHgwNlxuICAgIElOVF9QLCAvLyAweDA3XG4gICAgSU5UX1AsIC8vIDB4MDhcbiAgICBJTlRfUCwgLy8gMHgwOVxuICAgIElOVF9QLCAvLyAweDBBXG4gICAgSU5UX1AsIC8vIDB4MEJcbiAgICBJTlRfUCwgLy8gMHgwQ1xuICAgIElOVF9QLCAvLyAweDBEXG4gICAgSU5UX1AsIC8vIDB4MEVcbiAgICBJTlRfUCwgLy8gMHgwRlxuICAgIElOVF9QLCAvLyAweDEwXG4gICAgSU5UX1AsIC8vIDB4MTFcbiAgICBJTlRfUCwgLy8gMHgxMlxuICAgIElOVF9QLCAvLyAweDEzXG4gICAgSU5UX1AsIC8vIDB4MTRcbiAgICBJTlRfUCwgLy8gMHgxNVxuICAgIElOVF9QLCAvLyAweDE2XG4gICAgSU5UX1AsIC8vIDB4MTdcbiAgICAvLyBVbnNpZ25lZCBpbnRlZ2VyIChvbmUtYnl0ZSB1aW50OF90IGZvbGxvd3MpXG4gICAgVUlOVF9QXzgsIC8vIDB4MThcbiAgICAvLyBVbnNpZ25lZCBpbnRlZ2VyICh0d28tYnl0ZSB1aW50MTZfdCBmb2xsb3dzKVxuICAgIFVJTlRfUF8xNiwgLy8gMHgxOVxuICAgIC8vIFVuc2lnbmVkIGludGVnZXIgKGZvdXItYnl0ZSB1aW50MzJfdCBmb2xsb3dzKVxuICAgIFVJTlRfUF8zMiwgLy8gMHgxYVxuICAgIC8vIFVuc2lnbmVkIGludGVnZXIgKGVpZ2h0LWJ5dGUgdWludDY0X3QgZm9sbG93cylcbiAgICBVSU5UX1BfNjQsIC8vIDB4MWJcbiAgICBFUlJPUiwgLy8gMHgxY1xuICAgIEVSUk9SLCAvLyAweDFkXG4gICAgRVJST1IsIC8vIDB4MWVcbiAgICBFUlJPUiwgLy8gMHgxZlxuICAgIC8vIE5lZ2F0aXZlIGludGVnZXIgLTEtMHgwMC4uLTEtMHgxNyAoLTEuLi0yNClcbiAgICBJTlRfTiwgLy8gMHgyMFxuICAgIElOVF9OLCAvLyAweDIxXG4gICAgSU5UX04sIC8vIDB4MjJcbiAgICBJTlRfTiwgLy8gMHgyM1xuICAgIElOVF9OLCAvLyAweDI0XG4gICAgSU5UX04sIC8vIDB4MjVcbiAgICBJTlRfTiwgLy8gMHgyNlxuICAgIElOVF9OLCAvLyAweDI3XG4gICAgSU5UX04sIC8vIDB4MjhcbiAgICBJTlRfTiwgLy8gMHgyOVxuICAgIElOVF9OLCAvLyAweDJBXG4gICAgSU5UX04sIC8vIDB4MkJcbiAgICBJTlRfTiwgLy8gMHgyQ1xuICAgIElOVF9OLCAvLyAweDJEXG4gICAgSU5UX04sIC8vIDB4MkVcbiAgICBJTlRfTiwgLy8gMHgyRlxuICAgIElOVF9OLCAvLyAweDMwXG4gICAgSU5UX04sIC8vIDB4MzFcbiAgICBJTlRfTiwgLy8gMHgzMlxuICAgIElOVF9OLCAvLyAweDMzXG4gICAgSU5UX04sIC8vIDB4MzRcbiAgICBJTlRfTiwgLy8gMHgzNVxuICAgIElOVF9OLCAvLyAweDM2XG4gICAgSU5UX04sIC8vIDB4MzdcbiAgICAvLyBOZWdhdGl2ZSBpbnRlZ2VyIC0xLW4gKG9uZS1ieXRlIHVpbnQ4X3QgZm9yIG4gZm9sbG93cylcbiAgICBVSU5UX05fOCwgLy8gMHgzOFxuICAgIC8vIE5lZ2F0aXZlIGludGVnZXIgLTEtbiAodHdvLWJ5dGUgdWludDE2X3QgZm9yIG4gZm9sbG93cylcbiAgICBVSU5UX05fMTYsIC8vIDB4MzlcbiAgICAvLyBOZWdhdGl2ZSBpbnRlZ2VyIC0xLW4gKGZvdXItYnl0ZSB1aW50MzJfdCBmb3IgbmZvbGxvd3MpXG4gICAgVUlOVF9OXzMyLCAvLyAweDNhXG4gICAgLy8gTmVnYXRpdmUgaW50ZWdlciAtMS1uIChlaWdodC1ieXRlIHVpbnQ2NF90IGZvciBuIGZvbGxvd3MpXG4gICAgVUlOVF9OXzY0LCAvLyAweDNiXG4gICAgRVJST1IsIC8vIDB4M2NcbiAgICBFUlJPUiwgLy8gMHgzZFxuICAgIEVSUk9SLCAvLyAweDNlXG4gICAgRVJST1IsIC8vIDB4M2ZcbiAgICAvLyBieXRlIHN0cmluZyAoMHgwMC4uMHgxNyBieXRlcyBmb2xsb3cpXG4gICAgQllURV9TVFJJTkcsIC8vIDB4NDBcbiAgICBCWVRFX1NUUklORywgLy8gMHg0MVxuICAgIEJZVEVfU1RSSU5HLCAvLyAweDQyXG4gICAgQllURV9TVFJJTkcsIC8vIDB4NDNcbiAgICBCWVRFX1NUUklORywgLy8gMHg0NFxuICAgIEJZVEVfU1RSSU5HLCAvLyAweDQ1XG4gICAgQllURV9TVFJJTkcsIC8vIDB4NDZcbiAgICBCWVRFX1NUUklORywgLy8gMHg0N1xuICAgIEJZVEVfU1RSSU5HLCAvLyAweDQ4XG4gICAgQllURV9TVFJJTkcsIC8vIDB4NDlcbiAgICBCWVRFX1NUUklORywgLy8gMHg0QVxuICAgIEJZVEVfU1RSSU5HLCAvLyAweDRCXG4gICAgQllURV9TVFJJTkcsIC8vIDB4NENcbiAgICBCWVRFX1NUUklORywgLy8gMHg0RFxuICAgIEJZVEVfU1RSSU5HLCAvLyAweDRFXG4gICAgQllURV9TVFJJTkcsIC8vIDB4NEZcbiAgICBCWVRFX1NUUklORywgLy8gMHg1MFxuICAgIEJZVEVfU1RSSU5HLCAvLyAweDUxXG4gICAgQllURV9TVFJJTkcsIC8vIDB4NTJcbiAgICBCWVRFX1NUUklORywgLy8gMHg1M1xuICAgIEJZVEVfU1RSSU5HLCAvLyAweDU0XG4gICAgQllURV9TVFJJTkcsIC8vIDB4NTVcbiAgICBCWVRFX1NUUklORywgLy8gMHg1NlxuICAgIEJZVEVfU1RSSU5HLCAvLyAweDU3XG4gICAgLy8gYnl0ZSBzdHJpbmcgKG9uZS1ieXRlIHVpbnQ4X3QgZm9yIG4sIGFuZCB0aGVuIG4gYnl0ZXMgZm9sbG93KVxuICAgIEJZVEVfU1RSSU5HXzgsIC8vIDB4NThcbiAgICAvLyBieXRlIHN0cmluZyAodHdvLWJ5dGUgdWludDE2X3QgZm9yIG4sIGFuZCB0aGVuIG4gYnl0ZXMgZm9sbG93KVxuICAgIEJZVEVfU1RSSU5HXzE2LCAvLyAweDU5XG4gICAgLy8gYnl0ZSBzdHJpbmcgKGZvdXItYnl0ZSB1aW50MzJfdCBmb3IgbiwgYW5kIHRoZW4gbiBieXRlcyBmb2xsb3cpXG4gICAgQllURV9TVFJJTkdfMzIsIC8vIDB4NWFcbiAgICAvLyBieXRlIHN0cmluZyAoZWlnaHQtYnl0ZSB1aW50NjRfdCBmb3IgbiwgYW5kIHRoZW4gbiBieXRlcyBmb2xsb3cpXG4gICAgQllURV9TVFJJTkdfNjQsIC8vIDB4NWJcbiAgICBFUlJPUiwgLy8gMHg1Y1xuICAgIEVSUk9SLCAvLyAweDVkXG4gICAgRVJST1IsIC8vIDB4NWVcbiAgICAvLyBieXRlIHN0cmluZywgYnl0ZSBzdHJpbmdzIGZvbGxvdywgdGVybWluYXRlZCBieSBcImJyZWFrXCJcbiAgICBCWVRFX1NUUklOR19CUkVBSywgLy8gMHg1ZlxuICAgIC8vIFVURi04IHN0cmluZyAoMHgwMC4uMHgxNyBieXRlcyBmb2xsb3cpXG4gICAgVVRGOF9TVFJJTkcsIC8vIDB4NjBcbiAgICBVVEY4X1NUUklORywgLy8gMHg2MVxuICAgIFVURjhfU1RSSU5HLCAvLyAweDYyXG4gICAgVVRGOF9TVFJJTkcsIC8vIDB4NjNcbiAgICBVVEY4X1NUUklORywgLy8gMHg2NFxuICAgIFVURjhfU1RSSU5HLCAvLyAweDY1XG4gICAgVVRGOF9TVFJJTkcsIC8vIDB4NjZcbiAgICBVVEY4X1NUUklORywgLy8gMHg2N1xuICAgIFVURjhfU1RSSU5HLCAvLyAweDY4XG4gICAgVVRGOF9TVFJJTkcsIC8vIDB4NjlcbiAgICBVVEY4X1NUUklORywgLy8gMHg2QVxuICAgIFVURjhfU1RSSU5HLCAvLyAweDZCXG4gICAgVVRGOF9TVFJJTkcsIC8vIDB4NkNcbiAgICBVVEY4X1NUUklORywgLy8gMHg2RFxuICAgIFVURjhfU1RSSU5HLCAvLyAweDZFXG4gICAgVVRGOF9TVFJJTkcsIC8vIDB4NkZcbiAgICBVVEY4X1NUUklORywgLy8gMHg3MFxuICAgIFVURjhfU1RSSU5HLCAvLyAweDcxXG4gICAgVVRGOF9TVFJJTkcsIC8vIDB4NzJcbiAgICBVVEY4X1NUUklORywgLy8gMHg3M1xuICAgIFVURjhfU1RSSU5HLCAvLyAweDc0XG4gICAgVVRGOF9TVFJJTkcsIC8vIDB4NzVcbiAgICBVVEY4X1NUUklORywgLy8gMHg3NlxuICAgIFVURjhfU1RSSU5HLCAvLyAweDc3XG4gICAgLy8gVVRGLTggc3RyaW5nIChvbmUtYnl0ZSB1aW50OF90IGZvciBuLCBhbmQgdGhlbiBuIGJ5dGVzIGZvbGxvdylcbiAgICBVVEY4X1NUUklOR184LCAvLyAweDc4XG4gICAgLy8gVVRGLTggc3RyaW5nICh0d28tYnl0ZSB1aW50MTZfdCBmb3IgbiwgYW5kIHRoZW4gbiBieXRlcyBmb2xsb3cpXG4gICAgVVRGOF9TVFJJTkdfMTYsIC8vIDB4NzlcbiAgICAvLyBVVEYtOCBzdHJpbmcgKGZvdXItYnl0ZSB1aW50MzJfdCBmb3IgbiwgYW5kIHRoZW4gbiBieXRlcyBmb2xsb3cpXG4gICAgVVRGOF9TVFJJTkdfMzIsIC8vIDB4N2FcbiAgICAvLyBVVEYtOCBzdHJpbmcgKGVpZ2h0LWJ5dGUgdWludDY0X3QgZm9yIG4sIGFuZCB0aGVuIG4gYnl0ZXMgZm9sbG93KVxuICAgIFVURjhfU1RSSU5HXzY0LCAvLyAweDdiXG4gICAgLy8gVVRGLTggc3RyaW5nLCBVVEYtOCBzdHJpbmdzIGZvbGxvdywgdGVybWluYXRlZCBieSBcImJyZWFrXCJcbiAgICBFUlJPUiwgLy8gMHg3Y1xuICAgIEVSUk9SLCAvLyAweDdkXG4gICAgRVJST1IsIC8vIDB4N2VcbiAgICBVVEY4X1NUUklOR19CUkVBSywgLy8gMHg3ZlxuICAgIC8vIGFycmF5ICgweDAwLi4weDE3IGRhdGEgaXRlbXMgZm9sbG93KVxuICAgIEFSUkFZLCAvLyAweDgwXG4gICAgQVJSQVksIC8vIDB4ODFcbiAgICBBUlJBWSwgLy8gMHg4MlxuICAgIEFSUkFZLCAvLyAweDgzXG4gICAgQVJSQVksIC8vIDB4ODRcbiAgICBBUlJBWSwgLy8gMHg4NVxuICAgIEFSUkFZLCAvLyAweDg2XG4gICAgQVJSQVksIC8vIDB4ODdcbiAgICBBUlJBWSwgLy8gMHg4OFxuICAgIEFSUkFZLCAvLyAweDg5XG4gICAgQVJSQVksIC8vIDB4OEFcbiAgICBBUlJBWSwgLy8gMHg4QlxuICAgIEFSUkFZLCAvLyAweDhDXG4gICAgQVJSQVksIC8vIDB4OERcbiAgICBBUlJBWSwgLy8gMHg4RVxuICAgIEFSUkFZLCAvLyAweDhGXG4gICAgQVJSQVksIC8vIDB4OTBcbiAgICBBUlJBWSwgLy8gMHg5MVxuICAgIEFSUkFZLCAvLyAweDkyXG4gICAgQVJSQVksIC8vIDB4OTNcbiAgICBBUlJBWSwgLy8gMHg5NFxuICAgIEFSUkFZLCAvLyAweDk1XG4gICAgQVJSQVksIC8vIDB4OTZcbiAgICBBUlJBWSwgLy8gMHg5N1xuICAgIC8vIGFycmF5IChvbmUtYnl0ZSB1aW50OF90IGZvLCBhbmQgdGhlbiBuIGRhdGEgaXRlbXMgZm9sbG93KVxuICAgIEFSUkFZXzgsIC8vIDB4OThcbiAgICAvLyBhcnJheSAodHdvLWJ5dGUgdWludDE2X3QgZm9yIG4sIGFuZCB0aGVuIG4gZGF0YSBpdGVtcyBmb2xsb3cpXG4gICAgQVJSQVlfMTYsIC8vIDB4OTlcbiAgICAvLyBhcnJheSAoZm91ci1ieXRlIHVpbnQzMl90IGZvciBuLCBhbmQgdGhlbiBuIGRhdGEgaXRlbXMgZm9sbG93KVxuICAgIEFSUkFZXzMyLCAvLyAweDlhXG4gICAgLy8gYXJyYXkgKGVpZ2h0LWJ5dGUgdWludDY0X3QgZm9yIG4sIGFuZCB0aGVuIG4gZGF0YSBpdGVtcyBmb2xsb3cpXG4gICAgQVJSQVlfNjQsIC8vIDB4OWJcbiAgICAvLyBhcnJheSwgZGF0YSBpdGVtcyBmb2xsb3csIHRlcm1pbmF0ZWQgYnkgXCJicmVha1wiXG4gICAgRVJST1IsIC8vIDB4OWNcbiAgICBFUlJPUiwgLy8gMHg5ZFxuICAgIEVSUk9SLCAvLyAweDllXG4gICAgQVJSQVlfQlJFQUssIC8vIDB4OWZcbiAgICAvLyBtYXAgKDB4MDAuLjB4MTcgcGFpcnMgb2YgZGF0YSBpdGVtcyBmb2xsb3cpXG4gICAgTUFQLCAvLyAweGEwXG4gICAgTUFQLCAvLyAweGExXG4gICAgTUFQLCAvLyAweGEyXG4gICAgTUFQLCAvLyAweGEzXG4gICAgTUFQLCAvLyAweGE0XG4gICAgTUFQLCAvLyAweGE1XG4gICAgTUFQLCAvLyAweGE2XG4gICAgTUFQLCAvLyAweGE3XG4gICAgTUFQLCAvLyAweGE4XG4gICAgTUFQLCAvLyAweGE5XG4gICAgTUFQLCAvLyAweGFBXG4gICAgTUFQLCAvLyAweGFCXG4gICAgTUFQLCAvLyAweGFDXG4gICAgTUFQLCAvLyAweGFEXG4gICAgTUFQLCAvLyAweGFFXG4gICAgTUFQLCAvLyAweGFGXG4gICAgTUFQLCAvLyAweGIwXG4gICAgTUFQLCAvLyAweGIxXG4gICAgTUFQLCAvLyAweGIyXG4gICAgTUFQLCAvLyAweGIzXG4gICAgTUFQLCAvLyAweGI0XG4gICAgTUFQLCAvLyAweGI1XG4gICAgTUFQLCAvLyAweGI2XG4gICAgTUFQLCAvLyAweGI3XG4gICAgLy8gbWFwIChvbmUtYnl0ZSB1aW50OF90IGZvciBuLCBhbmQgdGhlbiBuIHBhaXJzIG9mIGRhdGEgaXRlbXMgZm9sbG93KVxuICAgIE1BUF84LCAvLyAweGI4XG4gICAgLy8gbWFwICh0d28tYnl0ZSB1aW50MTZfdCBmb3IgbiwgYW5kIHRoZW4gbiBwYWlycyBvZiBkYXRhIGl0ZW1zIGZvbGxvdylcbiAgICBNQVBfMTYsIC8vIDB4YjlcbiAgICAvLyBtYXAgKGZvdXItYnl0ZSB1aW50MzJfdCBmb3IgbiwgYW5kIHRoZW4gbiBwYWlycyBvZiBkYXRhIGl0ZW1zIGZvbGxvdylcbiAgICBNQVBfMzIsIC8vIDB4YmFcbiAgICAvLyBtYXAgKGVpZ2h0LWJ5dGUgdWludDY0X3QgZm9yIG4sIGFuZCB0aGVuIG4gcGFpcnMgb2YgZGF0YSBpdGVtcyBmb2xsb3cpXG4gICAgTUFQXzY0LCAvLyAweGJiXG4gICAgRVJST1IsIC8vIDB4YmNcbiAgICBFUlJPUiwgLy8gMHhiZFxuICAgIEVSUk9SLCAvLyAweGJlXG4gICAgLy8gbWFwLCBwYWlycyBvZiBkYXRhIGl0ZW1zIGZvbGxvdywgdGVybWluYXRlZCBieSBcImJyZWFrXCJcbiAgICBNQVBfQlJFQUssIC8vIDB4YmZcbiAgICAvLyBUZXh0LWJhc2VkIGRhdGUvdGltZSAoZGF0YSBpdGVtIGZvbGxvd3M7IHNlZSBTZWN0aW9uIDIuNC4xKVxuICAgIFRBR19LTk9XTiwgLy8gMHhjMFxuICAgIC8vIEVwb2NoLWJhc2VkIGRhdGUvdGltZSAoZGF0YSBpdGVtIGZvbGxvd3M7IHNlZSBTZWN0aW9uIDIuNC4xKVxuICAgIFRBR19LTk9XTiwgLy8gMHhjMVxuICAgIC8vIFBvc2l0aXZlIGJpZ251bSAoZGF0YSBpdGVtIFwiYnl0ZSBzdHJpbmdcIiBmb2xsb3dzKVxuICAgIFRBR19LTk9XTiwgLy8gMHhjMlxuICAgIC8vIE5lZ2F0aXZlIGJpZ251bSAoZGF0YSBpdGVtIFwiYnl0ZSBzdHJpbmdcIiBmb2xsb3dzKVxuICAgIFRBR19LTk9XTiwgLy8gMHhjM1xuICAgIC8vIERlY2ltYWwgRnJhY3Rpb24gKGRhdGEgaXRlbSBcImFycmF5XCIgZm9sbG93czsgc2VlIFNlY3Rpb24gMi40LjMpXG4gICAgVEFHX0tOT1dOLCAvLyAweGM0XG4gICAgLy8gQmlnZmxvYXQgKGRhdGEgaXRlbSBcImFycmF5XCIgZm9sbG93czsgc2VlIFNlY3Rpb24gMi40LjMpXG4gICAgVEFHX0tOT1dOLCAvLyAweGM1XG4gICAgLy8gKHRhZ2dlZCBpdGVtKVxuICAgIFRBR19VTkFTU0lHTkVELCAvLyAweGM2XG4gICAgVEFHX1VOQVNTSUdORUQsIC8vIDB4YzdcbiAgICBUQUdfVU5BU1NJR05FRCwgLy8gMHhjOFxuICAgIFRBR19VTkFTU0lHTkVELCAvLyAweGM5XG4gICAgVEFHX1VOQVNTSUdORUQsIC8vIDB4Y2FcbiAgICBUQUdfVU5BU1NJR05FRCwgLy8gMHhjYlxuICAgIFRBR19VTkFTU0lHTkVELCAvLyAweGNjXG4gICAgVEFHX1VOQVNTSUdORUQsIC8vIDB4Y2RcbiAgICBUQUdfVU5BU1NJR05FRCwgLy8gMHhjZVxuICAgIFRBR19VTkFTU0lHTkVELCAvLyAweGNmXG4gICAgVEFHX1VOQVNTSUdORUQsIC8vIDB4ZDBcbiAgICBUQUdfVU5BU1NJR05FRCwgLy8gMHhkMVxuICAgIFRBR19VTkFTU0lHTkVELCAvLyAweGQyXG4gICAgVEFHX1VOQVNTSUdORUQsIC8vIDB4ZDNcbiAgICBUQUdfVU5BU1NJR05FRCwgLy8gMHhkNFxuICAgIC8vIEV4cGVjdGVkIENvbnZlcnNpb24gKGRhdGEgaXRlbSBmb2xsb3dzOyBzZWUgU2VjdGlvbiAyLjQuNC4yKVxuICAgIFRBR19VTkFTU0lHTkVELCAvLyAweGQ1XG4gICAgVEFHX1VOQVNTSUdORUQsIC8vIDB4ZDZcbiAgICBUQUdfVU5BU1NJR05FRCwgLy8gMHhkN1xuICAgIC8vIChtb3JlIHRhZ2dlZCBpdGVtcywgMS8yLzQvOCBieXRlcyBhbmQgdGhlbiBhIGRhdGEgaXRlbSBmb2xsb3cpXG4gICAgVEFHX01PUkVfMSwgLy8gMHhkOFxuICAgIFRBR19NT1JFXzIsIC8vIDB4ZDlcbiAgICBUQUdfTU9SRV80LCAvLyAweGRhXG4gICAgVEFHX01PUkVfOCwgLy8gMHhkYlxuICAgIEVSUk9SLCAvLyAweGRjXG4gICAgRVJST1IsIC8vIDB4ZGRcbiAgICBFUlJPUiwgLy8gMHhkZVxuICAgIEVSUk9SLCAvLyAweGRmXG4gICAgLy8gKHNpbXBsZSB2YWx1ZSlcbiAgICBTSU1QTEVfVU5BU1NJR05FRCwgLy8gMHhlMFxuICAgIFNJTVBMRV9VTkFTU0lHTkVELCAvLyAweGUxXG4gICAgU0lNUExFX1VOQVNTSUdORUQsIC8vIDB4ZTJcbiAgICBTSU1QTEVfVU5BU1NJR05FRCwgLy8gMHhlM1xuICAgIFNJTVBMRV9VTkFTU0lHTkVELCAvLyAweGU0XG4gICAgU0lNUExFX1VOQVNTSUdORUQsIC8vIDB4ZTVcbiAgICBTSU1QTEVfVU5BU1NJR05FRCwgLy8gMHhlNlxuICAgIFNJTVBMRV9VTkFTU0lHTkVELCAvLyAweGU3XG4gICAgU0lNUExFX1VOQVNTSUdORUQsIC8vIDB4ZThcbiAgICBTSU1QTEVfVU5BU1NJR05FRCwgLy8gMHhlOVxuICAgIFNJTVBMRV9VTkFTU0lHTkVELCAvLyAweGVhXG4gICAgU0lNUExFX1VOQVNTSUdORUQsIC8vIDB4ZWJcbiAgICBTSU1QTEVfVU5BU1NJR05FRCwgLy8gMHhlY1xuICAgIFNJTVBMRV9VTkFTU0lHTkVELCAvLyAweGVkXG4gICAgU0lNUExFX1VOQVNTSUdORUQsIC8vIDB4ZWVcbiAgICBTSU1QTEVfVU5BU1NJR05FRCwgLy8gMHhlZlxuICAgIFNJTVBMRV9VTkFTU0lHTkVELCAvLyAweGYwXG4gICAgU0lNUExFX1VOQVNTSUdORUQsIC8vIDB4ZjFcbiAgICBTSU1QTEVfVU5BU1NJR05FRCwgLy8gMHhmMlxuICAgIFNJTVBMRV9VTkFTU0lHTkVELCAvLyAweGYzXG4gICAgLy8gRmFsc2VcbiAgICBTSU1QTEVfRkFMU0UsIC8vIDB4ZjRcbiAgICAvLyBUcnVlXG4gICAgU0lNUExFX1RSVUUsIC8vIDB4ZjVcbiAgICAvLyBOdWxsXG4gICAgU0lNUExFX05VTEwsIC8vIDB4ZjZcbiAgICAvLyBVbmRlZmluZWRcbiAgICBTSU1QTEVfVU5ERUZJTkVELCAvLyAweGY3XG4gICAgLy8gKHNpbXBsZSB2YWx1ZSwgb25lIGJ5dGUgZm9sbG93cylcbiAgICBTSU1QTEVfQllURSwgLy8gMHhmOFxuICAgIC8vIEhhbGYtUHJlY2lzaW9uIEZsb2F0ICh0d28tYnl0ZSBJRUVFIDc1NClcbiAgICBTSU1QTEVfRkxPQVRfSEFMRiwgLy8gMHhmOVxuICAgIC8vIFNpbmdsZS1QcmVjaXNpb24gRmxvYXQgKGZvdXItYnl0ZSBJRUVFIDc1NClcbiAgICBTSU1QTEVfRkxPQVRfU0lOR0xFLCAvLyAweGZhXG4gICAgLy8gRG91YmxlLVByZWNpc2lvbiBGbG9hdCAoZWlnaHQtYnl0ZSBJRUVFIDc1NClcbiAgICBTSU1QTEVfRkxPQVRfRE9VQkxFLCAvLyAweGZiXG4gICAgRVJST1IsIC8vIDB4ZmNcbiAgICBFUlJPUiwgLy8gMHhmZFxuICAgIEVSUk9SLCAvLyAweGZlXG4gICAgLy8gXCJicmVha1wiIHN0b3AgY29kZVxuICAgIEJSRUFLIC8vIDB4ZmZcbiAgXVxuXG4gIC8vIC0tXG5cbiAgcmV0dXJuIHtcbiAgICBwYXJzZTogcGFyc2VcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/borc/src/decoder.asm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/borc/src/decoder.js":
/*!**********************************************!*\
  !*** ../../node_modules/borc/src/decoder.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nconst { Buffer } = __webpack_require__(/*! buffer */ \"(app-pages-browser)/../../node_modules/borc/node_modules/buffer/index.js\")\nconst ieee754 = __webpack_require__(/*! ieee754 */ \"(app-pages-browser)/../../node_modules/ieee754/index.js\")\nconst Bignumber = (__webpack_require__(/*! bignumber.js */ \"(app-pages-browser)/../../node_modules/bignumber.js/bignumber.js\").BigNumber)\n\nconst parser = __webpack_require__(/*! ./decoder.asm */ \"(app-pages-browser)/../../node_modules/borc/src/decoder.asm.js\")\nconst utils = __webpack_require__(/*! ./utils */ \"(app-pages-browser)/../../node_modules/borc/src/utils.js\")\nconst c = __webpack_require__(/*! ./constants */ \"(app-pages-browser)/../../node_modules/borc/src/constants.js\")\nconst Simple = __webpack_require__(/*! ./simple */ \"(app-pages-browser)/../../node_modules/borc/src/simple.js\")\nconst Tagged = __webpack_require__(/*! ./tagged */ \"(app-pages-browser)/../../node_modules/borc/src/tagged.js\")\nconst { URL } = __webpack_require__(/*! iso-url */ \"(app-pages-browser)/../../node_modules/iso-url/index.js\")\n\n/**\n * Transform binary cbor data into JavaScript objects.\n */\nclass Decoder {\n  /**\n   * @param {Object} [opts={}]\n   * @param {number} [opts.size=65536] - Size of the allocated heap.\n   */\n  constructor (opts) {\n    opts = opts || {}\n\n    if (!opts.size || opts.size < 0x10000) {\n      opts.size = 0x10000\n    } else {\n      // Ensure the size is a power of 2\n      opts.size = utils.nextPowerOf2(opts.size)\n    }\n\n    // Heap use to share the input with the parser\n    this._heap = new ArrayBuffer(opts.size)\n    this._heap8 = new Uint8Array(this._heap)\n    this._buffer = Buffer.from(this._heap)\n\n    this._reset()\n\n    // Known tags\n    this._knownTags = Object.assign({\n      0: (val) => new Date(val),\n      1: (val) => new Date(val * 1000),\n      2: (val) => utils.arrayBufferToBignumber(val),\n      3: (val) => c.NEG_ONE.minus(utils.arrayBufferToBignumber(val)),\n      4: (v) => {\n        // const v = new Uint8Array(val)\n        return c.TEN.pow(v[0]).times(v[1])\n      },\n      5: (v) => {\n        // const v = new Uint8Array(val)\n        return c.TWO.pow(v[0]).times(v[1])\n      },\n      32: (val) => new URL(val),\n      35: (val) => new RegExp(val)\n    }, opts.tags)\n\n    // Initialize asm based parser\n    this.parser = parser(__webpack_require__.g, {\n      // eslint-disable-next-line no-console\n      log: console.log.bind(console),\n      pushInt: this.pushInt.bind(this),\n      pushInt32: this.pushInt32.bind(this),\n      pushInt32Neg: this.pushInt32Neg.bind(this),\n      pushInt64: this.pushInt64.bind(this),\n      pushInt64Neg: this.pushInt64Neg.bind(this),\n      pushFloat: this.pushFloat.bind(this),\n      pushFloatSingle: this.pushFloatSingle.bind(this),\n      pushFloatDouble: this.pushFloatDouble.bind(this),\n      pushTrue: this.pushTrue.bind(this),\n      pushFalse: this.pushFalse.bind(this),\n      pushUndefined: this.pushUndefined.bind(this),\n      pushNull: this.pushNull.bind(this),\n      pushInfinity: this.pushInfinity.bind(this),\n      pushInfinityNeg: this.pushInfinityNeg.bind(this),\n      pushNaN: this.pushNaN.bind(this),\n      pushNaNNeg: this.pushNaNNeg.bind(this),\n      pushArrayStart: this.pushArrayStart.bind(this),\n      pushArrayStartFixed: this.pushArrayStartFixed.bind(this),\n      pushArrayStartFixed32: this.pushArrayStartFixed32.bind(this),\n      pushArrayStartFixed64: this.pushArrayStartFixed64.bind(this),\n      pushObjectStart: this.pushObjectStart.bind(this),\n      pushObjectStartFixed: this.pushObjectStartFixed.bind(this),\n      pushObjectStartFixed32: this.pushObjectStartFixed32.bind(this),\n      pushObjectStartFixed64: this.pushObjectStartFixed64.bind(this),\n      pushByteString: this.pushByteString.bind(this),\n      pushByteStringStart: this.pushByteStringStart.bind(this),\n      pushUtf8String: this.pushUtf8String.bind(this),\n      pushUtf8StringStart: this.pushUtf8StringStart.bind(this),\n      pushSimpleUnassigned: this.pushSimpleUnassigned.bind(this),\n      pushTagUnassigned: this.pushTagUnassigned.bind(this),\n      pushTagStart: this.pushTagStart.bind(this),\n      pushTagStart4: this.pushTagStart4.bind(this),\n      pushTagStart8: this.pushTagStart8.bind(this),\n      pushBreak: this.pushBreak.bind(this)\n    }, this._heap)\n  }\n\n  get _depth () {\n    return this._parents.length\n  }\n\n  get _currentParent () {\n    return this._parents[this._depth - 1]\n  }\n\n  get _ref () {\n    return this._currentParent.ref\n  }\n\n  // Finish the current parent\n  _closeParent () {\n    var p = this._parents.pop()\n\n    if (p.length > 0) {\n      throw new Error(`Missing ${p.length} elements`)\n    }\n\n    switch (p.type) {\n      case c.PARENT.TAG:\n        this._push(\n          this.createTag(p.ref[0], p.ref[1])\n        )\n        break\n      case c.PARENT.BYTE_STRING:\n        this._push(this.createByteString(p.ref, p.length))\n        break\n      case c.PARENT.UTF8_STRING:\n        this._push(this.createUtf8String(p.ref, p.length))\n        break\n      case c.PARENT.MAP:\n        if (p.values % 2 > 0) {\n          throw new Error('Odd number of elements in the map')\n        }\n        this._push(this.createMap(p.ref, p.length))\n        break\n      case c.PARENT.OBJECT:\n        if (p.values % 2 > 0) {\n          throw new Error('Odd number of elements in the map')\n        }\n        this._push(this.createObject(p.ref, p.length))\n        break\n      case c.PARENT.ARRAY:\n        this._push(this.createArray(p.ref, p.length))\n        break\n      default:\n        break\n    }\n\n    if (this._currentParent && this._currentParent.type === c.PARENT.TAG) {\n      this._dec()\n    }\n  }\n\n  // Reduce the expected length of the current parent by one\n  _dec () {\n    const p = this._currentParent\n    // The current parent does not know the epxected child length\n\n    if (p.length < 0) {\n      return\n    }\n\n    p.length--\n\n    // All children were seen, we can close the current parent\n    if (p.length === 0) {\n      this._closeParent()\n    }\n  }\n\n  // Push any value to the current parent\n  _push (val, hasChildren) {\n    const p = this._currentParent\n    p.values++\n\n    switch (p.type) {\n      case c.PARENT.ARRAY:\n      case c.PARENT.BYTE_STRING:\n      case c.PARENT.UTF8_STRING:\n        if (p.length > -1) {\n          this._ref[this._ref.length - p.length] = val\n        } else {\n          this._ref.push(val)\n        }\n        this._dec()\n        break\n      case c.PARENT.OBJECT:\n        if (p.tmpKey != null) {\n          this._ref[p.tmpKey] = val\n          p.tmpKey = null\n          this._dec()\n        } else {\n          p.tmpKey = val\n\n          if (typeof p.tmpKey !== 'string') {\n            // too bad, convert to a Map\n            p.type = c.PARENT.MAP\n            p.ref = utils.buildMap(p.ref)\n          }\n        }\n        break\n      case c.PARENT.MAP:\n        if (p.tmpKey != null) {\n          this._ref.set(p.tmpKey, val)\n          p.tmpKey = null\n          this._dec()\n        } else {\n          p.tmpKey = val\n        }\n        break\n      case c.PARENT.TAG:\n        this._ref.push(val)\n        if (!hasChildren) {\n          this._dec()\n        }\n        break\n      default:\n        throw new Error('Unknown parent type')\n    }\n  }\n\n  // Create a new parent in the parents list\n  _createParent (obj, type, len) {\n    this._parents[this._depth] = {\n      type: type,\n      length: len,\n      ref: obj,\n      values: 0,\n      tmpKey: null\n    }\n  }\n\n  // Reset all state back to the beginning, also used for initiatlization\n  _reset () {\n    this._res = []\n    this._parents = [{\n      type: c.PARENT.ARRAY,\n      length: -1,\n      ref: this._res,\n      values: 0,\n      tmpKey: null\n    }]\n  }\n\n  // -- Interface to customize deoding behaviour\n  createTag (tagNumber, value) {\n    const typ = this._knownTags[tagNumber]\n\n    if (!typ) {\n      return new Tagged(tagNumber, value)\n    }\n\n    return typ(value)\n  }\n\n  createMap (obj, len) {\n    return obj\n  }\n\n  createObject (obj, len) {\n    return obj\n  }\n\n  createArray (arr, len) {\n    return arr\n  }\n\n  createByteString (raw, len) {\n    return Buffer.concat(raw)\n  }\n\n  createByteStringFromHeap (start, end) {\n    if (start === end) {\n      return Buffer.alloc(0)\n    }\n\n    return Buffer.from(this._heap.slice(start, end))\n  }\n\n  createInt (val) {\n    return val\n  }\n\n  createInt32 (f, g) {\n    return utils.buildInt32(f, g)\n  }\n\n  createInt64 (f1, f2, g1, g2) {\n    return utils.buildInt64(f1, f2, g1, g2)\n  }\n\n  createFloat (val) {\n    return val\n  }\n\n  createFloatSingle (a, b, c, d) {\n    return ieee754.read([a, b, c, d], 0, false, 23, 4)\n  }\n\n  createFloatDouble (a, b, c, d, e, f, g, h) {\n    return ieee754.read([a, b, c, d, e, f, g, h], 0, false, 52, 8)\n  }\n\n  createInt32Neg (f, g) {\n    return -1 - utils.buildInt32(f, g)\n  }\n\n  createInt64Neg (f1, f2, g1, g2) {\n    const f = utils.buildInt32(f1, f2)\n    const g = utils.buildInt32(g1, g2)\n\n    if (f > c.MAX_SAFE_HIGH) {\n      return c.NEG_ONE.minus(new Bignumber(f).times(c.SHIFT32).plus(g))\n    }\n\n    return -1 - ((f * c.SHIFT32) + g)\n  }\n\n  createTrue () {\n    return true\n  }\n\n  createFalse () {\n    return false\n  }\n\n  createNull () {\n    return null\n  }\n\n  createUndefined () {\n    return undefined\n  }\n\n  createInfinity () {\n    return Infinity\n  }\n\n  createInfinityNeg () {\n    return -Infinity\n  }\n\n  createNaN () {\n    return NaN\n  }\n\n  createNaNNeg () {\n    return -NaN\n  }\n\n  createUtf8String (raw, len) {\n    return raw.join('')\n  }\n\n  createUtf8StringFromHeap (start, end) {\n    if (start === end) {\n      return ''\n    }\n\n    return this._buffer.toString('utf8', start, end)\n  }\n\n  createSimpleUnassigned (val) {\n    return new Simple(val)\n  }\n\n  // -- Interface for decoder.asm.js\n\n  pushInt (val) {\n    this._push(this.createInt(val))\n  }\n\n  pushInt32 (f, g) {\n    this._push(this.createInt32(f, g))\n  }\n\n  pushInt64 (f1, f2, g1, g2) {\n    this._push(this.createInt64(f1, f2, g1, g2))\n  }\n\n  pushFloat (val) {\n    this._push(this.createFloat(val))\n  }\n\n  pushFloatSingle (a, b, c, d) {\n    this._push(this.createFloatSingle(a, b, c, d))\n  }\n\n  pushFloatDouble (a, b, c, d, e, f, g, h) {\n    this._push(this.createFloatDouble(a, b, c, d, e, f, g, h))\n  }\n\n  pushInt32Neg (f, g) {\n    this._push(this.createInt32Neg(f, g))\n  }\n\n  pushInt64Neg (f1, f2, g1, g2) {\n    this._push(this.createInt64Neg(f1, f2, g1, g2))\n  }\n\n  pushTrue () {\n    this._push(this.createTrue())\n  }\n\n  pushFalse () {\n    this._push(this.createFalse())\n  }\n\n  pushNull () {\n    this._push(this.createNull())\n  }\n\n  pushUndefined () {\n    this._push(this.createUndefined())\n  }\n\n  pushInfinity () {\n    this._push(this.createInfinity())\n  }\n\n  pushInfinityNeg () {\n    this._push(this.createInfinityNeg())\n  }\n\n  pushNaN () {\n    this._push(this.createNaN())\n  }\n\n  pushNaNNeg () {\n    this._push(this.createNaNNeg())\n  }\n\n  pushArrayStart () {\n    this._createParent([], c.PARENT.ARRAY, -1)\n  }\n\n  pushArrayStartFixed (len) {\n    this._createArrayStartFixed(len)\n  }\n\n  pushArrayStartFixed32 (len1, len2) {\n    const len = utils.buildInt32(len1, len2)\n    this._createArrayStartFixed(len)\n  }\n\n  pushArrayStartFixed64 (len1, len2, len3, len4) {\n    const len = utils.buildInt64(len1, len2, len3, len4)\n    this._createArrayStartFixed(len)\n  }\n\n  pushObjectStart () {\n    this._createObjectStartFixed(-1)\n  }\n\n  pushObjectStartFixed (len) {\n    this._createObjectStartFixed(len)\n  }\n\n  pushObjectStartFixed32 (len1, len2) {\n    const len = utils.buildInt32(len1, len2)\n    this._createObjectStartFixed(len)\n  }\n\n  pushObjectStartFixed64 (len1, len2, len3, len4) {\n    const len = utils.buildInt64(len1, len2, len3, len4)\n    this._createObjectStartFixed(len)\n  }\n\n  pushByteStringStart () {\n    this._parents[this._depth] = {\n      type: c.PARENT.BYTE_STRING,\n      length: -1,\n      ref: [],\n      values: 0,\n      tmpKey: null\n    }\n  }\n\n  pushByteString (start, end) {\n    this._push(this.createByteStringFromHeap(start, end))\n  }\n\n  pushUtf8StringStart () {\n    this._parents[this._depth] = {\n      type: c.PARENT.UTF8_STRING,\n      length: -1,\n      ref: [],\n      values: 0,\n      tmpKey: null\n    }\n  }\n\n  pushUtf8String (start, end) {\n    this._push(this.createUtf8StringFromHeap(start, end))\n  }\n\n  pushSimpleUnassigned (val) {\n    this._push(this.createSimpleUnassigned(val))\n  }\n\n  pushTagStart (tag) {\n    this._parents[this._depth] = {\n      type: c.PARENT.TAG,\n      length: 1,\n      ref: [tag]\n    }\n  }\n\n  pushTagStart4 (f, g) {\n    this.pushTagStart(utils.buildInt32(f, g))\n  }\n\n  pushTagStart8 (f1, f2, g1, g2) {\n    this.pushTagStart(utils.buildInt64(f1, f2, g1, g2))\n  }\n\n  pushTagUnassigned (tagNumber) {\n    this._push(this.createTag(tagNumber))\n  }\n\n  pushBreak () {\n    if (this._currentParent.length > -1) {\n      throw new Error('Unexpected break')\n    }\n\n    this._closeParent()\n  }\n\n  _createObjectStartFixed (len) {\n    if (len === 0) {\n      this._push(this.createObject({}))\n      return\n    }\n\n    this._createParent({}, c.PARENT.OBJECT, len)\n  }\n\n  _createArrayStartFixed (len) {\n    if (len === 0) {\n      this._push(this.createArray([]))\n      return\n    }\n\n    this._createParent(new Array(len), c.PARENT.ARRAY, len)\n  }\n\n  _decode (input) {\n    if (input.byteLength === 0) {\n      throw new Error('Input too short')\n    }\n\n    this._reset()\n    this._heap8.set(input)\n    const code = this.parser.parse(input.byteLength)\n\n    if (this._depth > 1) {\n      while (this._currentParent.length === 0) {\n        this._closeParent()\n      }\n      if (this._depth > 1) {\n        throw new Error('Undeterminated nesting')\n      }\n    }\n\n    if (code > 0) {\n      throw new Error('Failed to parse')\n    }\n\n    if (this._res.length === 0) {\n      throw new Error('No valid result')\n    }\n  }\n\n  // -- Public Interface\n\n  decodeFirst (input) {\n    this._decode(input)\n\n    return this._res[0]\n  }\n\n  decodeAll (input) {\n    this._decode(input)\n\n    return this._res\n  }\n\n  /**\n   * Decode the first cbor object.\n   *\n   * @param {Buffer|string} input\n   * @param {string} [enc='hex'] - Encoding used if a string is passed.\n   * @returns {*}\n   */\n  static decode (input, enc) {\n    if (typeof input === 'string') {\n      input = Buffer.from(input, enc || 'hex')\n    }\n\n    const dec = new Decoder({ size: input.length })\n    return dec.decodeFirst(input)\n  }\n\n  /**\n   * Decode all cbor objects.\n   *\n   * @param {Buffer|string} input\n   * @param {string} [enc='hex'] - Encoding used if a string is passed.\n   * @returns {Array<*>}\n   */\n  static decodeAll (input, enc) {\n    if (typeof input === 'string') {\n      input = Buffer.from(input, enc || 'hex')\n    }\n\n    const dec = new Decoder({ size: input.length })\n    return dec.decodeAll(input)\n  }\n}\n\nDecoder.decodeFirst = Decoder.decode\n\nmodule.exports = Decoder\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYm9yYy9zcmMvZGVjb2Rlci5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHdGQUFRO0FBQ25DLGdCQUFnQixtQkFBTyxDQUFDLHdFQUFTO0FBQ2pDLGtCQUFrQix1SEFBaUM7O0FBRW5ELGVBQWUsbUJBQU8sQ0FBQyxxRkFBZTtBQUN0QyxjQUFjLG1CQUFPLENBQUMseUVBQVM7QUFDL0IsVUFBVSxtQkFBTyxDQUFDLGlGQUFhO0FBQy9CLGVBQWUsbUJBQU8sQ0FBQywyRUFBVTtBQUNqQyxlQUFlLG1CQUFPLENBQUMsMkVBQVU7QUFDakMsUUFBUSxNQUFNLEVBQUUsbUJBQU8sQ0FBQyx3RUFBUzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUSxRQUFRO0FBQzdCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHlCQUF5QixxQkFBTTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLFVBQVU7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUIsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QixvQkFBb0I7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUIsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QixvQkFBb0I7QUFDbEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvYm9yYy9zcmMvZGVjb2Rlci5qcz81NmNhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZSgnYnVmZmVyJylcbmNvbnN0IGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbmNvbnN0IEJpZ251bWJlciA9IHJlcXVpcmUoJ2JpZ251bWJlci5qcycpLkJpZ051bWJlclxuXG5jb25zdCBwYXJzZXIgPSByZXF1aXJlKCcuL2RlY29kZXIuYXNtJylcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpXG5jb25zdCBjID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgU2ltcGxlID0gcmVxdWlyZSgnLi9zaW1wbGUnKVxuY29uc3QgVGFnZ2VkID0gcmVxdWlyZSgnLi90YWdnZWQnKVxuY29uc3QgeyBVUkwgfSA9IHJlcXVpcmUoJ2lzby11cmwnKVxuXG4vKipcbiAqIFRyYW5zZm9ybSBiaW5hcnkgY2JvciBkYXRhIGludG8gSmF2YVNjcmlwdCBvYmplY3RzLlxuICovXG5jbGFzcyBEZWNvZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cz17fV1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnNpemU9NjU1MzZdIC0gU2l6ZSBvZiB0aGUgYWxsb2NhdGVkIGhlYXAuXG4gICAqL1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgICBpZiAoIW9wdHMuc2l6ZSB8fCBvcHRzLnNpemUgPCAweDEwMDAwKSB7XG4gICAgICBvcHRzLnNpemUgPSAweDEwMDAwXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEVuc3VyZSB0aGUgc2l6ZSBpcyBhIHBvd2VyIG9mIDJcbiAgICAgIG9wdHMuc2l6ZSA9IHV0aWxzLm5leHRQb3dlck9mMihvcHRzLnNpemUpXG4gICAgfVxuXG4gICAgLy8gSGVhcCB1c2UgdG8gc2hhcmUgdGhlIGlucHV0IHdpdGggdGhlIHBhcnNlclxuICAgIHRoaXMuX2hlYXAgPSBuZXcgQXJyYXlCdWZmZXIob3B0cy5zaXplKVxuICAgIHRoaXMuX2hlYXA4ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5faGVhcClcbiAgICB0aGlzLl9idWZmZXIgPSBCdWZmZXIuZnJvbSh0aGlzLl9oZWFwKVxuXG4gICAgdGhpcy5fcmVzZXQoKVxuXG4gICAgLy8gS25vd24gdGFnc1xuICAgIHRoaXMuX2tub3duVGFncyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgMDogKHZhbCkgPT4gbmV3IERhdGUodmFsKSxcbiAgICAgIDE6ICh2YWwpID0+IG5ldyBEYXRlKHZhbCAqIDEwMDApLFxuICAgICAgMjogKHZhbCkgPT4gdXRpbHMuYXJyYXlCdWZmZXJUb0JpZ251bWJlcih2YWwpLFxuICAgICAgMzogKHZhbCkgPT4gYy5ORUdfT05FLm1pbnVzKHV0aWxzLmFycmF5QnVmZmVyVG9CaWdudW1iZXIodmFsKSksXG4gICAgICA0OiAodikgPT4ge1xuICAgICAgICAvLyBjb25zdCB2ID0gbmV3IFVpbnQ4QXJyYXkodmFsKVxuICAgICAgICByZXR1cm4gYy5URU4ucG93KHZbMF0pLnRpbWVzKHZbMV0pXG4gICAgICB9LFxuICAgICAgNTogKHYpID0+IHtcbiAgICAgICAgLy8gY29uc3QgdiA9IG5ldyBVaW50OEFycmF5KHZhbClcbiAgICAgICAgcmV0dXJuIGMuVFdPLnBvdyh2WzBdKS50aW1lcyh2WzFdKVxuICAgICAgfSxcbiAgICAgIDMyOiAodmFsKSA9PiBuZXcgVVJMKHZhbCksXG4gICAgICAzNTogKHZhbCkgPT4gbmV3IFJlZ0V4cCh2YWwpXG4gICAgfSwgb3B0cy50YWdzKVxuXG4gICAgLy8gSW5pdGlhbGl6ZSBhc20gYmFzZWQgcGFyc2VyXG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXIoZ2xvYmFsLCB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgbG9nOiBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLFxuICAgICAgcHVzaEludDogdGhpcy5wdXNoSW50LmJpbmQodGhpcyksXG4gICAgICBwdXNoSW50MzI6IHRoaXMucHVzaEludDMyLmJpbmQodGhpcyksXG4gICAgICBwdXNoSW50MzJOZWc6IHRoaXMucHVzaEludDMyTmVnLmJpbmQodGhpcyksXG4gICAgICBwdXNoSW50NjQ6IHRoaXMucHVzaEludDY0LmJpbmQodGhpcyksXG4gICAgICBwdXNoSW50NjROZWc6IHRoaXMucHVzaEludDY0TmVnLmJpbmQodGhpcyksXG4gICAgICBwdXNoRmxvYXQ6IHRoaXMucHVzaEZsb2F0LmJpbmQodGhpcyksXG4gICAgICBwdXNoRmxvYXRTaW5nbGU6IHRoaXMucHVzaEZsb2F0U2luZ2xlLmJpbmQodGhpcyksXG4gICAgICBwdXNoRmxvYXREb3VibGU6IHRoaXMucHVzaEZsb2F0RG91YmxlLmJpbmQodGhpcyksXG4gICAgICBwdXNoVHJ1ZTogdGhpcy5wdXNoVHJ1ZS5iaW5kKHRoaXMpLFxuICAgICAgcHVzaEZhbHNlOiB0aGlzLnB1c2hGYWxzZS5iaW5kKHRoaXMpLFxuICAgICAgcHVzaFVuZGVmaW5lZDogdGhpcy5wdXNoVW5kZWZpbmVkLmJpbmQodGhpcyksXG4gICAgICBwdXNoTnVsbDogdGhpcy5wdXNoTnVsbC5iaW5kKHRoaXMpLFxuICAgICAgcHVzaEluZmluaXR5OiB0aGlzLnB1c2hJbmZpbml0eS5iaW5kKHRoaXMpLFxuICAgICAgcHVzaEluZmluaXR5TmVnOiB0aGlzLnB1c2hJbmZpbml0eU5lZy5iaW5kKHRoaXMpLFxuICAgICAgcHVzaE5hTjogdGhpcy5wdXNoTmFOLmJpbmQodGhpcyksXG4gICAgICBwdXNoTmFOTmVnOiB0aGlzLnB1c2hOYU5OZWcuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hBcnJheVN0YXJ0OiB0aGlzLnB1c2hBcnJheVN0YXJ0LmJpbmQodGhpcyksXG4gICAgICBwdXNoQXJyYXlTdGFydEZpeGVkOiB0aGlzLnB1c2hBcnJheVN0YXJ0Rml4ZWQuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hBcnJheVN0YXJ0Rml4ZWQzMjogdGhpcy5wdXNoQXJyYXlTdGFydEZpeGVkMzIuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hBcnJheVN0YXJ0Rml4ZWQ2NDogdGhpcy5wdXNoQXJyYXlTdGFydEZpeGVkNjQuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hPYmplY3RTdGFydDogdGhpcy5wdXNoT2JqZWN0U3RhcnQuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hPYmplY3RTdGFydEZpeGVkOiB0aGlzLnB1c2hPYmplY3RTdGFydEZpeGVkLmJpbmQodGhpcyksXG4gICAgICBwdXNoT2JqZWN0U3RhcnRGaXhlZDMyOiB0aGlzLnB1c2hPYmplY3RTdGFydEZpeGVkMzIuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hPYmplY3RTdGFydEZpeGVkNjQ6IHRoaXMucHVzaE9iamVjdFN0YXJ0Rml4ZWQ2NC5iaW5kKHRoaXMpLFxuICAgICAgcHVzaEJ5dGVTdHJpbmc6IHRoaXMucHVzaEJ5dGVTdHJpbmcuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hCeXRlU3RyaW5nU3RhcnQ6IHRoaXMucHVzaEJ5dGVTdHJpbmdTdGFydC5iaW5kKHRoaXMpLFxuICAgICAgcHVzaFV0ZjhTdHJpbmc6IHRoaXMucHVzaFV0ZjhTdHJpbmcuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hVdGY4U3RyaW5nU3RhcnQ6IHRoaXMucHVzaFV0ZjhTdHJpbmdTdGFydC5iaW5kKHRoaXMpLFxuICAgICAgcHVzaFNpbXBsZVVuYXNzaWduZWQ6IHRoaXMucHVzaFNpbXBsZVVuYXNzaWduZWQuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hUYWdVbmFzc2lnbmVkOiB0aGlzLnB1c2hUYWdVbmFzc2lnbmVkLmJpbmQodGhpcyksXG4gICAgICBwdXNoVGFnU3RhcnQ6IHRoaXMucHVzaFRhZ1N0YXJ0LmJpbmQodGhpcyksXG4gICAgICBwdXNoVGFnU3RhcnQ0OiB0aGlzLnB1c2hUYWdTdGFydDQuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hUYWdTdGFydDg6IHRoaXMucHVzaFRhZ1N0YXJ0OC5iaW5kKHRoaXMpLFxuICAgICAgcHVzaEJyZWFrOiB0aGlzLnB1c2hCcmVhay5iaW5kKHRoaXMpXG4gICAgfSwgdGhpcy5faGVhcClcbiAgfVxuXG4gIGdldCBfZGVwdGggKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXJlbnRzLmxlbmd0aFxuICB9XG5cbiAgZ2V0IF9jdXJyZW50UGFyZW50ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50c1t0aGlzLl9kZXB0aCAtIDFdXG4gIH1cblxuICBnZXQgX3JlZiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRQYXJlbnQucmVmXG4gIH1cblxuICAvLyBGaW5pc2ggdGhlIGN1cnJlbnQgcGFyZW50XG4gIF9jbG9zZVBhcmVudCAoKSB7XG4gICAgdmFyIHAgPSB0aGlzLl9wYXJlbnRzLnBvcCgpXG5cbiAgICBpZiAocC5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgJHtwLmxlbmd0aH0gZWxlbWVudHNgKVxuICAgIH1cblxuICAgIHN3aXRjaCAocC50eXBlKSB7XG4gICAgICBjYXNlIGMuUEFSRU5ULlRBRzpcbiAgICAgICAgdGhpcy5fcHVzaChcbiAgICAgICAgICB0aGlzLmNyZWF0ZVRhZyhwLnJlZlswXSwgcC5yZWZbMV0pXG4gICAgICAgIClcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgYy5QQVJFTlQuQllURV9TVFJJTkc6XG4gICAgICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVCeXRlU3RyaW5nKHAucmVmLCBwLmxlbmd0aCkpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIGMuUEFSRU5ULlVURjhfU1RSSU5HOlxuICAgICAgICB0aGlzLl9wdXNoKHRoaXMuY3JlYXRlVXRmOFN0cmluZyhwLnJlZiwgcC5sZW5ndGgpKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBjLlBBUkVOVC5NQVA6XG4gICAgICAgIGlmIChwLnZhbHVlcyAlIDIgPiAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPZGQgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBtYXAnKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVNYXAocC5yZWYsIHAubGVuZ3RoKSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgYy5QQVJFTlQuT0JKRUNUOlxuICAgICAgICBpZiAocC52YWx1ZXMgJSAyID4gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT2RkIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgbWFwJylcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wdXNoKHRoaXMuY3JlYXRlT2JqZWN0KHAucmVmLCBwLmxlbmd0aCkpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIGMuUEFSRU5ULkFSUkFZOlxuICAgICAgICB0aGlzLl9wdXNoKHRoaXMuY3JlYXRlQXJyYXkocC5yZWYsIHAubGVuZ3RoKSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2N1cnJlbnRQYXJlbnQgJiYgdGhpcy5fY3VycmVudFBhcmVudC50eXBlID09PSBjLlBBUkVOVC5UQUcpIHtcbiAgICAgIHRoaXMuX2RlYygpXG4gICAgfVxuICB9XG5cbiAgLy8gUmVkdWNlIHRoZSBleHBlY3RlZCBsZW5ndGggb2YgdGhlIGN1cnJlbnQgcGFyZW50IGJ5IG9uZVxuICBfZGVjICgpIHtcbiAgICBjb25zdCBwID0gdGhpcy5fY3VycmVudFBhcmVudFxuICAgIC8vIFRoZSBjdXJyZW50IHBhcmVudCBkb2VzIG5vdCBrbm93IHRoZSBlcHhlY3RlZCBjaGlsZCBsZW5ndGhcblxuICAgIGlmIChwLmxlbmd0aCA8IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHAubGVuZ3RoLS1cblxuICAgIC8vIEFsbCBjaGlsZHJlbiB3ZXJlIHNlZW4sIHdlIGNhbiBjbG9zZSB0aGUgY3VycmVudCBwYXJlbnRcbiAgICBpZiAocC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuX2Nsb3NlUGFyZW50KClcbiAgICB9XG4gIH1cblxuICAvLyBQdXNoIGFueSB2YWx1ZSB0byB0aGUgY3VycmVudCBwYXJlbnRcbiAgX3B1c2ggKHZhbCwgaGFzQ2hpbGRyZW4pIHtcbiAgICBjb25zdCBwID0gdGhpcy5fY3VycmVudFBhcmVudFxuICAgIHAudmFsdWVzKytcblxuICAgIHN3aXRjaCAocC50eXBlKSB7XG4gICAgICBjYXNlIGMuUEFSRU5ULkFSUkFZOlxuICAgICAgY2FzZSBjLlBBUkVOVC5CWVRFX1NUUklORzpcbiAgICAgIGNhc2UgYy5QQVJFTlQuVVRGOF9TVFJJTkc6XG4gICAgICAgIGlmIChwLmxlbmd0aCA+IC0xKSB7XG4gICAgICAgICAgdGhpcy5fcmVmW3RoaXMuX3JlZi5sZW5ndGggLSBwLmxlbmd0aF0gPSB2YWxcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9yZWYucHVzaCh2YWwpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGVjKClcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgYy5QQVJFTlQuT0JKRUNUOlxuICAgICAgICBpZiAocC50bXBLZXkgIT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuX3JlZltwLnRtcEtleV0gPSB2YWxcbiAgICAgICAgICBwLnRtcEtleSA9IG51bGxcbiAgICAgICAgICB0aGlzLl9kZWMoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHAudG1wS2V5ID0gdmFsXG5cbiAgICAgICAgICBpZiAodHlwZW9mIHAudG1wS2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gdG9vIGJhZCwgY29udmVydCB0byBhIE1hcFxuICAgICAgICAgICAgcC50eXBlID0gYy5QQVJFTlQuTUFQXG4gICAgICAgICAgICBwLnJlZiA9IHV0aWxzLmJ1aWxkTWFwKHAucmVmKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBjLlBBUkVOVC5NQVA6XG4gICAgICAgIGlmIChwLnRtcEtleSAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5fcmVmLnNldChwLnRtcEtleSwgdmFsKVxuICAgICAgICAgIHAudG1wS2V5ID0gbnVsbFxuICAgICAgICAgIHRoaXMuX2RlYygpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcC50bXBLZXkgPSB2YWxcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBjLlBBUkVOVC5UQUc6XG4gICAgICAgIHRoaXMuX3JlZi5wdXNoKHZhbClcbiAgICAgICAgaWYgKCFoYXNDaGlsZHJlbikge1xuICAgICAgICAgIHRoaXMuX2RlYygpXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBwYXJlbnQgdHlwZScpXG4gICAgfVxuICB9XG5cbiAgLy8gQ3JlYXRlIGEgbmV3IHBhcmVudCBpbiB0aGUgcGFyZW50cyBsaXN0XG4gIF9jcmVhdGVQYXJlbnQgKG9iaiwgdHlwZSwgbGVuKSB7XG4gICAgdGhpcy5fcGFyZW50c1t0aGlzLl9kZXB0aF0gPSB7XG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgbGVuZ3RoOiBsZW4sXG4gICAgICByZWY6IG9iaixcbiAgICAgIHZhbHVlczogMCxcbiAgICAgIHRtcEtleTogbnVsbFxuICAgIH1cbiAgfVxuXG4gIC8vIFJlc2V0IGFsbCBzdGF0ZSBiYWNrIHRvIHRoZSBiZWdpbm5pbmcsIGFsc28gdXNlZCBmb3IgaW5pdGlhdGxpemF0aW9uXG4gIF9yZXNldCAoKSB7XG4gICAgdGhpcy5fcmVzID0gW11cbiAgICB0aGlzLl9wYXJlbnRzID0gW3tcbiAgICAgIHR5cGU6IGMuUEFSRU5ULkFSUkFZLFxuICAgICAgbGVuZ3RoOiAtMSxcbiAgICAgIHJlZjogdGhpcy5fcmVzLFxuICAgICAgdmFsdWVzOiAwLFxuICAgICAgdG1wS2V5OiBudWxsXG4gICAgfV1cbiAgfVxuXG4gIC8vIC0tIEludGVyZmFjZSB0byBjdXN0b21pemUgZGVvZGluZyBiZWhhdmlvdXJcbiAgY3JlYXRlVGFnICh0YWdOdW1iZXIsIHZhbHVlKSB7XG4gICAgY29uc3QgdHlwID0gdGhpcy5fa25vd25UYWdzW3RhZ051bWJlcl1cblxuICAgIGlmICghdHlwKSB7XG4gICAgICByZXR1cm4gbmV3IFRhZ2dlZCh0YWdOdW1iZXIsIHZhbHVlKVxuICAgIH1cblxuICAgIHJldHVybiB0eXAodmFsdWUpXG4gIH1cblxuICBjcmVhdGVNYXAgKG9iaiwgbGVuKSB7XG4gICAgcmV0dXJuIG9ialxuICB9XG5cbiAgY3JlYXRlT2JqZWN0IChvYmosIGxlbikge1xuICAgIHJldHVybiBvYmpcbiAgfVxuXG4gIGNyZWF0ZUFycmF5IChhcnIsIGxlbikge1xuICAgIHJldHVybiBhcnJcbiAgfVxuXG4gIGNyZWF0ZUJ5dGVTdHJpbmcgKHJhdywgbGVuKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQocmF3KVxuICB9XG5cbiAgY3JlYXRlQnl0ZVN0cmluZ0Zyb21IZWFwIChzdGFydCwgZW5kKSB7XG4gICAgaWYgKHN0YXJ0ID09PSBlbmQpIHtcbiAgICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgICB9XG5cbiAgICByZXR1cm4gQnVmZmVyLmZyb20odGhpcy5faGVhcC5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxuXG4gIGNyZWF0ZUludCAodmFsKSB7XG4gICAgcmV0dXJuIHZhbFxuICB9XG5cbiAgY3JlYXRlSW50MzIgKGYsIGcpIHtcbiAgICByZXR1cm4gdXRpbHMuYnVpbGRJbnQzMihmLCBnKVxuICB9XG5cbiAgY3JlYXRlSW50NjQgKGYxLCBmMiwgZzEsIGcyKSB7XG4gICAgcmV0dXJuIHV0aWxzLmJ1aWxkSW50NjQoZjEsIGYyLCBnMSwgZzIpXG4gIH1cblxuICBjcmVhdGVGbG9hdCAodmFsKSB7XG4gICAgcmV0dXJuIHZhbFxuICB9XG5cbiAgY3JlYXRlRmxvYXRTaW5nbGUgKGEsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gaWVlZTc1NC5yZWFkKFthLCBiLCBjLCBkXSwgMCwgZmFsc2UsIDIzLCA0KVxuICB9XG5cbiAgY3JlYXRlRmxvYXREb3VibGUgKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgpIHtcbiAgICByZXR1cm4gaWVlZTc1NC5yZWFkKFthLCBiLCBjLCBkLCBlLCBmLCBnLCBoXSwgMCwgZmFsc2UsIDUyLCA4KVxuICB9XG5cbiAgY3JlYXRlSW50MzJOZWcgKGYsIGcpIHtcbiAgICByZXR1cm4gLTEgLSB1dGlscy5idWlsZEludDMyKGYsIGcpXG4gIH1cblxuICBjcmVhdGVJbnQ2NE5lZyAoZjEsIGYyLCBnMSwgZzIpIHtcbiAgICBjb25zdCBmID0gdXRpbHMuYnVpbGRJbnQzMihmMSwgZjIpXG4gICAgY29uc3QgZyA9IHV0aWxzLmJ1aWxkSW50MzIoZzEsIGcyKVxuXG4gICAgaWYgKGYgPiBjLk1BWF9TQUZFX0hJR0gpIHtcbiAgICAgIHJldHVybiBjLk5FR19PTkUubWludXMobmV3IEJpZ251bWJlcihmKS50aW1lcyhjLlNISUZUMzIpLnBsdXMoZykpXG4gICAgfVxuXG4gICAgcmV0dXJuIC0xIC0gKChmICogYy5TSElGVDMyKSArIGcpXG4gIH1cblxuICBjcmVhdGVUcnVlICgpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgY3JlYXRlRmFsc2UgKCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgY3JlYXRlTnVsbCAoKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGNyZWF0ZVVuZGVmaW5lZCAoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgY3JlYXRlSW5maW5pdHkgKCkge1xuICAgIHJldHVybiBJbmZpbml0eVxuICB9XG5cbiAgY3JlYXRlSW5maW5pdHlOZWcgKCkge1xuICAgIHJldHVybiAtSW5maW5pdHlcbiAgfVxuXG4gIGNyZWF0ZU5hTiAoKSB7XG4gICAgcmV0dXJuIE5hTlxuICB9XG5cbiAgY3JlYXRlTmFOTmVnICgpIHtcbiAgICByZXR1cm4gLU5hTlxuICB9XG5cbiAgY3JlYXRlVXRmOFN0cmluZyAocmF3LCBsZW4pIHtcbiAgICByZXR1cm4gcmF3LmpvaW4oJycpXG4gIH1cblxuICBjcmVhdGVVdGY4U3RyaW5nRnJvbUhlYXAgKHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoc3RhcnQgPT09IGVuZCkge1xuICAgICAgcmV0dXJuICcnXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2J1ZmZlci50b1N0cmluZygndXRmOCcsIHN0YXJ0LCBlbmQpXG4gIH1cblxuICBjcmVhdGVTaW1wbGVVbmFzc2lnbmVkICh2YWwpIHtcbiAgICByZXR1cm4gbmV3IFNpbXBsZSh2YWwpXG4gIH1cblxuICAvLyAtLSBJbnRlcmZhY2UgZm9yIGRlY29kZXIuYXNtLmpzXG5cbiAgcHVzaEludCAodmFsKSB7XG4gICAgdGhpcy5fcHVzaCh0aGlzLmNyZWF0ZUludCh2YWwpKVxuICB9XG5cbiAgcHVzaEludDMyIChmLCBnKSB7XG4gICAgdGhpcy5fcHVzaCh0aGlzLmNyZWF0ZUludDMyKGYsIGcpKVxuICB9XG5cbiAgcHVzaEludDY0IChmMSwgZjIsIGcxLCBnMikge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVJbnQ2NChmMSwgZjIsIGcxLCBnMikpXG4gIH1cblxuICBwdXNoRmxvYXQgKHZhbCkge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVGbG9hdCh2YWwpKVxuICB9XG5cbiAgcHVzaEZsb2F0U2luZ2xlIChhLCBiLCBjLCBkKSB7XG4gICAgdGhpcy5fcHVzaCh0aGlzLmNyZWF0ZUZsb2F0U2luZ2xlKGEsIGIsIGMsIGQpKVxuICB9XG5cbiAgcHVzaEZsb2F0RG91YmxlIChhLCBiLCBjLCBkLCBlLCBmLCBnLCBoKSB7XG4gICAgdGhpcy5fcHVzaCh0aGlzLmNyZWF0ZUZsb2F0RG91YmxlKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgpKVxuICB9XG5cbiAgcHVzaEludDMyTmVnIChmLCBnKSB7XG4gICAgdGhpcy5fcHVzaCh0aGlzLmNyZWF0ZUludDMyTmVnKGYsIGcpKVxuICB9XG5cbiAgcHVzaEludDY0TmVnIChmMSwgZjIsIGcxLCBnMikge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVJbnQ2NE5lZyhmMSwgZjIsIGcxLCBnMikpXG4gIH1cblxuICBwdXNoVHJ1ZSAoKSB7XG4gICAgdGhpcy5fcHVzaCh0aGlzLmNyZWF0ZVRydWUoKSlcbiAgfVxuXG4gIHB1c2hGYWxzZSAoKSB7XG4gICAgdGhpcy5fcHVzaCh0aGlzLmNyZWF0ZUZhbHNlKCkpXG4gIH1cblxuICBwdXNoTnVsbCAoKSB7XG4gICAgdGhpcy5fcHVzaCh0aGlzLmNyZWF0ZU51bGwoKSlcbiAgfVxuXG4gIHB1c2hVbmRlZmluZWQgKCkge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVVbmRlZmluZWQoKSlcbiAgfVxuXG4gIHB1c2hJbmZpbml0eSAoKSB7XG4gICAgdGhpcy5fcHVzaCh0aGlzLmNyZWF0ZUluZmluaXR5KCkpXG4gIH1cblxuICBwdXNoSW5maW5pdHlOZWcgKCkge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVJbmZpbml0eU5lZygpKVxuICB9XG5cbiAgcHVzaE5hTiAoKSB7XG4gICAgdGhpcy5fcHVzaCh0aGlzLmNyZWF0ZU5hTigpKVxuICB9XG5cbiAgcHVzaE5hTk5lZyAoKSB7XG4gICAgdGhpcy5fcHVzaCh0aGlzLmNyZWF0ZU5hTk5lZygpKVxuICB9XG5cbiAgcHVzaEFycmF5U3RhcnQgKCkge1xuICAgIHRoaXMuX2NyZWF0ZVBhcmVudChbXSwgYy5QQVJFTlQuQVJSQVksIC0xKVxuICB9XG5cbiAgcHVzaEFycmF5U3RhcnRGaXhlZCAobGVuKSB7XG4gICAgdGhpcy5fY3JlYXRlQXJyYXlTdGFydEZpeGVkKGxlbilcbiAgfVxuXG4gIHB1c2hBcnJheVN0YXJ0Rml4ZWQzMiAobGVuMSwgbGVuMikge1xuICAgIGNvbnN0IGxlbiA9IHV0aWxzLmJ1aWxkSW50MzIobGVuMSwgbGVuMilcbiAgICB0aGlzLl9jcmVhdGVBcnJheVN0YXJ0Rml4ZWQobGVuKVxuICB9XG5cbiAgcHVzaEFycmF5U3RhcnRGaXhlZDY0IChsZW4xLCBsZW4yLCBsZW4zLCBsZW40KSB7XG4gICAgY29uc3QgbGVuID0gdXRpbHMuYnVpbGRJbnQ2NChsZW4xLCBsZW4yLCBsZW4zLCBsZW40KVxuICAgIHRoaXMuX2NyZWF0ZUFycmF5U3RhcnRGaXhlZChsZW4pXG4gIH1cblxuICBwdXNoT2JqZWN0U3RhcnQgKCkge1xuICAgIHRoaXMuX2NyZWF0ZU9iamVjdFN0YXJ0Rml4ZWQoLTEpXG4gIH1cblxuICBwdXNoT2JqZWN0U3RhcnRGaXhlZCAobGVuKSB7XG4gICAgdGhpcy5fY3JlYXRlT2JqZWN0U3RhcnRGaXhlZChsZW4pXG4gIH1cblxuICBwdXNoT2JqZWN0U3RhcnRGaXhlZDMyIChsZW4xLCBsZW4yKSB7XG4gICAgY29uc3QgbGVuID0gdXRpbHMuYnVpbGRJbnQzMihsZW4xLCBsZW4yKVxuICAgIHRoaXMuX2NyZWF0ZU9iamVjdFN0YXJ0Rml4ZWQobGVuKVxuICB9XG5cbiAgcHVzaE9iamVjdFN0YXJ0Rml4ZWQ2NCAobGVuMSwgbGVuMiwgbGVuMywgbGVuNCkge1xuICAgIGNvbnN0IGxlbiA9IHV0aWxzLmJ1aWxkSW50NjQobGVuMSwgbGVuMiwgbGVuMywgbGVuNClcbiAgICB0aGlzLl9jcmVhdGVPYmplY3RTdGFydEZpeGVkKGxlbilcbiAgfVxuXG4gIHB1c2hCeXRlU3RyaW5nU3RhcnQgKCkge1xuICAgIHRoaXMuX3BhcmVudHNbdGhpcy5fZGVwdGhdID0ge1xuICAgICAgdHlwZTogYy5QQVJFTlQuQllURV9TVFJJTkcsXG4gICAgICBsZW5ndGg6IC0xLFxuICAgICAgcmVmOiBbXSxcbiAgICAgIHZhbHVlczogMCxcbiAgICAgIHRtcEtleTogbnVsbFxuICAgIH1cbiAgfVxuXG4gIHB1c2hCeXRlU3RyaW5nIChzdGFydCwgZW5kKSB7XG4gICAgdGhpcy5fcHVzaCh0aGlzLmNyZWF0ZUJ5dGVTdHJpbmdGcm9tSGVhcChzdGFydCwgZW5kKSlcbiAgfVxuXG4gIHB1c2hVdGY4U3RyaW5nU3RhcnQgKCkge1xuICAgIHRoaXMuX3BhcmVudHNbdGhpcy5fZGVwdGhdID0ge1xuICAgICAgdHlwZTogYy5QQVJFTlQuVVRGOF9TVFJJTkcsXG4gICAgICBsZW5ndGg6IC0xLFxuICAgICAgcmVmOiBbXSxcbiAgICAgIHZhbHVlczogMCxcbiAgICAgIHRtcEtleTogbnVsbFxuICAgIH1cbiAgfVxuXG4gIHB1c2hVdGY4U3RyaW5nIChzdGFydCwgZW5kKSB7XG4gICAgdGhpcy5fcHVzaCh0aGlzLmNyZWF0ZVV0ZjhTdHJpbmdGcm9tSGVhcChzdGFydCwgZW5kKSlcbiAgfVxuXG4gIHB1c2hTaW1wbGVVbmFzc2lnbmVkICh2YWwpIHtcbiAgICB0aGlzLl9wdXNoKHRoaXMuY3JlYXRlU2ltcGxlVW5hc3NpZ25lZCh2YWwpKVxuICB9XG5cbiAgcHVzaFRhZ1N0YXJ0ICh0YWcpIHtcbiAgICB0aGlzLl9wYXJlbnRzW3RoaXMuX2RlcHRoXSA9IHtcbiAgICAgIHR5cGU6IGMuUEFSRU5ULlRBRyxcbiAgICAgIGxlbmd0aDogMSxcbiAgICAgIHJlZjogW3RhZ11cbiAgICB9XG4gIH1cblxuICBwdXNoVGFnU3RhcnQ0IChmLCBnKSB7XG4gICAgdGhpcy5wdXNoVGFnU3RhcnQodXRpbHMuYnVpbGRJbnQzMihmLCBnKSlcbiAgfVxuXG4gIHB1c2hUYWdTdGFydDggKGYxLCBmMiwgZzEsIGcyKSB7XG4gICAgdGhpcy5wdXNoVGFnU3RhcnQodXRpbHMuYnVpbGRJbnQ2NChmMSwgZjIsIGcxLCBnMikpXG4gIH1cblxuICBwdXNoVGFnVW5hc3NpZ25lZCAodGFnTnVtYmVyKSB7XG4gICAgdGhpcy5fcHVzaCh0aGlzLmNyZWF0ZVRhZyh0YWdOdW1iZXIpKVxuICB9XG5cbiAgcHVzaEJyZWFrICgpIHtcbiAgICBpZiAodGhpcy5fY3VycmVudFBhcmVudC5sZW5ndGggPiAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGJyZWFrJylcbiAgICB9XG5cbiAgICB0aGlzLl9jbG9zZVBhcmVudCgpXG4gIH1cblxuICBfY3JlYXRlT2JqZWN0U3RhcnRGaXhlZCAobGVuKSB7XG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhpcy5fcHVzaCh0aGlzLmNyZWF0ZU9iamVjdCh7fSkpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9jcmVhdGVQYXJlbnQoe30sIGMuUEFSRU5ULk9CSkVDVCwgbGVuKVxuICB9XG5cbiAgX2NyZWF0ZUFycmF5U3RhcnRGaXhlZCAobGVuKSB7XG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhpcy5fcHVzaCh0aGlzLmNyZWF0ZUFycmF5KFtdKSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX2NyZWF0ZVBhcmVudChuZXcgQXJyYXkobGVuKSwgYy5QQVJFTlQuQVJSQVksIGxlbilcbiAgfVxuXG4gIF9kZWNvZGUgKGlucHV0KSB7XG4gICAgaWYgKGlucHV0LmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgdG9vIHNob3J0JylcbiAgICB9XG5cbiAgICB0aGlzLl9yZXNldCgpXG4gICAgdGhpcy5faGVhcDguc2V0KGlucHV0KVxuICAgIGNvbnN0IGNvZGUgPSB0aGlzLnBhcnNlci5wYXJzZShpbnB1dC5ieXRlTGVuZ3RoKVxuXG4gICAgaWYgKHRoaXMuX2RlcHRoID4gMSkge1xuICAgICAgd2hpbGUgKHRoaXMuX2N1cnJlbnRQYXJlbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2Nsb3NlUGFyZW50KClcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9kZXB0aCA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmRldGVybWluYXRlZCBuZXN0aW5nJylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZSA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHBhcnNlJylcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB2YWxpZCByZXN1bHQnKVxuICAgIH1cbiAgfVxuXG4gIC8vIC0tIFB1YmxpYyBJbnRlcmZhY2VcblxuICBkZWNvZGVGaXJzdCAoaW5wdXQpIHtcbiAgICB0aGlzLl9kZWNvZGUoaW5wdXQpXG5cbiAgICByZXR1cm4gdGhpcy5fcmVzWzBdXG4gIH1cblxuICBkZWNvZGVBbGwgKGlucHV0KSB7XG4gICAgdGhpcy5fZGVjb2RlKGlucHV0KVxuXG4gICAgcmV0dXJuIHRoaXMuX3Jlc1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSB0aGUgZmlyc3QgY2JvciBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfHN0cmluZ30gaW5wdXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtlbmM9J2hleCddIC0gRW5jb2RpbmcgdXNlZCBpZiBhIHN0cmluZyBpcyBwYXNzZWQuXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgc3RhdGljIGRlY29kZSAoaW5wdXQsIGVuYykge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpbnB1dCA9IEJ1ZmZlci5mcm9tKGlucHV0LCBlbmMgfHwgJ2hleCcpXG4gICAgfVxuXG4gICAgY29uc3QgZGVjID0gbmV3IERlY29kZXIoeyBzaXplOiBpbnB1dC5sZW5ndGggfSlcbiAgICByZXR1cm4gZGVjLmRlY29kZUZpcnN0KGlucHV0KVxuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbGwgY2JvciBvYmplY3RzLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcnxzdHJpbmd9IGlucHV0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZW5jPSdoZXgnXSAtIEVuY29kaW5nIHVzZWQgaWYgYSBzdHJpbmcgaXMgcGFzc2VkLlxuICAgKiBAcmV0dXJucyB7QXJyYXk8Kj59XG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQWxsIChpbnB1dCwgZW5jKSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlucHV0ID0gQnVmZmVyLmZyb20oaW5wdXQsIGVuYyB8fCAnaGV4JylcbiAgICB9XG5cbiAgICBjb25zdCBkZWMgPSBuZXcgRGVjb2Rlcih7IHNpemU6IGlucHV0Lmxlbmd0aCB9KVxuICAgIHJldHVybiBkZWMuZGVjb2RlQWxsKGlucHV0KVxuICB9XG59XG5cbkRlY29kZXIuZGVjb2RlRmlyc3QgPSBEZWNvZGVyLmRlY29kZVxuXG5tb2R1bGUuZXhwb3J0cyA9IERlY29kZXJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/borc/src/decoder.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/borc/src/diagnose.js":
/*!***********************************************!*\
  !*** ../../node_modules/borc/src/diagnose.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nconst { Buffer } = __webpack_require__(/*! buffer */ \"(app-pages-browser)/../../node_modules/borc/node_modules/buffer/index.js\")\nconst Decoder = __webpack_require__(/*! ./decoder */ \"(app-pages-browser)/../../node_modules/borc/src/decoder.js\")\nconst utils = __webpack_require__(/*! ./utils */ \"(app-pages-browser)/../../node_modules/borc/src/utils.js\")\n\n/**\n * Output the diagnostic format from a stream of CBOR bytes.\n *\n */\nclass Diagnose extends Decoder {\n  createTag (tagNumber, value) {\n    return `${tagNumber}(${value})`\n  }\n\n  createInt (val) {\n    return super.createInt(val).toString()\n  }\n\n  createInt32 (f, g) {\n    return super.createInt32(f, g).toString()\n  }\n\n  createInt64 (f1, f2, g1, g2) {\n    return super.createInt64(f1, f2, g1, g2).toString()\n  }\n\n  createInt32Neg (f, g) {\n    return super.createInt32Neg(f, g).toString()\n  }\n\n  createInt64Neg (f1, f2, g1, g2) {\n    return super.createInt64Neg(f1, f2, g1, g2).toString()\n  }\n\n  createTrue () {\n    return 'true'\n  }\n\n  createFalse () {\n    return 'false'\n  }\n\n  createFloat (val) {\n    const fl = super.createFloat(val)\n    if (utils.isNegativeZero(val)) {\n      return '-0_1'\n    }\n\n    return `${fl}_1`\n  }\n\n  createFloatSingle (a, b, c, d) {\n    const fl = super.createFloatSingle(a, b, c, d)\n    return `${fl}_2`\n  }\n\n  createFloatDouble (a, b, c, d, e, f, g, h) {\n    const fl = super.createFloatDouble(a, b, c, d, e, f, g, h)\n    return `${fl}_3`\n  }\n\n  createByteString (raw, len) {\n    const val = raw.join(', ')\n\n    if (len === -1) {\n      return `(_ ${val})`\n    }\n    return `h'${val}`\n  }\n\n  createByteStringFromHeap (start, end) {\n    const val = (Buffer.from(\n      super.createByteStringFromHeap(start, end)\n    )).toString('hex')\n\n    return `h'${val}'`\n  }\n\n  createInfinity () {\n    return 'Infinity_1'\n  }\n\n  createInfinityNeg () {\n    return '-Infinity_1'\n  }\n\n  createNaN () {\n    return 'NaN_1'\n  }\n\n  createNaNNeg () {\n    return '-NaN_1'\n  }\n\n  createNull () {\n    return 'null'\n  }\n\n  createUndefined () {\n    return 'undefined'\n  }\n\n  createSimpleUnassigned (val) {\n    return `simple(${val})`\n  }\n\n  createArray (arr, len) {\n    const val = super.createArray(arr, len)\n\n    if (len === -1) {\n      // indefinite\n      return `[_ ${val.join(', ')}]`\n    }\n\n    return `[${val.join(', ')}]`\n  }\n\n  createMap (map, len) {\n    const val = super.createMap(map)\n    const list = Array.from(val.keys())\n      .reduce(collectObject(val), '')\n\n    if (len === -1) {\n      return `{_ ${list}}`\n    }\n\n    return `{${list}}`\n  }\n\n  createObject (obj, len) {\n    const val = super.createObject(obj)\n    const map = Object.keys(val)\n      .reduce(collectObject(val), '')\n\n    if (len === -1) {\n      return `{_ ${map}}`\n    }\n\n    return `{${map}}`\n  }\n\n  createUtf8String (raw, len) {\n    const val = raw.join(', ')\n\n    if (len === -1) {\n      return `(_ ${val})`\n    }\n\n    return `\"${val}\"`\n  }\n\n  createUtf8StringFromHeap (start, end) {\n    const val = (Buffer.from(\n      super.createUtf8StringFromHeap(start, end)\n    )).toString('utf8')\n\n    return `\"${val}\"`\n  }\n\n  static diagnose (input, enc) {\n    if (typeof input === 'string') {\n      input = Buffer.from(input, enc || 'hex')\n    }\n\n    const dec = new Diagnose()\n    return dec.decodeFirst(input)\n  }\n}\n\nmodule.exports = Diagnose\n\nfunction collectObject (val) {\n  return (acc, key) => {\n    if (acc) {\n      return `${acc}, ${key}: ${val[key]}`\n    }\n    return `${key}: ${val[key]}`\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYm9yYy9zcmMvZGlhZ25vc2UuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyx3RkFBUTtBQUNuQyxnQkFBZ0IsbUJBQU8sQ0FBQyw2RUFBVztBQUNuQyxjQUFjLG1CQUFPLENBQUMseUVBQVM7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVSxHQUFHLE1BQU07QUFDakM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxHQUFHO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQSxjQUFjLEdBQUc7QUFDakI7O0FBRUE7QUFDQTtBQUNBLGNBQWMsR0FBRztBQUNqQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLElBQUk7QUFDdkI7QUFDQSxnQkFBZ0IsSUFBSTtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsSUFBSTtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixJQUFJO0FBQ3pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDOztBQUVBLGVBQWUsZUFBZTtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsSUFBSSxNQUFNO0FBQ3pCOztBQUVBLGFBQWEsRUFBRSxNQUFNO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxJQUFJLEtBQUs7QUFDeEI7O0FBRUEsYUFBYSxFQUFFLEtBQUs7QUFDcEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixJQUFJO0FBQ3ZCOztBQUVBLGVBQWUsSUFBSTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLElBQUk7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLElBQUksSUFBSSxJQUFJLElBQUksU0FBUztBQUN6QztBQUNBLGNBQWMsSUFBSSxJQUFJLFNBQVM7QUFDL0I7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL2JvcmMvc3JjL2RpYWdub3NlLmpzPzdjZjQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgQnVmZmVyIH0gPSByZXF1aXJlKCdidWZmZXInKVxuY29uc3QgRGVjb2RlciA9IHJlcXVpcmUoJy4vZGVjb2RlcicpXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuXG4vKipcbiAqIE91dHB1dCB0aGUgZGlhZ25vc3RpYyBmb3JtYXQgZnJvbSBhIHN0cmVhbSBvZiBDQk9SIGJ5dGVzLlxuICpcbiAqL1xuY2xhc3MgRGlhZ25vc2UgZXh0ZW5kcyBEZWNvZGVyIHtcbiAgY3JlYXRlVGFnICh0YWdOdW1iZXIsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGAke3RhZ051bWJlcn0oJHt2YWx1ZX0pYFxuICB9XG5cbiAgY3JlYXRlSW50ICh2YWwpIHtcbiAgICByZXR1cm4gc3VwZXIuY3JlYXRlSW50KHZhbCkudG9TdHJpbmcoKVxuICB9XG5cbiAgY3JlYXRlSW50MzIgKGYsIGcpIHtcbiAgICByZXR1cm4gc3VwZXIuY3JlYXRlSW50MzIoZiwgZykudG9TdHJpbmcoKVxuICB9XG5cbiAgY3JlYXRlSW50NjQgKGYxLCBmMiwgZzEsIGcyKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNyZWF0ZUludDY0KGYxLCBmMiwgZzEsIGcyKS50b1N0cmluZygpXG4gIH1cblxuICBjcmVhdGVJbnQzMk5lZyAoZiwgZykge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGVJbnQzMk5lZyhmLCBnKS50b1N0cmluZygpXG4gIH1cblxuICBjcmVhdGVJbnQ2NE5lZyAoZjEsIGYyLCBnMSwgZzIpIHtcbiAgICByZXR1cm4gc3VwZXIuY3JlYXRlSW50NjROZWcoZjEsIGYyLCBnMSwgZzIpLnRvU3RyaW5nKClcbiAgfVxuXG4gIGNyZWF0ZVRydWUgKCkge1xuICAgIHJldHVybiAndHJ1ZSdcbiAgfVxuXG4gIGNyZWF0ZUZhbHNlICgpIHtcbiAgICByZXR1cm4gJ2ZhbHNlJ1xuICB9XG5cbiAgY3JlYXRlRmxvYXQgKHZhbCkge1xuICAgIGNvbnN0IGZsID0gc3VwZXIuY3JlYXRlRmxvYXQodmFsKVxuICAgIGlmICh1dGlscy5pc05lZ2F0aXZlWmVybyh2YWwpKSB7XG4gICAgICByZXR1cm4gJy0wXzEnXG4gICAgfVxuXG4gICAgcmV0dXJuIGAke2ZsfV8xYFxuICB9XG5cbiAgY3JlYXRlRmxvYXRTaW5nbGUgKGEsIGIsIGMsIGQpIHtcbiAgICBjb25zdCBmbCA9IHN1cGVyLmNyZWF0ZUZsb2F0U2luZ2xlKGEsIGIsIGMsIGQpXG4gICAgcmV0dXJuIGAke2ZsfV8yYFxuICB9XG5cbiAgY3JlYXRlRmxvYXREb3VibGUgKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgpIHtcbiAgICBjb25zdCBmbCA9IHN1cGVyLmNyZWF0ZUZsb2F0RG91YmxlKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgpXG4gICAgcmV0dXJuIGAke2ZsfV8zYFxuICB9XG5cbiAgY3JlYXRlQnl0ZVN0cmluZyAocmF3LCBsZW4pIHtcbiAgICBjb25zdCB2YWwgPSByYXcuam9pbignLCAnKVxuXG4gICAgaWYgKGxlbiA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBgKF8gJHt2YWx9KWBcbiAgICB9XG4gICAgcmV0dXJuIGBoJyR7dmFsfWBcbiAgfVxuXG4gIGNyZWF0ZUJ5dGVTdHJpbmdGcm9tSGVhcCAoc3RhcnQsIGVuZCkge1xuICAgIGNvbnN0IHZhbCA9IChCdWZmZXIuZnJvbShcbiAgICAgIHN1cGVyLmNyZWF0ZUJ5dGVTdHJpbmdGcm9tSGVhcChzdGFydCwgZW5kKVxuICAgICkpLnRvU3RyaW5nKCdoZXgnKVxuXG4gICAgcmV0dXJuIGBoJyR7dmFsfSdgXG4gIH1cblxuICBjcmVhdGVJbmZpbml0eSAoKSB7XG4gICAgcmV0dXJuICdJbmZpbml0eV8xJ1xuICB9XG5cbiAgY3JlYXRlSW5maW5pdHlOZWcgKCkge1xuICAgIHJldHVybiAnLUluZmluaXR5XzEnXG4gIH1cblxuICBjcmVhdGVOYU4gKCkge1xuICAgIHJldHVybiAnTmFOXzEnXG4gIH1cblxuICBjcmVhdGVOYU5OZWcgKCkge1xuICAgIHJldHVybiAnLU5hTl8xJ1xuICB9XG5cbiAgY3JlYXRlTnVsbCAoKSB7XG4gICAgcmV0dXJuICdudWxsJ1xuICB9XG5cbiAgY3JlYXRlVW5kZWZpbmVkICgpIHtcbiAgICByZXR1cm4gJ3VuZGVmaW5lZCdcbiAgfVxuXG4gIGNyZWF0ZVNpbXBsZVVuYXNzaWduZWQgKHZhbCkge1xuICAgIHJldHVybiBgc2ltcGxlKCR7dmFsfSlgXG4gIH1cblxuICBjcmVhdGVBcnJheSAoYXJyLCBsZW4pIHtcbiAgICBjb25zdCB2YWwgPSBzdXBlci5jcmVhdGVBcnJheShhcnIsIGxlbilcblxuICAgIGlmIChsZW4gPT09IC0xKSB7XG4gICAgICAvLyBpbmRlZmluaXRlXG4gICAgICByZXR1cm4gYFtfICR7dmFsLmpvaW4oJywgJyl9XWBcbiAgICB9XG5cbiAgICByZXR1cm4gYFske3ZhbC5qb2luKCcsICcpfV1gXG4gIH1cblxuICBjcmVhdGVNYXAgKG1hcCwgbGVuKSB7XG4gICAgY29uc3QgdmFsID0gc3VwZXIuY3JlYXRlTWFwKG1hcClcbiAgICBjb25zdCBsaXN0ID0gQXJyYXkuZnJvbSh2YWwua2V5cygpKVxuICAgICAgLnJlZHVjZShjb2xsZWN0T2JqZWN0KHZhbCksICcnKVxuXG4gICAgaWYgKGxlbiA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBge18gJHtsaXN0fX1gXG4gICAgfVxuXG4gICAgcmV0dXJuIGB7JHtsaXN0fX1gXG4gIH1cblxuICBjcmVhdGVPYmplY3QgKG9iaiwgbGVuKSB7XG4gICAgY29uc3QgdmFsID0gc3VwZXIuY3JlYXRlT2JqZWN0KG9iailcbiAgICBjb25zdCBtYXAgPSBPYmplY3Qua2V5cyh2YWwpXG4gICAgICAucmVkdWNlKGNvbGxlY3RPYmplY3QodmFsKSwgJycpXG5cbiAgICBpZiAobGVuID09PSAtMSkge1xuICAgICAgcmV0dXJuIGB7XyAke21hcH19YFxuICAgIH1cblxuICAgIHJldHVybiBgeyR7bWFwfX1gXG4gIH1cblxuICBjcmVhdGVVdGY4U3RyaW5nIChyYXcsIGxlbikge1xuICAgIGNvbnN0IHZhbCA9IHJhdy5qb2luKCcsICcpXG5cbiAgICBpZiAobGVuID09PSAtMSkge1xuICAgICAgcmV0dXJuIGAoXyAke3ZhbH0pYFxuICAgIH1cblxuICAgIHJldHVybiBgXCIke3ZhbH1cImBcbiAgfVxuXG4gIGNyZWF0ZVV0ZjhTdHJpbmdGcm9tSGVhcCAoc3RhcnQsIGVuZCkge1xuICAgIGNvbnN0IHZhbCA9IChCdWZmZXIuZnJvbShcbiAgICAgIHN1cGVyLmNyZWF0ZVV0ZjhTdHJpbmdGcm9tSGVhcChzdGFydCwgZW5kKVxuICAgICkpLnRvU3RyaW5nKCd1dGY4JylcblxuICAgIHJldHVybiBgXCIke3ZhbH1cImBcbiAgfVxuXG4gIHN0YXRpYyBkaWFnbm9zZSAoaW5wdXQsIGVuYykge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpbnB1dCA9IEJ1ZmZlci5mcm9tKGlucHV0LCBlbmMgfHwgJ2hleCcpXG4gICAgfVxuXG4gICAgY29uc3QgZGVjID0gbmV3IERpYWdub3NlKClcbiAgICByZXR1cm4gZGVjLmRlY29kZUZpcnN0KGlucHV0KVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGlhZ25vc2VcblxuZnVuY3Rpb24gY29sbGVjdE9iamVjdCAodmFsKSB7XG4gIHJldHVybiAoYWNjLCBrZXkpID0+IHtcbiAgICBpZiAoYWNjKSB7XG4gICAgICByZXR1cm4gYCR7YWNjfSwgJHtrZXl9OiAke3ZhbFtrZXldfWBcbiAgICB9XG4gICAgcmV0dXJuIGAke2tleX06ICR7dmFsW2tleV19YFxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/borc/src/diagnose.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/borc/src/encoder.js":
/*!**********************************************!*\
  !*** ../../node_modules/borc/src/encoder.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nconst { Buffer } = __webpack_require__(/*! buffer */ \"(app-pages-browser)/../../node_modules/borc/node_modules/buffer/index.js\")\nconst { URL } = __webpack_require__(/*! iso-url */ \"(app-pages-browser)/../../node_modules/iso-url/index.js\")\nconst Bignumber = (__webpack_require__(/*! bignumber.js */ \"(app-pages-browser)/../../node_modules/bignumber.js/bignumber.js\").BigNumber)\n\nconst utils = __webpack_require__(/*! ./utils */ \"(app-pages-browser)/../../node_modules/borc/src/utils.js\")\nconst constants = __webpack_require__(/*! ./constants */ \"(app-pages-browser)/../../node_modules/borc/src/constants.js\")\nconst MT = constants.MT\nconst NUMBYTES = constants.NUMBYTES\nconst SHIFT32 = constants.SHIFT32\nconst SYMS = constants.SYMS\nconst TAG = constants.TAG\nconst HALF = (constants.MT.SIMPLE_FLOAT << 5) | constants.NUMBYTES.TWO\nconst FLOAT = (constants.MT.SIMPLE_FLOAT << 5) | constants.NUMBYTES.FOUR\nconst DOUBLE = (constants.MT.SIMPLE_FLOAT << 5) | constants.NUMBYTES.EIGHT\nconst TRUE = (constants.MT.SIMPLE_FLOAT << 5) | constants.SIMPLE.TRUE\nconst FALSE = (constants.MT.SIMPLE_FLOAT << 5) | constants.SIMPLE.FALSE\nconst UNDEFINED = (constants.MT.SIMPLE_FLOAT << 5) | constants.SIMPLE.UNDEFINED\nconst NULL = (constants.MT.SIMPLE_FLOAT << 5) | constants.SIMPLE.NULL\n\nconst MAXINT_BN = new Bignumber('0x20000000000000')\nconst BUF_NAN = Buffer.from('f97e00', 'hex')\nconst BUF_INF_NEG = Buffer.from('f9fc00', 'hex')\nconst BUF_INF_POS = Buffer.from('f97c00', 'hex')\n\nfunction toType (obj) {\n  // [object Type]\n  // --------8---1\n  return ({}).toString.call(obj).slice(8, -1)\n}\n\n/**\n * Transform JavaScript values into CBOR bytes\n *\n */\nclass Encoder {\n  /**\n   * @param {Object} [options={}]\n   * @param {function(Buffer)} options.stream\n   */\n  constructor (options) {\n    options = options || {}\n\n    this.streaming = typeof options.stream === 'function'\n    this.onData = options.stream\n\n    this.semanticTypes = [\n      [URL, this._pushUrl],\n      [Bignumber, this._pushBigNumber]\n    ]\n\n    const addTypes = options.genTypes || []\n    const len = addTypes.length\n    for (let i = 0; i < len; i++) {\n      this.addSemanticType(\n        addTypes[i][0],\n        addTypes[i][1]\n      )\n    }\n\n    this._reset()\n  }\n\n  addSemanticType (type, fun) {\n    const len = this.semanticTypes.length\n    for (let i = 0; i < len; i++) {\n      const typ = this.semanticTypes[i][0]\n      if (typ === type) {\n        const old = this.semanticTypes[i][1]\n        this.semanticTypes[i][1] = fun\n        return old\n      }\n    }\n    this.semanticTypes.push([type, fun])\n    return null\n  }\n\n  push (val) {\n    if (!val) {\n      return true\n    }\n\n    this.result[this.offset] = val\n    this.resultMethod[this.offset] = 0\n    this.resultLength[this.offset] = val.length\n    this.offset++\n\n    if (this.streaming) {\n      this.onData(this.finalize())\n    }\n\n    return true\n  }\n\n  pushWrite (val, method, len) {\n    this.result[this.offset] = val\n    this.resultMethod[this.offset] = method\n    this.resultLength[this.offset] = len\n    this.offset++\n\n    if (this.streaming) {\n      this.onData(this.finalize())\n    }\n\n    return true\n  }\n\n  _pushUInt8 (val) {\n    return this.pushWrite(val, 1, 1)\n  }\n\n  _pushUInt16BE (val) {\n    return this.pushWrite(val, 2, 2)\n  }\n\n  _pushUInt32BE (val) {\n    return this.pushWrite(val, 3, 4)\n  }\n\n  _pushDoubleBE (val) {\n    return this.pushWrite(val, 4, 8)\n  }\n\n  _pushNaN () {\n    return this.push(BUF_NAN)\n  }\n\n  _pushInfinity (obj) {\n    const half = (obj < 0) ? BUF_INF_NEG : BUF_INF_POS\n    return this.push(half)\n  }\n\n  _pushFloat (obj) {\n    const b2 = Buffer.allocUnsafe(2)\n\n    if (utils.writeHalf(b2, obj)) {\n      if (utils.parseHalf(b2) === obj) {\n        return this._pushUInt8(HALF) && this.push(b2)\n      }\n    }\n\n    const b4 = Buffer.allocUnsafe(4)\n    b4.writeFloatBE(obj, 0)\n    if (b4.readFloatBE(0) === obj) {\n      return this._pushUInt8(FLOAT) && this.push(b4)\n    }\n\n    return this._pushUInt8(DOUBLE) && this._pushDoubleBE(obj)\n  }\n\n  _pushInt (obj, mt, orig) {\n    const m = mt << 5\n    if (obj < 24) {\n      return this._pushUInt8(m | obj)\n    }\n\n    if (obj <= 0xff) {\n      return this._pushUInt8(m | NUMBYTES.ONE) && this._pushUInt8(obj)\n    }\n\n    if (obj <= 0xffff) {\n      return this._pushUInt8(m | NUMBYTES.TWO) && this._pushUInt16BE(obj)\n    }\n\n    if (obj <= 0xffffffff) {\n      return this._pushUInt8(m | NUMBYTES.FOUR) && this._pushUInt32BE(obj)\n    }\n\n    if (obj <= Number.MAX_SAFE_INTEGER) {\n      return this._pushUInt8(m | NUMBYTES.EIGHT) &&\n        this._pushUInt32BE(Math.floor(obj / SHIFT32)) &&\n        this._pushUInt32BE(obj % SHIFT32)\n    }\n\n    if (mt === MT.NEG_INT) {\n      return this._pushFloat(orig)\n    }\n\n    return this._pushFloat(obj)\n  }\n\n  _pushIntNum (obj) {\n    if (obj < 0) {\n      return this._pushInt(-obj - 1, MT.NEG_INT, obj)\n    } else {\n      return this._pushInt(obj, MT.POS_INT)\n    }\n  }\n\n  _pushNumber (obj) {\n    switch (false) {\n      case (obj === obj): // eslint-disable-line\n        return this._pushNaN(obj)\n      case isFinite(obj):\n        return this._pushInfinity(obj)\n      case ((obj % 1) !== 0):\n        return this._pushIntNum(obj)\n      default:\n        return this._pushFloat(obj)\n    }\n  }\n\n  _pushString (obj) {\n    const len = Buffer.byteLength(obj, 'utf8')\n    return this._pushInt(len, MT.UTF8_STRING) && this.pushWrite(obj, 5, len)\n  }\n\n  _pushBoolean (obj) {\n    return this._pushUInt8(obj ? TRUE : FALSE)\n  }\n\n  _pushUndefined (obj) {\n    return this._pushUInt8(UNDEFINED)\n  }\n\n  _pushArray (gen, obj) {\n    const len = obj.length\n    if (!gen._pushInt(len, MT.ARRAY)) {\n      return false\n    }\n    for (let j = 0; j < len; j++) {\n      if (!gen.pushAny(obj[j])) {\n        return false\n      }\n    }\n    return true\n  }\n\n  _pushTag (tag) {\n    return this._pushInt(tag, MT.TAG)\n  }\n\n  _pushDate (gen, obj) {\n    // Round date, to get seconds since 1970-01-01 00:00:00 as defined in\n    // Sec. 2.4.1 and get a possibly more compact encoding. Note that it is\n    // still allowed to encode fractions of seconds which can be achieved by\n    // changing overwriting the encode function for Date objects.\n    return gen._pushTag(TAG.DATE_EPOCH) && gen.pushAny(Math.round(obj / 1000))\n  }\n\n  _pushBuffer (gen, obj) {\n    return gen._pushInt(obj.length, MT.BYTE_STRING) && gen.push(obj)\n  }\n\n  _pushNoFilter (gen, obj) {\n    return gen._pushBuffer(gen, obj.slice())\n  }\n\n  _pushRegexp (gen, obj) {\n    return gen._pushTag(TAG.REGEXP) && gen.pushAny(obj.source)\n  }\n\n  _pushSet (gen, obj) {\n    if (!gen._pushInt(obj.size, MT.ARRAY)) {\n      return false\n    }\n    for (const x of obj) {\n      if (!gen.pushAny(x)) {\n        return false\n      }\n    }\n    return true\n  }\n\n  _pushUrl (gen, obj) {\n    return gen._pushTag(TAG.URI) && gen.pushAny(obj.format())\n  }\n\n  _pushBigint (obj) {\n    let tag = TAG.POS_BIGINT\n    if (obj.isNegative()) {\n      obj = obj.negated().minus(1)\n      tag = TAG.NEG_BIGINT\n    }\n    let str = obj.toString(16)\n    if (str.length % 2) {\n      str = '0' + str\n    }\n    const buf = Buffer.from(str, 'hex')\n    return this._pushTag(tag) && this._pushBuffer(this, buf)\n  }\n\n  _pushBigNumber (gen, obj) {\n    if (obj.isNaN()) {\n      return gen._pushNaN()\n    }\n    if (!obj.isFinite()) {\n      return gen._pushInfinity(obj.isNegative() ? -Infinity : Infinity)\n    }\n    if (obj.isInteger()) {\n      return gen._pushBigint(obj)\n    }\n    if (!(gen._pushTag(TAG.DECIMAL_FRAC) &&\n      gen._pushInt(2, MT.ARRAY))) {\n      return false\n    }\n\n    const dec = obj.decimalPlaces()\n    const slide = obj.multipliedBy(new Bignumber(10).pow(dec))\n    if (!gen._pushIntNum(-dec)) {\n      return false\n    }\n    if (slide.abs().isLessThan(MAXINT_BN)) {\n      return gen._pushIntNum(slide.toNumber())\n    } else {\n      return gen._pushBigint(slide)\n    }\n  }\n\n  _pushMap (gen, obj) {\n    if (!gen._pushInt(obj.size, MT.MAP)) {\n      return false\n    }\n\n    return this._pushRawMap(\n      obj.size,\n      Array.from(obj)\n    )\n  }\n\n  _pushObject (obj) {\n    if (!obj) {\n      return this._pushUInt8(NULL)\n    }\n\n    var len = this.semanticTypes.length\n    for (var i = 0; i < len; i++) {\n      if (obj instanceof this.semanticTypes[i][0]) {\n        return this.semanticTypes[i][1].call(obj, this, obj)\n      }\n    }\n\n    var f = obj.encodeCBOR\n    if (typeof f === 'function') {\n      return f.call(obj, this)\n    }\n\n    var keys = Object.keys(obj)\n    var keyLength = keys.length\n    if (!this._pushInt(keyLength, MT.MAP)) {\n      return false\n    }\n\n    return this._pushRawMap(\n      keyLength,\n      keys.map((k) => [k, obj[k]])\n    )\n  }\n\n  _pushRawMap (len, map) {\n    // Sort keys for canoncialization\n    // 1. encode key\n    // 2. shorter key comes before longer key\n    // 3. same length keys are sorted with lower\n    //    byte value before higher\n\n    map = map.map(function (a) {\n      a[0] = Encoder.encode(a[0])\n      return a\n    }).sort(utils.keySorter)\n\n    for (var j = 0; j < len; j++) {\n      if (!this.push(map[j][0])) {\n        return false\n      }\n\n      if (!this.pushAny(map[j][1])) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * Alias for `.pushAny`\n   *\n   * @param {*} obj\n   * @returns {boolean} true on success\n   */\n  write (obj) {\n    return this.pushAny(obj)\n  }\n\n  /**\n   * Push any supported type onto the encoded stream\n   *\n   * @param {any} obj\n   * @returns {boolean} true on success\n   */\n  pushAny (obj) {\n    var typ = toType(obj)\n\n    switch (typ) {\n      case 'Number':\n        return this._pushNumber(obj)\n      case 'String':\n        return this._pushString(obj)\n      case 'Boolean':\n        return this._pushBoolean(obj)\n      case 'Object':\n        return this._pushObject(obj)\n      case 'Array':\n        return this._pushArray(this, obj)\n      case 'Uint8Array':\n        return this._pushBuffer(this, Buffer.isBuffer(obj) ? obj : Buffer.from(obj))\n      case 'Null':\n        return this._pushUInt8(NULL)\n      case 'Undefined':\n        return this._pushUndefined(obj)\n      case 'Map':\n        return this._pushMap(this, obj)\n      case 'Set':\n        return this._pushSet(this, obj)\n      case 'URL':\n        return this._pushUrl(this, obj)\n      case 'BigNumber':\n        return this._pushBigNumber(this, obj)\n      case 'Date':\n        return this._pushDate(this, obj)\n      case 'RegExp':\n        return this._pushRegexp(this, obj)\n      case 'Symbol':\n        switch (obj) {\n          case SYMS.NULL:\n            return this._pushObject(null)\n          case SYMS.UNDEFINED:\n            return this._pushUndefined(undefined)\n          // TODO: Add pluggable support for other symbols\n          default:\n            throw new Error('Unknown symbol: ' + obj.toString())\n        }\n      default:\n        throw new Error('Unknown type: ' + typeof obj + ', ' + (obj ? obj.toString() : ''))\n    }\n  }\n\n  finalize () {\n    if (this.offset === 0) {\n      return null\n    }\n\n    var result = this.result\n    var resultLength = this.resultLength\n    var resultMethod = this.resultMethod\n    var offset = this.offset\n\n    // Determine the size of the buffer\n    var size = 0\n    var i = 0\n\n    for (; i < offset; i++) {\n      size += resultLength[i]\n    }\n\n    var res = Buffer.allocUnsafe(size)\n    var index = 0\n    var length = 0\n\n    // Write the content into the result buffer\n    for (i = 0; i < offset; i++) {\n      length = resultLength[i]\n\n      switch (resultMethod[i]) {\n        case 0:\n          result[i].copy(res, index)\n          break\n        case 1:\n          res.writeUInt8(result[i], index, true)\n          break\n        case 2:\n          res.writeUInt16BE(result[i], index, true)\n          break\n        case 3:\n          res.writeUInt32BE(result[i], index, true)\n          break\n        case 4:\n          res.writeDoubleBE(result[i], index, true)\n          break\n        case 5:\n          res.write(result[i], index, length, 'utf8')\n          break\n        default:\n          throw new Error('unkown method')\n      }\n\n      index += length\n    }\n\n    var tmp = res\n\n    this._reset()\n\n    return tmp\n  }\n\n  _reset () {\n    this.result = []\n    this.resultMethod = []\n    this.resultLength = []\n    this.offset = 0\n  }\n\n  /**\n   * Encode the given value\n   * @param {*} o\n   * @returns {Buffer}\n   */\n  static encode (o) {\n    const enc = new Encoder()\n    const ret = enc.pushAny(o)\n    if (!ret) {\n      throw new Error('Failed to encode input')\n    }\n\n    return enc.finalize()\n  }\n}\n\nmodule.exports = Encoder\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYm9yYy9zcmMvZW5jb2Rlci5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHdGQUFRO0FBQ25DLFFBQVEsTUFBTSxFQUFFLG1CQUFPLENBQUMsd0VBQVM7QUFDakMsa0JBQWtCLHVIQUFpQzs7QUFFbkQsY0FBYyxtQkFBTyxDQUFDLHlFQUFTO0FBQy9CLGtCQUFrQixtQkFBTyxDQUFDLGlGQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRLFdBQVc7QUFDaEMsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEdBQUc7QUFDaEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLEdBQUc7QUFDaEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL2JvcmMvc3JjL2VuY29kZXIuanM/ODBkYyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5jb25zdCB7IFVSTCB9ID0gcmVxdWlyZSgnaXNvLXVybCcpXG5jb25zdCBCaWdudW1iZXIgPSByZXF1aXJlKCdiaWdudW1iZXIuanMnKS5CaWdOdW1iZXJcblxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJylcbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IE1UID0gY29uc3RhbnRzLk1UXG5jb25zdCBOVU1CWVRFUyA9IGNvbnN0YW50cy5OVU1CWVRFU1xuY29uc3QgU0hJRlQzMiA9IGNvbnN0YW50cy5TSElGVDMyXG5jb25zdCBTWU1TID0gY29uc3RhbnRzLlNZTVNcbmNvbnN0IFRBRyA9IGNvbnN0YW50cy5UQUdcbmNvbnN0IEhBTEYgPSAoY29uc3RhbnRzLk1ULlNJTVBMRV9GTE9BVCA8PCA1KSB8IGNvbnN0YW50cy5OVU1CWVRFUy5UV09cbmNvbnN0IEZMT0FUID0gKGNvbnN0YW50cy5NVC5TSU1QTEVfRkxPQVQgPDwgNSkgfCBjb25zdGFudHMuTlVNQllURVMuRk9VUlxuY29uc3QgRE9VQkxFID0gKGNvbnN0YW50cy5NVC5TSU1QTEVfRkxPQVQgPDwgNSkgfCBjb25zdGFudHMuTlVNQllURVMuRUlHSFRcbmNvbnN0IFRSVUUgPSAoY29uc3RhbnRzLk1ULlNJTVBMRV9GTE9BVCA8PCA1KSB8IGNvbnN0YW50cy5TSU1QTEUuVFJVRVxuY29uc3QgRkFMU0UgPSAoY29uc3RhbnRzLk1ULlNJTVBMRV9GTE9BVCA8PCA1KSB8IGNvbnN0YW50cy5TSU1QTEUuRkFMU0VcbmNvbnN0IFVOREVGSU5FRCA9IChjb25zdGFudHMuTVQuU0lNUExFX0ZMT0FUIDw8IDUpIHwgY29uc3RhbnRzLlNJTVBMRS5VTkRFRklORURcbmNvbnN0IE5VTEwgPSAoY29uc3RhbnRzLk1ULlNJTVBMRV9GTE9BVCA8PCA1KSB8IGNvbnN0YW50cy5TSU1QTEUuTlVMTFxuXG5jb25zdCBNQVhJTlRfQk4gPSBuZXcgQmlnbnVtYmVyKCcweDIwMDAwMDAwMDAwMDAwJylcbmNvbnN0IEJVRl9OQU4gPSBCdWZmZXIuZnJvbSgnZjk3ZTAwJywgJ2hleCcpXG5jb25zdCBCVUZfSU5GX05FRyA9IEJ1ZmZlci5mcm9tKCdmOWZjMDAnLCAnaGV4JylcbmNvbnN0IEJVRl9JTkZfUE9TID0gQnVmZmVyLmZyb20oJ2Y5N2MwMCcsICdoZXgnKVxuXG5mdW5jdGlvbiB0b1R5cGUgKG9iaikge1xuICAvLyBbb2JqZWN0IFR5cGVdXG4gIC8vIC0tLS0tLS0tOC0tLTFcbiAgcmV0dXJuICh7fSkudG9TdHJpbmcuY2FsbChvYmopLnNsaWNlKDgsIC0xKVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBKYXZhU2NyaXB0IHZhbHVlcyBpbnRvIENCT1IgYnl0ZXNcbiAqXG4gKi9cbmNsYXNzIEVuY29kZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEJ1ZmZlcil9IG9wdGlvbnMuc3RyZWFtXG4gICAqL1xuICBjb25zdHJ1Y3RvciAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgICB0aGlzLnN0cmVhbWluZyA9IHR5cGVvZiBvcHRpb25zLnN0cmVhbSA9PT0gJ2Z1bmN0aW9uJ1xuICAgIHRoaXMub25EYXRhID0gb3B0aW9ucy5zdHJlYW1cblxuICAgIHRoaXMuc2VtYW50aWNUeXBlcyA9IFtcbiAgICAgIFtVUkwsIHRoaXMuX3B1c2hVcmxdLFxuICAgICAgW0JpZ251bWJlciwgdGhpcy5fcHVzaEJpZ051bWJlcl1cbiAgICBdXG5cbiAgICBjb25zdCBhZGRUeXBlcyA9IG9wdGlvbnMuZ2VuVHlwZXMgfHwgW11cbiAgICBjb25zdCBsZW4gPSBhZGRUeXBlcy5sZW5ndGhcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0aGlzLmFkZFNlbWFudGljVHlwZShcbiAgICAgICAgYWRkVHlwZXNbaV1bMF0sXG4gICAgICAgIGFkZFR5cGVzW2ldWzFdXG4gICAgICApXG4gICAgfVxuXG4gICAgdGhpcy5fcmVzZXQoKVxuICB9XG5cbiAgYWRkU2VtYW50aWNUeXBlICh0eXBlLCBmdW4pIHtcbiAgICBjb25zdCBsZW4gPSB0aGlzLnNlbWFudGljVHlwZXMubGVuZ3RoXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgdHlwID0gdGhpcy5zZW1hbnRpY1R5cGVzW2ldWzBdXG4gICAgICBpZiAodHlwID09PSB0eXBlKSB7XG4gICAgICAgIGNvbnN0IG9sZCA9IHRoaXMuc2VtYW50aWNUeXBlc1tpXVsxXVxuICAgICAgICB0aGlzLnNlbWFudGljVHlwZXNbaV1bMV0gPSBmdW5cbiAgICAgICAgcmV0dXJuIG9sZFxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNlbWFudGljVHlwZXMucHVzaChbdHlwZSwgZnVuXSlcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgcHVzaCAodmFsKSB7XG4gICAgaWYgKCF2YWwpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgdGhpcy5yZXN1bHRbdGhpcy5vZmZzZXRdID0gdmFsXG4gICAgdGhpcy5yZXN1bHRNZXRob2RbdGhpcy5vZmZzZXRdID0gMFxuICAgIHRoaXMucmVzdWx0TGVuZ3RoW3RoaXMub2Zmc2V0XSA9IHZhbC5sZW5ndGhcbiAgICB0aGlzLm9mZnNldCsrXG5cbiAgICBpZiAodGhpcy5zdHJlYW1pbmcpIHtcbiAgICAgIHRoaXMub25EYXRhKHRoaXMuZmluYWxpemUoKSlcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcHVzaFdyaXRlICh2YWwsIG1ldGhvZCwgbGVuKSB7XG4gICAgdGhpcy5yZXN1bHRbdGhpcy5vZmZzZXRdID0gdmFsXG4gICAgdGhpcy5yZXN1bHRNZXRob2RbdGhpcy5vZmZzZXRdID0gbWV0aG9kXG4gICAgdGhpcy5yZXN1bHRMZW5ndGhbdGhpcy5vZmZzZXRdID0gbGVuXG4gICAgdGhpcy5vZmZzZXQrK1xuXG4gICAgaWYgKHRoaXMuc3RyZWFtaW5nKSB7XG4gICAgICB0aGlzLm9uRGF0YSh0aGlzLmZpbmFsaXplKCkpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIF9wdXNoVUludDggKHZhbCkge1xuICAgIHJldHVybiB0aGlzLnB1c2hXcml0ZSh2YWwsIDEsIDEpXG4gIH1cblxuICBfcHVzaFVJbnQxNkJFICh2YWwpIHtcbiAgICByZXR1cm4gdGhpcy5wdXNoV3JpdGUodmFsLCAyLCAyKVxuICB9XG5cbiAgX3B1c2hVSW50MzJCRSAodmFsKSB7XG4gICAgcmV0dXJuIHRoaXMucHVzaFdyaXRlKHZhbCwgMywgNClcbiAgfVxuXG4gIF9wdXNoRG91YmxlQkUgKHZhbCkge1xuICAgIHJldHVybiB0aGlzLnB1c2hXcml0ZSh2YWwsIDQsIDgpXG4gIH1cblxuICBfcHVzaE5hTiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucHVzaChCVUZfTkFOKVxuICB9XG5cbiAgX3B1c2hJbmZpbml0eSAob2JqKSB7XG4gICAgY29uc3QgaGFsZiA9IChvYmogPCAwKSA/IEJVRl9JTkZfTkVHIDogQlVGX0lORl9QT1NcbiAgICByZXR1cm4gdGhpcy5wdXNoKGhhbGYpXG4gIH1cblxuICBfcHVzaEZsb2F0IChvYmopIHtcbiAgICBjb25zdCBiMiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyKVxuXG4gICAgaWYgKHV0aWxzLndyaXRlSGFsZihiMiwgb2JqKSkge1xuICAgICAgaWYgKHV0aWxzLnBhcnNlSGFsZihiMikgPT09IG9iaikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaFVJbnQ4KEhBTEYpICYmIHRoaXMucHVzaChiMilcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBiNCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg0KVxuICAgIGI0LndyaXRlRmxvYXRCRShvYmosIDApXG4gICAgaWYgKGI0LnJlYWRGbG9hdEJFKDApID09PSBvYmopIHtcbiAgICAgIHJldHVybiB0aGlzLl9wdXNoVUludDgoRkxPQVQpICYmIHRoaXMucHVzaChiNClcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcHVzaFVJbnQ4KERPVUJMRSkgJiYgdGhpcy5fcHVzaERvdWJsZUJFKG9iailcbiAgfVxuXG4gIF9wdXNoSW50IChvYmosIG10LCBvcmlnKSB7XG4gICAgY29uc3QgbSA9IG10IDw8IDVcbiAgICBpZiAob2JqIDwgMjQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wdXNoVUludDgobSB8IG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqIDw9IDB4ZmYpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wdXNoVUludDgobSB8IE5VTUJZVEVTLk9ORSkgJiYgdGhpcy5fcHVzaFVJbnQ4KG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqIDw9IDB4ZmZmZikge1xuICAgICAgcmV0dXJuIHRoaXMuX3B1c2hVSW50OChtIHwgTlVNQllURVMuVFdPKSAmJiB0aGlzLl9wdXNoVUludDE2QkUob2JqKVxuICAgIH1cblxuICAgIGlmIChvYmogPD0gMHhmZmZmZmZmZikge1xuICAgICAgcmV0dXJuIHRoaXMuX3B1c2hVSW50OChtIHwgTlVNQllURVMuRk9VUikgJiYgdGhpcy5fcHVzaFVJbnQzMkJFKG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqIDw9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHVzaFVJbnQ4KG0gfCBOVU1CWVRFUy5FSUdIVCkgJiZcbiAgICAgICAgdGhpcy5fcHVzaFVJbnQzMkJFKE1hdGguZmxvb3Iob2JqIC8gU0hJRlQzMikpICYmXG4gICAgICAgIHRoaXMuX3B1c2hVSW50MzJCRShvYmogJSBTSElGVDMyKVxuICAgIH1cblxuICAgIGlmIChtdCA9PT0gTVQuTkVHX0lOVCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3B1c2hGbG9hdChvcmlnKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9wdXNoRmxvYXQob2JqKVxuICB9XG5cbiAgX3B1c2hJbnROdW0gKG9iaikge1xuICAgIGlmIChvYmogPCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHVzaEludCgtb2JqIC0gMSwgTVQuTkVHX0lOVCwgb2JqKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHVzaEludChvYmosIE1ULlBPU19JTlQpXG4gICAgfVxuICB9XG5cbiAgX3B1c2hOdW1iZXIgKG9iaikge1xuICAgIHN3aXRjaCAoZmFsc2UpIHtcbiAgICAgIGNhc2UgKG9iaiA9PT0gb2JqKTogLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaE5hTihvYmopXG4gICAgICBjYXNlIGlzRmluaXRlKG9iaik6XG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoSW5maW5pdHkob2JqKVxuICAgICAgY2FzZSAoKG9iaiAlIDEpICE9PSAwKTpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hJbnROdW0ob2JqKVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hGbG9hdChvYmopXG4gICAgfVxuICB9XG5cbiAgX3B1c2hTdHJpbmcgKG9iaikge1xuICAgIGNvbnN0IGxlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKG9iaiwgJ3V0ZjgnKVxuICAgIHJldHVybiB0aGlzLl9wdXNoSW50KGxlbiwgTVQuVVRGOF9TVFJJTkcpICYmIHRoaXMucHVzaFdyaXRlKG9iaiwgNSwgbGVuKVxuICB9XG5cbiAgX3B1c2hCb29sZWFuIChvYmopIHtcbiAgICByZXR1cm4gdGhpcy5fcHVzaFVJbnQ4KG9iaiA/IFRSVUUgOiBGQUxTRSlcbiAgfVxuXG4gIF9wdXNoVW5kZWZpbmVkIChvYmopIHtcbiAgICByZXR1cm4gdGhpcy5fcHVzaFVJbnQ4KFVOREVGSU5FRClcbiAgfVxuXG4gIF9wdXNoQXJyYXkgKGdlbiwgb2JqKSB7XG4gICAgY29uc3QgbGVuID0gb2JqLmxlbmd0aFxuICAgIGlmICghZ2VuLl9wdXNoSW50KGxlbiwgTVQuQVJSQVkpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBsZW47IGorKykge1xuICAgICAgaWYgKCFnZW4ucHVzaEFueShvYmpbal0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgX3B1c2hUYWcgKHRhZykge1xuICAgIHJldHVybiB0aGlzLl9wdXNoSW50KHRhZywgTVQuVEFHKVxuICB9XG5cbiAgX3B1c2hEYXRlIChnZW4sIG9iaikge1xuICAgIC8vIFJvdW5kIGRhdGUsIHRvIGdldCBzZWNvbmRzIHNpbmNlIDE5NzAtMDEtMDEgMDA6MDA6MDAgYXMgZGVmaW5lZCBpblxuICAgIC8vIFNlYy4gMi40LjEgYW5kIGdldCBhIHBvc3NpYmx5IG1vcmUgY29tcGFjdCBlbmNvZGluZy4gTm90ZSB0aGF0IGl0IGlzXG4gICAgLy8gc3RpbGwgYWxsb3dlZCB0byBlbmNvZGUgZnJhY3Rpb25zIG9mIHNlY29uZHMgd2hpY2ggY2FuIGJlIGFjaGlldmVkIGJ5XG4gICAgLy8gY2hhbmdpbmcgb3ZlcndyaXRpbmcgdGhlIGVuY29kZSBmdW5jdGlvbiBmb3IgRGF0ZSBvYmplY3RzLlxuICAgIHJldHVybiBnZW4uX3B1c2hUYWcoVEFHLkRBVEVfRVBPQ0gpICYmIGdlbi5wdXNoQW55KE1hdGgucm91bmQob2JqIC8gMTAwMCkpXG4gIH1cblxuICBfcHVzaEJ1ZmZlciAoZ2VuLCBvYmopIHtcbiAgICByZXR1cm4gZ2VuLl9wdXNoSW50KG9iai5sZW5ndGgsIE1ULkJZVEVfU1RSSU5HKSAmJiBnZW4ucHVzaChvYmopXG4gIH1cblxuICBfcHVzaE5vRmlsdGVyIChnZW4sIG9iaikge1xuICAgIHJldHVybiBnZW4uX3B1c2hCdWZmZXIoZ2VuLCBvYmouc2xpY2UoKSlcbiAgfVxuXG4gIF9wdXNoUmVnZXhwIChnZW4sIG9iaikge1xuICAgIHJldHVybiBnZW4uX3B1c2hUYWcoVEFHLlJFR0VYUCkgJiYgZ2VuLnB1c2hBbnkob2JqLnNvdXJjZSlcbiAgfVxuXG4gIF9wdXNoU2V0IChnZW4sIG9iaikge1xuICAgIGlmICghZ2VuLl9wdXNoSW50KG9iai5zaXplLCBNVC5BUlJBWSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IHggb2Ygb2JqKSB7XG4gICAgICBpZiAoIWdlbi5wdXNoQW55KHgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgX3B1c2hVcmwgKGdlbiwgb2JqKSB7XG4gICAgcmV0dXJuIGdlbi5fcHVzaFRhZyhUQUcuVVJJKSAmJiBnZW4ucHVzaEFueShvYmouZm9ybWF0KCkpXG4gIH1cblxuICBfcHVzaEJpZ2ludCAob2JqKSB7XG4gICAgbGV0IHRhZyA9IFRBRy5QT1NfQklHSU5UXG4gICAgaWYgKG9iai5pc05lZ2F0aXZlKCkpIHtcbiAgICAgIG9iaiA9IG9iai5uZWdhdGVkKCkubWludXMoMSlcbiAgICAgIHRhZyA9IFRBRy5ORUdfQklHSU5UXG4gICAgfVxuICAgIGxldCBzdHIgPSBvYmoudG9TdHJpbmcoMTYpXG4gICAgaWYgKHN0ci5sZW5ndGggJSAyKSB7XG4gICAgICBzdHIgPSAnMCcgKyBzdHJcbiAgICB9XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmZyb20oc3RyLCAnaGV4JylcbiAgICByZXR1cm4gdGhpcy5fcHVzaFRhZyh0YWcpICYmIHRoaXMuX3B1c2hCdWZmZXIodGhpcywgYnVmKVxuICB9XG5cbiAgX3B1c2hCaWdOdW1iZXIgKGdlbiwgb2JqKSB7XG4gICAgaWYgKG9iai5pc05hTigpKSB7XG4gICAgICByZXR1cm4gZ2VuLl9wdXNoTmFOKClcbiAgICB9XG4gICAgaWYgKCFvYmouaXNGaW5pdGUoKSkge1xuICAgICAgcmV0dXJuIGdlbi5fcHVzaEluZmluaXR5KG9iai5pc05lZ2F0aXZlKCkgPyAtSW5maW5pdHkgOiBJbmZpbml0eSlcbiAgICB9XG4gICAgaWYgKG9iai5pc0ludGVnZXIoKSkge1xuICAgICAgcmV0dXJuIGdlbi5fcHVzaEJpZ2ludChvYmopXG4gICAgfVxuICAgIGlmICghKGdlbi5fcHVzaFRhZyhUQUcuREVDSU1BTF9GUkFDKSAmJlxuICAgICAgZ2VuLl9wdXNoSW50KDIsIE1ULkFSUkFZKSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGNvbnN0IGRlYyA9IG9iai5kZWNpbWFsUGxhY2VzKClcbiAgICBjb25zdCBzbGlkZSA9IG9iai5tdWx0aXBsaWVkQnkobmV3IEJpZ251bWJlcigxMCkucG93KGRlYykpXG4gICAgaWYgKCFnZW4uX3B1c2hJbnROdW0oLWRlYykpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAoc2xpZGUuYWJzKCkuaXNMZXNzVGhhbihNQVhJTlRfQk4pKSB7XG4gICAgICByZXR1cm4gZ2VuLl9wdXNoSW50TnVtKHNsaWRlLnRvTnVtYmVyKCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnZW4uX3B1c2hCaWdpbnQoc2xpZGUpXG4gICAgfVxuICB9XG5cbiAgX3B1c2hNYXAgKGdlbiwgb2JqKSB7XG4gICAgaWYgKCFnZW4uX3B1c2hJbnQob2JqLnNpemUsIE1ULk1BUCkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9wdXNoUmF3TWFwKFxuICAgICAgb2JqLnNpemUsXG4gICAgICBBcnJheS5mcm9tKG9iailcbiAgICApXG4gIH1cblxuICBfcHVzaE9iamVjdCAob2JqKSB7XG4gICAgaWYgKCFvYmopIHtcbiAgICAgIHJldHVybiB0aGlzLl9wdXNoVUludDgoTlVMTClcbiAgICB9XG5cbiAgICB2YXIgbGVuID0gdGhpcy5zZW1hbnRpY1R5cGVzLmxlbmd0aFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChvYmogaW5zdGFuY2VvZiB0aGlzLnNlbWFudGljVHlwZXNbaV1bMF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VtYW50aWNUeXBlc1tpXVsxXS5jYWxsKG9iaiwgdGhpcywgb2JqKVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmID0gb2JqLmVuY29kZUNCT1JcbiAgICBpZiAodHlwZW9mIGYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBmLmNhbGwob2JqLCB0aGlzKVxuICAgIH1cblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKVxuICAgIHZhciBrZXlMZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgIGlmICghdGhpcy5fcHVzaEludChrZXlMZW5ndGgsIE1ULk1BUCkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9wdXNoUmF3TWFwKFxuICAgICAga2V5TGVuZ3RoLFxuICAgICAga2V5cy5tYXAoKGspID0+IFtrLCBvYmpba11dKVxuICAgIClcbiAgfVxuXG4gIF9wdXNoUmF3TWFwIChsZW4sIG1hcCkge1xuICAgIC8vIFNvcnQga2V5cyBmb3IgY2Fub25jaWFsaXphdGlvblxuICAgIC8vIDEuIGVuY29kZSBrZXlcbiAgICAvLyAyLiBzaG9ydGVyIGtleSBjb21lcyBiZWZvcmUgbG9uZ2VyIGtleVxuICAgIC8vIDMuIHNhbWUgbGVuZ3RoIGtleXMgYXJlIHNvcnRlZCB3aXRoIGxvd2VyXG4gICAgLy8gICAgYnl0ZSB2YWx1ZSBiZWZvcmUgaGlnaGVyXG5cbiAgICBtYXAgPSBtYXAubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgICBhWzBdID0gRW5jb2Rlci5lbmNvZGUoYVswXSlcbiAgICAgIHJldHVybiBhXG4gICAgfSkuc29ydCh1dGlscy5rZXlTb3J0ZXIpXG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICBpZiAoIXRoaXMucHVzaChtYXBbal1bMF0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMucHVzaEFueShtYXBbal1bMV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQWxpYXMgZm9yIGAucHVzaEFueWBcbiAgICpcbiAgICogQHBhcmFtIHsqfSBvYmpcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgb24gc3VjY2Vzc1xuICAgKi9cbiAgd3JpdGUgKG9iaikge1xuICAgIHJldHVybiB0aGlzLnB1c2hBbnkob2JqKVxuICB9XG5cbiAgLyoqXG4gICAqIFB1c2ggYW55IHN1cHBvcnRlZCB0eXBlIG9udG8gdGhlIGVuY29kZWQgc3RyZWFtXG4gICAqXG4gICAqIEBwYXJhbSB7YW55fSBvYmpcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgb24gc3VjY2Vzc1xuICAgKi9cbiAgcHVzaEFueSAob2JqKSB7XG4gICAgdmFyIHR5cCA9IHRvVHlwZShvYmopXG5cbiAgICBzd2l0Y2ggKHR5cCkge1xuICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hOdW1iZXIob2JqKVxuICAgICAgY2FzZSAnU3RyaW5nJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hTdHJpbmcob2JqKVxuICAgICAgY2FzZSAnQm9vbGVhbic6XG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoQm9vbGVhbihvYmopXG4gICAgICBjYXNlICdPYmplY3QnOlxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaE9iamVjdChvYmopXG4gICAgICBjYXNlICdBcnJheSc6XG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoQXJyYXkodGhpcywgb2JqKVxuICAgICAgY2FzZSAnVWludDhBcnJheSc6XG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoQnVmZmVyKHRoaXMsIEJ1ZmZlci5pc0J1ZmZlcihvYmopID8gb2JqIDogQnVmZmVyLmZyb20ob2JqKSlcbiAgICAgIGNhc2UgJ051bGwnOlxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaFVJbnQ4KE5VTEwpXG4gICAgICBjYXNlICdVbmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaFVuZGVmaW5lZChvYmopXG4gICAgICBjYXNlICdNYXAnOlxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaE1hcCh0aGlzLCBvYmopXG4gICAgICBjYXNlICdTZXQnOlxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaFNldCh0aGlzLCBvYmopXG4gICAgICBjYXNlICdVUkwnOlxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaFVybCh0aGlzLCBvYmopXG4gICAgICBjYXNlICdCaWdOdW1iZXInOlxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaEJpZ051bWJlcih0aGlzLCBvYmopXG4gICAgICBjYXNlICdEYXRlJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hEYXRlKHRoaXMsIG9iailcbiAgICAgIGNhc2UgJ1JlZ0V4cCc6XG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoUmVnZXhwKHRoaXMsIG9iailcbiAgICAgIGNhc2UgJ1N5bWJvbCc6XG4gICAgICAgIHN3aXRjaCAob2JqKSB7XG4gICAgICAgICAgY2FzZSBTWU1TLk5VTEw6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHVzaE9iamVjdChudWxsKVxuICAgICAgICAgIGNhc2UgU1lNUy5VTkRFRklORUQ6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHVzaFVuZGVmaW5lZCh1bmRlZmluZWQpXG4gICAgICAgICAgLy8gVE9ETzogQWRkIHBsdWdnYWJsZSBzdXBwb3J0IGZvciBvdGhlciBzeW1ib2xzXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBzeW1ib2w6ICcgKyBvYmoudG9TdHJpbmcoKSlcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGU6ICcgKyB0eXBlb2Ygb2JqICsgJywgJyArIChvYmogPyBvYmoudG9TdHJpbmcoKSA6ICcnKSlcbiAgICB9XG4gIH1cblxuICBmaW5hbGl6ZSAoKSB7XG4gICAgaWYgKHRoaXMub2Zmc2V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSB0aGlzLnJlc3VsdFxuICAgIHZhciByZXN1bHRMZW5ndGggPSB0aGlzLnJlc3VsdExlbmd0aFxuICAgIHZhciByZXN1bHRNZXRob2QgPSB0aGlzLnJlc3VsdE1ldGhvZFxuICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldFxuXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBzaXplIG9mIHRoZSBidWZmZXJcbiAgICB2YXIgc2l6ZSA9IDBcbiAgICB2YXIgaSA9IDBcblxuICAgIGZvciAoOyBpIDwgb2Zmc2V0OyBpKyspIHtcbiAgICAgIHNpemUgKz0gcmVzdWx0TGVuZ3RoW2ldXG4gICAgfVxuXG4gICAgdmFyIHJlcyA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShzaXplKVxuICAgIHZhciBpbmRleCA9IDBcbiAgICB2YXIgbGVuZ3RoID0gMFxuXG4gICAgLy8gV3JpdGUgdGhlIGNvbnRlbnQgaW50byB0aGUgcmVzdWx0IGJ1ZmZlclxuICAgIGZvciAoaSA9IDA7IGkgPCBvZmZzZXQ7IGkrKykge1xuICAgICAgbGVuZ3RoID0gcmVzdWx0TGVuZ3RoW2ldXG5cbiAgICAgIHN3aXRjaCAocmVzdWx0TWV0aG9kW2ldKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXN1bHRbaV0uY29weShyZXMsIGluZGV4KVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXMud3JpdGVVSW50OChyZXN1bHRbaV0sIGluZGV4LCB0cnVlKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICByZXMud3JpdGVVSW50MTZCRShyZXN1bHRbaV0sIGluZGV4LCB0cnVlKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICByZXMud3JpdGVVSW50MzJCRShyZXN1bHRbaV0sIGluZGV4LCB0cnVlKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICByZXMud3JpdGVEb3VibGVCRShyZXN1bHRbaV0sIGluZGV4LCB0cnVlKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZXMud3JpdGUocmVzdWx0W2ldLCBpbmRleCwgbGVuZ3RoLCAndXRmOCcpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua293biBtZXRob2QnKVxuICAgICAgfVxuXG4gICAgICBpbmRleCArPSBsZW5ndGhcbiAgICB9XG5cbiAgICB2YXIgdG1wID0gcmVzXG5cbiAgICB0aGlzLl9yZXNldCgpXG5cbiAgICByZXR1cm4gdG1wXG4gIH1cblxuICBfcmVzZXQgKCkge1xuICAgIHRoaXMucmVzdWx0ID0gW11cbiAgICB0aGlzLnJlc3VsdE1ldGhvZCA9IFtdXG4gICAgdGhpcy5yZXN1bHRMZW5ndGggPSBbXVxuICAgIHRoaXMub2Zmc2V0ID0gMFxuICB9XG5cbiAgLyoqXG4gICAqIEVuY29kZSB0aGUgZ2l2ZW4gdmFsdWVcbiAgICogQHBhcmFtIHsqfSBvXG4gICAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gICAqL1xuICBzdGF0aWMgZW5jb2RlIChvKSB7XG4gICAgY29uc3QgZW5jID0gbmV3IEVuY29kZXIoKVxuICAgIGNvbnN0IHJldCA9IGVuYy5wdXNoQW55KG8pXG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGVuY29kZSBpbnB1dCcpXG4gICAgfVxuXG4gICAgcmV0dXJuIGVuYy5maW5hbGl6ZSgpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFbmNvZGVyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/borc/src/encoder.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/borc/src/index.js":
/*!********************************************!*\
  !*** ../../node_modules/borc/src/index.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\n// exports.Commented = require('./commented')\nexports.Diagnose = __webpack_require__(/*! ./diagnose */ \"(app-pages-browser)/../../node_modules/borc/src/diagnose.js\")\nexports.Decoder = __webpack_require__(/*! ./decoder */ \"(app-pages-browser)/../../node_modules/borc/src/decoder.js\")\nexports.Encoder = __webpack_require__(/*! ./encoder */ \"(app-pages-browser)/../../node_modules/borc/src/encoder.js\")\nexports.Simple = __webpack_require__(/*! ./simple */ \"(app-pages-browser)/../../node_modules/borc/src/simple.js\")\nexports.Tagged = __webpack_require__(/*! ./tagged */ \"(app-pages-browser)/../../node_modules/borc/src/tagged.js\")\n\n// exports.comment = exports.Commented.comment\nexports.decodeAll = exports.Decoder.decodeAll\nexports.decodeFirst = exports.Decoder.decodeFirst\nexports.diagnose = exports.Diagnose.diagnose\nexports.encode = exports.Encoder.encode\nexports.decode = exports.Decoder.decode\n\nexports.leveldb = {\n  decode: exports.Decoder.decodeAll,\n  encode: exports.Encoder.encode,\n  buffer: true,\n  name: 'cbor'\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYm9yYy9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQSx1SEFBd0M7QUFDeEMsb0hBQXNDO0FBQ3RDLG9IQUFzQztBQUN0QyxpSEFBb0M7QUFDcEMsaUhBQW9DOztBQUVwQztBQUNBLGlCQUFpQjtBQUNqQixtQkFBbUI7QUFDbkIsZ0JBQWdCO0FBQ2hCLGNBQWM7QUFDZCxjQUFjOztBQUVkLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvYm9yYy9zcmMvaW5kZXguanM/OWQ0YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLy8gZXhwb3J0cy5Db21tZW50ZWQgPSByZXF1aXJlKCcuL2NvbW1lbnRlZCcpXG5leHBvcnRzLkRpYWdub3NlID0gcmVxdWlyZSgnLi9kaWFnbm9zZScpXG5leHBvcnRzLkRlY29kZXIgPSByZXF1aXJlKCcuL2RlY29kZXInKVxuZXhwb3J0cy5FbmNvZGVyID0gcmVxdWlyZSgnLi9lbmNvZGVyJylcbmV4cG9ydHMuU2ltcGxlID0gcmVxdWlyZSgnLi9zaW1wbGUnKVxuZXhwb3J0cy5UYWdnZWQgPSByZXF1aXJlKCcuL3RhZ2dlZCcpXG5cbi8vIGV4cG9ydHMuY29tbWVudCA9IGV4cG9ydHMuQ29tbWVudGVkLmNvbW1lbnRcbmV4cG9ydHMuZGVjb2RlQWxsID0gZXhwb3J0cy5EZWNvZGVyLmRlY29kZUFsbFxuZXhwb3J0cy5kZWNvZGVGaXJzdCA9IGV4cG9ydHMuRGVjb2Rlci5kZWNvZGVGaXJzdFxuZXhwb3J0cy5kaWFnbm9zZSA9IGV4cG9ydHMuRGlhZ25vc2UuZGlhZ25vc2VcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5FbmNvZGVyLmVuY29kZVxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLkRlY29kZXIuZGVjb2RlXG5cbmV4cG9ydHMubGV2ZWxkYiA9IHtcbiAgZGVjb2RlOiBleHBvcnRzLkRlY29kZXIuZGVjb2RlQWxsLFxuICBlbmNvZGU6IGV4cG9ydHMuRW5jb2Rlci5lbmNvZGUsXG4gIGJ1ZmZlcjogdHJ1ZSxcbiAgbmFtZTogJ2Nib3InXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/borc/src/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/borc/src/simple.js":
/*!*********************************************!*\
  !*** ../../node_modules/borc/src/simple.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nconst constants = __webpack_require__(/*! ./constants */ \"(app-pages-browser)/../../node_modules/borc/src/constants.js\")\nconst MT = constants.MT\nconst SIMPLE = constants.SIMPLE\nconst SYMS = constants.SYMS\n\n/**\n * A CBOR Simple Value that does not map onto a known constant.\n */\nclass Simple {\n  /**\n   * Creates an instance of Simple.\n   *\n   * @param {integer} value - the simple value's integer value\n   */\n  constructor (value) {\n    if (typeof value !== 'number') {\n      throw new Error('Invalid Simple type: ' + (typeof value))\n    }\n    if ((value < 0) || (value > 255) || ((value | 0) !== value)) {\n      throw new Error('value must be a small positive integer: ' + value)\n    }\n    this.value = value\n  }\n\n  /**\n   * Debug string for simple value\n   *\n   * @returns {string} simple(value)\n   */\n  toString () {\n    return 'simple(' + this.value + ')'\n  }\n\n  /**\n   * Debug string for simple value\n   *\n   * @returns {string} simple(value)\n   */\n  inspect () {\n    return 'simple(' + this.value + ')'\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream\n   *\n   * @param {cbor.Encoder} gen The generator to push onto\n   * @returns {number}\n   */\n  encodeCBOR (gen) {\n    return gen._pushInt(this.value, MT.SIMPLE_FLOAT)\n  }\n\n  /**\n   * Is the given object a Simple?\n   *\n   * @param {any} obj - object to test\n   * @returns {bool} - is it Simple?\n   */\n  static isSimple (obj) {\n    return obj instanceof Simple\n  }\n\n  /**\n   * Decode from the CBOR additional information into a JavaScript value.\n   * If the CBOR item has no parent, return a \"safe\" symbol instead of\n   * `null` or `undefined`, so that the value can be passed through a\n   * stream in object mode.\n   *\n   * @param {Number} val - the CBOR additional info to convert\n   * @param {bool} hasParent - Does the CBOR item have a parent?\n   * @returns {(null|undefined|Boolean|Symbol)} - the decoded value\n   */\n  static decode (val, hasParent) {\n    if (hasParent == null) {\n      hasParent = true\n    }\n    switch (val) {\n      case SIMPLE.FALSE:\n        return false\n      case SIMPLE.TRUE:\n        return true\n      case SIMPLE.NULL:\n        if (hasParent) {\n          return null\n        } else {\n          return SYMS.NULL\n        }\n      case SIMPLE.UNDEFINED:\n        if (hasParent) {\n          return undefined\n        } else {\n          return SYMS.UNDEFINED\n        }\n      case -1:\n        if (!hasParent) {\n          throw new Error('Invalid BREAK')\n        }\n        return SYMS.BREAK\n      default:\n        return new Simple(val)\n    }\n  }\n}\n\nmodule.exports = Simple\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYm9yYy9zcmMvc2ltcGxlLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGtCQUFrQixtQkFBTyxDQUFDLGlGQUFhO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxNQUFNO0FBQ25CLGVBQWUsaUNBQWlDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvYm9yYy9zcmMvc2ltcGxlLmpzPzFkNDMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IE1UID0gY29uc3RhbnRzLk1UXG5jb25zdCBTSU1QTEUgPSBjb25zdGFudHMuU0lNUExFXG5jb25zdCBTWU1TID0gY29uc3RhbnRzLlNZTVNcblxuLyoqXG4gKiBBIENCT1IgU2ltcGxlIFZhbHVlIHRoYXQgZG9lcyBub3QgbWFwIG9udG8gYSBrbm93biBjb25zdGFudC5cbiAqL1xuY2xhc3MgU2ltcGxlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgU2ltcGxlLlxuICAgKlxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIC0gdGhlIHNpbXBsZSB2YWx1ZSdzIGludGVnZXIgdmFsdWVcbiAgICovXG4gIGNvbnN0cnVjdG9yICh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgU2ltcGxlIHR5cGU6ICcgKyAodHlwZW9mIHZhbHVlKSlcbiAgICB9XG4gICAgaWYgKCh2YWx1ZSA8IDApIHx8ICh2YWx1ZSA+IDI1NSkgfHwgKCh2YWx1ZSB8IDApICE9PSB2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndmFsdWUgbXVzdCBiZSBhIHNtYWxsIHBvc2l0aXZlIGludGVnZXI6ICcgKyB2YWx1ZSlcbiAgICB9XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlXG4gIH1cblxuICAvKipcbiAgICogRGVidWcgc3RyaW5nIGZvciBzaW1wbGUgdmFsdWVcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gc2ltcGxlKHZhbHVlKVxuICAgKi9cbiAgdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiAnc2ltcGxlKCcgKyB0aGlzLnZhbHVlICsgJyknXG4gIH1cblxuICAvKipcbiAgICogRGVidWcgc3RyaW5nIGZvciBzaW1wbGUgdmFsdWVcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gc2ltcGxlKHZhbHVlKVxuICAgKi9cbiAgaW5zcGVjdCAoKSB7XG4gICAgcmV0dXJuICdzaW1wbGUoJyArIHRoaXMudmFsdWUgKyAnKSdcbiAgfVxuXG4gIC8qKlxuICAgKiBQdXNoIHRoZSBzaW1wbGUgdmFsdWUgb250byB0aGUgQ0JPUiBzdHJlYW1cbiAgICpcbiAgICogQHBhcmFtIHtjYm9yLkVuY29kZXJ9IGdlbiBUaGUgZ2VuZXJhdG9yIHRvIHB1c2ggb250b1xuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZW5jb2RlQ0JPUiAoZ2VuKSB7XG4gICAgcmV0dXJuIGdlbi5fcHVzaEludCh0aGlzLnZhbHVlLCBNVC5TSU1QTEVfRkxPQVQpXG4gIH1cblxuICAvKipcbiAgICogSXMgdGhlIGdpdmVuIG9iamVjdCBhIFNpbXBsZT9cbiAgICpcbiAgICogQHBhcmFtIHthbnl9IG9iaiAtIG9iamVjdCB0byB0ZXN0XG4gICAqIEByZXR1cm5zIHtib29sfSAtIGlzIGl0IFNpbXBsZT9cbiAgICovXG4gIHN0YXRpYyBpc1NpbXBsZSAob2JqKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIFNpbXBsZVxuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBmcm9tIHRoZSBDQk9SIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gaW50byBhIEphdmFTY3JpcHQgdmFsdWUuXG4gICAqIElmIHRoZSBDQk9SIGl0ZW0gaGFzIG5vIHBhcmVudCwgcmV0dXJuIGEgXCJzYWZlXCIgc3ltYm9sIGluc3RlYWQgb2ZcbiAgICogYG51bGxgIG9yIGB1bmRlZmluZWRgLCBzbyB0aGF0IHRoZSB2YWx1ZSBjYW4gYmUgcGFzc2VkIHRocm91Z2ggYVxuICAgKiBzdHJlYW0gaW4gb2JqZWN0IG1vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWwgLSB0aGUgQ0JPUiBhZGRpdGlvbmFsIGluZm8gdG8gY29udmVydFxuICAgKiBAcGFyYW0ge2Jvb2x9IGhhc1BhcmVudCAtIERvZXMgdGhlIENCT1IgaXRlbSBoYXZlIGEgcGFyZW50P1xuICAgKiBAcmV0dXJucyB7KG51bGx8dW5kZWZpbmVkfEJvb2xlYW58U3ltYm9sKX0gLSB0aGUgZGVjb2RlZCB2YWx1ZVxuICAgKi9cbiAgc3RhdGljIGRlY29kZSAodmFsLCBoYXNQYXJlbnQpIHtcbiAgICBpZiAoaGFzUGFyZW50ID09IG51bGwpIHtcbiAgICAgIGhhc1BhcmVudCA9IHRydWVcbiAgICB9XG4gICAgc3dpdGNoICh2YWwpIHtcbiAgICAgIGNhc2UgU0lNUExFLkZBTFNFOlxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIGNhc2UgU0lNUExFLlRSVUU6XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICBjYXNlIFNJTVBMRS5OVUxMOlxuICAgICAgICBpZiAoaGFzUGFyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gU1lNUy5OVUxMXG4gICAgICAgIH1cbiAgICAgIGNhc2UgU0lNUExFLlVOREVGSU5FRDpcbiAgICAgICAgaWYgKGhhc1BhcmVudCkge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gU1lNUy5VTkRFRklORURcbiAgICAgICAgfVxuICAgICAgY2FzZSAtMTpcbiAgICAgICAgaWYgKCFoYXNQYXJlbnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgQlJFQUsnKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTWU1TLkJSRUFLXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbmV3IFNpbXBsZSh2YWwpXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2ltcGxlXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/borc/src/simple.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/borc/src/tagged.js":
/*!*********************************************!*\
  !*** ../../node_modules/borc/src/tagged.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\n/**\n * A CBOR tagged item, where the tag does not have semantics specified at the\n * moment, or those semantics threw an error during parsing. Typically this will\n * be an extension point you're not yet expecting.\n */\nclass Tagged {\n  /**\n   * Creates an instance of Tagged.\n   *\n   * @param {Number} tag - the number of the tag\n   * @param {any} value - the value inside the tag\n   * @param {Error} err - the error that was thrown parsing the tag, or null\n   */\n  constructor (tag, value, err) {\n    this.tag = tag\n    this.value = value\n    this.err = err\n    if (typeof this.tag !== 'number') {\n      throw new Error('Invalid tag type (' + (typeof this.tag) + ')')\n    }\n    if ((this.tag < 0) || ((this.tag | 0) !== this.tag)) {\n      throw new Error('Tag must be a positive integer: ' + this.tag)\n    }\n  }\n\n  /**\n   * Convert to a String\n   *\n   * @returns {String} string of the form '1(2)'\n   */\n  toString () {\n    return `${this.tag}(${JSON.stringify(this.value)})`\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream\n   *\n   * @param {cbor.Encoder} gen The generator to push onto\n   * @returns {number}\n   */\n  encodeCBOR (gen) {\n    gen._pushTag(this.tag)\n    return gen.pushAny(this.value)\n  }\n\n  /**\n   * If we have a converter for this type, do the conversion.  Some converters\n   * are built-in.  Additional ones can be passed in.  If you want to remove\n   * a built-in converter, pass a converter in whose value is 'null' instead\n   * of a function.\n   *\n   * @param {Object} converters - keys in the object are a tag number, the value\n   *   is a function that takes the decoded CBOR and returns a JavaScript value\n   *   of the appropriate type.  Throw an exception in the function on errors.\n   * @returns {any} - the converted item\n   */\n  convert (converters) {\n    var er, f\n    f = converters != null ? converters[this.tag] : undefined\n    if (typeof f !== 'function') {\n      f = Tagged['_tag' + this.tag]\n      if (typeof f !== 'function') {\n        return this\n      }\n    }\n    try {\n      return f.call(Tagged, this.value)\n    } catch (error) {\n      er = error\n      this.err = er\n      return this\n    }\n  }\n}\n\nmodule.exports = Tagged\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYm9yYy9zcmMvdGFnZ2VkLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLEtBQUs7QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLGNBQWMsU0FBUyxHQUFHLDJCQUEyQjtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0IsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL2JvcmMvc3JjL3RhZ2dlZC5qcz85YjdkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIEEgQ0JPUiB0YWdnZWQgaXRlbSwgd2hlcmUgdGhlIHRhZyBkb2VzIG5vdCBoYXZlIHNlbWFudGljcyBzcGVjaWZpZWQgYXQgdGhlXG4gKiBtb21lbnQsIG9yIHRob3NlIHNlbWFudGljcyB0aHJldyBhbiBlcnJvciBkdXJpbmcgcGFyc2luZy4gVHlwaWNhbGx5IHRoaXMgd2lsbFxuICogYmUgYW4gZXh0ZW5zaW9uIHBvaW50IHlvdSdyZSBub3QgeWV0IGV4cGVjdGluZy5cbiAqL1xuY2xhc3MgVGFnZ2VkIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgVGFnZ2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gdGFnIC0gdGhlIG51bWJlciBvZiB0aGUgdGFnXG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZSAtIHRoZSB2YWx1ZSBpbnNpZGUgdGhlIHRhZ1xuICAgKiBAcGFyYW0ge0Vycm9yfSBlcnIgLSB0aGUgZXJyb3IgdGhhdCB3YXMgdGhyb3duIHBhcnNpbmcgdGhlIHRhZywgb3IgbnVsbFxuICAgKi9cbiAgY29uc3RydWN0b3IgKHRhZywgdmFsdWUsIGVycikge1xuICAgIHRoaXMudGFnID0gdGFnXG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlXG4gICAgdGhpcy5lcnIgPSBlcnJcbiAgICBpZiAodHlwZW9mIHRoaXMudGFnICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRhZyB0eXBlICgnICsgKHR5cGVvZiB0aGlzLnRhZykgKyAnKScpXG4gICAgfVxuICAgIGlmICgodGhpcy50YWcgPCAwKSB8fCAoKHRoaXMudGFnIHwgMCkgIT09IHRoaXMudGFnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUYWcgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXI6ICcgKyB0aGlzLnRhZylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCB0byBhIFN0cmluZ1xuICAgKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgb2YgdGhlIGZvcm0gJzEoMiknXG4gICAqL1xuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMudGFnfSgke0pTT04uc3RyaW5naWZ5KHRoaXMudmFsdWUpfSlgXG4gIH1cblxuICAvKipcbiAgICogUHVzaCB0aGUgc2ltcGxlIHZhbHVlIG9udG8gdGhlIENCT1Igc3RyZWFtXG4gICAqXG4gICAqIEBwYXJhbSB7Y2Jvci5FbmNvZGVyfSBnZW4gVGhlIGdlbmVyYXRvciB0byBwdXNoIG9udG9cbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGVuY29kZUNCT1IgKGdlbikge1xuICAgIGdlbi5fcHVzaFRhZyh0aGlzLnRhZylcbiAgICByZXR1cm4gZ2VuLnB1c2hBbnkodGhpcy52YWx1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB3ZSBoYXZlIGEgY29udmVydGVyIGZvciB0aGlzIHR5cGUsIGRvIHRoZSBjb252ZXJzaW9uLiAgU29tZSBjb252ZXJ0ZXJzXG4gICAqIGFyZSBidWlsdC1pbi4gIEFkZGl0aW9uYWwgb25lcyBjYW4gYmUgcGFzc2VkIGluLiAgSWYgeW91IHdhbnQgdG8gcmVtb3ZlXG4gICAqIGEgYnVpbHQtaW4gY29udmVydGVyLCBwYXNzIGEgY29udmVydGVyIGluIHdob3NlIHZhbHVlIGlzICdudWxsJyBpbnN0ZWFkXG4gICAqIG9mIGEgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb252ZXJ0ZXJzIC0ga2V5cyBpbiB0aGUgb2JqZWN0IGFyZSBhIHRhZyBudW1iZXIsIHRoZSB2YWx1ZVxuICAgKiAgIGlzIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyB0aGUgZGVjb2RlZCBDQk9SIGFuZCByZXR1cm5zIGEgSmF2YVNjcmlwdCB2YWx1ZVxuICAgKiAgIG9mIHRoZSBhcHByb3ByaWF0ZSB0eXBlLiAgVGhyb3cgYW4gZXhjZXB0aW9uIGluIHRoZSBmdW5jdGlvbiBvbiBlcnJvcnMuXG4gICAqIEByZXR1cm5zIHthbnl9IC0gdGhlIGNvbnZlcnRlZCBpdGVtXG4gICAqL1xuICBjb252ZXJ0IChjb252ZXJ0ZXJzKSB7XG4gICAgdmFyIGVyLCBmXG4gICAgZiA9IGNvbnZlcnRlcnMgIT0gbnVsbCA/IGNvbnZlcnRlcnNbdGhpcy50YWddIDogdW5kZWZpbmVkXG4gICAgaWYgKHR5cGVvZiBmICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmID0gVGFnZ2VkWydfdGFnJyArIHRoaXMudGFnXVxuICAgICAgaWYgKHR5cGVvZiBmICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZi5jYWxsKFRhZ2dlZCwgdGhpcy52YWx1ZSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZXIgPSBlcnJvclxuICAgICAgdGhpcy5lcnIgPSBlclxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUYWdnZWRcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/borc/src/tagged.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/borc/src/utils.js":
/*!********************************************!*\
  !*** ../../node_modules/borc/src/utils.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nconst { Buffer } = __webpack_require__(/*! buffer */ \"(app-pages-browser)/../../node_modules/borc/node_modules/buffer/index.js\")\nconst Bignumber = (__webpack_require__(/*! bignumber.js */ \"(app-pages-browser)/../../node_modules/bignumber.js/bignumber.js\").BigNumber)\n\nconst constants = __webpack_require__(/*! ./constants */ \"(app-pages-browser)/../../node_modules/borc/src/constants.js\")\nconst SHIFT32 = constants.SHIFT32\nconst SHIFT16 = constants.SHIFT16\nconst MAX_SAFE_HIGH = 0x1fffff\n\nexports.parseHalf = function parseHalf (buf) {\n  var exp, mant, sign\n  sign = buf[0] & 0x80 ? -1 : 1\n  exp = (buf[0] & 0x7C) >> 2\n  mant = ((buf[0] & 0x03) << 8) | buf[1]\n  if (!exp) {\n    return sign * 5.9604644775390625e-8 * mant\n  } else if (exp === 0x1f) {\n    return sign * (mant ? 0 / 0 : 2e308)\n  } else {\n    return sign * Math.pow(2, exp - 25) * (1024 + mant)\n  }\n}\n\nfunction toHex (n) {\n  if (n < 16) {\n    return '0' + n.toString(16)\n  }\n\n  return n.toString(16)\n}\n\nexports.arrayBufferToBignumber = function (buf) {\n  const len = buf.byteLength\n  let res = ''\n  for (let i = 0; i < len; i++) {\n    res += toHex(buf[i])\n  }\n\n  return new Bignumber(res, 16)\n}\n\n// convert an Object into a Map\nexports.buildMap = (obj) => {\n  const res = new Map()\n  const keys = Object.keys(obj)\n  const length = keys.length\n  for (let i = 0; i < length; i++) {\n    res.set(keys[i], obj[keys[i]])\n  }\n  return res\n}\n\nexports.buildInt32 = (f, g) => {\n  return f * SHIFT16 + g\n}\n\nexports.buildInt64 = (f1, f2, g1, g2) => {\n  const f = exports.buildInt32(f1, f2)\n  const g = exports.buildInt32(g1, g2)\n\n  if (f > MAX_SAFE_HIGH) {\n    return new Bignumber(f).times(SHIFT32).plus(g)\n  } else {\n    return (f * SHIFT32) + g\n  }\n}\n\nexports.writeHalf = function writeHalf (buf, half) {\n  // assume 0, -0, NaN, Infinity, and -Infinity have already been caught\n\n  // HACK: everyone settle in.  This isn't going to be pretty.\n  // Translate cn-cbor's C code (from Carsten Borman):\n\n  // uint32_t be32;\n  // uint16_t be16, u16;\n  // union {\n  //   float f;\n  //   uint32_t u;\n  // } u32;\n  // u32.f = float_val;\n\n  const u32 = Buffer.allocUnsafe(4)\n  u32.writeFloatBE(half, 0)\n  const u = u32.readUInt32BE(0)\n\n  // if ((u32.u & 0x1FFF) == 0) { /* worth trying half */\n\n  // hildjj: If the lower 13 bits are 0, we won't lose anything in the conversion\n  if ((u & 0x1FFF) !== 0) {\n    return false\n  }\n\n  //   int s16 = (u32.u >> 16) & 0x8000;\n  //   int exp = (u32.u >> 23) & 0xff;\n  //   int mant = u32.u & 0x7fffff;\n\n  var s16 = (u >> 16) & 0x8000 // top bit is sign\n  const exp = (u >> 23) & 0xff // then 5 bits of exponent\n  const mant = u & 0x7fffff\n\n  //   if (exp == 0 && mant == 0)\n  //     ;              /* 0.0, -0.0 */\n\n  // hildjj: zeros already handled.  Assert if you don't believe me.\n\n  //   else if (exp >= 113 && exp <= 142) /* normalized */\n  //     s16 += ((exp - 112) << 10) + (mant >> 13);\n  if ((exp >= 113) && (exp <= 142)) {\n    s16 += ((exp - 112) << 10) + (mant >> 13)\n\n  //   else if (exp >= 103 && exp < 113) { /* denorm, exp16 = 0 */\n  //     if (mant & ((1 << (126 - exp)) - 1))\n  //       goto float32;         /* loss of precision */\n  //     s16 += ((mant + 0x800000) >> (126 - exp));\n  } else if ((exp >= 103) && (exp < 113)) {\n    if (mant & ((1 << (126 - exp)) - 1)) {\n      return false\n    }\n    s16 += ((mant + 0x800000) >> (126 - exp))\n\n    //   } else if (exp == 255 && mant == 0) { /* Inf */\n    //     s16 += 0x7c00;\n\n    // hildjj: Infinity already handled\n\n  //   } else\n  //     goto float32;           /* loss of range */\n  } else {\n    return false\n  }\n\n  //   ensure_writable(3);\n  //   u16 = s16;\n  //   be16 = hton16p((const uint8_t*)&u16);\n  buf.writeUInt16BE(s16, 0)\n  return true\n}\n\nexports.keySorter = function (a, b) {\n  var lenA = a[0].byteLength\n  var lenB = b[0].byteLength\n\n  if (lenA > lenB) {\n    return 1\n  }\n\n  if (lenB > lenA) {\n    return -1\n  }\n\n  return a[0].compare(b[0])\n}\n\n// Adapted from http://www.2ality.com/2012/03/signedzero.html\nexports.isNegativeZero = (x) => {\n  return x === 0 && (1 / x < 0)\n}\n\nexports.nextPowerOf2 = (n) => {\n  let count = 0\n  // First n in the below condition is for\n  // the case where n is 0\n  if (n && !(n & (n - 1))) {\n    return n\n  }\n\n  while (n !== 0) {\n    n >>= 1\n    count += 1\n  }\n\n  return 1 << count\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYm9yYy9zcmMvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyx3RkFBUTtBQUNuQyxrQkFBa0IsdUhBQWlDOztBQUVuRCxrQkFBa0IsbUJBQU8sQ0FBQyxpRkFBYTtBQUN2QztBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7O0FBRXhCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBLGlDQUFpQztBQUNqQztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLG9DQUFvQztBQUMvQzs7QUFFQTs7QUFFQSxTQUFTO0FBQ1QsaUNBQWlDO0FBQ2pDLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9ib3JjL3NyYy91dGlscy5qcz8zZDRiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZSgnYnVmZmVyJylcbmNvbnN0IEJpZ251bWJlciA9IHJlcXVpcmUoJ2JpZ251bWJlci5qcycpLkJpZ051bWJlclxuXG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCBTSElGVDMyID0gY29uc3RhbnRzLlNISUZUMzJcbmNvbnN0IFNISUZUMTYgPSBjb25zdGFudHMuU0hJRlQxNlxuY29uc3QgTUFYX1NBRkVfSElHSCA9IDB4MWZmZmZmXG5cbmV4cG9ydHMucGFyc2VIYWxmID0gZnVuY3Rpb24gcGFyc2VIYWxmIChidWYpIHtcbiAgdmFyIGV4cCwgbWFudCwgc2lnblxuICBzaWduID0gYnVmWzBdICYgMHg4MCA/IC0xIDogMVxuICBleHAgPSAoYnVmWzBdICYgMHg3QykgPj4gMlxuICBtYW50ID0gKChidWZbMF0gJiAweDAzKSA8PCA4KSB8IGJ1ZlsxXVxuICBpZiAoIWV4cCkge1xuICAgIHJldHVybiBzaWduICogNS45NjA0NjQ0Nzc1MzkwNjI1ZS04ICogbWFudFxuICB9IGVsc2UgaWYgKGV4cCA9PT0gMHgxZikge1xuICAgIHJldHVybiBzaWduICogKG1hbnQgPyAwIC8gMCA6IDJlMzA4KVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBzaWduICogTWF0aC5wb3coMiwgZXhwIC0gMjUpICogKDEwMjQgKyBtYW50KVxuICB9XG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHtcbiAgICByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgfVxuXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5leHBvcnRzLmFycmF5QnVmZmVyVG9CaWdudW1iZXIgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGNvbnN0IGxlbiA9IGJ1Zi5ieXRlTGVuZ3RoXG4gIGxldCByZXMgPSAnJ1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcmVzICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuXG4gIHJldHVybiBuZXcgQmlnbnVtYmVyKHJlcywgMTYpXG59XG5cbi8vIGNvbnZlcnQgYW4gT2JqZWN0IGludG8gYSBNYXBcbmV4cG9ydHMuYnVpbGRNYXAgPSAob2JqKSA9PiB7XG4gIGNvbnN0IHJlcyA9IG5ldyBNYXAoKVxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKVxuICBjb25zdCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnNldChrZXlzW2ldLCBvYmpba2V5c1tpXV0pXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5leHBvcnRzLmJ1aWxkSW50MzIgPSAoZiwgZykgPT4ge1xuICByZXR1cm4gZiAqIFNISUZUMTYgKyBnXG59XG5cbmV4cG9ydHMuYnVpbGRJbnQ2NCA9IChmMSwgZjIsIGcxLCBnMikgPT4ge1xuICBjb25zdCBmID0gZXhwb3J0cy5idWlsZEludDMyKGYxLCBmMilcbiAgY29uc3QgZyA9IGV4cG9ydHMuYnVpbGRJbnQzMihnMSwgZzIpXG5cbiAgaWYgKGYgPiBNQVhfU0FGRV9ISUdIKSB7XG4gICAgcmV0dXJuIG5ldyBCaWdudW1iZXIoZikudGltZXMoU0hJRlQzMikucGx1cyhnKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoZiAqIFNISUZUMzIpICsgZ1xuICB9XG59XG5cbmV4cG9ydHMud3JpdGVIYWxmID0gZnVuY3Rpb24gd3JpdGVIYWxmIChidWYsIGhhbGYpIHtcbiAgLy8gYXNzdW1lIDAsIC0wLCBOYU4sIEluZmluaXR5LCBhbmQgLUluZmluaXR5IGhhdmUgYWxyZWFkeSBiZWVuIGNhdWdodFxuXG4gIC8vIEhBQ0s6IGV2ZXJ5b25lIHNldHRsZSBpbi4gIFRoaXMgaXNuJ3QgZ29pbmcgdG8gYmUgcHJldHR5LlxuICAvLyBUcmFuc2xhdGUgY24tY2JvcidzIEMgY29kZSAoZnJvbSBDYXJzdGVuIEJvcm1hbik6XG5cbiAgLy8gdWludDMyX3QgYmUzMjtcbiAgLy8gdWludDE2X3QgYmUxNiwgdTE2O1xuICAvLyB1bmlvbiB7XG4gIC8vICAgZmxvYXQgZjtcbiAgLy8gICB1aW50MzJfdCB1O1xuICAvLyB9IHUzMjtcbiAgLy8gdTMyLmYgPSBmbG9hdF92YWw7XG5cbiAgY29uc3QgdTMyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDQpXG4gIHUzMi53cml0ZUZsb2F0QkUoaGFsZiwgMClcbiAgY29uc3QgdSA9IHUzMi5yZWFkVUludDMyQkUoMClcblxuICAvLyBpZiAoKHUzMi51ICYgMHgxRkZGKSA9PSAwKSB7IC8qIHdvcnRoIHRyeWluZyBoYWxmICovXG5cbiAgLy8gaGlsZGpqOiBJZiB0aGUgbG93ZXIgMTMgYml0cyBhcmUgMCwgd2Ugd29uJ3QgbG9zZSBhbnl0aGluZyBpbiB0aGUgY29udmVyc2lvblxuICBpZiAoKHUgJiAweDFGRkYpICE9PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyAgIGludCBzMTYgPSAodTMyLnUgPj4gMTYpICYgMHg4MDAwO1xuICAvLyAgIGludCBleHAgPSAodTMyLnUgPj4gMjMpICYgMHhmZjtcbiAgLy8gICBpbnQgbWFudCA9IHUzMi51ICYgMHg3ZmZmZmY7XG5cbiAgdmFyIHMxNiA9ICh1ID4+IDE2KSAmIDB4ODAwMCAvLyB0b3AgYml0IGlzIHNpZ25cbiAgY29uc3QgZXhwID0gKHUgPj4gMjMpICYgMHhmZiAvLyB0aGVuIDUgYml0cyBvZiBleHBvbmVudFxuICBjb25zdCBtYW50ID0gdSAmIDB4N2ZmZmZmXG5cbiAgLy8gICBpZiAoZXhwID09IDAgJiYgbWFudCA9PSAwKVxuICAvLyAgICAgOyAgICAgICAgICAgICAgLyogMC4wLCAtMC4wICovXG5cbiAgLy8gaGlsZGpqOiB6ZXJvcyBhbHJlYWR5IGhhbmRsZWQuICBBc3NlcnQgaWYgeW91IGRvbid0IGJlbGlldmUgbWUuXG5cbiAgLy8gICBlbHNlIGlmIChleHAgPj0gMTEzICYmIGV4cCA8PSAxNDIpIC8qIG5vcm1hbGl6ZWQgKi9cbiAgLy8gICAgIHMxNiArPSAoKGV4cCAtIDExMikgPDwgMTApICsgKG1hbnQgPj4gMTMpO1xuICBpZiAoKGV4cCA+PSAxMTMpICYmIChleHAgPD0gMTQyKSkge1xuICAgIHMxNiArPSAoKGV4cCAtIDExMikgPDwgMTApICsgKG1hbnQgPj4gMTMpXG5cbiAgLy8gICBlbHNlIGlmIChleHAgPj0gMTAzICYmIGV4cCA8IDExMykgeyAvKiBkZW5vcm0sIGV4cDE2ID0gMCAqL1xuICAvLyAgICAgaWYgKG1hbnQgJiAoKDEgPDwgKDEyNiAtIGV4cCkpIC0gMSkpXG4gIC8vICAgICAgIGdvdG8gZmxvYXQzMjsgICAgICAgICAvKiBsb3NzIG9mIHByZWNpc2lvbiAqL1xuICAvLyAgICAgczE2ICs9ICgobWFudCArIDB4ODAwMDAwKSA+PiAoMTI2IC0gZXhwKSk7XG4gIH0gZWxzZSBpZiAoKGV4cCA+PSAxMDMpICYmIChleHAgPCAxMTMpKSB7XG4gICAgaWYgKG1hbnQgJiAoKDEgPDwgKDEyNiAtIGV4cCkpIC0gMSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBzMTYgKz0gKChtYW50ICsgMHg4MDAwMDApID4+ICgxMjYgLSBleHApKVxuXG4gICAgLy8gICB9IGVsc2UgaWYgKGV4cCA9PSAyNTUgJiYgbWFudCA9PSAwKSB7IC8qIEluZiAqL1xuICAgIC8vICAgICBzMTYgKz0gMHg3YzAwO1xuXG4gICAgLy8gaGlsZGpqOiBJbmZpbml0eSBhbHJlYWR5IGhhbmRsZWRcblxuICAvLyAgIH0gZWxzZVxuICAvLyAgICAgZ290byBmbG9hdDMyOyAgICAgICAgICAgLyogbG9zcyBvZiByYW5nZSAqL1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gICBlbnN1cmVfd3JpdGFibGUoMyk7XG4gIC8vICAgdTE2ID0gczE2O1xuICAvLyAgIGJlMTYgPSBodG9uMTZwKChjb25zdCB1aW50OF90KikmdTE2KTtcbiAgYnVmLndyaXRlVUludDE2QkUoczE2LCAwKVxuICByZXR1cm4gdHJ1ZVxufVxuXG5leHBvcnRzLmtleVNvcnRlciA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIHZhciBsZW5BID0gYVswXS5ieXRlTGVuZ3RoXG4gIHZhciBsZW5CID0gYlswXS5ieXRlTGVuZ3RoXG5cbiAgaWYgKGxlbkEgPiBsZW5CKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIGlmIChsZW5CID4gbGVuQSkge1xuICAgIHJldHVybiAtMVxuICB9XG5cbiAgcmV0dXJuIGFbMF0uY29tcGFyZShiWzBdKVxufVxuXG4vLyBBZGFwdGVkIGZyb20gaHR0cDovL3d3dy4yYWxpdHkuY29tLzIwMTIvMDMvc2lnbmVkemVyby5odG1sXG5leHBvcnRzLmlzTmVnYXRpdmVaZXJvID0gKHgpID0+IHtcbiAgcmV0dXJuIHggPT09IDAgJiYgKDEgLyB4IDwgMClcbn1cblxuZXhwb3J0cy5uZXh0UG93ZXJPZjIgPSAobikgPT4ge1xuICBsZXQgY291bnQgPSAwXG4gIC8vIEZpcnN0IG4gaW4gdGhlIGJlbG93IGNvbmRpdGlvbiBpcyBmb3JcbiAgLy8gdGhlIGNhc2Ugd2hlcmUgbiBpcyAwXG4gIGlmIChuICYmICEobiAmIChuIC0gMSkpKSB7XG4gICAgcmV0dXJuIG5cbiAgfVxuXG4gIHdoaWxlIChuICE9PSAwKSB7XG4gICAgbiA+Pj0gMVxuICAgIGNvdW50ICs9IDFcbiAgfVxuXG4gIHJldHVybiAxIDw8IGNvdW50XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/borc/src/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/buffer/index.js":
/*!******************************************!*\
  !*** ../../node_modules/buffer/index.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nconst base64 = __webpack_require__(/*! base64-js */ \"(app-pages-browser)/../../node_modules/base64-js/index.js\")\nconst ieee754 = __webpack_require__(/*! ieee754 */ \"(app-pages-browser)/../../node_modules/ieee754/index.js\")\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVZOztBQUVaLGVBQWUsbUJBQU8sQ0FBQyw0RUFBVztBQUNsQyxnQkFBZ0IsbUJBQU8sQ0FBQyx3RUFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Qsa0JBQWtCO0FBQ2xCLHlCQUF5Qjs7QUFFekI7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsRUFBRTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixlQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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OztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzPzVmZDYiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxuY29uc3QgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbmNvbnN0IGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbmNvbnN0IGN1c3RvbUluc3BlY3RTeW1ib2wgPVxuICAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sWydmb3InXSA9PT0gJ2Z1bmN0aW9uJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICA/IFN5bWJvbFsnZm9yJ10oJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICA6IG51bGxcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG5jb25zdCBLX01BWF9MRU5HVEggPSAweDdmZmZmZmZmXG5leHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEhcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdFxuICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlXG4gKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXG4gKiAoU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzgpLiBJRSAxMCBsYWNrcyBzdXBwb3J0XG4gKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgY29uc29sZS5lcnJvcihcbiAgICAnVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5ICcgK1xuICAgICdgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LidcbiAgKVxufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cbiAgdHJ5IHtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGNvbnN0IHByb3RvID0geyBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH0gfVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihwcm90bywgVWludDhBcnJheS5wcm90b3R5cGUpXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGFyciwgcHJvdG8pXG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAncGFyZW50Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ1ZmZlclxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGxlbmd0aCArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyLnByb3RvdHlwZSlcbiAgcmV0dXJuIGJ1ZlxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKGFyZylcbiAgfVxuICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheVZpZXcodmFsdWUpXG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gICAgKVxuICB9XG5cbiAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIChpc0luc3RhbmNlKHZhbHVlLCBTaGFyZWRBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgU2hhcmVkQXJyYXlCdWZmZXIpKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgKVxuICB9XG5cbiAgY29uc3QgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YgJiYgdmFsdWUudmFsdWVPZigpXG4gIGlmICh2YWx1ZU9mICE9IG51bGwgJiYgdmFsdWVPZiAhPT0gdmFsdWUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVPZiwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgY29uc3QgYiA9IGZyb21PYmplY3QodmFsdWUpXG4gIGlmIChiKSByZXR1cm4gYlxuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9QcmltaXRpdmUgIT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSgnc3RyaW5nJyksIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1Zzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLnByb3RvdHlwZSwgVWludDhBcnJheS5wcm90b3R5cGUpXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLCBVaW50OEFycmF5KVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgc2l6ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cblxuICBjb25zdCBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICBsZXQgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICBjb25zdCBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKGFycmF5KSB7XG4gIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICBjb25zdCBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheVZpZXcgKGFycmF5Vmlldykge1xuICBpZiAoaXNJbnN0YW5jZShhcnJheVZpZXcsIFVpbnQ4QXJyYXkpKSB7XG4gICAgY29uc3QgY29weSA9IG5ldyBVaW50OEFycmF5KGFycmF5VmlldylcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKGNvcHkuYnVmZmVyLCBjb3B5LmJ5dGVPZmZzZXQsIGNvcHkuYnl0ZUxlbmd0aClcbiAgfVxuICByZXR1cm4gZnJvbUFycmF5TGlrZShhcnJheVZpZXcpXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBsZXQgYnVmXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAob2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIGNvbnN0IGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgY29uc3QgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICB9XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICB9XG5cbiAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZSAmJlxuICAgIGIgIT09IEJ1ZmZlci5wcm90b3R5cGUgLy8gc28gQnVmZmVyLmlzQnVmZmVyKEJ1ZmZlci5wcm90b3R5cGUpIHdpbGwgYmUgZmFsc2Vcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKSBhID0gQnVmZmVyLmZyb20oYSwgYS5vZmZzZXQsIGEuYnl0ZUxlbmd0aClcbiAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpIGIgPSBCdWZmZXIuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5J1xuICAgIClcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIGxldCB4ID0gYS5sZW5ndGhcbiAgbGV0IHkgPSBiLmxlbmd0aFxuXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgbGV0IGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICBsZXQgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIGxldCBidWYgPSBsaXN0W2ldXG4gICAgaWYgKGlzSW5zdGFuY2UoYnVmLCBVaW50OEFycmF5KSkge1xuICAgICAgaWYgKHBvcyArIGJ1Zi5sZW5ndGggPiBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZilcbiAgICAgICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgYnVmLFxuICAgICAgICAgIHBvc1xuICAgICAgICApXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIH1cbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBpc0luc3RhbmNlKHN0cmluZywgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHN0cmluZ1xuICAgIClcbiAgfVxuXG4gIGNvbnN0IGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgY29uc3QgbXVzdE1hdGNoID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZSlcbiAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7XG4gICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJjaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgY29uc3QgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgY29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nXG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgbGV0IHN0ciA9ICcnXG4gIGNvbnN0IG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKVxuICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5pZiAoY3VzdG9tSW5zcGVjdFN5bWJvbCkge1xuICBCdWZmZXIucHJvdG90eXBlW2N1c3RvbUluc3BlY3RTeW1ib2xdID0gQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHtcbiAgICB0YXJnZXQgPSBCdWZmZXIuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKVxuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdGFyZ2V0KVxuICAgIClcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIGxldCB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICBsZXQgeSA9IGVuZCAtIHN0YXJ0XG4gIGNvbnN0IGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgY29uc3QgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgY29uc3QgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgW3ZhbF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIGxldCBpbmRleFNpemUgPSAxXG4gIGxldCBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIGxldCB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIGxldCBpXG4gIGlmIChkaXIpIHtcbiAgICBsZXQgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBsZXQgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIGNvbnN0IHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBsZXQgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICBjb25zdCByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgY29uc3QgcmVzID0gW11cblxuICBsZXQgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgY29uc3QgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgbGV0IGNvZGVQb2ludCA9IG51bGxcbiAgICBsZXQgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKVxuICAgICAgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKVxuICAgICAgICAgID8gM1xuICAgICAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpXG4gICAgICAgICAgICAgID8gMlxuICAgICAgICAgICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIGxldCBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbmNvbnN0IE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICBjb25zdCBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIGxldCByZXMgPSAnJ1xuICBsZXQgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGxldCByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICBsZXQgb3V0ID0gJydcbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gaGV4U2xpY2VMb29rdXBUYWJsZVtidWZbaV1dXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBjb25zdCBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICBsZXQgcmVzID0gJydcbiAgLy8gSWYgYnl0ZXMubGVuZ3RoIGlzIG9kZCwgdGhlIGxhc3QgOCBiaXRzIG11c3QgYmUgaWdub3JlZCAoc2FtZSBhcyBub2RlLmpzKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aCAtIDE7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICBjb25zdCBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihuZXdCdWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludExFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0XVxuICBsZXQgbXVsID0gMVxuICBsZXQgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50QkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIGxldCBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDggPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDE2TEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MTZCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQzMkxFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDMyQkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnVUludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ1VJbnQ2NExFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgbG8gPSBmaXJzdCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDI0XG5cbiAgY29uc3QgaGkgPSB0aGlzWysrb2Zmc2V0XSArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgbGFzdCAqIDIgKiogMjRcblxuICByZXR1cm4gQmlnSW50KGxvKSArIChCaWdJbnQoaGkpIDw8IEJpZ0ludCgzMikpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdVSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnVUludDY0QkUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCBoaSA9IGZpcnN0ICogMiAqKiAyNCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF1cblxuICBjb25zdCBsbyA9IHRoaXNbKytvZmZzZXRdICogMiAqKiAyNCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgbGFzdFxuXG4gIHJldHVybiAoQmlnSW50KGhpKSA8PCBCaWdJbnQoMzIpKSArIEJpZ0ludChsbylcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldF1cbiAgbGV0IG11bCA9IDFcbiAgbGV0IGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICBsZXQgaSA9IGJ5dGVMZW5ndGhcbiAgbGV0IG11bCA9IDFcbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICBjb25zdCB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnSW50NjRMRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgNF0gK1xuICAgIHRoaXNbb2Zmc2V0ICsgNV0gKiAyICoqIDggK1xuICAgIHRoaXNbb2Zmc2V0ICsgNl0gKiAyICoqIDE2ICtcbiAgICAobGFzdCA8PCAyNCkgLy8gT3ZlcmZsb3dcblxuICByZXR1cm4gKEJpZ0ludCh2YWwpIDw8IEJpZ0ludCgzMikpICtcbiAgICBCaWdJbnQoZmlyc3QgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAyNClcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ0ludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ0ludDY0QkUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCB2YWwgPSAoZmlyc3QgPDwgMjQpICsgLy8gT3ZlcmZsb3dcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XVxuXG4gIHJldHVybiAoQmlnSW50KHZhbCkgPDwgQmlnSW50KDMyKSkgK1xuICAgIEJpZ0ludCh0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIGxhc3QpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnRMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICBsZXQgbXVsID0gMVxuICBsZXQgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludEJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIGxldCBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgbGV0IG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50OCA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQxNkxFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MTZCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDMyTEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQzMkJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIHdydEJpZ1VJbnQ2NExFIChidWYsIHZhbHVlLCBvZmZzZXQsIG1pbiwgbWF4KSB7XG4gIGNoZWNrSW50QkkodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgNylcblxuICBsZXQgbG8gPSBOdW1iZXIodmFsdWUgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsZXQgaGkgPSBOdW1iZXIodmFsdWUgPj4gQmlnSW50KDMyKSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIHJldHVybiBvZmZzZXRcbn1cblxuZnVuY3Rpb24gd3J0QmlnVUludDY0QkUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbWluLCBtYXgpIHtcbiAgY2hlY2tJbnRCSSh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCA3KVxuXG4gIGxldCBsbyA9IE51bWJlcih2YWx1ZSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCArIDddID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQgKyA2XSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0ICsgNV0gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCArIDRdID0gbG9cbiAgbGV0IGhpID0gTnVtYmVyKHZhbHVlID4+IEJpZ0ludCgzMikgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQgKyAzXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0ICsgMl0gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCArIDFdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXRdID0gaGlcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ1VJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnVUludDY0TEUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRMRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBCaWdJbnQoMCksIEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnVUludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdVSW50NjRCRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NEJFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIEJpZ0ludCgwKSwgQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgbGV0IGkgPSAwXG4gIGxldCBtdWwgPSAxXG4gIGxldCBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgbGV0IGkgPSBieXRlTGVuZ3RoIC0gMVxuICBsZXQgbXVsID0gMVxuICBsZXQgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ0ludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdJbnQ2NExFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0TEUodGhpcywgdmFsdWUsIG9mZnNldCwgLUJpZ0ludCgnMHg4MDAwMDAwMDAwMDAwMDAwJyksIEJpZ0ludCgnMHg3ZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ0ludDY0QkUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRCRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAtQmlnSW50KCcweDgwMDAwMDAwMDAwMDAwMDAnKSwgQmlnSW50KCcweDdmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlcicpXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICBjb25zdCBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVc2UgYnVpbHQtaW4gd2hlbiBhdmFpbGFibGUsIG1pc3NpbmcgZnJvbSBJRTExXG4gICAgdGhpcy5jb3B5V2l0aGluKHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnICYmIGNvZGUgPCAxMjgpIHx8XG4gICAgICAgICAgZW5jb2RpbmcgPT09ICdsYXRpbjEnKSB7XG4gICAgICAgIC8vIEZhc3QgcGF0aDogSWYgYHZhbGAgZml0cyBpbnRvIGEgc2luZ2xlIGJ5dGUsIHVzZSB0aGF0IG51bWVyaWMgdmFsdWUuXG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpIHtcbiAgICB2YWwgPSBOdW1iZXIodmFsKVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIGxldCBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgICBjb25zdCBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInICsgdmFsICtcbiAgICAgICAgJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpXG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIENVU1RPTSBFUlJPUlNcbi8vID09PT09PT09PT09PT1cblxuLy8gU2ltcGxpZmllZCB2ZXJzaW9ucyBmcm9tIE5vZGUsIGNoYW5nZWQgZm9yIEJ1ZmZlci1vbmx5IHVzYWdlXG5jb25zdCBlcnJvcnMgPSB7fVxuZnVuY3Rpb24gRSAoc3ltLCBnZXRNZXNzYWdlLCBCYXNlKSB7XG4gIGVycm9yc1tzeW1dID0gY2xhc3MgTm9kZUVycm9yIGV4dGVuZHMgQmFzZSB7XG4gICAgY29uc3RydWN0b3IgKCkge1xuICAgICAgc3VwZXIoKVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ21lc3NhZ2UnLCB7XG4gICAgICAgIHZhbHVlOiBnZXRNZXNzYWdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pXG5cbiAgICAgIC8vIEFkZCB0aGUgZXJyb3IgY29kZSB0byB0aGUgbmFtZSB0byBpbmNsdWRlIGl0IGluIHRoZSBzdGFjayB0cmFjZS5cbiAgICAgIHRoaXMubmFtZSA9IGAke3RoaXMubmFtZX0gWyR7c3ltfV1gXG4gICAgICAvLyBBY2Nlc3MgdGhlIHN0YWNrIHRvIGdlbmVyYXRlIHRoZSBlcnJvciBtZXNzYWdlIGluY2x1ZGluZyB0aGUgZXJyb3IgY29kZVxuICAgICAgLy8gZnJvbSB0aGUgbmFtZS5cbiAgICAgIHRoaXMuc3RhY2sgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcbiAgICAgIC8vIFJlc2V0IHRoZSBuYW1lIHRvIHRoZSBhY3R1YWwgbmFtZS5cbiAgICAgIGRlbGV0ZSB0aGlzLm5hbWVcbiAgICB9XG5cbiAgICBnZXQgY29kZSAoKSB7XG4gICAgICByZXR1cm4gc3ltXG4gICAgfVxuXG4gICAgc2V0IGNvZGUgKHZhbHVlKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NvZGUnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KVxuICAgIH1cblxuICAgIHRvU3RyaW5nICgpIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLm5hbWV9IFske3N5bX1dOiAke3RoaXMubWVzc2FnZX1gXG4gICAgfVxuICB9XG59XG5cbkUoJ0VSUl9CVUZGRVJfT1VUX09GX0JPVU5EUycsXG4gIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiBgJHtuYW1lfSBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHNgXG4gICAgfVxuXG4gICAgcmV0dXJuICdBdHRlbXB0IHRvIGFjY2VzcyBtZW1vcnkgb3V0c2lkZSBidWZmZXIgYm91bmRzJ1xuICB9LCBSYW5nZUVycm9yKVxuRSgnRVJSX0lOVkFMSURfQVJHX1RZUEUnLFxuICBmdW5jdGlvbiAobmFtZSwgYWN0dWFsKSB7XG4gICAgcmV0dXJuIGBUaGUgXCIke25hbWV9XCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSAke3R5cGVvZiBhY3R1YWx9YFxuICB9LCBUeXBlRXJyb3IpXG5FKCdFUlJfT1VUX09GX1JBTkdFJyxcbiAgZnVuY3Rpb24gKHN0ciwgcmFuZ2UsIGlucHV0KSB7XG4gICAgbGV0IG1zZyA9IGBUaGUgdmFsdWUgb2YgXCIke3N0cn1cIiBpcyBvdXQgb2YgcmFuZ2UuYFxuICAgIGxldCByZWNlaXZlZCA9IGlucHV0XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIoaW5wdXQpICYmIE1hdGguYWJzKGlucHV0KSA+IDIgKiogMzIpIHtcbiAgICAgIHJlY2VpdmVkID0gYWRkTnVtZXJpY2FsU2VwYXJhdG9yKFN0cmluZyhpbnB1dCkpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdiaWdpbnQnKSB7XG4gICAgICByZWNlaXZlZCA9IFN0cmluZyhpbnB1dClcbiAgICAgIGlmIChpbnB1dCA+IEJpZ0ludCgyKSAqKiBCaWdJbnQoMzIpIHx8IGlucHV0IDwgLShCaWdJbnQoMikgKiogQmlnSW50KDMyKSkpIHtcbiAgICAgICAgcmVjZWl2ZWQgPSBhZGROdW1lcmljYWxTZXBhcmF0b3IocmVjZWl2ZWQpXG4gICAgICB9XG4gICAgICByZWNlaXZlZCArPSAnbidcbiAgICB9XG4gICAgbXNnICs9IGAgSXQgbXVzdCBiZSAke3JhbmdlfS4gUmVjZWl2ZWQgJHtyZWNlaXZlZH1gXG4gICAgcmV0dXJuIG1zZ1xuICB9LCBSYW5nZUVycm9yKVxuXG5mdW5jdGlvbiBhZGROdW1lcmljYWxTZXBhcmF0b3IgKHZhbCkge1xuICBsZXQgcmVzID0gJydcbiAgbGV0IGkgPSB2YWwubGVuZ3RoXG4gIGNvbnN0IHN0YXJ0ID0gdmFsWzBdID09PSAnLScgPyAxIDogMFxuICBmb3IgKDsgaSA+PSBzdGFydCArIDQ7IGkgLT0gMykge1xuICAgIHJlcyA9IGBfJHt2YWwuc2xpY2UoaSAtIDMsIGkpfSR7cmVzfWBcbiAgfVxuICByZXR1cm4gYCR7dmFsLnNsaWNlKDAsIGkpfSR7cmVzfWBcbn1cblxuLy8gQ0hFQ0sgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT1cblxuZnVuY3Rpb24gY2hlY2tCb3VuZHMgKGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGlmIChidWZbb2Zmc2V0XSA9PT0gdW5kZWZpbmVkIHx8IGJ1ZltvZmZzZXQgKyBieXRlTGVuZ3RoXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCBidWYubGVuZ3RoIC0gKGJ5dGVMZW5ndGggKyAxKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0ludEJJICh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikge1xuICAgIGNvbnN0IG4gPSB0eXBlb2YgbWluID09PSAnYmlnaW50JyA/ICduJyA6ICcnXG4gICAgbGV0IHJhbmdlXG4gICAgaWYgKGJ5dGVMZW5ndGggPiAzKSB7XG4gICAgICBpZiAobWluID09PSAwIHx8IG1pbiA9PT0gQmlnSW50KDApKSB7XG4gICAgICAgIHJhbmdlID0gYD49IDAke259IGFuZCA8IDIke259ICoqICR7KGJ5dGVMZW5ndGggKyAxKSAqIDh9JHtufWBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhbmdlID0gYD49IC0oMiR7bn0gKiogJHsoYnl0ZUxlbmd0aCArIDEpICogOCAtIDF9JHtufSkgYW5kIDwgMiAqKiBgICtcbiAgICAgICAgICAgICAgICBgJHsoYnl0ZUxlbmd0aCArIDEpICogOCAtIDF9JHtufWBcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2UgPSBgPj0gJHttaW59JHtufSBhbmQgPD0gJHttYXh9JHtufWBcbiAgICB9XG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKCd2YWx1ZScsIHJhbmdlLCB2YWx1ZSlcbiAgfVxuICBjaGVja0JvdW5kcyhidWYsIG9mZnNldCwgYnl0ZUxlbmd0aClcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVOdW1iZXIgKHZhbHVlLCBuYW1lKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCAnbnVtYmVyJywgdmFsdWUpXG4gIH1cbn1cblxuZnVuY3Rpb24gYm91bmRzRXJyb3IgKHZhbHVlLCBsZW5ndGgsIHR5cGUpIHtcbiAgaWYgKE1hdGguZmxvb3IodmFsdWUpICE9PSB2YWx1ZSkge1xuICAgIHZhbGlkYXRlTnVtYmVyKHZhbHVlLCB0eXBlKVxuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSh0eXBlIHx8ICdvZmZzZXQnLCAnYW4gaW50ZWdlcicsIHZhbHVlKVxuICB9XG5cbiAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9CVUZGRVJfT1VUX09GX0JPVU5EUygpXG4gIH1cblxuICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UodHlwZSB8fCAnb2Zmc2V0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGA+PSAke3R5cGUgPyAxIDogMH0gYW5kIDw9ICR7bGVuZ3RofWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSlcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG5jb25zdCBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXG4gIHN0ciA9IHN0ci5zcGxpdCgnPScpWzBdXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgbGV0IGNvZGVQb2ludFxuICBjb25zdCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIGxldCBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICBjb25zdCBieXRlcyA9IFtdXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIGNvbnN0IGJ5dGVBcnJheSA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgbGV0IGMsIGhpLCBsb1xuICBjb25zdCBieXRlQXJyYXkgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGxldCBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG4vLyBBcnJheUJ1ZmZlciBvciBVaW50OEFycmF5IG9iamVjdHMgZnJvbSBvdGhlciBjb250ZXh0cyAoaS5lLiBpZnJhbWVzKSBkbyBub3QgcGFzc1xuLy8gdGhlIGBpbnN0YW5jZW9mYCBjaGVjayBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyBvZiB0aGF0IHR5cGUuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjZcbmZ1bmN0aW9uIGlzSW5zdGFuY2UgKG9iaiwgdHlwZSkge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgdHlwZSB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSAhPSBudWxsICYmXG4gICAgICBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gdHlwZS5uYW1lKVxufVxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICAvLyBGb3IgSUUxMSBzdXBwb3J0XG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG4vLyBDcmVhdGUgbG9va3VwIHRhYmxlIGZvciBgdG9TdHJpbmcoJ2hleCcpYFxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMjE5XG5jb25zdCBoZXhTbGljZUxvb2t1cFRhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgYWxwaGFiZXQgPSAnMDEyMzQ1Njc4OWFiY2RlZidcbiAgY29uc3QgdGFibGUgPSBuZXcgQXJyYXkoMjU2KVxuICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICBjb25zdCBpMTYgPSBpICogMTZcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDE2OyArK2opIHtcbiAgICAgIHRhYmxlW2kxNiArIGpdID0gYWxwaGFiZXRbaV0gKyBhbHBoYWJldFtqXVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFibGVcbn0pKClcblxuLy8gUmV0dXJuIG5vdCBmdW5jdGlvbiB3aXRoIEVycm9yIGlmIEJpZ0ludCBub3Qgc3VwcG9ydGVkXG5mdW5jdGlvbiBkZWZpbmVCaWdJbnRNZXRob2QgKGZuKSB7XG4gIHJldHVybiB0eXBlb2YgQmlnSW50ID09PSAndW5kZWZpbmVkJyA/IEJ1ZmZlckJpZ0ludE5vdERlZmluZWQgOiBmblxufVxuXG5mdW5jdGlvbiBCdWZmZXJCaWdJbnROb3REZWZpbmVkICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdCaWdJbnQgbm90IHN1cHBvcnRlZCcpXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/buffer/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/html-parse-stringify/dist/html-parse-stringify.module.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/html-parse-stringify/dist/html-parse-stringify.module.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var void_elements__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! void-elements */ \"(app-pages-browser)/../../node_modules/void-elements/index.js\");\n/* harmony import */ var void_elements__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(void_elements__WEBPACK_IMPORTED_MODULE_0__);\nvar t=/\\s([^'\"/\\s><]+?)[\\s/>]|([^\\s=]+)=\\s?(\".*?\"|'.*?')/g;function n(n){var r={type:\"tag\",name:\"\",voidElement:!1,attrs:{},children:[]},i=n.match(/<\\/?([^\\s]+?)[/\\s>]/);if(i&&(r.name=i[1],((void_elements__WEBPACK_IMPORTED_MODULE_0___default())[i[1]]||\"/\"===n.charAt(n.length-2))&&(r.voidElement=!0),r.name.startsWith(\"!--\"))){var s=n.indexOf(\"--\\x3e\");return{type:\"comment\",comment:-1!==s?n.slice(4,s):\"\"}}for(var a=new RegExp(t),c=null;null!==(c=a.exec(n));)if(c[0].trim())if(c[1]){var o=c[1].trim(),l=[o,\"\"];o.indexOf(\"=\")>-1&&(l=o.split(\"=\")),r.attrs[l[0]]=l[1],a.lastIndex--}else c[2]&&(r.attrs[c[2]]=c[3].trim().substring(1,c[3].length-1));return r}var r=/<[a-zA-Z0-9\\-\\!\\/](?:\"[^\"]*\"|'[^']*'|[^'\">])*>/g,i=/^\\s*$/,s=Object.create(null);function a(e,t){switch(t.type){case\"text\":return e+t.content;case\"tag\":return e+=\"<\"+t.name+(t.attrs?function(e){var t=[];for(var n in e)t.push(n+'=\"'+e[n]+'\"');return t.length?\" \"+t.join(\" \"):\"\"}(t.attrs):\"\")+(t.voidElement?\"/>\":\">\"),t.voidElement?e:e+t.children.reduce(a,\"\")+\"</\"+t.name+\">\";case\"comment\":return e+\"\\x3c!--\"+t.comment+\"--\\x3e\"}}var c={parse:function(e,t){t||(t={}),t.components||(t.components=s);var a,c=[],o=[],l=-1,m=!1;if(0!==e.indexOf(\"<\")){var u=e.indexOf(\"<\");c.push({type:\"text\",content:-1===u?e:e.substring(0,u)})}return e.replace(r,function(r,s){if(m){if(r!==\"</\"+a.name+\">\")return;m=!1}var u,f=\"/\"!==r.charAt(1),h=r.startsWith(\"\\x3c!--\"),p=s+r.length,d=e.charAt(p);if(h){var v=n(r);return l<0?(c.push(v),c):((u=o[l]).children.push(v),c)}if(f&&(l++,\"tag\"===(a=n(r)).type&&t.components[a.name]&&(a.type=\"component\",m=!0),a.voidElement||m||!d||\"<\"===d||a.children.push({type:\"text\",content:e.slice(p,e.indexOf(\"<\",p))}),0===l&&c.push(a),(u=o[l-1])&&u.children.push(a),o[l]=a),(!f||a.voidElement)&&(l>-1&&(a.voidElement||a.name===r.slice(2,-1))&&(l--,a=-1===l?c:o[l]),!m&&\"<\"!==d&&d)){u=-1===l?c:o[l].children;var x=e.indexOf(\"<\",p),g=e.slice(p,-1===x?void 0:x);i.test(g)&&(g=\" \"),(x>-1&&l+u.length>=0||\" \"!==g)&&u.push({type:\"text\",content:g})}}),c},stringify:function(e){return e.reduce(function(e,t){return e+a(\"\",t)},\"\")}};/* harmony default export */ __webpack_exports__[\"default\"] = (c);\n//# sourceMappingURL=html-parse-stringify.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvaHRtbC1wYXJzZS1zdHJpbmdpZnkvZGlzdC9odG1sLXBhcnNlLXN0cmluZ2lmeS5tb2R1bGUuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQTZCLDJEQUEyRCxjQUFjLE9BQU8sMENBQTBDLGFBQWEsa0NBQWtDLG9CQUFvQixzREFBQyxtRkFBbUYsMEJBQTBCLE9BQU8sK0NBQStDLCtCQUErQixxQkFBcUIseUJBQXlCLDJCQUEyQixxRUFBcUUsa0VBQWtFLFNBQVMsd0ZBQXdGLGdCQUFnQixlQUFlLDhCQUE4QixvREFBb0QsU0FBUyx1Q0FBdUMsbUNBQW1DLGlHQUFpRyxxREFBcUQsT0FBTyxvQkFBb0IsUUFBUSxpQ0FBaUMsMEJBQTBCLHVCQUF1QixxQkFBcUIsUUFBUSw4Q0FBOEMsRUFBRSxpQ0FBaUMsTUFBTSw4QkFBOEIsS0FBSywrRUFBK0UsTUFBTSxXQUFXLHVEQUF1RCxrSUFBa0ksZ0RBQWdELHNLQUFzSyx5QkFBeUIsb0RBQW9ELDJEQUEyRCxzQkFBc0IsR0FBRyxJQUFJLHVCQUF1Qiw4QkFBOEIsaUJBQWlCLE9BQU8sK0RBQWUsQ0FBQyxFQUFDO0FBQ3RpRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWwtcGFyc2Utc3RyaW5naWZ5L2Rpc3QvaHRtbC1wYXJzZS1zdHJpbmdpZnkubW9kdWxlLmpzP2YwODciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGUgZnJvbVwidm9pZC1lbGVtZW50c1wiO3ZhciB0PS9cXHMoW14nXCIvXFxzPjxdKz8pW1xccy8+XXwoW15cXHM9XSspPVxccz8oXCIuKj9cInwnLio/JykvZztmdW5jdGlvbiBuKG4pe3ZhciByPXt0eXBlOlwidGFnXCIsbmFtZTpcIlwiLHZvaWRFbGVtZW50OiExLGF0dHJzOnt9LGNoaWxkcmVuOltdfSxpPW4ubWF0Y2goLzxcXC8/KFteXFxzXSs/KVsvXFxzPl0vKTtpZihpJiYoci5uYW1lPWlbMV0sKGVbaVsxXV18fFwiL1wiPT09bi5jaGFyQXQobi5sZW5ndGgtMikpJiYoci52b2lkRWxlbWVudD0hMCksci5uYW1lLnN0YXJ0c1dpdGgoXCIhLS1cIikpKXt2YXIgcz1uLmluZGV4T2YoXCItLVxceDNlXCIpO3JldHVybnt0eXBlOlwiY29tbWVudFwiLGNvbW1lbnQ6LTEhPT1zP24uc2xpY2UoNCxzKTpcIlwifX1mb3IodmFyIGE9bmV3IFJlZ0V4cCh0KSxjPW51bGw7bnVsbCE9PShjPWEuZXhlYyhuKSk7KWlmKGNbMF0udHJpbSgpKWlmKGNbMV0pe3ZhciBvPWNbMV0udHJpbSgpLGw9W28sXCJcIl07by5pbmRleE9mKFwiPVwiKT4tMSYmKGw9by5zcGxpdChcIj1cIikpLHIuYXR0cnNbbFswXV09bFsxXSxhLmxhc3RJbmRleC0tfWVsc2UgY1syXSYmKHIuYXR0cnNbY1syXV09Y1szXS50cmltKCkuc3Vic3RyaW5nKDEsY1szXS5sZW5ndGgtMSkpO3JldHVybiByfXZhciByPS88W2EtekEtWjAtOVxcLVxcIVxcL10oPzpcIlteXCJdKlwifCdbXiddKid8W14nXCI+XSkqPi9nLGk9L15cXHMqJC8scz1PYmplY3QuY3JlYXRlKG51bGwpO2Z1bmN0aW9uIGEoZSx0KXtzd2l0Y2godC50eXBlKXtjYXNlXCJ0ZXh0XCI6cmV0dXJuIGUrdC5jb250ZW50O2Nhc2VcInRhZ1wiOnJldHVybiBlKz1cIjxcIit0Lm5hbWUrKHQuYXR0cnM/ZnVuY3Rpb24oZSl7dmFyIHQ9W107Zm9yKHZhciBuIGluIGUpdC5wdXNoKG4rJz1cIicrZVtuXSsnXCInKTtyZXR1cm4gdC5sZW5ndGg/XCIgXCIrdC5qb2luKFwiIFwiKTpcIlwifSh0LmF0dHJzKTpcIlwiKSsodC52b2lkRWxlbWVudD9cIi8+XCI6XCI+XCIpLHQudm9pZEVsZW1lbnQ/ZTplK3QuY2hpbGRyZW4ucmVkdWNlKGEsXCJcIikrXCI8L1wiK3QubmFtZStcIj5cIjtjYXNlXCJjb21tZW50XCI6cmV0dXJuIGUrXCJcXHgzYyEtLVwiK3QuY29tbWVudCtcIi0tXFx4M2VcIn19dmFyIGM9e3BhcnNlOmZ1bmN0aW9uKGUsdCl7dHx8KHQ9e30pLHQuY29tcG9uZW50c3x8KHQuY29tcG9uZW50cz1zKTt2YXIgYSxjPVtdLG89W10sbD0tMSxtPSExO2lmKDAhPT1lLmluZGV4T2YoXCI8XCIpKXt2YXIgdT1lLmluZGV4T2YoXCI8XCIpO2MucHVzaCh7dHlwZTpcInRleHRcIixjb250ZW50Oi0xPT09dT9lOmUuc3Vic3RyaW5nKDAsdSl9KX1yZXR1cm4gZS5yZXBsYWNlKHIsZnVuY3Rpb24ocixzKXtpZihtKXtpZihyIT09XCI8L1wiK2EubmFtZStcIj5cIilyZXR1cm47bT0hMX12YXIgdSxmPVwiL1wiIT09ci5jaGFyQXQoMSksaD1yLnN0YXJ0c1dpdGgoXCJcXHgzYyEtLVwiKSxwPXMrci5sZW5ndGgsZD1lLmNoYXJBdChwKTtpZihoKXt2YXIgdj1uKHIpO3JldHVybiBsPDA/KGMucHVzaCh2KSxjKTooKHU9b1tsXSkuY2hpbGRyZW4ucHVzaCh2KSxjKX1pZihmJiYobCsrLFwidGFnXCI9PT0oYT1uKHIpKS50eXBlJiZ0LmNvbXBvbmVudHNbYS5uYW1lXSYmKGEudHlwZT1cImNvbXBvbmVudFwiLG09ITApLGEudm9pZEVsZW1lbnR8fG18fCFkfHxcIjxcIj09PWR8fGEuY2hpbGRyZW4ucHVzaCh7dHlwZTpcInRleHRcIixjb250ZW50OmUuc2xpY2UocCxlLmluZGV4T2YoXCI8XCIscCkpfSksMD09PWwmJmMucHVzaChhKSwodT1vW2wtMV0pJiZ1LmNoaWxkcmVuLnB1c2goYSksb1tsXT1hKSwoIWZ8fGEudm9pZEVsZW1lbnQpJiYobD4tMSYmKGEudm9pZEVsZW1lbnR8fGEubmFtZT09PXIuc2xpY2UoMiwtMSkpJiYobC0tLGE9LTE9PT1sP2M6b1tsXSksIW0mJlwiPFwiIT09ZCYmZCkpe3U9LTE9PT1sP2M6b1tsXS5jaGlsZHJlbjt2YXIgeD1lLmluZGV4T2YoXCI8XCIscCksZz1lLnNsaWNlKHAsLTE9PT14P3ZvaWQgMDp4KTtpLnRlc3QoZykmJihnPVwiIFwiKSwoeD4tMSYmbCt1Lmxlbmd0aD49MHx8XCIgXCIhPT1nKSYmdS5wdXNoKHt0eXBlOlwidGV4dFwiLGNvbnRlbnQ6Z30pfX0pLGN9LHN0cmluZ2lmeTpmdW5jdGlvbihlKXtyZXR1cm4gZS5yZWR1Y2UoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZSthKFwiXCIsdCl9LFwiXCIpfX07ZXhwb3J0IGRlZmF1bHQgYztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWh0bWwtcGFyc2Utc3RyaW5naWZ5Lm1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/html-parse-stringify/dist/html-parse-stringify.module.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/ieee754/index.js":
/*!*******************************************!*\
  !*** ../../node_modules/ieee754/index.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsV0FBVzs7QUFFcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUyxXQUFXOztBQUVwQjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLFdBQVc7O0FBRXBCO0FBQ0E7QUFDQSxTQUFTLFVBQVU7O0FBRW5CO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzPzZhZGEiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIGllZWU3NTQuIEJTRC0zLUNsYXVzZSBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/ieee754/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/iso-url/index.js":
/*!*******************************************!*\
  !*** ../../node_modules/iso-url/index.js ***!
  \*******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nconst {\n    URLWithLegacySupport,\n    format,\n    URLSearchParams,\n    defaultBase\n} = __webpack_require__(/*! ./src/url */ \"(app-pages-browser)/../../node_modules/iso-url/src/url-browser.js\");\nconst relative = __webpack_require__(/*! ./src/relative */ \"(app-pages-browser)/../../node_modules/iso-url/src/relative.js\");\n\nmodule.exports = {\n    URL: URLWithLegacySupport,\n    URLSearchParams,\n    format,\n    relative,\n    defaultBase\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvaXNvLXVybC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsb0ZBQVc7QUFDdkIsaUJBQWlCLG1CQUFPLENBQUMsc0ZBQWdCOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL2lzby11cmwvaW5kZXguanM/NmEyYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHtcbiAgICBVUkxXaXRoTGVnYWN5U3VwcG9ydCxcbiAgICBmb3JtYXQsXG4gICAgVVJMU2VhcmNoUGFyYW1zLFxuICAgIGRlZmF1bHRCYXNlXG59ID0gcmVxdWlyZSgnLi9zcmMvdXJsJyk7XG5jb25zdCByZWxhdGl2ZSA9IHJlcXVpcmUoJy4vc3JjL3JlbGF0aXZlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIFVSTDogVVJMV2l0aExlZ2FjeVN1cHBvcnQsXG4gICAgVVJMU2VhcmNoUGFyYW1zLFxuICAgIGZvcm1hdCxcbiAgICByZWxhdGl2ZSxcbiAgICBkZWZhdWx0QmFzZVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/iso-url/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/iso-url/src/relative.js":
/*!**************************************************!*\
  !*** ../../node_modules/iso-url/src/relative.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nconst { URLWithLegacySupport, format } = __webpack_require__(/*! ./url */ \"(app-pages-browser)/../../node_modules/iso-url/src/url-browser.js\");\n\nmodule.exports = (url, location = {}, protocolMap = {}, defaultProtocol) => {\n    let protocol = location.protocol ?\n        location.protocol.replace(':', '') :\n        'http';\n\n    // Check protocol map\n    protocol = (protocolMap[protocol] || defaultProtocol || protocol) + ':';\n    let urlParsed;\n\n    try {\n        urlParsed = new URLWithLegacySupport(url);\n    } catch (err) {\n        urlParsed = {};\n    }\n\n    const base = Object.assign({}, location, {\n        protocol: protocol || urlParsed.protocol,\n        host: location.host || urlParsed.host\n    });\n\n    return new URLWithLegacySupport(url, format(base)).toString();\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvaXNvLXVybC9zcmMvcmVsYXRpdmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsUUFBUSwrQkFBK0IsRUFBRSxtQkFBTyxDQUFDLGdGQUFPOztBQUV4RCxvQ0FBb0Msa0JBQWtCO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvaXNvLXVybC9zcmMvcmVsYXRpdmUuanM/NDQ1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgVVJMV2l0aExlZ2FjeVN1cHBvcnQsIGZvcm1hdCB9ID0gcmVxdWlyZSgnLi91cmwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAodXJsLCBsb2NhdGlvbiA9IHt9LCBwcm90b2NvbE1hcCA9IHt9LCBkZWZhdWx0UHJvdG9jb2wpID0+IHtcbiAgICBsZXQgcHJvdG9jb2wgPSBsb2NhdGlvbi5wcm90b2NvbCA/XG4gICAgICAgIGxvY2F0aW9uLnByb3RvY29sLnJlcGxhY2UoJzonLCAnJykgOlxuICAgICAgICAnaHR0cCc7XG5cbiAgICAvLyBDaGVjayBwcm90b2NvbCBtYXBcbiAgICBwcm90b2NvbCA9IChwcm90b2NvbE1hcFtwcm90b2NvbF0gfHwgZGVmYXVsdFByb3RvY29sIHx8IHByb3RvY29sKSArICc6JztcbiAgICBsZXQgdXJsUGFyc2VkO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgdXJsUGFyc2VkID0gbmV3IFVSTFdpdGhMZWdhY3lTdXBwb3J0KHVybCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHVybFBhcnNlZCA9IHt9O1xuICAgIH1cblxuICAgIGNvbnN0IGJhc2UgPSBPYmplY3QuYXNzaWduKHt9LCBsb2NhdGlvbiwge1xuICAgICAgICBwcm90b2NvbDogcHJvdG9jb2wgfHwgdXJsUGFyc2VkLnByb3RvY29sLFxuICAgICAgICBob3N0OiBsb2NhdGlvbi5ob3N0IHx8IHVybFBhcnNlZC5ob3N0XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmV3IFVSTFdpdGhMZWdhY3lTdXBwb3J0KHVybCwgZm9ybWF0KGJhc2UpKS50b1N0cmluZygpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/iso-url/src/relative.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/iso-url/src/url-browser.js":
/*!*****************************************************!*\
  !*** ../../node_modules/iso-url/src/url-browser.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nconst defaultBase = self.location ?\n    self.location.protocol + '//' + self.location.host :\n    '';\nconst URL = self.URL;\n\nclass URLWithLegacySupport {\n    constructor(url = '', base = defaultBase) {\n        this.super = new URL(url, base);\n        this.path = this.pathname + this.search;\n        this.auth =\n            this.username && this.password ?\n                this.username + ':' + this.password :\n                null;\n\n        this.query =\n            this.search && this.search.startsWith('?') ?\n                this.search.slice(1) :\n                null;\n    }\n\n    get hash() {\n        return this.super.hash;\n    }\n    get host() {\n        return this.super.host;\n    }\n    get hostname() {\n        return this.super.hostname;\n    }\n    get href() {\n        return this.super.href;\n    }\n    get origin() {\n        return this.super.origin;\n    }\n    get password() {\n        return this.super.password;\n    }\n    get pathname() {\n        return this.super.pathname;\n    }\n    get port() {\n        return this.super.port;\n    }\n    get protocol() {\n        return this.super.protocol;\n    }\n    get search() {\n        return this.super.search;\n    }\n    get searchParams() {\n        return this.super.searchParams;\n    }\n    get username() {\n        return this.super.username;\n    }\n\n    set hash(hash) {\n        this.super.hash = hash;\n    }\n    set host(host) {\n        this.super.host = host;\n    }\n    set hostname(hostname) {\n        this.super.hostname = hostname;\n    }\n    set href(href) {\n        this.super.href = href;\n    }\n    set origin(origin) {\n        this.super.origin = origin;\n    }\n    set password(password) {\n        this.super.password = password;\n    }\n    set pathname(pathname) {\n        this.super.pathname = pathname;\n    }\n    set port(port) {\n        this.super.port = port;\n    }\n    set protocol(protocol) {\n        this.super.protocol = protocol;\n    }\n    set search(search) {\n        this.super.search = search;\n    }\n    set searchParams(searchParams) {\n        this.super.searchParams = searchParams;\n    }\n    set username(username) {\n        this.super.username = username;\n    }\n\n    createObjectURL(o) {\n        return this.super.createObjectURL(o);\n    }\n    revokeObjectURL(o) {\n        this.super.revokeObjectURL(o);\n    }\n    toJSON() {\n        return this.super.toJSON();\n    }\n    toString() {\n        return this.super.toString();\n    }\n    format() {\n        return this.toString();\n    }\n}\n\nfunction format(obj) {\n    if (typeof obj === 'string') {\n        const url = new URL(obj);\n\n        return url.toString();\n    }\n\n    if (!(obj instanceof URL)) {\n        const userPass =\n            obj.username && obj.password ?\n                `${obj.username}:${obj.password}@` :\n                '';\n        const auth = obj.auth ? obj.auth + '@' : '';\n        const port = obj.port ? ':' + obj.port : '';\n        const protocol = obj.protocol ? obj.protocol + '//' : '';\n        const host = obj.host || '';\n        const hostname = obj.hostname || '';\n        const search = obj.search || (obj.query ? '?' + obj.query : '');\n        const hash = obj.hash || '';\n        const pathname = obj.pathname || '';\n        const path = obj.path || pathname + search;\n\n        return `${protocol}${userPass || auth}${host ||\n            hostname + port}${path}${hash}`;\n    }\n}\n\nmodule.exports = {\n    URLWithLegacySupport,\n    URLSearchParams: self.URLSearchParams,\n    defaultBase,\n    format\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvaXNvLXVybC9zcmMvdXJsLWJyb3dzZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGFBQWEsR0FBRyxhQUFhO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTLEVBQUUsaUJBQWlCLEVBQUU7QUFDaEQsNEJBQTRCLEVBQUUsS0FBSyxFQUFFLEtBQUs7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9pc28tdXJsL3NyYy91cmwtYnJvd3Nlci5qcz9jMzdlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZGVmYXVsdEJhc2UgPSBzZWxmLmxvY2F0aW9uID9cbiAgICBzZWxmLmxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIHNlbGYubG9jYXRpb24uaG9zdCA6XG4gICAgJyc7XG5jb25zdCBVUkwgPSBzZWxmLlVSTDtcblxuY2xhc3MgVVJMV2l0aExlZ2FjeVN1cHBvcnQge1xuICAgIGNvbnN0cnVjdG9yKHVybCA9ICcnLCBiYXNlID0gZGVmYXVsdEJhc2UpIHtcbiAgICAgICAgdGhpcy5zdXBlciA9IG5ldyBVUkwodXJsLCBiYXNlKTtcbiAgICAgICAgdGhpcy5wYXRoID0gdGhpcy5wYXRobmFtZSArIHRoaXMuc2VhcmNoO1xuICAgICAgICB0aGlzLmF1dGggPVxuICAgICAgICAgICAgdGhpcy51c2VybmFtZSAmJiB0aGlzLnBhc3N3b3JkID9cbiAgICAgICAgICAgICAgICB0aGlzLnVzZXJuYW1lICsgJzonICsgdGhpcy5wYXNzd29yZCA6XG4gICAgICAgICAgICAgICAgbnVsbDtcblxuICAgICAgICB0aGlzLnF1ZXJ5ID1cbiAgICAgICAgICAgIHRoaXMuc2VhcmNoICYmIHRoaXMuc2VhcmNoLnN0YXJ0c1dpdGgoJz8nKSA/XG4gICAgICAgICAgICAgICAgdGhpcy5zZWFyY2guc2xpY2UoMSkgOlxuICAgICAgICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgZ2V0IGhhc2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyLmhhc2g7XG4gICAgfVxuICAgIGdldCBob3N0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdXBlci5ob3N0O1xuICAgIH1cbiAgICBnZXQgaG9zdG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyLmhvc3RuYW1lO1xuICAgIH1cbiAgICBnZXQgaHJlZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwZXIuaHJlZjtcbiAgICB9XG4gICAgZ2V0IG9yaWdpbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwZXIub3JpZ2luO1xuICAgIH1cbiAgICBnZXQgcGFzc3dvcmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyLnBhc3N3b3JkO1xuICAgIH1cbiAgICBnZXQgcGF0aG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyLnBhdGhuYW1lO1xuICAgIH1cbiAgICBnZXQgcG9ydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwZXIucG9ydDtcbiAgICB9XG4gICAgZ2V0IHByb3RvY29sKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdXBlci5wcm90b2NvbDtcbiAgICB9XG4gICAgZ2V0IHNlYXJjaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwZXIuc2VhcmNoO1xuICAgIH1cbiAgICBnZXQgc2VhcmNoUGFyYW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdXBlci5zZWFyY2hQYXJhbXM7XG4gICAgfVxuICAgIGdldCB1c2VybmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwZXIudXNlcm5hbWU7XG4gICAgfVxuXG4gICAgc2V0IGhhc2goaGFzaCkge1xuICAgICAgICB0aGlzLnN1cGVyLmhhc2ggPSBoYXNoO1xuICAgIH1cbiAgICBzZXQgaG9zdChob3N0KSB7XG4gICAgICAgIHRoaXMuc3VwZXIuaG9zdCA9IGhvc3Q7XG4gICAgfVxuICAgIHNldCBob3N0bmFtZShob3N0bmFtZSkge1xuICAgICAgICB0aGlzLnN1cGVyLmhvc3RuYW1lID0gaG9zdG5hbWU7XG4gICAgfVxuICAgIHNldCBocmVmKGhyZWYpIHtcbiAgICAgICAgdGhpcy5zdXBlci5ocmVmID0gaHJlZjtcbiAgICB9XG4gICAgc2V0IG9yaWdpbihvcmlnaW4pIHtcbiAgICAgICAgdGhpcy5zdXBlci5vcmlnaW4gPSBvcmlnaW47XG4gICAgfVxuICAgIHNldCBwYXNzd29yZChwYXNzd29yZCkge1xuICAgICAgICB0aGlzLnN1cGVyLnBhc3N3b3JkID0gcGFzc3dvcmQ7XG4gICAgfVxuICAgIHNldCBwYXRobmFtZShwYXRobmFtZSkge1xuICAgICAgICB0aGlzLnN1cGVyLnBhdGhuYW1lID0gcGF0aG5hbWU7XG4gICAgfVxuICAgIHNldCBwb3J0KHBvcnQpIHtcbiAgICAgICAgdGhpcy5zdXBlci5wb3J0ID0gcG9ydDtcbiAgICB9XG4gICAgc2V0IHByb3RvY29sKHByb3RvY29sKSB7XG4gICAgICAgIHRoaXMuc3VwZXIucHJvdG9jb2wgPSBwcm90b2NvbDtcbiAgICB9XG4gICAgc2V0IHNlYXJjaChzZWFyY2gpIHtcbiAgICAgICAgdGhpcy5zdXBlci5zZWFyY2ggPSBzZWFyY2g7XG4gICAgfVxuICAgIHNldCBzZWFyY2hQYXJhbXMoc2VhcmNoUGFyYW1zKSB7XG4gICAgICAgIHRoaXMuc3VwZXIuc2VhcmNoUGFyYW1zID0gc2VhcmNoUGFyYW1zO1xuICAgIH1cbiAgICBzZXQgdXNlcm5hbWUodXNlcm5hbWUpIHtcbiAgICAgICAgdGhpcy5zdXBlci51c2VybmFtZSA9IHVzZXJuYW1lO1xuICAgIH1cblxuICAgIGNyZWF0ZU9iamVjdFVSTChvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyLmNyZWF0ZU9iamVjdFVSTChvKTtcbiAgICB9XG4gICAgcmV2b2tlT2JqZWN0VVJMKG8pIHtcbiAgICAgICAgdGhpcy5zdXBlci5yZXZva2VPYmplY3RVUkwobyk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwZXIudG9KU09OKCk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdXBlci50b1N0cmluZygpO1xuICAgIH1cbiAgICBmb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmb3JtYXQob2JqKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwob2JqKTtcblxuICAgICAgICByZXR1cm4gdXJsLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgaWYgKCEob2JqIGluc3RhbmNlb2YgVVJMKSkge1xuICAgICAgICBjb25zdCB1c2VyUGFzcyA9XG4gICAgICAgICAgICBvYmoudXNlcm5hbWUgJiYgb2JqLnBhc3N3b3JkID9cbiAgICAgICAgICAgICAgICBgJHtvYmoudXNlcm5hbWV9OiR7b2JqLnBhc3N3b3JkfUBgIDpcbiAgICAgICAgICAgICAgICAnJztcbiAgICAgICAgY29uc3QgYXV0aCA9IG9iai5hdXRoID8gb2JqLmF1dGggKyAnQCcgOiAnJztcbiAgICAgICAgY29uc3QgcG9ydCA9IG9iai5wb3J0ID8gJzonICsgb2JqLnBvcnQgOiAnJztcbiAgICAgICAgY29uc3QgcHJvdG9jb2wgPSBvYmoucHJvdG9jb2wgPyBvYmoucHJvdG9jb2wgKyAnLy8nIDogJyc7XG4gICAgICAgIGNvbnN0IGhvc3QgPSBvYmouaG9zdCB8fCAnJztcbiAgICAgICAgY29uc3QgaG9zdG5hbWUgPSBvYmouaG9zdG5hbWUgfHwgJyc7XG4gICAgICAgIGNvbnN0IHNlYXJjaCA9IG9iai5zZWFyY2ggfHwgKG9iai5xdWVyeSA/ICc/JyArIG9iai5xdWVyeSA6ICcnKTtcbiAgICAgICAgY29uc3QgaGFzaCA9IG9iai5oYXNoIHx8ICcnO1xuICAgICAgICBjb25zdCBwYXRobmFtZSA9IG9iai5wYXRobmFtZSB8fCAnJztcbiAgICAgICAgY29uc3QgcGF0aCA9IG9iai5wYXRoIHx8IHBhdGhuYW1lICsgc2VhcmNoO1xuXG4gICAgICAgIHJldHVybiBgJHtwcm90b2NvbH0ke3VzZXJQYXNzIHx8IGF1dGh9JHtob3N0IHx8XG4gICAgICAgICAgICBob3N0bmFtZSArIHBvcnR9JHtwYXRofSR7aGFzaH1gO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgVVJMV2l0aExlZ2FjeVN1cHBvcnQsXG4gICAgVVJMU2VhcmNoUGFyYW1zOiBzZWxmLlVSTFNlYXJjaFBhcmFtcyxcbiAgICBkZWZhdWx0QmFzZSxcbiAgICBmb3JtYXRcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/iso-url/src/url-browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/simple-cbor/src/index.js":
/*!***************************************************!*\
  !*** ../../node_modules/simple-cbor/src/index.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__export(__webpack_require__(/*! ./serializer */ \"(app-pages-browser)/../../node_modules/simple-cbor/src/serializer.js\"));\nconst value = __importStar(__webpack_require__(/*! ./value */ \"(app-pages-browser)/../../node_modules/simple-cbor/src/value.js\"));\nexports.value = value;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvc2ltcGxlLWNib3Ivc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsU0FBUyxtQkFBTyxDQUFDLDBGQUFjO0FBQy9CLDJCQUEyQixtQkFBTyxDQUFDLGdGQUFTO0FBQzVDLGFBQWE7QUFDYiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL3NpbXBsZS1jYm9yL3NyYy9pbmRleC5qcz9kYjZlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3NlcmlhbGl6ZXJcIikpO1xuY29uc3QgdmFsdWUgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdmFsdWVcIikpO1xuZXhwb3J0cy52YWx1ZSA9IHZhbHVlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/simple-cbor/src/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/simple-cbor/src/serializer.js":
/*!********************************************************!*\
  !*** ../../node_modules/simple-cbor/src/serializer.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst cbor = __importStar(__webpack_require__(/*! ./value */ \"(app-pages-browser)/../../node_modules/simple-cbor/src/value.js\"));\nconst BufferClasses = [\n    ArrayBuffer,\n    Uint8Array,\n    Uint16Array,\n    Uint32Array,\n    Int8Array,\n    Int16Array,\n    Int32Array,\n    Float32Array,\n    Float64Array,\n];\nclass JsonDefaultCborEncoder {\n    // @param _serializer The CBOR Serializer to use.\n    // @param _stable Whether or not keys from objects should be sorted (stable). This is\n    //     particularly useful when testing encodings between JSON objects.\n    constructor(_serializer, _stable = false) {\n        this._serializer = _serializer;\n        this._stable = _stable;\n        this.name = \"jsonDefault\";\n        this.priority = -100;\n    }\n    match(value) {\n        return [\"undefined\", \"boolean\", \"number\", \"string\", \"object\"].indexOf(typeof value) != -1;\n    }\n    encode(value) {\n        switch (typeof value) {\n            case \"undefined\":\n                return cbor.undefined_();\n            case \"boolean\":\n                return cbor.bool(value);\n            case \"number\":\n                if (Math.floor(value) === value) {\n                    return cbor.number(value);\n                }\n                else {\n                    return cbor.doubleFloat(value);\n                }\n            case \"string\":\n                return cbor.string(value);\n            case \"object\":\n                if (value === null) {\n                    return cbor.null_();\n                }\n                else if (Array.isArray(value)) {\n                    return cbor.array(value.map((x) => this._serializer.serializeValue(x)));\n                }\n                else if (BufferClasses.find((x) => value instanceof x)) {\n                    return cbor.bytes(value.buffer);\n                }\n                else if (Object.getOwnPropertyNames(value).indexOf(\"toJSON\") !== -1) {\n                    return this.encode(value.toJSON());\n                }\n                else if (value instanceof Map) {\n                    const m = new Map();\n                    for (const [key, item] of value.entries()) {\n                        m.set(key, this._serializer.serializeValue(item));\n                    }\n                    return cbor.map(m, this._stable);\n                }\n                else {\n                    const m = new Map();\n                    for (const [key, item] of Object.entries(value)) {\n                        m.set(key, this._serializer.serializeValue(item));\n                    }\n                    return cbor.map(m, this._stable);\n                }\n            default:\n                throw new Error(\"Invalid value.\");\n        }\n    }\n}\nexports.JsonDefaultCborEncoder = JsonDefaultCborEncoder;\nclass ToCborEncoder {\n    constructor() {\n        this.name = \"cborEncoder\";\n        this.priority = -90;\n    }\n    match(value) {\n        return typeof value == \"object\" && typeof value[\"toCBOR\"] == \"function\";\n    }\n    encode(value) {\n        return value.toCBOR();\n    }\n}\nexports.ToCborEncoder = ToCborEncoder;\nclass CborSerializer {\n    constructor() {\n        this._encoders = new Set();\n    }\n    static withDefaultEncoders(stable = false) {\n        const s = new this();\n        s.addEncoder(new JsonDefaultCborEncoder(s, stable));\n        s.addEncoder(new ToCborEncoder());\n        return s;\n    }\n    removeEncoder(name) {\n        // Has to make an extra call to values() to ensure it doesn't break on iteration.\n        for (const encoder of this._encoders.values()) {\n            if (encoder.name == name) {\n                this._encoders.delete(encoder);\n            }\n        }\n    }\n    addEncoder(encoder) {\n        this._encoders.add(encoder);\n    }\n    getEncoderFor(value) {\n        let chosenEncoder = null;\n        for (const encoder of this._encoders) {\n            if (!chosenEncoder || encoder.priority > chosenEncoder.priority) {\n                if (encoder.match(value)) {\n                    chosenEncoder = encoder;\n                }\n            }\n        }\n        if (chosenEncoder === null) {\n            throw new Error(\"Could not find an encoder for value.\");\n        }\n        return chosenEncoder;\n    }\n    serializeValue(value) {\n        return this.getEncoderFor(value).encode(value);\n    }\n    serialize(value) {\n        return this.serializeValue(value);\n    }\n}\nexports.CborSerializer = CborSerializer;\nclass SelfDescribeCborSerializer extends CborSerializer {\n    serialize(value) {\n        return cbor.raw(new Uint8Array([\n            // Self describe CBOR.\n            ...new Uint8Array([0xd9, 0xd9, 0xf7]),\n            ...new Uint8Array(super.serializeValue(value)),\n        ]));\n    }\n}\nexports.SelfDescribeCborSerializer = SelfDescribeCborSerializer;\n//# sourceMappingURL=serializer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvc2ltcGxlLWNib3Ivc3JjL3NlcmlhbGl6ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEIsbUJBQU8sQ0FBQyxnRkFBUztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvc2ltcGxlLWNib3Ivc3JjL3NlcmlhbGl6ZXIuanM/MGNhMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNib3IgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdmFsdWVcIikpO1xuY29uc3QgQnVmZmVyQ2xhc3NlcyA9IFtcbiAgICBBcnJheUJ1ZmZlcixcbiAgICBVaW50OEFycmF5LFxuICAgIFVpbnQxNkFycmF5LFxuICAgIFVpbnQzMkFycmF5LFxuICAgIEludDhBcnJheSxcbiAgICBJbnQxNkFycmF5LFxuICAgIEludDMyQXJyYXksXG4gICAgRmxvYXQzMkFycmF5LFxuICAgIEZsb2F0NjRBcnJheSxcbl07XG5jbGFzcyBKc29uRGVmYXVsdENib3JFbmNvZGVyIHtcbiAgICAvLyBAcGFyYW0gX3NlcmlhbGl6ZXIgVGhlIENCT1IgU2VyaWFsaXplciB0byB1c2UuXG4gICAgLy8gQHBhcmFtIF9zdGFibGUgV2hldGhlciBvciBub3Qga2V5cyBmcm9tIG9iamVjdHMgc2hvdWxkIGJlIHNvcnRlZCAoc3RhYmxlKS4gVGhpcyBpc1xuICAgIC8vICAgICBwYXJ0aWN1bGFybHkgdXNlZnVsIHdoZW4gdGVzdGluZyBlbmNvZGluZ3MgYmV0d2VlbiBKU09OIG9iamVjdHMuXG4gICAgY29uc3RydWN0b3IoX3NlcmlhbGl6ZXIsIF9zdGFibGUgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLl9zZXJpYWxpemVyID0gX3NlcmlhbGl6ZXI7XG4gICAgICAgIHRoaXMuX3N0YWJsZSA9IF9zdGFibGU7XG4gICAgICAgIHRoaXMubmFtZSA9IFwianNvbkRlZmF1bHRcIjtcbiAgICAgICAgdGhpcy5wcmlvcml0eSA9IC0xMDA7XG4gICAgfVxuICAgIG1hdGNoKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBbXCJ1bmRlZmluZWRcIiwgXCJib29sZWFuXCIsIFwibnVtYmVyXCIsIFwic3RyaW5nXCIsIFwib2JqZWN0XCJdLmluZGV4T2YodHlwZW9mIHZhbHVlKSAhPSAtMTtcbiAgICB9XG4gICAgZW5jb2RlKHZhbHVlKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNib3IudW5kZWZpbmVkXygpO1xuICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gY2Jvci5ib29sKHZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYm9yLm51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2Jvci5kb3VibGVGbG9hdCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBjYm9yLnN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYm9yLm51bGxfKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYm9yLmFycmF5KHZhbHVlLm1hcCgoeCkgPT4gdGhpcy5fc2VyaWFsaXplci5zZXJpYWxpemVWYWx1ZSh4KSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChCdWZmZXJDbGFzc2VzLmZpbmQoKHgpID0+IHZhbHVlIGluc3RhbmNlb2YgeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNib3IuYnl0ZXModmFsdWUuYnVmZmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpLmluZGV4T2YoXCJ0b0pTT05cIikgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZSh2YWx1ZS50b0pTT04oKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG0gPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgaXRlbV0gb2YgdmFsdWUuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtLnNldChrZXksIHRoaXMuX3NlcmlhbGl6ZXIuc2VyaWFsaXplVmFsdWUoaXRlbSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYm9yLm1hcChtLCB0aGlzLl9zdGFibGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCBpdGVtXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uc2V0KGtleSwgdGhpcy5fc2VyaWFsaXplci5zZXJpYWxpemVWYWx1ZShpdGVtKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNib3IubWFwKG0sIHRoaXMuX3N0YWJsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZhbHVlLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuSnNvbkRlZmF1bHRDYm9yRW5jb2RlciA9IEpzb25EZWZhdWx0Q2JvckVuY29kZXI7XG5jbGFzcyBUb0Nib3JFbmNvZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJjYm9yRW5jb2RlclwiO1xuICAgICAgICB0aGlzLnByaW9yaXR5ID0gLTkwO1xuICAgIH1cbiAgICBtYXRjaCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlW1widG9DQk9SXCJdID09IFwiZnVuY3Rpb25cIjtcbiAgICB9XG4gICAgZW5jb2RlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b0NCT1IoKTtcbiAgICB9XG59XG5leHBvcnRzLlRvQ2JvckVuY29kZXIgPSBUb0Nib3JFbmNvZGVyO1xuY2xhc3MgQ2JvclNlcmlhbGl6ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9lbmNvZGVycyA9IG5ldyBTZXQoKTtcbiAgICB9XG4gICAgc3RhdGljIHdpdGhEZWZhdWx0RW5jb2RlcnMoc3RhYmxlID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgcyA9IG5ldyB0aGlzKCk7XG4gICAgICAgIHMuYWRkRW5jb2RlcihuZXcgSnNvbkRlZmF1bHRDYm9yRW5jb2RlcihzLCBzdGFibGUpKTtcbiAgICAgICAgcy5hZGRFbmNvZGVyKG5ldyBUb0Nib3JFbmNvZGVyKCkpO1xuICAgICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgcmVtb3ZlRW5jb2RlcihuYW1lKSB7XG4gICAgICAgIC8vIEhhcyB0byBtYWtlIGFuIGV4dHJhIGNhbGwgdG8gdmFsdWVzKCkgdG8gZW5zdXJlIGl0IGRvZXNuJ3QgYnJlYWsgb24gaXRlcmF0aW9uLlxuICAgICAgICBmb3IgKGNvbnN0IGVuY29kZXIgb2YgdGhpcy5fZW5jb2RlcnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChlbmNvZGVyLm5hbWUgPT0gbmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VuY29kZXJzLmRlbGV0ZShlbmNvZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRFbmNvZGVyKGVuY29kZXIpIHtcbiAgICAgICAgdGhpcy5fZW5jb2RlcnMuYWRkKGVuY29kZXIpO1xuICAgIH1cbiAgICBnZXRFbmNvZGVyRm9yKHZhbHVlKSB7XG4gICAgICAgIGxldCBjaG9zZW5FbmNvZGVyID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBlbmNvZGVyIG9mIHRoaXMuX2VuY29kZXJzKSB7XG4gICAgICAgICAgICBpZiAoIWNob3NlbkVuY29kZXIgfHwgZW5jb2Rlci5wcmlvcml0eSA+IGNob3NlbkVuY29kZXIucHJpb3JpdHkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW5jb2Rlci5tYXRjaCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hvc2VuRW5jb2RlciA9IGVuY29kZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjaG9zZW5FbmNvZGVyID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBhbiBlbmNvZGVyIGZvciB2YWx1ZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNob3NlbkVuY29kZXI7XG4gICAgfVxuICAgIHNlcmlhbGl6ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEVuY29kZXJGb3IodmFsdWUpLmVuY29kZSh2YWx1ZSk7XG4gICAgfVxuICAgIHNlcmlhbGl6ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVWYWx1ZSh2YWx1ZSk7XG4gICAgfVxufVxuZXhwb3J0cy5DYm9yU2VyaWFsaXplciA9IENib3JTZXJpYWxpemVyO1xuY2xhc3MgU2VsZkRlc2NyaWJlQ2JvclNlcmlhbGl6ZXIgZXh0ZW5kcyBDYm9yU2VyaWFsaXplciB7XG4gICAgc2VyaWFsaXplKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjYm9yLnJhdyhuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAvLyBTZWxmIGRlc2NyaWJlIENCT1IuXG4gICAgICAgICAgICAuLi5uZXcgVWludDhBcnJheShbMHhkOSwgMHhkOSwgMHhmN10pLFxuICAgICAgICAgICAgLi4ubmV3IFVpbnQ4QXJyYXkoc3VwZXIuc2VyaWFsaXplVmFsdWUodmFsdWUpKSxcbiAgICAgICAgXSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2VsZkRlc2NyaWJlQ2JvclNlcmlhbGl6ZXIgPSBTZWxmRGVzY3JpYmVDYm9yU2VyaWFsaXplcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcmlhbGl6ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/simple-cbor/src/serializer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/simple-cbor/src/value.js":
/*!***************************************************!*\
  !*** ../../node_modules/simple-cbor/src/value.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst MAX_U64_NUMBER = 0x20000000000000;\nfunction _concat(a, ...args) {\n    const newBuffer = new Uint8Array(a.byteLength + args.reduce((acc, b) => acc + b.byteLength, 0));\n    newBuffer.set(new Uint8Array(a), 0);\n    let i = a.byteLength;\n    for (const b of args) {\n        newBuffer.set(new Uint8Array(b), i);\n        i += b.byteLength;\n    }\n    return newBuffer.buffer;\n}\nfunction _serializeValue(major, minor, value) {\n    // Remove everything that's not an hexadecimal character. These are not\n    // considered errors since the value was already validated and they might\n    // be number decimals or sign.\n    value = value.replace(/[^0-9a-fA-F]/g, \"\");\n    // Create the buffer from the value with left padding with 0.\n    const length = 2 ** (minor - 24 /* Int8 */);\n    value = value.slice(-length * 2).padStart(length * 2, \"0\");\n    const bytes = [(major << 5) + minor].concat(value.match(/../g).map((byte) => parseInt(byte, 16)));\n    return new Uint8Array(bytes).buffer;\n}\nfunction _serializeNumber(major, value) {\n    if (value < 24) {\n        return new Uint8Array([(major << 5) + value]).buffer;\n    }\n    else {\n        const minor = value <= 0xff\n            ? 24 /* Int8 */\n            : value <= 0xffff\n                ? 25 /* Int16 */\n                : value <= 0xffffffff\n                    ? 26 /* Int32 */\n                    : 27 /* Int64 */;\n        return _serializeValue(major, minor, value.toString(16));\n    }\n}\nfunction _serializeString(str) {\n    const utf8 = [];\n    for (let i = 0; i < str.length; i++) {\n        let charcode = str.charCodeAt(i);\n        if (charcode < 0x80) {\n            utf8.push(charcode);\n        }\n        else if (charcode < 0x800) {\n            utf8.push(0xc0 | (charcode >> 6), 0x80 | (charcode & 0x3f));\n        }\n        else if (charcode < 0xd800 || charcode >= 0xe000) {\n            utf8.push(0xe0 | (charcode >> 12), 0x80 | ((charcode >> 6) & 0x3f), 0x80 | (charcode & 0x3f));\n        }\n        else {\n            // Surrogate pair\n            i++;\n            charcode = ((charcode & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff);\n            utf8.push(0xf0 | (charcode >> 18), 0x80 | ((charcode >> 12) & 0x3f), 0x80 | ((charcode >> 6) & 0x3f), 0x80 | (charcode & 0x3f));\n        }\n    }\n    return _concat(new Uint8Array(_serializeNumber(3 /* TextString */, str.length)), new Uint8Array(utf8));\n}\n/**\n * Tag a value.\n */\nfunction tagged(tag, value) {\n    if (tag == 0xd9d9f7) {\n        return _concat(new Uint8Array([0xd9, 0xd9, 0xf7]), value);\n    }\n    if (tag < 24) {\n        return _concat(new Uint8Array([(6 /* Tag */ << 5) + tag]), value);\n    }\n    else {\n        const minor = tag <= 0xff\n            ? 24 /* Int8 */\n            : tag <= 0xffff\n                ? 25 /* Int16 */\n                : tag <= 0xffffffff\n                    ? 26 /* Int32 */\n                    : 27 /* Int64 */;\n        const length = 2 ** (minor - 24 /* Int8 */);\n        const value = tag\n            .toString(16)\n            .slice(-length * 2)\n            .padStart(length * 2, \"0\");\n        const bytes = [(6 /* Tag */ << 5) + minor].concat(value.match(/../g).map((byte) => parseInt(byte, 16)));\n        return new Uint8Array(bytes).buffer;\n    }\n}\nexports.tagged = tagged;\n/**\n * Set the raw bytes contained by this value. This should only be used with another\n * CborValue, or if you are implementing extensions to CBOR.\n * @param bytes A buffer containing the value.\n */\nfunction raw(bytes) {\n    return new Uint8Array(bytes).buffer;\n}\nexports.raw = raw;\n/**\n * Encode a number that is between [0, 23].\n * @param n\n */\nfunction uSmall(n) {\n    if (isNaN(n)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    n = Math.min(Math.max(0, n), 23); // Clamp it.\n    const bytes = [(0 /* UnsignedInteger */ << 5) + n];\n    return new Uint8Array(bytes).buffer;\n}\nexports.uSmall = uSmall;\nfunction u8(u8, radix) {\n    // Force u8 into a number, and validate it.\n    u8 = parseInt(\"\" + u8, radix);\n    if (isNaN(u8)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    u8 = Math.min(Math.max(0, u8), 0xff); // Clamp it.\n    u8 = u8.toString(16);\n    return _serializeValue(0 /* UnsignedInteger */, 24 /* Int8 */, u8);\n}\nexports.u8 = u8;\nfunction u16(u16, radix) {\n    // Force u16 into a number, and validate it.\n    u16 = parseInt(\"\" + u16, radix);\n    if (isNaN(u16)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    u16 = Math.min(Math.max(0, u16), 0xffff); // Clamp it.\n    u16 = u16.toString(16);\n    return _serializeValue(0 /* UnsignedInteger */, 25 /* Int16 */, u16);\n}\nexports.u16 = u16;\nfunction u32(u32, radix) {\n    // Force u32 into a number, and validate it.\n    u32 = parseInt(\"\" + u32, radix);\n    if (isNaN(u32)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    u32 = Math.min(Math.max(0, u32), 0xffffffff); // Clamp it.\n    u32 = u32.toString(16);\n    return _serializeValue(0 /* UnsignedInteger */, 26 /* Int32 */, u32);\n}\nexports.u32 = u32;\nfunction u64(u64, radix) {\n    // Special consideration for numbers that might be larger than expected.\n    if (typeof u64 == \"string\" && radix == 16) {\n        // This is the only case where we guarantee we'll encode the number directly.\n        // Validate it's all hexadecimal first.\n        if (u64.match(/[^0-9a-fA-F]/)) {\n            throw new RangeError(\"Invalid number.\");\n        }\n        return _serializeValue(0 /* UnsignedInteger */, 27 /* Int64 */, u64);\n    }\n    // Force u64 into a number, and validate it.\n    u64 = parseInt(\"\" + u64, radix);\n    if (isNaN(u64)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    u64 = Math.min(Math.max(0, u64), MAX_U64_NUMBER); // Clamp it to actual limit.\n    u64 = u64.toString(16);\n    return _serializeValue(0 /* UnsignedInteger */, 27 /* Int64 */, u64);\n}\nexports.u64 = u64;\n/**\n * Encode a negative number that is between [-24, -1].\n */\nfunction iSmall(n) {\n    if (isNaN(n)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    if (n === 0) {\n        return uSmall(0);\n    }\n    // Negative n, clamped to [1, 24], minus 1 (there's no negative 0).\n    n = Math.min(Math.max(0, -n), 24) - 1;\n    const bytes = [(1 /* SignedInteger */ << 5) + n];\n    return new Uint8Array(bytes).buffer;\n}\nexports.iSmall = iSmall;\nfunction i8(i8, radix) {\n    // Force i8 into a number, and validate it.\n    i8 = parseInt(\"\" + i8, radix);\n    if (isNaN(i8)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    // Negative n, clamped, minus 1 (there's no negative 0).\n    i8 = Math.min(Math.max(0, -i8 - 1), 0xff);\n    i8 = i8.toString(16);\n    return _serializeValue(1 /* SignedInteger */, 24 /* Int8 */, i8);\n}\nexports.i8 = i8;\nfunction i16(i16, radix) {\n    // Force i16 into a number, and validate it.\n    i16 = parseInt(\"\" + i16, radix);\n    if (isNaN(i16)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    // Negative n, clamped, minus 1 (there's no negative 0).\n    i16 = Math.min(Math.max(0, -i16 - 1), 0xffff);\n    i16 = i16.toString(16);\n    return _serializeValue(1 /* SignedInteger */, 25 /* Int16 */, i16);\n}\nexports.i16 = i16;\nfunction i32(i32, radix) {\n    // Force i32 into a number, and validate it.\n    i32 = parseInt(\"\" + i32, radix);\n    if (isNaN(i32)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    // Negative n, clamped, minus 1 (there's no negative 0).\n    i32 = Math.min(Math.max(0, -i32 - 1), 0xffffffff);\n    i32 = i32.toString(16);\n    return _serializeValue(1 /* SignedInteger */, 26 /* Int32 */, i32);\n}\nexports.i32 = i32;\nfunction i64(i64, radix) {\n    // Special consideration for numbers that might be larger than expected.\n    if (typeof i64 == \"string\" && radix == 16) {\n        if (i64.startsWith(\"-\")) {\n            i64 = i64.slice(1);\n        }\n        else {\n            // Clamp it.\n            i64 = \"0\";\n        }\n        // This is the only case where we guarantee we'll encode the number directly.\n        // Validate it's all hexadecimal first.\n        if (i64.match(/[^0-9a-fA-F]/) || i64.length > 16) {\n            throw new RangeError(\"Invalid number.\");\n        }\n        // We need to do -1 to the number.\n        let done = false;\n        let newI64 = i64.split(\"\").reduceRight((acc, x) => {\n            if (done) {\n                return x + acc;\n            }\n            let n = parseInt(x, 16) - 1;\n            if (n >= 0) {\n                done = true;\n                return n.toString(16) + acc;\n            }\n            else {\n                return \"f\" + acc;\n            }\n        }, \"\");\n        if (!done) {\n            // This number was 0.\n            return u64(0);\n        }\n        return _serializeValue(1 /* SignedInteger */, 27 /* Int64 */, newI64);\n    }\n    // Force i64 into a number, and validate it.\n    i64 = parseInt(\"\" + i64, radix);\n    if (isNaN(i64)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    i64 = Math.min(Math.max(0, -i64 - 1), 0x20000000000000); // Clamp it to actual.\n    i64 = i64.toString(16);\n    return _serializeValue(1 /* SignedInteger */, 27 /* Int64 */, i64);\n}\nexports.i64 = i64;\n/**\n * Encode a number using the smallest amount of bytes, by calling the methods\n * above. e.g. If the number fits in a u8, it will use that.\n */\nfunction number(n) {\n    if (n >= 0) {\n        if (n < 24) {\n            return uSmall(n);\n        }\n        else if (n <= 0xff) {\n            return u8(n);\n        }\n        else if (n <= 0xffff) {\n            return u16(n);\n        }\n        else if (n <= 0xffffffff) {\n            return u32(n);\n        }\n        else {\n            return u64(n);\n        }\n    }\n    else {\n        if (n >= -24) {\n            return iSmall(n);\n        }\n        else if (n >= -0xff) {\n            return i8(n);\n        }\n        else if (n >= -0xffff) {\n            return i16(n);\n        }\n        else if (n >= -0xffffffff) {\n            return i32(n);\n        }\n        else {\n            return i64(n);\n        }\n    }\n}\nexports.number = number;\n/**\n * Encode a byte array. This is different than the `raw()` method.\n */\nfunction bytes(bytes) {\n    return _concat(_serializeNumber(2 /* ByteString */, bytes.byteLength), bytes);\n}\nexports.bytes = bytes;\n/**\n * Encode a JavaScript string.\n */\nfunction string(str) {\n    return _serializeString(str);\n}\nexports.string = string;\n/**\n * Encode an array of cbor values.\n */\nfunction array(items) {\n    return _concat(_serializeNumber(4 /* Array */, items.length), ...items);\n}\nexports.array = array;\n/**\n * Encode a map of key-value pairs. The keys are string, and the values are CBOR\n * encoded.\n */\nfunction map(items, stable = false) {\n    if (!(items instanceof Map)) {\n        items = new Map(Object.entries(items));\n    }\n    let entries = Array.from(items.entries());\n    if (stable) {\n        entries = entries.sort(([keyA], [keyB]) => keyA.localeCompare(keyB));\n    }\n    return _concat(_serializeNumber(5 /* Map */, items.size), ...entries.map(([k, v]) => _concat(_serializeString(k), v)));\n}\nexports.map = map;\n/**\n * Encode a single (32 bits) precision floating point number.\n */\nfunction singleFloat(f) {\n    const single = new Float32Array([f]);\n    return _concat(new Uint8Array([(7 /* SimpleValue */ << 5) + 26]), new Uint8Array(single.buffer));\n}\nexports.singleFloat = singleFloat;\n/**\n * Encode a double (64 bits) precision floating point number.\n */\nfunction doubleFloat(f) {\n    const single = new Float64Array([f]);\n    return _concat(new Uint8Array([(7 /* SimpleValue */ << 5) + 27]), new Uint8Array(single.buffer));\n}\nexports.doubleFloat = doubleFloat;\nfunction bool(v) {\n    return v ? true_() : false_();\n}\nexports.bool = bool;\n/**\n * Encode the boolean true.\n */\nfunction true_() {\n    return raw(new Uint8Array([(7 /* SimpleValue */ << 5) + 21]));\n}\nexports.true_ = true_;\n/**\n * Encode the boolean false.\n */\nfunction false_() {\n    return raw(new Uint8Array([(7 /* SimpleValue */ << 5) + 20]));\n}\nexports.false_ = false_;\n/**\n * Encode the constant null.\n */\nfunction null_() {\n    return raw(new Uint8Array([(7 /* SimpleValue */ << 5) + 22]));\n}\nexports.null_ = null_;\n/**\n * Encode the constant undefined.\n */\nfunction undefined_() {\n    return raw(new Uint8Array([(7 /* SimpleValue */ << 5) + 23]));\n}\nexports.undefined_ = undefined_;\n//# sourceMappingURL=value.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvc2ltcGxlLWNib3Ivc3JjL3ZhbHVlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL3NpbXBsZS1jYm9yL3NyYy92YWx1ZS5qcz8xNGFiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTUFYX1U2NF9OVU1CRVIgPSAweDIwMDAwMDAwMDAwMDAwO1xuZnVuY3Rpb24gX2NvbmNhdChhLCAuLi5hcmdzKSB7XG4gICAgY29uc3QgbmV3QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYS5ieXRlTGVuZ3RoICsgYXJncy5yZWR1Y2UoKGFjYywgYikgPT4gYWNjICsgYi5ieXRlTGVuZ3RoLCAwKSk7XG4gICAgbmV3QnVmZmVyLnNldChuZXcgVWludDhBcnJheShhKSwgMCk7XG4gICAgbGV0IGkgPSBhLmJ5dGVMZW5ndGg7XG4gICAgZm9yIChjb25zdCBiIG9mIGFyZ3MpIHtcbiAgICAgICAgbmV3QnVmZmVyLnNldChuZXcgVWludDhBcnJheShiKSwgaSk7XG4gICAgICAgIGkgKz0gYi5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gbmV3QnVmZmVyLmJ1ZmZlcjtcbn1cbmZ1bmN0aW9uIF9zZXJpYWxpemVWYWx1ZShtYWpvciwgbWlub3IsIHZhbHVlKSB7XG4gICAgLy8gUmVtb3ZlIGV2ZXJ5dGhpbmcgdGhhdCdzIG5vdCBhbiBoZXhhZGVjaW1hbCBjaGFyYWN0ZXIuIFRoZXNlIGFyZSBub3RcbiAgICAvLyBjb25zaWRlcmVkIGVycm9ycyBzaW5jZSB0aGUgdmFsdWUgd2FzIGFscmVhZHkgdmFsaWRhdGVkIGFuZCB0aGV5IG1pZ2h0XG4gICAgLy8gYmUgbnVtYmVyIGRlY2ltYWxzIG9yIHNpZ24uXG4gICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bXjAtOWEtZkEtRl0vZywgXCJcIik7XG4gICAgLy8gQ3JlYXRlIHRoZSBidWZmZXIgZnJvbSB0aGUgdmFsdWUgd2l0aCBsZWZ0IHBhZGRpbmcgd2l0aCAwLlxuICAgIGNvbnN0IGxlbmd0aCA9IDIgKiogKG1pbm9yIC0gMjQgLyogSW50OCAqLyk7XG4gICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgtbGVuZ3RoICogMikucGFkU3RhcnQobGVuZ3RoICogMiwgXCIwXCIpO1xuICAgIGNvbnN0IGJ5dGVzID0gWyhtYWpvciA8PCA1KSArIG1pbm9yXS5jb25jYXQodmFsdWUubWF0Y2goLy4uL2cpLm1hcCgoYnl0ZSkgPT4gcGFyc2VJbnQoYnl0ZSwgMTYpKSk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ5dGVzKS5idWZmZXI7XG59XG5mdW5jdGlvbiBfc2VyaWFsaXplTnVtYmVyKG1ham9yLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA8IDI0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbKG1ham9yIDw8IDUpICsgdmFsdWVdKS5idWZmZXI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBtaW5vciA9IHZhbHVlIDw9IDB4ZmZcbiAgICAgICAgICAgID8gMjQgLyogSW50OCAqL1xuICAgICAgICAgICAgOiB2YWx1ZSA8PSAweGZmZmZcbiAgICAgICAgICAgICAgICA/IDI1IC8qIEludDE2ICovXG4gICAgICAgICAgICAgICAgOiB2YWx1ZSA8PSAweGZmZmZmZmZmXG4gICAgICAgICAgICAgICAgICAgID8gMjYgLyogSW50MzIgKi9cbiAgICAgICAgICAgICAgICAgICAgOiAyNyAvKiBJbnQ2NCAqLztcbiAgICAgICAgcmV0dXJuIF9zZXJpYWxpemVWYWx1ZShtYWpvciwgbWlub3IsIHZhbHVlLnRvU3RyaW5nKDE2KSk7XG4gICAgfVxufVxuZnVuY3Rpb24gX3NlcmlhbGl6ZVN0cmluZyhzdHIpIHtcbiAgICBjb25zdCB1dGY4ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGNoYXJjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjaGFyY29kZSA8IDB4ODApIHtcbiAgICAgICAgICAgIHV0ZjgucHVzaChjaGFyY29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hhcmNvZGUgPCAweDgwMCkge1xuICAgICAgICAgICAgdXRmOC5wdXNoKDB4YzAgfCAoY2hhcmNvZGUgPj4gNiksIDB4ODAgfCAoY2hhcmNvZGUgJiAweDNmKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hhcmNvZGUgPCAweGQ4MDAgfHwgY2hhcmNvZGUgPj0gMHhlMDAwKSB7XG4gICAgICAgICAgICB1dGY4LnB1c2goMHhlMCB8IChjaGFyY29kZSA+PiAxMiksIDB4ODAgfCAoKGNoYXJjb2RlID4+IDYpICYgMHgzZiksIDB4ODAgfCAoY2hhcmNvZGUgJiAweDNmKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBTdXJyb2dhdGUgcGFpclxuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgY2hhcmNvZGUgPSAoKGNoYXJjb2RlICYgMHgzZmYpIDw8IDEwKSB8IChzdHIuY2hhckNvZGVBdChpKSAmIDB4M2ZmKTtcbiAgICAgICAgICAgIHV0ZjgucHVzaCgweGYwIHwgKGNoYXJjb2RlID4+IDE4KSwgMHg4MCB8ICgoY2hhcmNvZGUgPj4gMTIpICYgMHgzZiksIDB4ODAgfCAoKGNoYXJjb2RlID4+IDYpICYgMHgzZiksIDB4ODAgfCAoY2hhcmNvZGUgJiAweDNmKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIF9jb25jYXQobmV3IFVpbnQ4QXJyYXkoX3NlcmlhbGl6ZU51bWJlcigzIC8qIFRleHRTdHJpbmcgKi8sIHN0ci5sZW5ndGgpKSwgbmV3IFVpbnQ4QXJyYXkodXRmOCkpO1xufVxuLyoqXG4gKiBUYWcgYSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gdGFnZ2VkKHRhZywgdmFsdWUpIHtcbiAgICBpZiAodGFnID09IDB4ZDlkOWY3KSB7XG4gICAgICAgIHJldHVybiBfY29uY2F0KG5ldyBVaW50OEFycmF5KFsweGQ5LCAweGQ5LCAweGY3XSksIHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHRhZyA8IDI0KSB7XG4gICAgICAgIHJldHVybiBfY29uY2F0KG5ldyBVaW50OEFycmF5KFsoNiAvKiBUYWcgKi8gPDwgNSkgKyB0YWddKSwgdmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbWlub3IgPSB0YWcgPD0gMHhmZlxuICAgICAgICAgICAgPyAyNCAvKiBJbnQ4ICovXG4gICAgICAgICAgICA6IHRhZyA8PSAweGZmZmZcbiAgICAgICAgICAgICAgICA/IDI1IC8qIEludDE2ICovXG4gICAgICAgICAgICAgICAgOiB0YWcgPD0gMHhmZmZmZmZmZlxuICAgICAgICAgICAgICAgICAgICA/IDI2IC8qIEludDMyICovXG4gICAgICAgICAgICAgICAgICAgIDogMjcgLyogSW50NjQgKi87XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IDIgKiogKG1pbm9yIC0gMjQgLyogSW50OCAqLyk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGFnXG4gICAgICAgICAgICAudG9TdHJpbmcoMTYpXG4gICAgICAgICAgICAuc2xpY2UoLWxlbmd0aCAqIDIpXG4gICAgICAgICAgICAucGFkU3RhcnQobGVuZ3RoICogMiwgXCIwXCIpO1xuICAgICAgICBjb25zdCBieXRlcyA9IFsoNiAvKiBUYWcgKi8gPDwgNSkgKyBtaW5vcl0uY29uY2F0KHZhbHVlLm1hdGNoKC8uLi9nKS5tYXAoKGJ5dGUpID0+IHBhcnNlSW50KGJ5dGUsIDE2KSkpO1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpLmJ1ZmZlcjtcbiAgICB9XG59XG5leHBvcnRzLnRhZ2dlZCA9IHRhZ2dlZDtcbi8qKlxuICogU2V0IHRoZSByYXcgYnl0ZXMgY29udGFpbmVkIGJ5IHRoaXMgdmFsdWUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aXRoIGFub3RoZXJcbiAqIENib3JWYWx1ZSwgb3IgaWYgeW91IGFyZSBpbXBsZW1lbnRpbmcgZXh0ZW5zaW9ucyB0byBDQk9SLlxuICogQHBhcmFtIGJ5dGVzIEEgYnVmZmVyIGNvbnRhaW5pbmcgdGhlIHZhbHVlLlxuICovXG5mdW5jdGlvbiByYXcoYnl0ZXMpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpLmJ1ZmZlcjtcbn1cbmV4cG9ydHMucmF3ID0gcmF3O1xuLyoqXG4gKiBFbmNvZGUgYSBudW1iZXIgdGhhdCBpcyBiZXR3ZWVuIFswLCAyM10uXG4gKiBAcGFyYW0gblxuICovXG5mdW5jdGlvbiB1U21hbGwobikge1xuICAgIGlmIChpc05hTihuKSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgbnVtYmVyLlwiKTtcbiAgICB9XG4gICAgbiA9IE1hdGgubWluKE1hdGgubWF4KDAsIG4pLCAyMyk7IC8vIENsYW1wIGl0LlxuICAgIGNvbnN0IGJ5dGVzID0gWygwIC8qIFVuc2lnbmVkSW50ZWdlciAqLyA8PCA1KSArIG5dO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShieXRlcykuYnVmZmVyO1xufVxuZXhwb3J0cy51U21hbGwgPSB1U21hbGw7XG5mdW5jdGlvbiB1OCh1OCwgcmFkaXgpIHtcbiAgICAvLyBGb3JjZSB1OCBpbnRvIGEgbnVtYmVyLCBhbmQgdmFsaWRhdGUgaXQuXG4gICAgdTggPSBwYXJzZUludChcIlwiICsgdTgsIHJhZGl4KTtcbiAgICBpZiAoaXNOYU4odTgpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBudW1iZXIuXCIpO1xuICAgIH1cbiAgICB1OCA9IE1hdGgubWluKE1hdGgubWF4KDAsIHU4KSwgMHhmZik7IC8vIENsYW1wIGl0LlxuICAgIHU4ID0gdTgudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBfc2VyaWFsaXplVmFsdWUoMCAvKiBVbnNpZ25lZEludGVnZXIgKi8sIDI0IC8qIEludDggKi8sIHU4KTtcbn1cbmV4cG9ydHMudTggPSB1ODtcbmZ1bmN0aW9uIHUxNih1MTYsIHJhZGl4KSB7XG4gICAgLy8gRm9yY2UgdTE2IGludG8gYSBudW1iZXIsIGFuZCB2YWxpZGF0ZSBpdC5cbiAgICB1MTYgPSBwYXJzZUludChcIlwiICsgdTE2LCByYWRpeCk7XG4gICAgaWYgKGlzTmFOKHUxNikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG51bWJlci5cIik7XG4gICAgfVxuICAgIHUxNiA9IE1hdGgubWluKE1hdGgubWF4KDAsIHUxNiksIDB4ZmZmZik7IC8vIENsYW1wIGl0LlxuICAgIHUxNiA9IHUxNi50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIF9zZXJpYWxpemVWYWx1ZSgwIC8qIFVuc2lnbmVkSW50ZWdlciAqLywgMjUgLyogSW50MTYgKi8sIHUxNik7XG59XG5leHBvcnRzLnUxNiA9IHUxNjtcbmZ1bmN0aW9uIHUzMih1MzIsIHJhZGl4KSB7XG4gICAgLy8gRm9yY2UgdTMyIGludG8gYSBudW1iZXIsIGFuZCB2YWxpZGF0ZSBpdC5cbiAgICB1MzIgPSBwYXJzZUludChcIlwiICsgdTMyLCByYWRpeCk7XG4gICAgaWYgKGlzTmFOKHUzMikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG51bWJlci5cIik7XG4gICAgfVxuICAgIHUzMiA9IE1hdGgubWluKE1hdGgubWF4KDAsIHUzMiksIDB4ZmZmZmZmZmYpOyAvLyBDbGFtcCBpdC5cbiAgICB1MzIgPSB1MzIudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBfc2VyaWFsaXplVmFsdWUoMCAvKiBVbnNpZ25lZEludGVnZXIgKi8sIDI2IC8qIEludDMyICovLCB1MzIpO1xufVxuZXhwb3J0cy51MzIgPSB1MzI7XG5mdW5jdGlvbiB1NjQodTY0LCByYWRpeCkge1xuICAgIC8vIFNwZWNpYWwgY29uc2lkZXJhdGlvbiBmb3IgbnVtYmVycyB0aGF0IG1pZ2h0IGJlIGxhcmdlciB0aGFuIGV4cGVjdGVkLlxuICAgIGlmICh0eXBlb2YgdTY0ID09IFwic3RyaW5nXCIgJiYgcmFkaXggPT0gMTYpIHtcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgb25seSBjYXNlIHdoZXJlIHdlIGd1YXJhbnRlZSB3ZSdsbCBlbmNvZGUgdGhlIG51bWJlciBkaXJlY3RseS5cbiAgICAgICAgLy8gVmFsaWRhdGUgaXQncyBhbGwgaGV4YWRlY2ltYWwgZmlyc3QuXG4gICAgICAgIGlmICh1NjQubWF0Y2goL1teMC05YS1mQS1GXS8pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgbnVtYmVyLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZVZhbHVlKDAgLyogVW5zaWduZWRJbnRlZ2VyICovLCAyNyAvKiBJbnQ2NCAqLywgdTY0KTtcbiAgICB9XG4gICAgLy8gRm9yY2UgdTY0IGludG8gYSBudW1iZXIsIGFuZCB2YWxpZGF0ZSBpdC5cbiAgICB1NjQgPSBwYXJzZUludChcIlwiICsgdTY0LCByYWRpeCk7XG4gICAgaWYgKGlzTmFOKHU2NCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG51bWJlci5cIik7XG4gICAgfVxuICAgIHU2NCA9IE1hdGgubWluKE1hdGgubWF4KDAsIHU2NCksIE1BWF9VNjRfTlVNQkVSKTsgLy8gQ2xhbXAgaXQgdG8gYWN0dWFsIGxpbWl0LlxuICAgIHU2NCA9IHU2NC50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIF9zZXJpYWxpemVWYWx1ZSgwIC8qIFVuc2lnbmVkSW50ZWdlciAqLywgMjcgLyogSW50NjQgKi8sIHU2NCk7XG59XG5leHBvcnRzLnU2NCA9IHU2NDtcbi8qKlxuICogRW5jb2RlIGEgbmVnYXRpdmUgbnVtYmVyIHRoYXQgaXMgYmV0d2VlbiBbLTI0LCAtMV0uXG4gKi9cbmZ1bmN0aW9uIGlTbWFsbChuKSB7XG4gICAgaWYgKGlzTmFOKG4pKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBudW1iZXIuXCIpO1xuICAgIH1cbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdVNtYWxsKDApO1xuICAgIH1cbiAgICAvLyBOZWdhdGl2ZSBuLCBjbGFtcGVkIHRvIFsxLCAyNF0sIG1pbnVzIDEgKHRoZXJlJ3Mgbm8gbmVnYXRpdmUgMCkuXG4gICAgbiA9IE1hdGgubWluKE1hdGgubWF4KDAsIC1uKSwgMjQpIC0gMTtcbiAgICBjb25zdCBieXRlcyA9IFsoMSAvKiBTaWduZWRJbnRlZ2VyICovIDw8IDUpICsgbl07XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ5dGVzKS5idWZmZXI7XG59XG5leHBvcnRzLmlTbWFsbCA9IGlTbWFsbDtcbmZ1bmN0aW9uIGk4KGk4LCByYWRpeCkge1xuICAgIC8vIEZvcmNlIGk4IGludG8gYSBudW1iZXIsIGFuZCB2YWxpZGF0ZSBpdC5cbiAgICBpOCA9IHBhcnNlSW50KFwiXCIgKyBpOCwgcmFkaXgpO1xuICAgIGlmIChpc05hTihpOCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG51bWJlci5cIik7XG4gICAgfVxuICAgIC8vIE5lZ2F0aXZlIG4sIGNsYW1wZWQsIG1pbnVzIDEgKHRoZXJlJ3Mgbm8gbmVnYXRpdmUgMCkuXG4gICAgaTggPSBNYXRoLm1pbihNYXRoLm1heCgwLCAtaTggLSAxKSwgMHhmZik7XG4gICAgaTggPSBpOC50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIF9zZXJpYWxpemVWYWx1ZSgxIC8qIFNpZ25lZEludGVnZXIgKi8sIDI0IC8qIEludDggKi8sIGk4KTtcbn1cbmV4cG9ydHMuaTggPSBpODtcbmZ1bmN0aW9uIGkxNihpMTYsIHJhZGl4KSB7XG4gICAgLy8gRm9yY2UgaTE2IGludG8gYSBudW1iZXIsIGFuZCB2YWxpZGF0ZSBpdC5cbiAgICBpMTYgPSBwYXJzZUludChcIlwiICsgaTE2LCByYWRpeCk7XG4gICAgaWYgKGlzTmFOKGkxNikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG51bWJlci5cIik7XG4gICAgfVxuICAgIC8vIE5lZ2F0aXZlIG4sIGNsYW1wZWQsIG1pbnVzIDEgKHRoZXJlJ3Mgbm8gbmVnYXRpdmUgMCkuXG4gICAgaTE2ID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgLWkxNiAtIDEpLCAweGZmZmYpO1xuICAgIGkxNiA9IGkxNi50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIF9zZXJpYWxpemVWYWx1ZSgxIC8qIFNpZ25lZEludGVnZXIgKi8sIDI1IC8qIEludDE2ICovLCBpMTYpO1xufVxuZXhwb3J0cy5pMTYgPSBpMTY7XG5mdW5jdGlvbiBpMzIoaTMyLCByYWRpeCkge1xuICAgIC8vIEZvcmNlIGkzMiBpbnRvIGEgbnVtYmVyLCBhbmQgdmFsaWRhdGUgaXQuXG4gICAgaTMyID0gcGFyc2VJbnQoXCJcIiArIGkzMiwgcmFkaXgpO1xuICAgIGlmIChpc05hTihpMzIpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBudW1iZXIuXCIpO1xuICAgIH1cbiAgICAvLyBOZWdhdGl2ZSBuLCBjbGFtcGVkLCBtaW51cyAxICh0aGVyZSdzIG5vIG5lZ2F0aXZlIDApLlxuICAgIGkzMiA9IE1hdGgubWluKE1hdGgubWF4KDAsIC1pMzIgLSAxKSwgMHhmZmZmZmZmZik7XG4gICAgaTMyID0gaTMyLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gX3NlcmlhbGl6ZVZhbHVlKDEgLyogU2lnbmVkSW50ZWdlciAqLywgMjYgLyogSW50MzIgKi8sIGkzMik7XG59XG5leHBvcnRzLmkzMiA9IGkzMjtcbmZ1bmN0aW9uIGk2NChpNjQsIHJhZGl4KSB7XG4gICAgLy8gU3BlY2lhbCBjb25zaWRlcmF0aW9uIGZvciBudW1iZXJzIHRoYXQgbWlnaHQgYmUgbGFyZ2VyIHRoYW4gZXhwZWN0ZWQuXG4gICAgaWYgKHR5cGVvZiBpNjQgPT0gXCJzdHJpbmdcIiAmJiByYWRpeCA9PSAxNikge1xuICAgICAgICBpZiAoaTY0LnN0YXJ0c1dpdGgoXCItXCIpKSB7XG4gICAgICAgICAgICBpNjQgPSBpNjQuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBDbGFtcCBpdC5cbiAgICAgICAgICAgIGk2NCA9IFwiMFwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIG9ubHkgY2FzZSB3aGVyZSB3ZSBndWFyYW50ZWUgd2UnbGwgZW5jb2RlIHRoZSBudW1iZXIgZGlyZWN0bHkuXG4gICAgICAgIC8vIFZhbGlkYXRlIGl0J3MgYWxsIGhleGFkZWNpbWFsIGZpcnN0LlxuICAgICAgICBpZiAoaTY0Lm1hdGNoKC9bXjAtOWEtZkEtRl0vKSB8fCBpNjQubGVuZ3RoID4gMTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBudW1iZXIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gZG8gLTEgdG8gdGhlIG51bWJlci5cbiAgICAgICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICAgICAgbGV0IG5ld0k2NCA9IGk2NC5zcGxpdChcIlwiKS5yZWR1Y2VSaWdodCgoYWNjLCB4KSA9PiB7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4ICsgYWNjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG4gPSBwYXJzZUludCh4LCAxNikgLSAxO1xuICAgICAgICAgICAgaWYgKG4gPj0gMCkge1xuICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBuLnRvU3RyaW5nKDE2KSArIGFjYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBcImZcIiArIGFjYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgXCJcIik7XG4gICAgICAgIGlmICghZG9uZSkge1xuICAgICAgICAgICAgLy8gVGhpcyBudW1iZXIgd2FzIDAuXG4gICAgICAgICAgICByZXR1cm4gdTY0KDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfc2VyaWFsaXplVmFsdWUoMSAvKiBTaWduZWRJbnRlZ2VyICovLCAyNyAvKiBJbnQ2NCAqLywgbmV3STY0KTtcbiAgICB9XG4gICAgLy8gRm9yY2UgaTY0IGludG8gYSBudW1iZXIsIGFuZCB2YWxpZGF0ZSBpdC5cbiAgICBpNjQgPSBwYXJzZUludChcIlwiICsgaTY0LCByYWRpeCk7XG4gICAgaWYgKGlzTmFOKGk2NCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG51bWJlci5cIik7XG4gICAgfVxuICAgIGk2NCA9IE1hdGgubWluKE1hdGgubWF4KDAsIC1pNjQgLSAxKSwgMHgyMDAwMDAwMDAwMDAwMCk7IC8vIENsYW1wIGl0IHRvIGFjdHVhbC5cbiAgICBpNjQgPSBpNjQudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBfc2VyaWFsaXplVmFsdWUoMSAvKiBTaWduZWRJbnRlZ2VyICovLCAyNyAvKiBJbnQ2NCAqLywgaTY0KTtcbn1cbmV4cG9ydHMuaTY0ID0gaTY0O1xuLyoqXG4gKiBFbmNvZGUgYSBudW1iZXIgdXNpbmcgdGhlIHNtYWxsZXN0IGFtb3VudCBvZiBieXRlcywgYnkgY2FsbGluZyB0aGUgbWV0aG9kc1xuICogYWJvdmUuIGUuZy4gSWYgdGhlIG51bWJlciBmaXRzIGluIGEgdTgsIGl0IHdpbGwgdXNlIHRoYXQuXG4gKi9cbmZ1bmN0aW9uIG51bWJlcihuKSB7XG4gICAgaWYgKG4gPj0gMCkge1xuICAgICAgICBpZiAobiA8IDI0KSB7XG4gICAgICAgICAgICByZXR1cm4gdVNtYWxsKG4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG4gPD0gMHhmZikge1xuICAgICAgICAgICAgcmV0dXJuIHU4KG4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG4gPD0gMHhmZmZmKSB7XG4gICAgICAgICAgICByZXR1cm4gdTE2KG4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG4gPD0gMHhmZmZmZmZmZikge1xuICAgICAgICAgICAgcmV0dXJuIHUzMihuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1NjQobik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChuID49IC0yNCkge1xuICAgICAgICAgICAgcmV0dXJuIGlTbWFsbChuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuID49IC0weGZmKSB7XG4gICAgICAgICAgICByZXR1cm4gaTgobik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobiA+PSAtMHhmZmZmKSB7XG4gICAgICAgICAgICByZXR1cm4gaTE2KG4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG4gPj0gLTB4ZmZmZmZmZmYpIHtcbiAgICAgICAgICAgIHJldHVybiBpMzIobik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaTY0KG4pO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5udW1iZXIgPSBudW1iZXI7XG4vKipcbiAqIEVuY29kZSBhIGJ5dGUgYXJyYXkuIFRoaXMgaXMgZGlmZmVyZW50IHRoYW4gdGhlIGByYXcoKWAgbWV0aG9kLlxuICovXG5mdW5jdGlvbiBieXRlcyhieXRlcykge1xuICAgIHJldHVybiBfY29uY2F0KF9zZXJpYWxpemVOdW1iZXIoMiAvKiBCeXRlU3RyaW5nICovLCBieXRlcy5ieXRlTGVuZ3RoKSwgYnl0ZXMpO1xufVxuZXhwb3J0cy5ieXRlcyA9IGJ5dGVzO1xuLyoqXG4gKiBFbmNvZGUgYSBKYXZhU2NyaXB0IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nKHN0cikge1xuICAgIHJldHVybiBfc2VyaWFsaXplU3RyaW5nKHN0cik7XG59XG5leHBvcnRzLnN0cmluZyA9IHN0cmluZztcbi8qKlxuICogRW5jb2RlIGFuIGFycmF5IG9mIGNib3IgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBhcnJheShpdGVtcykge1xuICAgIHJldHVybiBfY29uY2F0KF9zZXJpYWxpemVOdW1iZXIoNCAvKiBBcnJheSAqLywgaXRlbXMubGVuZ3RoKSwgLi4uaXRlbXMpO1xufVxuZXhwb3J0cy5hcnJheSA9IGFycmF5O1xuLyoqXG4gKiBFbmNvZGUgYSBtYXAgb2Yga2V5LXZhbHVlIHBhaXJzLiBUaGUga2V5cyBhcmUgc3RyaW5nLCBhbmQgdGhlIHZhbHVlcyBhcmUgQ0JPUlxuICogZW5jb2RlZC5cbiAqL1xuZnVuY3Rpb24gbWFwKGl0ZW1zLCBzdGFibGUgPSBmYWxzZSkge1xuICAgIGlmICghKGl0ZW1zIGluc3RhbmNlb2YgTWFwKSkge1xuICAgICAgICBpdGVtcyA9IG5ldyBNYXAoT2JqZWN0LmVudHJpZXMoaXRlbXMpKTtcbiAgICB9XG4gICAgbGV0IGVudHJpZXMgPSBBcnJheS5mcm9tKGl0ZW1zLmVudHJpZXMoKSk7XG4gICAgaWYgKHN0YWJsZSkge1xuICAgICAgICBlbnRyaWVzID0gZW50cmllcy5zb3J0KChba2V5QV0sIFtrZXlCXSkgPT4ga2V5QS5sb2NhbGVDb21wYXJlKGtleUIpKTtcbiAgICB9XG4gICAgcmV0dXJuIF9jb25jYXQoX3NlcmlhbGl6ZU51bWJlcig1IC8qIE1hcCAqLywgaXRlbXMuc2l6ZSksIC4uLmVudHJpZXMubWFwKChbaywgdl0pID0+IF9jb25jYXQoX3NlcmlhbGl6ZVN0cmluZyhrKSwgdikpKTtcbn1cbmV4cG9ydHMubWFwID0gbWFwO1xuLyoqXG4gKiBFbmNvZGUgYSBzaW5nbGUgKDMyIGJpdHMpIHByZWNpc2lvbiBmbG9hdGluZyBwb2ludCBudW1iZXIuXG4gKi9cbmZ1bmN0aW9uIHNpbmdsZUZsb2F0KGYpIHtcbiAgICBjb25zdCBzaW5nbGUgPSBuZXcgRmxvYXQzMkFycmF5KFtmXSk7XG4gICAgcmV0dXJuIF9jb25jYXQobmV3IFVpbnQ4QXJyYXkoWyg3IC8qIFNpbXBsZVZhbHVlICovIDw8IDUpICsgMjZdKSwgbmV3IFVpbnQ4QXJyYXkoc2luZ2xlLmJ1ZmZlcikpO1xufVxuZXhwb3J0cy5zaW5nbGVGbG9hdCA9IHNpbmdsZUZsb2F0O1xuLyoqXG4gKiBFbmNvZGUgYSBkb3VibGUgKDY0IGJpdHMpIHByZWNpc2lvbiBmbG9hdGluZyBwb2ludCBudW1iZXIuXG4gKi9cbmZ1bmN0aW9uIGRvdWJsZUZsb2F0KGYpIHtcbiAgICBjb25zdCBzaW5nbGUgPSBuZXcgRmxvYXQ2NEFycmF5KFtmXSk7XG4gICAgcmV0dXJuIF9jb25jYXQobmV3IFVpbnQ4QXJyYXkoWyg3IC8qIFNpbXBsZVZhbHVlICovIDw8IDUpICsgMjddKSwgbmV3IFVpbnQ4QXJyYXkoc2luZ2xlLmJ1ZmZlcikpO1xufVxuZXhwb3J0cy5kb3VibGVGbG9hdCA9IGRvdWJsZUZsb2F0O1xuZnVuY3Rpb24gYm9vbCh2KSB7XG4gICAgcmV0dXJuIHYgPyB0cnVlXygpIDogZmFsc2VfKCk7XG59XG5leHBvcnRzLmJvb2wgPSBib29sO1xuLyoqXG4gKiBFbmNvZGUgdGhlIGJvb2xlYW4gdHJ1ZS5cbiAqL1xuZnVuY3Rpb24gdHJ1ZV8oKSB7XG4gICAgcmV0dXJuIHJhdyhuZXcgVWludDhBcnJheShbKDcgLyogU2ltcGxlVmFsdWUgKi8gPDwgNSkgKyAyMV0pKTtcbn1cbmV4cG9ydHMudHJ1ZV8gPSB0cnVlXztcbi8qKlxuICogRW5jb2RlIHRoZSBib29sZWFuIGZhbHNlLlxuICovXG5mdW5jdGlvbiBmYWxzZV8oKSB7XG4gICAgcmV0dXJuIHJhdyhuZXcgVWludDhBcnJheShbKDcgLyogU2ltcGxlVmFsdWUgKi8gPDwgNSkgKyAyMF0pKTtcbn1cbmV4cG9ydHMuZmFsc2VfID0gZmFsc2VfO1xuLyoqXG4gKiBFbmNvZGUgdGhlIGNvbnN0YW50IG51bGwuXG4gKi9cbmZ1bmN0aW9uIG51bGxfKCkge1xuICAgIHJldHVybiByYXcobmV3IFVpbnQ4QXJyYXkoWyg3IC8qIFNpbXBsZVZhbHVlICovIDw8IDUpICsgMjJdKSk7XG59XG5leHBvcnRzLm51bGxfID0gbnVsbF87XG4vKipcbiAqIEVuY29kZSB0aGUgY29uc3RhbnQgdW5kZWZpbmVkLlxuICovXG5mdW5jdGlvbiB1bmRlZmluZWRfKCkge1xuICAgIHJldHVybiByYXcobmV3IFVpbnQ4QXJyYXkoWyg3IC8qIFNpbXBsZVZhbHVlICovIDw8IDUpICsgMjNdKSk7XG59XG5leHBvcnRzLnVuZGVmaW5lZF8gPSB1bmRlZmluZWRfO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFsdWUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/simple-cbor/src/value.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/void-elements/index.js":
/*!*************************************************!*\
  !*** ../../node_modules/void-elements/index.js ***!
  \*************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/**\n * This file automatically generated from `pre-publish.js`.\n * Do not manually edit.\n */\n\nmodule.exports = {\n  \"area\": true,\n  \"base\": true,\n  \"br\": true,\n  \"col\": true,\n  \"embed\": true,\n  \"hr\": true,\n  \"img\": true,\n  \"input\": true,\n  \"link\": true,\n  \"meta\": true,\n  \"param\": true,\n  \"source\": true,\n  \"track\": true,\n  \"wbr\": true\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvdm9pZC1lbGVtZW50cy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL3ZvaWQtZWxlbWVudHMvaW5kZXguanM/ZDIxYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRoaXMgZmlsZSBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBmcm9tIGBwcmUtcHVibGlzaC5qc2AuXG4gKiBEbyBub3QgbWFudWFsbHkgZWRpdC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgXCJhcmVhXCI6IHRydWUsXG4gIFwiYmFzZVwiOiB0cnVlLFxuICBcImJyXCI6IHRydWUsXG4gIFwiY29sXCI6IHRydWUsXG4gIFwiZW1iZWRcIjogdHJ1ZSxcbiAgXCJoclwiOiB0cnVlLFxuICBcImltZ1wiOiB0cnVlLFxuICBcImlucHV0XCI6IHRydWUsXG4gIFwibGlua1wiOiB0cnVlLFxuICBcIm1ldGFcIjogdHJ1ZSxcbiAgXCJwYXJhbVwiOiB0cnVlLFxuICBcInNvdXJjZVwiOiB0cnVlLFxuICBcInRyYWNrXCI6IHRydWUsXG4gIFwid2JyXCI6IHRydWVcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/void-elements/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/image-component.js":
/*!**********************************************************!*\
  !*** ./node_modules/next/dist/client/image-component.js ***!
  \**********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"Image\", ({\n    enumerable: true,\n    get: function() {\n        return Image;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _reactdom = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\"));\nconst _head = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../shared/lib/head */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/head.js\"));\nconst _getimgprops = __webpack_require__(/*! ../shared/lib/get-img-props */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js\");\nconst _imageconfig = __webpack_require__(/*! ../shared/lib/image-config */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\");\nconst _imageconfigcontextsharedruntime = __webpack_require__(/*! ../shared/lib/image-config-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js\");\nconst _warnonce = __webpack_require__(/*! ../shared/lib/utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nconst _routercontextsharedruntime = __webpack_require__(/*! ../shared/lib/router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js\");\nconst _imageloader = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! next/dist/shared/lib/image-loader */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js\"));\n// This is replaced by webpack define plugin\nconst configEnv = {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[],\"output\":\"export\"};\nif (typeof window === \"undefined\") {\n    globalThis.__NEXT_IMAGE_IMPORTED = true;\n}\n// See https://stackoverflow.com/q/39777833/266535 for why we use this ref\n// handler instead of the img's onLoad attribute.\nfunction handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput) {\n    const src = img == null ? void 0 : img.src;\n    if (!img || img[\"data-loaded-src\"] === src) {\n        return;\n    }\n    img[\"data-loaded-src\"] = src;\n    const p = \"decode\" in img ? img.decode() : Promise.resolve();\n    p.catch(()=>{}).then(()=>{\n        if (!img.parentElement || !img.isConnected) {\n            // Exit early in case of race condition:\n            // - onload() is called\n            // - decode() is called but incomplete\n            // - unmount is called\n            // - decode() completes\n            return;\n        }\n        if (placeholder !== \"empty\") {\n            setBlurComplete(true);\n        }\n        if (onLoadRef == null ? void 0 : onLoadRef.current) {\n            // Since we don't have the SyntheticEvent here,\n            // we must create one with the same shape.\n            // See https://reactjs.org/docs/events.html\n            const event = new Event(\"load\");\n            Object.defineProperty(event, \"target\", {\n                writable: false,\n                value: img\n            });\n            let prevented = false;\n            let stopped = false;\n            onLoadRef.current({\n                ...event,\n                nativeEvent: event,\n                currentTarget: img,\n                target: img,\n                isDefaultPrevented: ()=>prevented,\n                isPropagationStopped: ()=>stopped,\n                persist: ()=>{},\n                preventDefault: ()=>{\n                    prevented = true;\n                    event.preventDefault();\n                },\n                stopPropagation: ()=>{\n                    stopped = true;\n                    event.stopPropagation();\n                }\n            });\n        }\n        if (onLoadingCompleteRef == null ? void 0 : onLoadingCompleteRef.current) {\n            onLoadingCompleteRef.current(img);\n        }\n        if (true) {\n            const origSrc = new URL(src, \"http://n\").searchParams.get(\"url\") || src;\n            if (img.getAttribute(\"data-nimg\") === \"fill\") {\n                if (!unoptimized && (!sizesInput || sizesInput === \"100vw\")) {\n                    let widthViewportRatio = img.getBoundingClientRect().width / window.innerWidth;\n                    if (widthViewportRatio < 0.6) {\n                        if (sizesInput === \"100vw\") {\n                            (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" prop and \"sizes\" prop of \"100vw\", but image is not rendered at full viewport width. Please adjust \"sizes\" to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes');\n                        } else {\n                            (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" but is missing \"sizes\" prop. Please add it to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes');\n                        }\n                    }\n                }\n                if (img.parentElement) {\n                    const { position } = window.getComputedStyle(img.parentElement);\n                    const valid = [\n                        \"absolute\",\n                        \"fixed\",\n                        \"relative\"\n                    ];\n                    if (!valid.includes(position)) {\n                        (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" and parent element with invalid \"position\". Provided \"' + position + '\" should be one of ' + valid.map(String).join(\",\") + \".\");\n                    }\n                }\n                if (img.height === 0) {\n                    (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" and a height value of 0. This is likely because the parent element of the image has not been styled to have a set height.');\n                }\n            }\n            const heightModified = img.height.toString() !== img.getAttribute(\"height\");\n            const widthModified = img.width.toString() !== img.getAttribute(\"width\");\n            if (heightModified && !widthModified || !heightModified && widthModified) {\n                (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has either width or height modified, but not the other. If you use CSS to change the size of your image, also include the styles \\'width: \"auto\"\\' or \\'height: \"auto\"\\' to maintain the aspect ratio.');\n            }\n        }\n    });\n}\nfunction getDynamicProps(fetchPriority) {\n    if (Boolean(_react.use)) {\n        // In React 19.0.0 or newer, we must use camelCase\n        // prop to avoid \"Warning: Invalid DOM property\".\n        // See https://github.com/facebook/react/pull/25927\n        return {\n            fetchPriority\n        };\n    }\n    // In React 18.2.0 or older, we must use lowercase prop\n    // to avoid \"Warning: Invalid DOM property\".\n    return {\n        fetchpriority: fetchPriority\n    };\n}\nconst ImageElement = /*#__PURE__*/ (0, _react.forwardRef)((param, forwardedRef)=>{\n    let { src, srcSet, sizes, height, width, decoding, className, style, fetchPriority, placeholder, loading, unoptimized, fill, onLoadRef, onLoadingCompleteRef, setBlurComplete, setShowAltText, sizesInput, onLoad, onError, ...rest } = param;\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(\"img\", {\n        ...rest,\n        ...getDynamicProps(fetchPriority),\n        // It's intended to keep `loading` before `src` because React updates\n        // props in order which causes Safari/Firefox to not lazy load properly.\n        // See https://github.com/facebook/react/issues/25883\n        loading: loading,\n        width: width,\n        height: height,\n        decoding: decoding,\n        \"data-nimg\": fill ? \"fill\" : \"1\",\n        className: className,\n        style: style,\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        sizes: sizes,\n        srcSet: srcSet,\n        src: src,\n        ref: (0, _react.useCallback)((img)=>{\n            if (forwardedRef) {\n                if (typeof forwardedRef === \"function\") forwardedRef(img);\n                else if (typeof forwardedRef === \"object\") {\n                    // @ts-ignore - .current is read only it's usually assigned by react internally\n                    forwardedRef.current = img;\n                }\n            }\n            if (!img) {\n                return;\n            }\n            if (onError) {\n                // If the image has an error before react hydrates, then the error is lost.\n                // The workaround is to wait until the image is mounted which is after hydration,\n                // then we set the src again to trigger the error handler (if there was an error).\n                // eslint-disable-next-line no-self-assign\n                img.src = img.src;\n            }\n            if (true) {\n                if (!src) {\n                    console.error('Image is missing required \"src\" property:', img);\n                }\n                if (img.getAttribute(\"alt\") === null) {\n                    console.error('Image is missing required \"alt\" property. Please add Alternative Text to describe the image for screen readers and search engines.');\n                }\n            }\n            if (img.complete) {\n                handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput);\n            }\n        }, [\n            src,\n            placeholder,\n            onLoadRef,\n            onLoadingCompleteRef,\n            setBlurComplete,\n            onError,\n            unoptimized,\n            sizesInput,\n            forwardedRef\n        ]),\n        onLoad: (event)=>{\n            const img = event.currentTarget;\n            handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput);\n        },\n        onError: (event)=>{\n            // if the real image fails to load, this will ensure \"alt\" is visible\n            setShowAltText(true);\n            if (placeholder !== \"empty\") {\n                // If the real image fails to load, this will still remove the placeholder.\n                setBlurComplete(true);\n            }\n            if (onError) {\n                onError(event);\n            }\n        }\n    });\n});\nfunction ImagePreload(param) {\n    let { isAppRouter, imgAttributes } = param;\n    const opts = {\n        as: \"image\",\n        imageSrcSet: imgAttributes.srcSet,\n        imageSizes: imgAttributes.sizes,\n        crossOrigin: imgAttributes.crossOrigin,\n        referrerPolicy: imgAttributes.referrerPolicy,\n        ...getDynamicProps(imgAttributes.fetchPriority)\n    };\n    if (isAppRouter && _reactdom.default.preload) {\n        // See https://github.com/facebook/react/pull/26940\n        _reactdom.default.preload(imgAttributes.src, opts);\n        return null;\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_head.default, {\n        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(\"link\", {\n            rel: \"preload\",\n            // Note how we omit the `href` attribute, as it would only be relevant\n            // for browsers that do not support `imagesrcset`, and in those cases\n            // it would cause the incorrect image to be preloaded.\n            //\n            // https://html.spec.whatwg.org/multipage/semantics.html#attr-link-imagesrcset\n            href: imgAttributes.srcSet ? undefined : imgAttributes.src,\n            ...opts\n        }, \"__nimg-\" + imgAttributes.src + imgAttributes.srcSet + imgAttributes.sizes)\n    });\n}\n_c = ImagePreload;\nconst Image = /*#__PURE__*/ (0, _react.forwardRef)((props, forwardedRef)=>{\n    const pagesRouter = (0, _react.useContext)(_routercontextsharedruntime.RouterContext);\n    // We're in the app directory if there is no pages router.\n    const isAppRouter = !pagesRouter;\n    const configContext = (0, _react.useContext)(_imageconfigcontextsharedruntime.ImageConfigContext);\n    const config = (0, _react.useMemo)(()=>{\n        const c = configEnv || configContext || _imageconfig.imageConfigDefault;\n        const allSizes = [\n            ...c.deviceSizes,\n            ...c.imageSizes\n        ].sort((a, b)=>a - b);\n        const deviceSizes = c.deviceSizes.sort((a, b)=>a - b);\n        return {\n            ...c,\n            allSizes,\n            deviceSizes\n        };\n    }, [\n        configContext\n    ]);\n    const { onLoad, onLoadingComplete } = props;\n    const onLoadRef = (0, _react.useRef)(onLoad);\n    (0, _react.useEffect)(()=>{\n        onLoadRef.current = onLoad;\n    }, [\n        onLoad\n    ]);\n    const onLoadingCompleteRef = (0, _react.useRef)(onLoadingComplete);\n    (0, _react.useEffect)(()=>{\n        onLoadingCompleteRef.current = onLoadingComplete;\n    }, [\n        onLoadingComplete\n    ]);\n    const [blurComplete, setBlurComplete] = (0, _react.useState)(false);\n    const [showAltText, setShowAltText] = (0, _react.useState)(false);\n    const { props: imgAttributes, meta: imgMeta } = (0, _getimgprops.getImgProps)(props, {\n        defaultLoader: _imageloader.default,\n        imgConf: config,\n        blurComplete,\n        showAltText\n    });\n    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n        children: [\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(ImageElement, {\n                ...imgAttributes,\n                unoptimized: imgMeta.unoptimized,\n                placeholder: imgMeta.placeholder,\n                fill: imgMeta.fill,\n                onLoadRef: onLoadRef,\n                onLoadingCompleteRef: onLoadingCompleteRef,\n                setBlurComplete: setBlurComplete,\n                setShowAltText: setShowAltText,\n                sizesInput: props.sizes,\n                ref: forwardedRef\n            }),\n            imgMeta.priority ? /*#__PURE__*/ (0, _jsxruntime.jsx)(ImagePreload, {\n                isAppRouter: isAppRouter,\n                imgAttributes: imgAttributes\n            }) : null\n        ]\n    });\n});\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=image-component.js.map\nvar _c;\n$RefreshReg$(_c, \"ImagePreload\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2ltYWdlLWNvbXBvbmVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OzsrRUFhaUI7cURBQ1dBLENBQUEsQ0FBQUMsbUJBQUFBLENBQUE7eUNBWU87O3lDQUVWQSxtQkFBQUEsQ0FBQTs7O0FBTXpCLE1BQUFDLGVBQUEsY0FBQUMseUJBQTRDSCxDQUFBLENBQUFDLG1CQUFBQSxDQUFBO0FBQzVDLDRDQUE4Qkc7QUFFOUIsTUFBSUMsWUFBT0MsNE9BQXdCO0lBQy9CRSxPQUFBQSxXQUFtQkMsYUFBQUE7SUFDdkJELFdBQUFDLHFCQUFBO0FBbUJBO0FBQ0EsMEVBQWlEO0FBQ2pELGlEQUdFQztTQU1BQyxjQUFZQyxHQUFBQSxFQUFBQSxXQUFBQSxFQUFBQSxTQUFRLEVBQUFDLG9CQUFBLEVBQUFDLGVBQUEsRUFBQUMsV0FBQSxFQUFBQyxVQUFBO0lBQ3BCLE1BQUtKLE1BQU9BLE9BQUksZ0JBQWtCQSxJQUFLSyxHQUFBQTtRQUNyQyxDQUFBTCxPQUFBQSxHQUFBLHdCQUFBSyxLQUFBO1FBQ0Y7SUFDQUw7SUFDQUEsR0FBQSxtQkFBc0JBLEdBQUFBO0lBQ3RCTSxNQUFFQyxJQUFNLFlBQWVQLE1BQUFBLElBQUFRLE1BQUEsS0FBQUMsUUFBQUMsT0FBQTtXQUNyQixDQUFJLEtBQUtDLEdBQUFBLElBQUFBLENBQUFBO1lBQ1AsQ0FBQVgsSUFBQVcsYUFBQSxLQUFBWCxJQUFBWSxXQUFBLEVBQXdDO1lBQ3hDLHdDQUF1QjtZQUN2QjtZQUNBLHNDQUFzQjtZQUN0QjtZQUNBO1lBQ0Y7UUFDQTtZQUNFVixnQkFBZ0I7WUFDbEJBLGdCQUFBO1FBQ0E7WUFDRUosYUFBQSxnQkFBQUEsVUFBQWUsT0FBQSxFQUErQztZQUMvQywrQ0FBMEM7WUFDMUM7WUFDQSwyQ0FBd0I7WUFDeEJDLE1BQUFBLFFBQU9DLElBQUFBLE1BQWVDO21CQUFtQkMsY0FBVSxDQUFBRCxPQUFBO2dCQUFP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QStELGNBQUE7Z0JBQ2pCM0gsR0FBQUEsYUFBYW9IO2dCQUNiOUMsYUFBYThDLFFBQVE5QyxXQUFXO2dCQUNoQ3NELGFBQU1SLFFBQVk5QyxXQUFBO2dCQUNsQjNFLE1BQUFBLFFBQVdBLElBQUFBO2dCQUNYRyxXQUFBQTtnQkFDQUMsc0JBQWlCQTtnQkFDakJ5RSxpQkFBZ0JBO2dCQUNoQnZFLGdCQUFZdUg7Z0JBQ1p4RCxZQUFLRSxNQUFBQSxLQUFBQTs7WUFHUmtEO29CQUVHbEMsUUFBQUEsR0FBYUEsV0FBQUEsR0FBQUEsQ0FBQUEsR0FBQUEsWUFBQUEsR0FBQUEsRUFBQUEsY0FBQUE7Z0JBQ2JQLGFBQUFBOytCQUVBQTs7O0lBR1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3NyYy9jbGllbnQvaW1hZ2UtY29tcG9uZW50LnRzeD81MWUxIl0sIm5hbWVzIjpbIl8iLCJyZXF1aXJlIiwiX2ltYWdlbG9hZGVyIiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwiX19ORVhUX0lNQUdFX09QVFMiLCJjb25maWdFbnYiLCJ3aW5kb3ciLCJlbnYiLCJnbG9iYWxUaGlzIiwiX19ORVhUX0lNQUdFX0lNUE9SVEVEIiwib25Mb2FkUmVmIiwiaGFuZGxlTG9hZGluZyIsImltZyIsIm9uTG9hZGluZ0NvbXBsZXRlUmVmIiwic2V0Qmx1ckNvbXBsZXRlIiwidW5vcHRpbWl6ZWQiLCJzaXplc0lucHV0Iiwic3JjIiwicCIsImNhdGNoIiwiZGVjb2RlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJwYXJlbnRFbGVtZW50IiwiaXNDb25uZWN0ZWQiLCJjdXJyZW50IiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJldmVudCIsIndyaXRhYmxlIiwidmFsdWUiLCJzdG9wcGVkIiwibmF0aXZlRXZlbnQiLCJjdXJyZW50VGFyZ2V0IiwidGFyZ2V0IiwiaXNEZWZhdWx0UHJldmVudGVkIiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJwcmV2ZW50ZWQiLCJwZXJzaXN0IiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJwcm9jZXNzIiwiZ2V0QXR0cmlidXRlIiwiVVJMIiwic2VhcmNoUGFyYW1zIiwiZ2V0Iiwid2lkdGhWaWV3cG9ydFJhdGlvIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwid2lkdGgiLCJpbm5lcldpZHRoIiwid2Fybk9uY2UiLCJfd2Fybm9uY2UiLCJvcmlnU3JjIiwidmFsaWQiLCJnZXRDb21wdXRlZFN0eWxlIiwicG9zaXRpb24iLCJtYXAiLCJTdHJpbmciLCJqb2luIiwid2lkdGhNb2RpZmllZCIsInRvU3RyaW5nIiwiaGVpZ2h0TW9kaWZpZWQiLCJCb29sZWFuIiwidXNlIiwiX3JlYWN0IiwiZmV0Y2hQcmlvcml0eSIsImZldGNocHJpb3JpdHkiLCJoZWlnaHQiLCJkZWNvZGluZyIsImNsYXNzTmFtZSIsInN0eWxlIiwic3JjU2V0Iiwic2l6ZXMiLCJyZXN0IiwiX2pzeHJ1bnRpbWUiLCJqc3giLCJnZXREeW5hbWljUHJvcHMiLCJsb2FkaW5nIiwiZGF0YS1uaW1nIiwicmVmIiwidXNlQ2FsbGJhY2siLCJmb3J3YXJkZWRSZWYiLCJvbkVycm9yIiwiY29uc29sZSIsImVycm9yIiwicGxhY2Vob2xkZXIiLCJvbkxvYWQiLCJzZXRTaG93QWx0VGV4dCIsIkltYWdlUHJlbG9hZCIsInBhcmFtIiwiaW1nQXR0cmlidXRlcyIsIm9wdHMiLCJhcyIsImltYWdlU3JjU2V0IiwiaW1hZ2VTaXplcyIsImNyb3NzT3JpZ2luIiwicmVmZXJyZXJQb2xpY3kiLCJpc0FwcFJvdXRlciIsIl9yZWFjdGRvbSIsImRlZmF1bHQiLCJwcmVsb2FkIiwiUmVhY3RET00iLCJfaGVhZCIsImxpbmsiLCJyZWwiLCJocmVmIiwidW5kZWZpbmVkIiwiSW1hZ2UiLCJ1c2VDb250ZXh0IiwicGFnZXNSb3V0ZXIiLCJSb3V0ZXJDb250ZXh0IiwiX3JvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lIiwiY29uZmlnQ29udGV4dCIsImNvbmZpZyIsInVzZU1lbW8iLCJfaW1hZ2Vjb25maWdjb250ZXh0c2hhcmVkcnVudGltZSIsIkltYWdlQ29uZmlnQ29udGV4dCIsImFsbFNpemVzIiwiX2ltYWdlY29uZmlnIiwiaW1hZ2VDb25maWdEZWZhdWx0IiwiZGV2aWNlU2l6ZXMiLCJjIiwiYSIsImIiLCJzb3J0IiwidXNlUmVmIiwidXNlRWZmZWN0Iiwib25Mb2FkaW5nQ29tcGxldGUiLCJzaG93QWx0VGV4dCIsInVzZVN0YXRlIiwibWV0YSIsImltZ01ldGEiLCJnZXRJbWdQcm9wcyIsImRlZmF1bHRMb2FkZXIiLCJfZ2V0aW1ncHJvcHMiLCJwcm9wcyIsImltZ0NvbmYiLCJibHVyQ29tcGxldGUiLCJJbWFnZUVsZW1lbnQiLCJmaWxsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/image-component.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js ***!
  \*************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"AmpStateContext\", ({\n    enumerable: true,\n    get: function() {\n        return AmpStateContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst AmpStateContext = _react.default.createContext({});\nif (true) {\n    AmpStateContext.displayName = \"AmpStateContext\";\n} //# sourceMappingURL=amp-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9hbXAtY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiOzs7O21EQUVhQTs7O2VBQUFBOzs7OzRFQUZLO0FBRVgsTUFBTUEsa0JBQXNDQyxPQUFBQSxPQUFLLENBQUNDLGFBQWEsQ0FBQyxDQUFDO0FBRXhFLElBQUlDLElBQXlCLEVBQWM7SUFDekNILGdCQUFnQkksV0FBVyxHQUFHO0FBQ2hDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9hbXAtY29udGV4dC5zaGFyZWQtcnVudGltZS50cz85NjQxIl0sIm5hbWVzIjpbIkFtcFN0YXRlQ29udGV4dCIsIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInByb2Nlc3MiLCJkaXNwbGF5TmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-mode.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/amp-mode.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isInAmpMode\", ({\n    enumerable: true,\n    get: function() {\n        return isInAmpMode;\n    }\n}));\nfunction isInAmpMode(param) {\n    let { ampFirst = false, hybrid = false, hasQuery = false } = param === void 0 ? {} : param;\n    return ampFirst || hybrid && hasQuery;\n} //# sourceMappingURL=amp-mode.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9hbXAtbW9kZS5qcyIsIm1hcHBpbmdzIjoiOzs7OytDQUFnQkE7OztlQUFBQTs7O0FBQVQsU0FBU0EsWUFBWUMsS0FBQTtJQUFBLE1BQzFCQyxXQUFXLEtBQUssRUFDaEJDLFNBQVMsS0FBSyxFQUNkQyxXQUFXLEtBQUssRUFDakIsR0FKMkJILFVBQUEsU0FJeEIsQ0FBQyxJQUp1QkE7SUFLMUIsT0FBT0MsWUFBYUMsVUFBVUM7QUFDaEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL2FtcC1tb2RlLnRzP2NlMDQiXSwibmFtZXMiOlsiaXNJbkFtcE1vZGUiLCJwYXJhbSIsImFtcEZpcnN0IiwiaHlicmlkIiwiaGFzUXVlcnkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-mode.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/get-img-props.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getImgProps\", ({\n    enumerable: true,\n    get: function() {\n        return getImgProps;\n    }\n}));\nconst _warnonce = __webpack_require__(/*! ./utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nconst _imageblursvg = __webpack_require__(/*! ./image-blur-svg */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-blur-svg.js\");\nconst _imageconfig = __webpack_require__(/*! ./image-config */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\");\nconst VALID_LOADING_VALUES = [\n    \"lazy\",\n    \"eager\",\n    undefined\n];\nfunction isStaticRequire(src) {\n    return src.default !== undefined;\n}\nfunction isStaticImageData(src) {\n    return src.src !== undefined;\n}\nfunction isStaticImport(src) {\n    return typeof src === \"object\" && (isStaticRequire(src) || isStaticImageData(src));\n}\nconst allImgs = new Map();\nlet perfObserver;\nfunction getInt(x) {\n    if (typeof x === \"undefined\") {\n        return x;\n    }\n    if (typeof x === \"number\") {\n        return Number.isFinite(x) ? x : NaN;\n    }\n    if (typeof x === \"string\" && /^[0-9]+$/.test(x)) {\n        return parseInt(x, 10);\n    }\n    return NaN;\n}\nfunction getWidths(param, width, sizes) {\n    let { deviceSizes, allSizes } = param;\n    if (sizes) {\n        // Find all the \"vw\" percent sizes used in the sizes prop\n        const viewportWidthRe = /(^|\\s)(1?\\d?\\d)vw/g;\n        const percentSizes = [];\n        for(let match; match = viewportWidthRe.exec(sizes); match){\n            percentSizes.push(parseInt(match[2]));\n        }\n        if (percentSizes.length) {\n            const smallestRatio = Math.min(...percentSizes) * 0.01;\n            return {\n                widths: allSizes.filter((s)=>s >= deviceSizes[0] * smallestRatio),\n                kind: \"w\"\n            };\n        }\n        return {\n            widths: allSizes,\n            kind: \"w\"\n        };\n    }\n    if (typeof width !== \"number\") {\n        return {\n            widths: deviceSizes,\n            kind: \"w\"\n        };\n    }\n    const widths = [\n        ...new Set(// > are actually 3x in the green color, but only 1.5x in the red and\n        // > blue colors. Showing a 3x resolution image in the app vs a 2x\n        // > resolution image will be visually the same, though the 3x image\n        // > takes significantly more data. Even true 3x resolution screens are\n        // > wasteful as the human eye cannot see that level of detail without\n        // > something like a magnifying glass.\n        // https://blog.twitter.com/engineering/en_us/topics/infrastructure/2019/capping-image-fidelity-on-ultra-high-resolution-devices.html\n        [\n            width,\n            width * 2 /*, width * 3*/ \n        ].map((w)=>allSizes.find((p)=>p >= w) || allSizes[allSizes.length - 1]))\n    ];\n    return {\n        widths,\n        kind: \"x\"\n    };\n}\nfunction generateImgAttrs(param) {\n    let { config, src, unoptimized, width, quality, sizes, loader } = param;\n    if (unoptimized) {\n        return {\n            src,\n            srcSet: undefined,\n            sizes: undefined\n        };\n    }\n    const { widths, kind } = getWidths(config, width, sizes);\n    const last = widths.length - 1;\n    return {\n        sizes: !sizes && kind === \"w\" ? \"100vw\" : sizes,\n        srcSet: widths.map((w, i)=>loader({\n                config,\n                src,\n                quality,\n                width: w\n            }) + \" \" + (kind === \"w\" ? w : i + 1) + kind).join(\", \"),\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        src: loader({\n            config,\n            src,\n            quality,\n            width: widths[last]\n        })\n    };\n}\nfunction getImgProps(param, _state) {\n    let { src, sizes, unoptimized = false, priority = false, loading, className, quality, width, height, fill = false, style, overrideSrc, onLoad, onLoadingComplete, placeholder = \"empty\", blurDataURL, fetchPriority, layout, objectFit, objectPosition, lazyBoundary, lazyRoot, ...rest } = param;\n    const { imgConf, showAltText, blurComplete, defaultLoader } = _state;\n    let config;\n    let c = imgConf || _imageconfig.imageConfigDefault;\n    if (\"allSizes\" in c) {\n        config = c;\n    } else {\n        const allSizes = [\n            ...c.deviceSizes,\n            ...c.imageSizes\n        ].sort((a, b)=>a - b);\n        const deviceSizes = c.deviceSizes.sort((a, b)=>a - b);\n        config = {\n            ...c,\n            allSizes,\n            deviceSizes\n        };\n    }\n    if (typeof defaultLoader === \"undefined\") {\n        throw new Error(\"images.loaderFile detected but the file is missing default export.\\nRead more: https://nextjs.org/docs/messages/invalid-images-config\");\n    }\n    let loader = rest.loader || defaultLoader;\n    // Remove property so it's not spread on <img> element\n    delete rest.loader;\n    delete rest.srcSet;\n    // This special value indicates that the user\n    // didn't define a \"loader\" prop or \"loader\" config.\n    const isDefaultLoader = \"__next_img_default\" in loader;\n    if (isDefaultLoader) {\n        if (config.loader === \"custom\") {\n            throw new Error('Image with src \"' + src + '\" is missing \"loader\" prop.' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader\");\n        }\n    } else {\n        // The user defined a \"loader\" prop or config.\n        // Since the config object is internal only, we\n        // must not pass it to the user-defined \"loader\".\n        const customImageLoader = loader;\n        loader = (obj)=>{\n            const { config: _, ...opts } = obj;\n            return customImageLoader(opts);\n        };\n    }\n    if (layout) {\n        if (layout === \"fill\") {\n            fill = true;\n        }\n        const layoutToStyle = {\n            intrinsic: {\n                maxWidth: \"100%\",\n                height: \"auto\"\n            },\n            responsive: {\n                width: \"100%\",\n                height: \"auto\"\n            }\n        };\n        const layoutToSizes = {\n            responsive: \"100vw\",\n            fill: \"100vw\"\n        };\n        const layoutStyle = layoutToStyle[layout];\n        if (layoutStyle) {\n            style = {\n                ...style,\n                ...layoutStyle\n            };\n        }\n        const layoutSizes = layoutToSizes[layout];\n        if (layoutSizes && !sizes) {\n            sizes = layoutSizes;\n        }\n    }\n    let staticSrc = \"\";\n    let widthInt = getInt(width);\n    let heightInt = getInt(height);\n    let blurWidth;\n    let blurHeight;\n    if (isStaticImport(src)) {\n        const staticImageData = isStaticRequire(src) ? src.default : src;\n        if (!staticImageData.src) {\n            throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include src. Received \" + JSON.stringify(staticImageData));\n        }\n        if (!staticImageData.height || !staticImageData.width) {\n            throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include height and width. Received \" + JSON.stringify(staticImageData));\n        }\n        blurWidth = staticImageData.blurWidth;\n        blurHeight = staticImageData.blurHeight;\n        blurDataURL = blurDataURL || staticImageData.blurDataURL;\n        staticSrc = staticImageData.src;\n        if (!fill) {\n            if (!widthInt && !heightInt) {\n                widthInt = staticImageData.width;\n                heightInt = staticImageData.height;\n            } else if (widthInt && !heightInt) {\n                const ratio = widthInt / staticImageData.width;\n                heightInt = Math.round(staticImageData.height * ratio);\n            } else if (!widthInt && heightInt) {\n                const ratio = heightInt / staticImageData.height;\n                widthInt = Math.round(staticImageData.width * ratio);\n            }\n        }\n    }\n    src = typeof src === \"string\" ? src : staticSrc;\n    let isLazy = !priority && (loading === \"lazy\" || typeof loading === \"undefined\");\n    if (!src || src.startsWith(\"data:\") || src.startsWith(\"blob:\")) {\n        // https://developer.mozilla.org/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\n        unoptimized = true;\n        isLazy = false;\n    }\n    if (config.unoptimized) {\n        unoptimized = true;\n    }\n    if (isDefaultLoader && src.endsWith(\".svg\") && !config.dangerouslyAllowSVG) {\n        // Special case to make svg serve as-is to avoid proxying\n        // through the built-in Image Optimization API.\n        unoptimized = true;\n    }\n    if (priority) {\n        fetchPriority = \"high\";\n    }\n    const qualityInt = getInt(quality);\n    if (true) {\n        if (config.output === \"export\" && isDefaultLoader && !unoptimized) {\n            throw new Error(\"Image Optimization using the default loader is not compatible with `{ output: 'export' }`.\\n  Possible solutions:\\n    - Remove `{ output: 'export' }` and run \\\"next start\\\" to run server mode including the Image Optimization API.\\n    - Configure `{ images: { unoptimized: true } }` in `next.config.js` to disable the Image Optimization API.\\n  Read more: https://nextjs.org/docs/messages/export-image-api\");\n        }\n        if (!src) {\n            // React doesn't show the stack trace and there's\n            // no `src` to help identify which image, so we\n            // instead console.error(ref) during mount.\n            unoptimized = true;\n        } else {\n            if (fill) {\n                if (width) {\n                    throw new Error('Image with src \"' + src + '\" has both \"width\" and \"fill\" properties. Only one should be used.');\n                }\n                if (height) {\n                    throw new Error('Image with src \"' + src + '\" has both \"height\" and \"fill\" properties. Only one should be used.');\n                }\n                if ((style == null ? void 0 : style.position) && style.position !== \"absolute\") {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.position\" properties. Images with \"fill\" always use position absolute - it cannot be modified.');\n                }\n                if ((style == null ? void 0 : style.width) && style.width !== \"100%\") {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.width\" properties. Images with \"fill\" always use width 100% - it cannot be modified.');\n                }\n                if ((style == null ? void 0 : style.height) && style.height !== \"100%\") {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.height\" properties. Images with \"fill\" always use height 100% - it cannot be modified.');\n                }\n            } else {\n                if (typeof widthInt === \"undefined\") {\n                    throw new Error('Image with src \"' + src + '\" is missing required \"width\" property.');\n                } else if (isNaN(widthInt)) {\n                    throw new Error('Image with src \"' + src + '\" has invalid \"width\" property. Expected a numeric value in pixels but received \"' + width + '\".');\n                }\n                if (typeof heightInt === \"undefined\") {\n                    throw new Error('Image with src \"' + src + '\" is missing required \"height\" property.');\n                } else if (isNaN(heightInt)) {\n                    throw new Error('Image with src \"' + src + '\" has invalid \"height\" property. Expected a numeric value in pixels but received \"' + height + '\".');\n                }\n            }\n        }\n        if (!VALID_LOADING_VALUES.includes(loading)) {\n            throw new Error('Image with src \"' + src + '\" has invalid \"loading\" property. Provided \"' + loading + '\" should be one of ' + VALID_LOADING_VALUES.map(String).join(\",\") + \".\");\n        }\n        if (priority && loading === \"lazy\") {\n            throw new Error('Image with src \"' + src + '\" has both \"priority\" and \"loading=\\'lazy\\'\" properties. Only one should be used.');\n        }\n        if (placeholder !== \"empty\" && placeholder !== \"blur\" && !placeholder.startsWith(\"data:image/\")) {\n            throw new Error('Image with src \"' + src + '\" has invalid \"placeholder\" property \"' + placeholder + '\".');\n        }\n        if (placeholder !== \"empty\") {\n            if (widthInt && heightInt && widthInt * heightInt < 1600) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is smaller than 40x40. Consider removing the \"placeholder\" property to improve performance.');\n            }\n        }\n        if (placeholder === \"blur\" && !blurDataURL) {\n            const VALID_BLUR_EXT = [\n                \"jpeg\",\n                \"png\",\n                \"webp\",\n                \"avif\"\n            ] // should match next-image-loader\n            ;\n            throw new Error('Image with src \"' + src + '\" has \"placeholder=\\'blur\\'\" property but is missing the \"blurDataURL\" property.\\n        Possible solutions:\\n          - Add a \"blurDataURL\" property, the contents should be a small Data URL to represent the image\\n          - Change the \"src\" property to a static import with one of the supported file types: ' + VALID_BLUR_EXT.join(\",\") + ' (animated images not supported)\\n          - Remove the \"placeholder\" property, effectively no blur effect\\n        Read more: https://nextjs.org/docs/messages/placeholder-blur-data-url');\n        }\n        if (\"ref\" in rest) {\n            (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is using unsupported \"ref\" property. Consider using the \"onLoad\" property instead.');\n        }\n        if (!unoptimized && !isDefaultLoader) {\n            const urlStr = loader({\n                config,\n                src,\n                width: widthInt || 400,\n                quality: qualityInt || 75\n            });\n            let url;\n            try {\n                url = new URL(urlStr);\n            } catch (err) {}\n            if (urlStr === src || url && url.pathname === src && !url.search) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" has a \"loader\" property that does not implement width. Please implement it or use the \"unoptimized\" property instead.' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader-width\");\n            }\n        }\n        if (onLoadingComplete) {\n            (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is using deprecated \"onLoadingComplete\" property. Please use the \"onLoad\" property instead.');\n        }\n        for (const [legacyKey, legacyValue] of Object.entries({\n            layout,\n            objectFit,\n            objectPosition,\n            lazyBoundary,\n            lazyRoot\n        })){\n            if (legacyValue) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" has legacy prop \"' + legacyKey + '\". Did you forget to run the codemod?' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-upgrade-to-13\");\n            }\n        }\n        if (typeof window !== \"undefined\" && !perfObserver && window.PerformanceObserver) {\n            perfObserver = new PerformanceObserver((entryList)=>{\n                for (const entry of entryList.getEntries()){\n                    var _entry_element;\n                    // @ts-ignore - missing \"LargestContentfulPaint\" class with \"element\" prop\n                    const imgSrc = (entry == null ? void 0 : (_entry_element = entry.element) == null ? void 0 : _entry_element.src) || \"\";\n                    const lcpImage = allImgs.get(imgSrc);\n                    if (lcpImage && !lcpImage.priority && lcpImage.placeholder === \"empty\" && !lcpImage.src.startsWith(\"data:\") && !lcpImage.src.startsWith(\"blob:\")) {\n                        // https://web.dev/lcp/#measure-lcp-in-javascript\n                        (0, _warnonce.warnOnce)('Image with src \"' + lcpImage.src + '\" was detected as the Largest Contentful Paint (LCP). Please add the \"priority\" property if this image is above the fold.' + \"\\nRead more: https://nextjs.org/docs/api-reference/next/image#priority\");\n                    }\n                }\n            });\n            try {\n                perfObserver.observe({\n                    type: \"largest-contentful-paint\",\n                    buffered: true\n                });\n            } catch (err) {\n                // Log error but don't crash the app\n                console.error(err);\n            }\n        }\n    }\n    const imgStyle = Object.assign(fill ? {\n        position: \"absolute\",\n        height: \"100%\",\n        width: \"100%\",\n        left: 0,\n        top: 0,\n        right: 0,\n        bottom: 0,\n        objectFit,\n        objectPosition\n    } : {}, showAltText ? {} : {\n        color: \"transparent\"\n    }, style);\n    const backgroundImage = !blurComplete && placeholder !== \"empty\" ? placeholder === \"blur\" ? 'url(\"data:image/svg+xml;charset=utf-8,' + (0, _imageblursvg.getImageBlurSvg)({\n        widthInt,\n        heightInt,\n        blurWidth,\n        blurHeight,\n        blurDataURL: blurDataURL || \"\",\n        objectFit: imgStyle.objectFit\n    }) + '\")' : 'url(\"' + placeholder + '\")' // assume `data:image/`\n     : null;\n    let placeholderStyle = backgroundImage ? {\n        backgroundSize: imgStyle.objectFit || \"cover\",\n        backgroundPosition: imgStyle.objectPosition || \"50% 50%\",\n        backgroundRepeat: \"no-repeat\",\n        backgroundImage\n    } : {};\n    if (true) {\n        if (placeholderStyle.backgroundImage && placeholder === \"blur\" && (blurDataURL == null ? void 0 : blurDataURL.startsWith(\"/\"))) {\n            // During `next dev`, we don't want to generate blur placeholders with webpack\n            // because it can delay starting the dev server. Instead, `next-image-loader.js`\n            // will inline a special url to lazily generate the blur placeholder at request time.\n            placeholderStyle.backgroundImage = 'url(\"' + blurDataURL + '\")';\n        }\n    }\n    const imgAttributes = generateImgAttrs({\n        config,\n        src,\n        unoptimized,\n        width: widthInt,\n        quality: qualityInt,\n        sizes,\n        loader\n    });\n    if (true) {\n        if (typeof window !== \"undefined\") {\n            let fullUrl;\n            try {\n                fullUrl = new URL(imgAttributes.src);\n            } catch (e) {\n                fullUrl = new URL(imgAttributes.src, window.location.href);\n            }\n            allImgs.set(fullUrl.href, {\n                src,\n                priority,\n                placeholder\n            });\n        }\n    }\n    const props = {\n        ...rest,\n        loading: isLazy ? \"lazy\" : loading,\n        fetchPriority,\n        width: widthInt,\n        height: heightInt,\n        decoding: \"async\",\n        className,\n        style: {\n            ...imgStyle,\n            ...placeholderStyle\n        },\n        sizes: imgAttributes.sizes,\n        srcSet: imgAttributes.srcSet,\n        src: overrideSrc || imgAttributes.src\n    };\n    const meta = {\n        unoptimized,\n        priority,\n        placeholder,\n        fill\n    };\n    return {\n        props,\n        meta\n    };\n} //# sourceMappingURL=get-img-props.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9nZXQtaW1nLXByb3BzLmpzIiwibWFwcGluZ3MiOiI7Ozs7K0NBMk9nQkE7OztlQUFBQTs7O3NDQTNPUzswQ0FDTzt5Q0FDRztBQTZFbkMsTUFBTUMsdUJBQXVCO0lBQUM7SUFBUTtJQUFTQztDQUFVO0FBa0J6RCxTQUFTQyxnQkFDUEMsR0FBb0M7SUFFcEMsT0FBT0EsSUFBdUJDLE9BQU8sS0FBS0g7QUFDNUM7QUFFQSxTQUFTSSxrQkFDUEYsR0FBb0M7SUFFcEMsT0FBT0EsSUFBeUJBLEdBQUcsS0FBS0Y7QUFDMUM7QUFFQSxTQUFTSyxlQUFlSCxHQUEwQjtJQUNoRCxPQUNFLE9BQU9BLFFBQVEsWUFDZEQsQ0FBQUEsZ0JBQWdCQyxRQUNmRSxrQkFBa0JGLElBQUFBO0FBRXhCO0FBRUEsTUFBTUksVUFBVSxJQUFJQztBQUlwQixJQUFJQztBQUVKLFNBQVNDLE9BQU9DLENBQVU7SUFDeEIsSUFBSSxPQUFPQSxNQUFNLGFBQWE7UUFDNUIsT0FBT0E7SUFDVDtJQUNBLElBQUksT0FBT0EsTUFBTSxVQUFVO1FBQ3pCLE9BQU9DLE9BQU9DLFFBQVEsQ0FBQ0YsS0FBS0EsSUFBSUc7SUFDbEM7SUFDQSxJQUFJLE9BQU9ILE1BQU0sWUFBWSxXQUFXSSxJQUFJLENBQUNKLElBQUk7UUFDL0MsT0FBT0ssU0FBU0wsR0FBRztJQUNyQjtJQUNBLE9BQU9HO0FBQ1Q7QUFFQSxTQUFTRyxVQUNQQyxLQUFzQyxFQUN0Q0MsS0FBeUIsRUFDekJDLEtBQXlCO0lBRnpCLE1BQUVDLFdBQVcsRUFBRUMsUUFBUSxFQUFlLEdBQXRDSjtJQUlBLElBQUlFLE9BQU87UUFDVCx5REFBeUQ7UUFDekQsTUFBTUcsa0JBQWtCO1FBQ3hCLE1BQU1DLGVBQWUsRUFBRTtRQUN2QixJQUFLLElBQUlDLE9BQVFBLFFBQVFGLGdCQUFnQkcsSUFBSSxDQUFDTixRQUFTSyxNQUFPO1lBQzVERCxhQUFhRyxJ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QUFPMEU7UUFDUGpELFNBQVM4RDtRQUNUdEY7UUFDQXlCO0lBQ0Y7SUFFQSxJQUFJOEQsSUFBeUIsRUFBYztRQUN6QyxJQUFJLE9BQU9rQixXQUFXLGFBQWE7WUFDakMsSUFBSTRCO1lBQ0osSUFBSTtnQkFDRkEsVUFBVSxJQUFJcEMsSUFBSW1DLGNBQWNySixHQUFHO1lBQ3JDLEVBQUUsT0FBT3VKLEdBQUc7Z0JBQ1ZELFVBQVUsSUFBSXBDLElBQUltQyxjQUFjckosR0FBRyxFQUFFMEgsT0FBTzhCLFFBQVEsQ0FBQ0MsSUFBSTtZQUMzRDtZQUNBckosUUFBUXNKLEdBQUcsQ0FBQ0osUUFBUUcsSUFBSSxFQUFFO2dCQUFFeko7Z0JBQUtnRDtnQkFBVVM7WUFBWTtRQUN6RDtJQUNGO0lBRUEsTUFBTWtHLFFBQWtCO1FBQ3RCLEdBQUcxRixJQUFJO1FBQ1BoQixTQUFTa0QsU0FBUyxTQUFTbEQ7UUFDM0JVO1FBQ0EzQyxPQUFPMEU7UUFDUHZDLFFBQVF3QztRQUNSaUUsVUFBVTtRQUNWMUc7UUFDQUcsT0FBTztZQUFFLEdBQUdtRixRQUFRO1lBQUUsR0FBR1MsZ0JBQWdCO1FBQUM7UUFDMUNoSSxPQUFPb0ksY0FBY3BJLEtBQUs7UUFDMUIwQixRQUFRMEcsY0FBYzFHLE1BQU07UUFDNUIzQyxLQUFLc0QsZUFBZStGLGNBQWNySixHQUFHO0lBQ3ZDO0lBQ0EsTUFBTTZKLE9BQU87UUFBRXJIO1FBQWFRO1FBQVVTO1FBQWFMO0lBQUs7SUFDeEQsT0FBTztRQUFFdUc7UUFBT0U7SUFBSztBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvZ2V0LWltZy1wcm9wcy50cz9lYzkxIl0sIm5hbWVzIjpbImdldEltZ1Byb3BzIiwiVkFMSURfTE9BRElOR19WQUxVRVMiLCJ1bmRlZmluZWQiLCJpc1N0YXRpY1JlcXVpcmUiLCJzcmMiLCJkZWZhdWx0IiwiaXNTdGF0aWNJbWFnZURhdGEiLCJpc1N0YXRpY0ltcG9ydCIsImFsbEltZ3MiLCJNYXAiLCJwZXJmT2JzZXJ2ZXIiLCJnZXRJbnQiLCJ4IiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJOYU4iLCJ0ZXN0IiwicGFyc2VJbnQiLCJnZXRXaWR0aHMiLCJwYXJhbSIsIndpZHRoIiwic2l6ZXMiLCJkZXZpY2VTaXplcyIsImFsbFNpemVzIiwidmlld3BvcnRXaWR0aFJlIiwicGVyY2VudFNpemVzIiwibWF0Y2giLCJleGVjIiwicHVzaCIsImxlbmd0aCIsInNtYWxsZXN0UmF0aW8iLCJNYXRoIiwibWluIiwid2lkdGhzIiwiZmlsdGVyIiwicyIsImtpbmQiLCJTZXQiLCJtYXAiLCJ3IiwiZmluZCIsInAiLCJnZW5lcmF0ZUltZ0F0dHJzIiwiY29uZmlnIiwidW5vcHRpbWl6ZWQiLCJxdWFsaXR5IiwibG9hZGVyIiwic3JjU2V0IiwibGFzdCIsImkiLCJqb2luIiwiX3N0YXRlIiwicHJpb3JpdHkiLCJsb2FkaW5nIiwiY2xhc3NOYW1lIiwiaGVpZ2h0IiwiZmlsbCIsInN0eWxlIiwib3ZlcnJpZGVTcmMiLCJvbkxvYWQiLCJvbkxvYWRpbmdDb21wbGV0ZSIsInBsYWNlaG9sZGVyIiwiYmx1ckRhdGFVUkwiLCJmZXRjaFByaW9yaXR5IiwibGF5b3V0Iiwib2JqZWN0Rml0Iiwib2JqZWN0UG9zaXRpb24iLCJsYXp5Qm91bmRhcnkiLCJsYXp5Um9vdCIsInJlc3QiLCJpbWdDb25mIiwic2hvd0FsdFRleHQiLCJibHVyQ29tcGxldGUiLCJkZWZhdWx0TG9hZGVyIiwiYyIsImltYWdlQ29uZmlnRGVmYXVsdCIsImltYWdlU2l6ZXMiLCJzb3J0IiwiYSIsImIiLCJFcnJvciIsImlzRGVmYXVsdExvYWRlciIsImN1c3RvbUltYWdlTG9hZGVyIiwib2JqIiwiXyIsIm9wdHMiLCJsYXlvdXRUb1N0eWxlIiwiaW50cmluc2ljIiwibWF4V2lkdGgiLCJyZXNwb25zaXZlIiwibGF5b3V0VG9TaXplcyIsImxheW91dFN0eWxlIiwibGF5b3V0U2l6ZXMiLCJzdGF0aWNTcmMiLCJ3aWR0aEludCIsImhlaWdodEludCIsImJsdXJXaWR0aCIsImJsdXJIZWlnaHQiLCJzdGF0aWNJbWFnZURhdGEiLCJKU09OIiwic3RyaW5naWZ5IiwicmF0aW8iLCJyb3VuZCIsImlzTGF6eSIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsImRhbmdlcm91c2x5QWxsb3dTVkciLCJxdWFsaXR5SW50IiwicHJvY2VzcyIsIm91dHB1dCIsInBvc2l0aW9uIiwiaXNOYU4iLCJpbmNsdWRlcyIsIlN0cmluZyIsIndhcm5PbmNlIiwiVkFMSURfQkxVUl9FWFQiLCJ1cmxTdHIiLCJ1cmwiLCJVUkwiLCJlcnIiLCJwYXRobmFtZSIsInNlYXJjaCIsImxlZ2FjeUtleSIsImxlZ2FjeVZhbHVlIiwiT2JqZWN0IiwiZW50cmllcyIsIndpbmRvdyIsIlBlcmZvcm1hbmNlT2JzZXJ2ZXIiLCJlbnRyeUxpc3QiLCJlbnRyeSIsImdldEVudHJpZXMiLCJpbWdTcmMiLCJlbGVtZW50IiwibGNwSW1hZ2UiLCJnZXQiLCJvYnNlcnZlIiwidHlwZSIsImJ1ZmZlcmVkIiwiY29uc29sZSIsImVycm9yIiwiaW1nU3R5bGUiLCJhc3NpZ24iLCJsZWZ0IiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJjb2xvciIsImJhY2tncm91bmRJbWFnZSIsImdldEltYWdlQmx1clN2ZyIsInBsYWNlaG9sZGVyU3R5bGUiLCJiYWNrZ3JvdW5kU2l6ZSIsImJhY2tncm91bmRQb3NpdGlvbiIsImJhY2tncm91bmRSZXBlYXQiLCJpbWdBdHRyaWJ1dGVzIiwiZnVsbFVybCIsImUiLCJsb2NhdGlvbiIsImhyZWYiLCJzZXQiLCJwcm9wcyIsImRlY29kaW5nIiwibWV0YSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/head.js":
/*!***************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/head.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    default: function() {\n        return _default;\n    },\n    defaultHead: function() {\n        return defaultHead;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _sideeffect = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./side-effect */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/side-effect.js\"));\nconst _ampcontextsharedruntime = __webpack_require__(/*! ./amp-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js\");\nconst _headmanagercontextsharedruntime = __webpack_require__(/*! ./head-manager-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js\");\nconst _ampmode = __webpack_require__(/*! ./amp-mode */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-mode.js\");\nconst _warnonce = __webpack_require__(/*! ./utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nfunction defaultHead(inAmpMode) {\n    if (inAmpMode === void 0) inAmpMode = false;\n    const head = [\n        /*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n            charSet: \"utf-8\"\n        })\n    ];\n    if (!inAmpMode) {\n        head.push(/*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n            name: \"viewport\",\n            content: \"width=device-width\"\n        }));\n    }\n    return head;\n}\nfunction onlyReactElement(list, child) {\n    // React children can be \"string\" or \"number\" in this case we ignore them for backwards compat\n    if (typeof child === \"string\" || typeof child === \"number\") {\n        return list;\n    }\n    // Adds support for React.Fragment\n    if (child.type === _react.default.Fragment) {\n        return list.concat(_react.default.Children.toArray(child.props.children).reduce((fragmentList, fragmentChild)=>{\n            if (typeof fragmentChild === \"string\" || typeof fragmentChild === \"number\") {\n                return fragmentList;\n            }\n            return fragmentList.concat(fragmentChild);\n        }, []));\n    }\n    return list.concat(child);\n}\nconst METATYPES = [\n    \"name\",\n    \"httpEquiv\",\n    \"charSet\",\n    \"itemProp\"\n];\n/*\n returns a function for filtering head child elements\n which shouldn't be duplicated, like <title/>\n Also adds support for deduplicated `key` properties\n*/ function unique() {\n    const keys = new Set();\n    const tags = new Set();\n    const metaTypes = new Set();\n    const metaCategories = {};\n    return (h)=>{\n        let isUnique = true;\n        let hasKey = false;\n        if (h.key && typeof h.key !== \"number\" && h.key.indexOf(\"$\") > 0) {\n            hasKey = true;\n            const key = h.key.slice(h.key.indexOf(\"$\") + 1);\n            if (keys.has(key)) {\n                isUnique = false;\n            } else {\n                keys.add(key);\n            }\n        }\n        // eslint-disable-next-line default-case\n        switch(h.type){\n            case \"title\":\n            case \"base\":\n                if (tags.has(h.type)) {\n                    isUnique = false;\n                } else {\n                    tags.add(h.type);\n                }\n                break;\n            case \"meta\":\n                for(let i = 0, len = METATYPES.length; i < len; i++){\n                    const metatype = METATYPES[i];\n                    if (!h.props.hasOwnProperty(metatype)) continue;\n                    if (metatype === \"charSet\") {\n                        if (metaTypes.has(metatype)) {\n                            isUnique = false;\n                        } else {\n                            metaTypes.add(metatype);\n                        }\n                    } else {\n                        const category = h.props[metatype];\n                        const categories = metaCategories[metatype] || new Set();\n                        if ((metatype !== \"name\" || !hasKey) && categories.has(category)) {\n                            isUnique = false;\n                        } else {\n                            categories.add(category);\n                            metaCategories[metatype] = categories;\n                        }\n                    }\n                }\n                break;\n        }\n        return isUnique;\n    };\n}\n/**\n *\n * @param headChildrenElements List of children of <Head>\n */ function reduceComponents(headChildrenElements, props) {\n    const { inAmpMode } = props;\n    return headChildrenElements.reduce(onlyReactElement, []).reverse().concat(defaultHead(inAmpMode).reverse()).filter(unique()).reverse().map((c, i)=>{\n        const key = c.key || i;\n        if (false) {}\n        if (true) {\n            // omit JSON-LD structured data snippets from the warning\n            if (c.type === \"script\" && c.props[\"type\"] !== \"application/ld+json\") {\n                const srcMessage = c.props[\"src\"] ? '<script> tag with src=\"' + c.props[\"src\"] + '\"' : \"inline <script>\";\n                (0, _warnonce.warnOnce)(\"Do not add <script> tags using next/head (see \" + srcMessage + \"). Use next/script instead. \\nSee more info here: https://nextjs.org/docs/messages/no-script-tags-in-head-component\");\n            } else if (c.type === \"link\" && c.props[\"rel\"] === \"stylesheet\") {\n                (0, _warnonce.warnOnce)('Do not add stylesheets using next/head (see <link rel=\"stylesheet\"> tag with href=\"' + c.props[\"href\"] + '\"). Use Document instead. \\nSee more info here: https://nextjs.org/docs/messages/no-stylesheets-in-head-component');\n            }\n        }\n        return /*#__PURE__*/ _react.default.cloneElement(c, {\n            key\n        });\n    });\n}\n/**\n * This component injects elements to `<head>` of your page.\n * To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.\n */ function Head(param) {\n    let { children } = param;\n    const ampState = (0, _react.useContext)(_ampcontextsharedruntime.AmpStateContext);\n    const headManager = (0, _react.useContext)(_headmanagercontextsharedruntime.HeadManagerContext);\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_sideeffect.default, {\n        reduceComponentsToState: reduceComponents,\n        headManager: headManager,\n        inAmpMode: (0, _ampmode.isInAmpMode)(ampState),\n        children: children\n    });\n}\n_c = Head;\nconst _default = Head;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=head.js.map\nvar _c;\n$RefreshReg$(_c, \"Head\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9oZWFkLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O1FBcU1BQSxTQUFtQjs7O0lBeExIQztpQkFBQUE7Ozs7Ozs7OzJEQVRnQkMsQ0FBQSxDQUFBQyxtQkFBQUEsQ0FBQTs7eUNBRUpBLG1CQUFBQSxDQUFBOztBQU9yQixNQUFBQyxZQUFTSCxtQkFBQUEsQ0FBWUkscUdBQUFBO1NBQUFBLFlBQUFBLFNBQUFBO0lBQzFCLElBQUFBLGNBQWEsUUFBQUEsWUFBQTs7bUJBQU9DLEdBQVEsSUFBQUMsWUFBQUMsR0FBQTs7UUFBVztLQUN2QztRQUNFQyxDQUFBQSxXQUFTO2FBQU9DLElBQUFBLENBQUssa0JBQUFILFlBQUFDLEdBQUE7WUFBV0csTUFBQUE7O1FBQ2xDO0lBQ0E7SUFDRixPQUFBRjtBQUVBO1NBSUVHLGlCQUFBQyxJQUFBLEVBQUFDLEtBQUE7SUFDQSw4RkFBNEQ7UUFDMUQsT0FBT0QsVUFBQUEsWUFBQUEsT0FBQUEsVUFBQUEsVUFBQUE7UUFDVCxPQUFBQTtJQUNBO0lBQ0Esa0NBQXlCRTtRQUN2QkQsTUFBQUUsSUFBT0gsS0FBS0ksT0FDVkMsT0FBQSxDQUFBSCxRQUFBO1FBQ0FJLE9BQUFBLEtBQUFBLE1BQU1DLENBRUpDLE9BQ0VDLE9BQUFBLENBQ0FDLFFBQUFBLENBQUFBLE9BQUFBLENBQUFBLE1BQUFBLEtBQUFBLENBQUFBLFFBQUFBLEVBQUFBLE1BQUFBLGdCQUdTQTtnQkFHUCxPQUFPRCxrQkFBQUEsWUFBQUEsT0FBQUEsa0JBQUFBLFVBQUFBO2dCQUNULE9BQUFBO1lBQ0E7WUFFRixPQUFFQSxhQUFBTCxNQUFBLENBQUFNO1FBR1I7SUFDQTtJQUNGLE9BQUFWLEtBQUFJLE1BQUEsQ0FBQUg7QUFFQTtNQUFtQlUsWUFBQTtJQUFRO0lBQWE7SUFBVztJQUFXO0NBRTlEOzs7OztZQU1RQztJQUNOLE1BQU1DLE9BQU8sSUFBSUM7SUFDakIsTUFB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QSxDQUNFLEdBQUF6QyxPQUFBd0MsVUFBQSxFQUFDRyxpQ0FBTUQsa0JBQUE7V0FDTEUsV0FBQUEsR0FBQUEsQ0FBQUEsR0FBQUEsWUFBeUJDLEdBQUFBLEVBQUFBLFlBQUFBLE9BQUFBLEVBQUFBO1FBQ3pCSix5QkFBYUE7UUFDYnpELGFBQVc4RDttQkFFVlQsQ0FBQUEsR0FBQUEsU0FBQUEsV0FBQUEsRUFBQUE7O0lBR1A7O0tBWmdCQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvaGVhZC50c3g/MzY3MCJdLCJuYW1lcyI6WyJleHBvcnRzIiwiZGVmYXVsdEhlYWQiLCJfIiwicmVxdWlyZSIsIl93YXJub25jZSIsImluQW1wTW9kZSIsImNoYXJTZXQiLCJfanN4cnVudGltZSIsImpzeCIsImhlYWQiLCJuYW1lIiwiY29udGVudCIsIm9ubHlSZWFjdEVsZW1lbnQiLCJsaXN0IiwiY2hpbGQiLCJGcmFnbWVudCIsInR5cGUiLCJjb25jYXQiLCJkZWZhdWx0IiwiUmVhY3QiLCJDaGlsZHJlbiIsIl9yZWFjdCIsImZyYWdtZW50TGlzdCIsImZyYWdtZW50Q2hpbGQiLCJNRVRBVFlQRVMiLCJrZXlzIiwidGFncyIsIlNldCIsIm1ldGFUeXBlcyIsIm1ldGFDYXRlZ29yaWVzIiwiaCIsImlzVW5pcXVlIiwiaGFzS2V5Iiwia2V5IiwiaW5kZXhPZiIsImFkZCIsImkiLCJtZXRhdHlwZSIsImxlbiIsImhhc093blByb3BlcnR5IiwiY2F0ZWdvcmllcyIsImhhcyIsImNhdGVnb3J5IiwicHJvcHMiLCJoZWFkQ2hpbGRyZW5FbGVtZW50cyIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImMiLCJfX05FWFRfT1BUSU1JWkVfRk9OVFMiLCJzb21lIiwidXJsIiwibmV3UHJvcHMiLCJzdGFydHNXaXRoIiwidW5kZWZpbmVkIiwiY2xvbmVFbGVtZW50Iiwic3JjTWVzc2FnZSIsIndhcm5PbmNlIiwiY2hpbGRyZW4iLCJwYXJhbSIsImFtcFN0YXRlIiwidXNlQ29udGV4dCIsImhlYWRNYW5hZ2VyIiwiSGVhZE1hbmFnZXJDb250ZXh0IiwiRWZmZWN0IiwicmVkdWNlQ29tcG9uZW50c1RvU3RhdGUiLCJyZWR1Y2VDb21wb25lbnRzIiwiaXNJbkFtcE1vZGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/head.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-blur-svg.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-blur-svg.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * A shared function, used on both client and server, to generate a SVG blur placeholder.\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getImageBlurSvg\", ({\n    enumerable: true,\n    get: function() {\n        return getImageBlurSvg;\n    }\n}));\nfunction getImageBlurSvg(param) {\n    let { widthInt, heightInt, blurWidth, blurHeight, blurDataURL, objectFit } = param;\n    const std = 20;\n    const svgWidth = blurWidth ? blurWidth * 40 : widthInt;\n    const svgHeight = blurHeight ? blurHeight * 40 : heightInt;\n    const viewBox = svgWidth && svgHeight ? \"viewBox='0 0 \" + svgWidth + \" \" + svgHeight + \"'\" : \"\";\n    const preserveAspectRatio = viewBox ? \"none\" : objectFit === \"contain\" ? \"xMidYMid\" : objectFit === \"cover\" ? \"xMidYMid slice\" : \"none\";\n    return \"%3Csvg xmlns='http://www.w3.org/2000/svg' \" + viewBox + \"%3E%3Cfilter id='b' color-interpolation-filters='sRGB'%3E%3CfeGaussianBlur stdDeviation='\" + std + \"'/%3E%3CfeColorMatrix values='1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 100 -1' result='s'/%3E%3CfeFlood x='0' y='0' width='100%25' height='100%25'/%3E%3CfeComposite operator='out' in='s'/%3E%3CfeComposite in2='SourceGraphic'/%3E%3CfeGaussianBlur stdDeviation='\" + std + \"'/%3E%3C/filter%3E%3Cimage width='100%25' height='100%25' x='0' y='0' preserveAspectRatio='\" + preserveAspectRatio + \"' style='filter: url(%23b);' href='\" + blurDataURL + \"'/%3E%3C/svg%3E\";\n} //# sourceMappingURL=image-blur-svg.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1ibHVyLXN2Zy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQzs7OzttREFDZUE7OztlQUFBQTs7O0FBQVQsU0FBU0EsZ0JBQWdCQyxLQWMvQjtJQWQrQixNQUM5QkMsUUFBUSxFQUNSQyxTQUFTLEVBQ1RDLFNBQVMsRUFDVEMsVUFBVSxFQUNWQyxXQUFXLEVBQ1hDLFNBQVMsRUFRVixHQWQrQk47SUFlOUIsTUFBTU8sTUFBTTtJQUNaLE1BQU1DLFdBQVdMLFlBQVlBLFlBQVksS0FBS0Y7SUFDOUMsTUFBTVEsWUFBWUwsYUFBYUEsYUFBYSxLQUFLRjtJQUVqRCxNQUFNUSxVQUNKRixZQUFZQyxZQUFZLGtCQUFnQkQsV0FBUyxNQUFHQyxZQUFVLE1BQUs7SUFDckUsTUFBTUUsc0JBQXNCRCxVQUN4QixTQUNBSixjQUFjLFlBQ2QsYUFDQUEsY0FBYyxVQUNkLG1CQUNBO0lBRUosT0FBTywrQ0FBNkNJLFVBQVEsOEZBQTJGSCxNQUFJLG9RQUFpUUEsTUFBSSxnR0FBNkZJLHNCQUFvQix3Q0FBcUNOLGNBQVk7QUFDcGtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9pbWFnZS1ibHVyLXN2Zy50cz9jNzljIl0sIm5hbWVzIjpbImdldEltYWdlQmx1clN2ZyIsInBhcmFtIiwid2lkdGhJbnQiLCJoZWlnaHRJbnQiLCJibHVyV2lkdGgiLCJibHVySGVpZ2h0IiwiYmx1ckRhdGFVUkwiLCJvYmplY3RGaXQiLCJzdGQiLCJzdmdXaWR0aCIsInN2Z0hlaWdodCIsInZpZXdCb3giLCJwcmVzZXJ2ZUFzcGVjdFJhdGlvIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-blur-svg.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js ***!
  \**********************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"ImageConfigContext\", ({\n    enumerable: true,\n    get: function() {\n        return ImageConfigContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _imageconfig = __webpack_require__(/*! ./image-config */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\");\nconst ImageConfigContext = _react.default.createContext(_imageconfig.imageConfigDefault);\nif (true) {\n    ImageConfigContext.displayName = \"ImageConfigContext\";\n} //# sourceMappingURL=image-config-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1jb25maWctY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiOzs7O3NEQUlhQTs7O2VBQUFBOzs7OzRFQUpLO3lDQUVpQjtBQUU1QixNQUFNQSxxQkFDWEMsT0FBQUEsT0FBSyxDQUFDQyxhQUFhLENBQXNCQyxhQUFBQSxrQkFBa0I7QUFFN0QsSUFBSUMsSUFBeUIsRUFBYztJQUN6Q0osbUJBQW1CSyxXQUFXLEdBQUc7QUFDbkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL2ltYWdlLWNvbmZpZy1jb250ZXh0LnNoYXJlZC1ydW50aW1lLnRzPzNkNzUiXSwibmFtZXMiOlsiSW1hZ2VDb25maWdDb250ZXh0IiwiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwiaW1hZ2VDb25maWdEZWZhdWx0IiwicHJvY2VzcyIsImRpc3BsYXlOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-config.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    VALID_LOADERS: function() {\n        return VALID_LOADERS;\n    },\n    imageConfigDefault: function() {\n        return imageConfigDefault;\n    }\n});\nconst VALID_LOADERS = [\n    \"default\",\n    \"imgix\",\n    \"cloudinary\",\n    \"akamai\",\n    \"custom\"\n];\nconst imageConfigDefault = {\n    deviceSizes: [\n        640,\n        750,\n        828,\n        1080,\n        1200,\n        1920,\n        2048,\n        3840\n    ],\n    imageSizes: [\n        16,\n        32,\n        48,\n        64,\n        96,\n        128,\n        256,\n        384\n    ],\n    path: \"/_next/image\",\n    loader: \"default\",\n    loaderFile: \"\",\n    domains: [],\n    disableStaticImages: false,\n    minimumCacheTTL: 60,\n    formats: [\n        \"image/webp\"\n    ],\n    dangerouslyAllowSVG: false,\n    contentSecurityPolicy: \"script-src 'none'; frame-src 'none'; sandbox;\",\n    contentDispositionType: \"inline\",\n    remotePatterns: [],\n    unoptimized: false\n}; //# sourceMappingURL=image-config.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1jb25maWcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBQWFBLGVBQWE7ZUFBYkE7O0lBc0dBQyxvQkFBa0I7ZUFBbEJBOzs7QUF0R04sTUFBTUQsZ0JBQWdCO0lBQzNCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQWdHTSxNQUFNQyxxQkFBMEM7SUFDckRDLGFBQWE7UUFBQztRQUFLO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO0tBQUs7SUFDMURDLFlBQVk7UUFBQztRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSztRQUFLO0tBQUk7SUFDL0NDLE1BQU07SUFDTkMsUUFBUTtJQUNSQyxZQUFZO0lBQ1pDLFNBQVMsRUFBRTtJQUNYQyxxQkFBcUI7SUFDckJDLGlCQUFpQjtJQUNqQkMsU0FBUztRQUFDO0tBQWE7SUFDdkJDLHFCQUFxQjtJQUNyQkMsdUJBQXdCO0lBQ3hCQyx3QkFBd0I7SUFDeEJDLGdCQUFnQixFQUFFO0lBQ2xCQyxhQUFhO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL2ltYWdlLWNvbmZpZy50cz8xMzRhIl0sIm5hbWVzIjpbIlZBTElEX0xPQURFUlMiLCJpbWFnZUNvbmZpZ0RlZmF1bHQiLCJkZXZpY2VTaXplcyIsImltYWdlU2l6ZXMiLCJwYXRoIiwibG9hZGVyIiwibG9hZGVyRmlsZSIsImRvbWFpbnMiLCJkaXNhYmxlU3RhdGljSW1hZ2VzIiwibWluaW11bUNhY2hlVFRMIiwiZm9ybWF0cyIsImRhbmdlcm91c2x5QWxsb3dTVkciLCJjb250ZW50U2VjdXJpdHlQb2xpY3kiLCJjb250ZW50RGlzcG9zaXRpb25UeXBlIiwicmVtb3RlUGF0dGVybnMiLCJ1bm9wdGltaXplZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-external.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-external.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    default: function() {\n        return _default;\n    },\n    getImageProps: function() {\n        return getImageProps;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _getimgprops = __webpack_require__(/*! ./get-img-props */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js\");\nconst _imagecomponent = __webpack_require__(/*! ../../client/image-component */ \"(app-pages-browser)/./node_modules/next/dist/client/image-component.js\");\nconst _imageloader = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! next/dist/shared/lib/image-loader */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js\"));\nfunction getImageProps(imgProps) {\n    const { props } = (0, _getimgprops.getImgProps)(imgProps, {\n        defaultLoader: _imageloader.default,\n        // This is replaced by webpack define plugin\n        imgConf: {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[],\"output\":\"export\"}\n    });\n    // Normally we don't care about undefined props because we pass to JSX,\n    // but this exported function could be used by the end user for anything\n    // so we delete undefined props to clean it up a little.\n    for (const [key, value] of Object.entries(props)){\n        if (value === undefined) {\n            delete props[key];\n        }\n    }\n    return {\n        props\n    };\n}\nconst _default = _imagecomponent.Image; //# sourceMappingURL=image-external.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1leHRlcm5hbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFpQ0FBLFNBQW9CO2VBQXBCQzs7SUFqQmdCQyxlQUFhO2VBQWJBOzs7O3lDQWJZOzRDQUNOO2tGQUdJO0FBU25CLFNBQVNBLGNBQWNDLFFBQW9CO0lBQ2hELE1BQU0sRUFBRUMsS0FBSyxFQUFFLEdBQUdDLENBQUFBLEdBQUFBLGFBQUFBLFdBQVcsRUFBQ0YsVUFBVTtRQUN0Q0csZUFBQUEsYUFBQUEsT0FBYTtRQUNiLDRDQUE0QztRQUM1Q0MsU0FBU0MsNE9BQTZCO0lBQ3hDO0lBQ0EsdUVBQXVFO0lBQ3ZFLHdFQUF3RTtJQUN4RSx3REFBd0Q7SUFDeEQsS0FBSyxNQUFNLENBQUNHLEtBQUtDLE1BQU0sSUFBSUMsT0FBT0MsT0FBTyxDQUFDVixPQUFRO1FBQ2hELElBQUlRLFVBQVVHLFdBQVc7WUFDdkIsT0FBT1gsS0FBSyxDQUFDTyxJQUEwQjtRQUN6QztJQUNGO0lBQ0EsT0FBTztRQUFFUDtJQUFNO0FBQ2pCO01BRUFILFdBQWVlLGdCQUFBQSxLQUFLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9pbWFnZS1leHRlcm5hbC50c3g/MzgyNiJdLCJuYW1lcyI6WyJkZWZhdWx0IiwiX2RlZmF1bHQiLCJnZXRJbWFnZVByb3BzIiwiaW1nUHJvcHMiLCJwcm9wcyIsImdldEltZ1Byb3BzIiwiZGVmYXVsdExvYWRlciIsImltZ0NvbmYiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0lNQUdFX09QVFMiLCJrZXkiLCJ2YWx1ZSIsIk9iamVjdCIsImVudHJpZXMiLCJ1bmRlZmluZWQiLCJJbWFnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-external.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-loader.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return _default;\n    }\n}));\nfunction defaultLoader(param) {\n    let { config, src, width, quality } = param;\n    if (true) {\n        const missingValues = [];\n        // these should always be provided but make sure they are\n        if (!src) missingValues.push(\"src\");\n        if (!width) missingValues.push(\"width\");\n        if (missingValues.length > 0) {\n            throw new Error(\"Next Image Optimization requires \" + missingValues.join(\", \") + \" to be provided. Make sure you pass them as props to the `next/image` component. Received: \" + JSON.stringify({\n                src,\n                width,\n                quality\n            }));\n        }\n        if (src.startsWith(\"//\")) {\n            throw new Error('Failed to parse src \"' + src + '\" on `next/image`, protocol-relative URL (//) must be changed to an absolute URL (http:// or https://)');\n        }\n        if (!src.startsWith(\"/\") && (config.domains || config.remotePatterns)) {\n            let parsedSrc;\n            try {\n                parsedSrc = new URL(src);\n            } catch (err) {\n                console.error(err);\n                throw new Error('Failed to parse src \"' + src + '\" on `next/image`, if using relative image it must start with a leading slash \"/\" or be an absolute URL (http:// or https://)');\n            }\n            if (true) {\n                // We use dynamic require because this should only error in development\n                const { hasMatch } = __webpack_require__(/*! ./match-remote-pattern */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/match-remote-pattern.js\");\n                if (!hasMatch(config.domains, config.remotePatterns, parsedSrc)) {\n                    throw new Error(\"Invalid src prop (\" + src + ') on `next/image`, hostname \"' + parsedSrc.hostname + '\" is not configured under images in your `next.config.js`\\n' + \"See more info: https://nextjs.org/docs/messages/next-image-unconfigured-host\");\n                }\n            }\n        }\n    }\n    return config.path + \"?url=\" + encodeURIComponent(src) + \"&w=\" + width + \"&q=\" + (quality || 75) + ( false ? 0 : \"\");\n}\n// We use this to determine if the import is the default loader\n// or a custom loader defined by the user in next.config.js\ndefaultLoader.__next_img_default = true;\nconst _default = defaultLoader; //# sourceMappingURL=image-loader.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1sb2FkZXIuanMiLCJtYXBwaW5ncyI6Ijs7OzsyQ0F3RUE7OztlQUFBQTs7O0FBdEVBLFNBQVNDLGNBQWNDLEtBS007SUFMTixNQUNyQkMsTUFBTSxFQUNOQyxHQUFHLEVBQ0hDLEtBQUssRUFDTEMsT0FBTyxFQUNvQixHQUxOSjtJQU1yQixJQUFJSyxJQUF5QixFQUFjO1FBQ3pDLE1BQU1DLGdCQUFnQixFQUFFO1FBRXhCLHlEQUF5RDtRQUN6RCxJQUFJLENBQUNKLEtBQUtJLGNBQWNDLElBQUksQ0FBQztRQUM3QixJQUFJLENBQUNKLE9BQU9HLGNBQWNDLElBQUksQ0FBQztRQUUvQixJQUFJRCxjQUFjRSxNQUFNLEdBQUcsR0FBRztZQUM1QixNQUFNLElBQUlDLE1BQ1Isc0NBQW9DSCxjQUFjSSxJQUFJLENBQ3BELFFBQ0EsZ0dBQStGQyxLQUFLQyxTQUFTLENBQzdHO2dCQUFFVjtnQkFBS0M7Z0JBQU9DO1lBQVE7UUFHNUI7UUFFQSxJQUFJRixJQUFJVyxVQUFVLENBQUMsT0FBTztZQUN4QixNQUFNLElBQUlKLE1BQ1IsMEJBQXdCUCxNQUFJO1FBRWhDO1FBRUEsSUFBSSxDQUFDQSxJQUFJVyxVQUFVLENBQUMsUUFBU1osQ0FBQUEsT0FBT2EsT0FBTyxJQUFJYixPQUFPYyxjQUFjLEdBQUc7WUFDckUsSUFBSUM7WUFDSixJQUFJO2dCQUNGQSxZQUFZLElBQUlDLElBQUlmO1lBQ3RCLEVBQUUsT0FBT2dCLEtBQUs7Z0JBQ1pDLFFBQVFDLEtBQUssQ0FBQ0Y7Z0JBQ2QsTUFBTSxJQUFJVCxNQUNSLDBCQUF3QlAsTUFBSTtZQUVoQztZQUVBLElBQ0VHLElBRTZCLEVBQzdCO2dCQUNBLHVFQUF1RTtnQkFDdkUsTUFBTSxFQUFFa0IsUUFBUSxFQUFFLEdBQUdDLG1CQUFBQSxDQUFRO2dCQUM3QixJQUFJLENBQUNELFNBQVN0QixPQUFPYSxPQUFPLEVBQUViLE9BQU9jLGNBQWMsRUFBRUMsWUFBWTtvQkFDL0QsTUFBTSxJQUFJUCxNQUNSLHVCQUFxQlAsTUFBSSxrQ0FBaUNjLFVBQVVTLFFBQVEsR0FBQyxnRUFDMUU7Z0JBRVA7WUFDRjtRQUNGO0lBQ0Y7SUFFQSxPQUFPeEIsT0FBVXlCLElBQUksR0FBQyxVQUFPQyxtQkFBbUJ6QixPQUFLLFFBQUtDLFFBQU0sUUFDOURDLENBQUFBLFdBQVcsTUFFWEMsQ0FBQUEsTUFBOEIsR0FDMUIsQ0FBc0MsR0FDdEM7QUFFUjtBQUVBLCtEQUErRDtBQUMvRCwyREFBMkQ7QUFDM0ROLGNBQWM4QixrQkFBa0IsR0FBRztNQUVuQy9CLFdBQWVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9pbWFnZS1sb2FkZXIudHM/ZDI4MCJdLCJuYW1lcyI6WyJfZGVmYXVsdCIsImRlZmF1bHRMb2FkZXIiLCJwYXJhbSIsImNvbmZpZyIsInNyYyIsIndpZHRoIiwicXVhbGl0eSIsInByb2Nlc3MiLCJtaXNzaW5nVmFsdWVzIiwicHVzaCIsImxlbmd0aCIsIkVycm9yIiwiam9pbiIsIkpTT04iLCJzdHJpbmdpZnkiLCJzdGFydHNXaXRoIiwiZG9tYWlucyIsInJlbW90ZVBhdHRlcm5zIiwicGFyc2VkU3JjIiwiVVJMIiwiZXJyIiwiY29uc29sZSIsImVycm9yIiwiZW52IiwiTkVYVF9SVU5USU1FIiwiaGFzTWF0Y2giLCJyZXF1aXJlIiwiaG9zdG5hbWUiLCJwYXRoIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiTkVYVF9ERVBMT1lNRU5UX0lEIiwiX19uZXh0X2ltZ19kZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/match-remote-pattern.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/match-remote-pattern.js ***!
  \*******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    hasMatch: function() {\n        return hasMatch;\n    },\n    matchRemotePattern: function() {\n        return matchRemotePattern;\n    }\n});\nconst _picomatch = __webpack_require__(/*! next/dist/compiled/picomatch */ \"(app-pages-browser)/./node_modules/next/dist/compiled/picomatch/index.js\");\nfunction matchRemotePattern(pattern, url) {\n    if (pattern.protocol !== undefined) {\n        const actualProto = url.protocol.slice(0, -1);\n        if (pattern.protocol !== actualProto) {\n            return false;\n        }\n    }\n    if (pattern.port !== undefined) {\n        if (pattern.port !== url.port) {\n            return false;\n        }\n    }\n    if (pattern.hostname === undefined) {\n        throw new Error(\"Pattern should define hostname but found\\n\" + JSON.stringify(pattern));\n    } else {\n        if (!(0, _picomatch.makeRe)(pattern.hostname).test(url.hostname)) {\n            return false;\n        }\n    }\n    var _pattern_pathname;\n    if (!(0, _picomatch.makeRe)((_pattern_pathname = pattern.pathname) != null ? _pattern_pathname : \"**\", {\n        dot: true\n    }).test(url.pathname)) {\n        return false;\n    }\n    return true;\n}\nfunction hasMatch(domains, remotePatterns, url) {\n    return domains.some((domain)=>url.hostname === domain) || remotePatterns.some((p)=>matchRemotePattern(p, url));\n} //# sourceMappingURL=match-remote-pattern.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9tYXRjaC1yZW1vdGUtcGF0dGVybi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFpQ2dCQSxVQUFRO2VBQVJBOztJQTlCQUMsb0JBQWtCO2VBQWxCQTs7O3VDQUZPO0FBRWhCLFNBQVNBLG1CQUFtQkMsT0FBc0IsRUFBRUMsR0FBUTtJQUNqRSxJQUFJRCxRQUFRRSxRQUFRLEtBQUtDLFdBQVc7UUFDbEMsTUFBTUMsY0FBY0gsSUFBSUMsUUFBUSxDQUFDRyxLQUFLLENBQUMsR0FBRyxDQUFDO1FBQzNDLElBQUlMLFFBQVFFLFFBQVEsS0FBS0UsYUFBYTtZQUNwQyxPQUFPO1FBQ1Q7SUFDRjtJQUNBLElBQUlKLFFBQVFNLElBQUksS0FBS0gsV0FBVztRQUM5QixJQUFJSCxRQUFRTSxJQUFJLEtBQUtMLElBQUlLLElBQUksRUFBRTtZQUM3QixPQUFPO1FBQ1Q7SUFDRjtJQUVBLElBQUlOLFFBQVFPLFFBQVEsS0FBS0osV0FBVztRQUNsQyxNQUFNLElBQUlLLE1BQ1IsK0NBQTZDQyxLQUFLQyxTQUFTLENBQUNWO0lBRWhFLE9BQU87UUFDTCxJQUFJLENBQUNXLENBQUFBLEdBQUFBLFdBQUFBLE1BQU0sRUFBQ1gsUUFBUU8sUUFBUSxFQUFFSyxJQUFJLENBQUNYLElBQUlNLFFBQVEsR0FBRztZQUNoRCxPQUFPO1FBQ1Q7SUFDRjtRQUVZUDtJQUFaLElBQUksQ0FBQ1csQ0FBQUEsR0FBQUEsV0FBQUEsTUFBTSxFQUFDWCxDQUFBQSxvQkFBQUEsUUFBUWEsUUFBUSxZQUFoQmIsb0JBQW9CLE1BQU07UUFBRWMsS0FBSztJQUFLLEdBQUdGLElBQUksQ0FBQ1gsSUFBSVksUUFBUSxHQUFHO1FBQ3ZFLE9BQU87SUFDVDtJQUVBLE9BQU87QUFDVDtBQUVPLFNBQVNmLFNBQ2RpQixPQUFpQixFQUNqQkMsY0FBK0IsRUFDL0JmLEdBQVE7SUFFUixPQUNFYyxRQUFRRSxJQUFJLENBQUMsQ0FBQ0MsU0FBV2pCLElBQUlNLFFBQVEsS0FBS1csV0FDMUNGLGVBQWVDLElBQUksQ0FBQyxDQUFDRSxJQUFNcEIsbUJBQW1Cb0IsR0FBR2xCO0FBRXJEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9tYXRjaC1yZW1vdGUtcGF0dGVybi50cz9kNjFkIl0sIm5hbWVzIjpbImhhc01hdGNoIiwibWF0Y2hSZW1vdGVQYXR0ZXJuIiwicGF0dGVybiIsInVybCIsInByb3RvY29sIiwidW5kZWZpbmVkIiwiYWN0dWFsUHJvdG8iLCJzbGljZSIsInBvcnQiLCJob3N0bmFtZSIsIkVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsIm1ha2VSZSIsInRlc3QiLCJwYXRobmFtZSIsImRvdCIsImRvbWFpbnMiLCJyZW1vdGVQYXR0ZXJucyIsInNvbWUiLCJkb21haW4iLCJwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/match-remote-pattern.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router-context.shared-runtime.js ***!
  \****************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"RouterContext\", ({\n    enumerable: true,\n    get: function() {\n        return RouterContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst RouterContext = _react.default.createContext(null);\nif (true) {\n    RouterContext.displayName = \"RouterContext\";\n} //# sourceMappingURL=router-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiOzs7O2lEQUdhQTs7O2VBQUFBOzs7OzRFQUhLO0FBR1gsTUFBTUEsZ0JBQWdCQyxPQUFBQSxPQUFLLENBQUNDLGFBQWEsQ0FBb0I7QUFFcEUsSUFBSUMsSUFBeUIsRUFBYztJQUN6Q0gsY0FBY0ksV0FBVyxHQUFHO0FBQzlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZS50cz82MzZjIl0sIm5hbWVzIjpbIlJvdXRlckNvbnRleHQiLCJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJwcm9jZXNzIiwiZGlzcGxheU5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/side-effect.js":
/*!**********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/side-effect.js ***!
  \**********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return SideEffect;\n    }\n}));\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nconst isServer = typeof window === \"undefined\";\nconst useClientOnlyLayoutEffect = isServer ? ()=>{} : _react.useLayoutEffect;\nconst useClientOnlyEffect = isServer ? ()=>{} : _react.useEffect;\nfunction SideEffect(props) {\n    _s();\n    const { headManager, reduceComponentsToState } = props;\n    function emitChange() {\n        if (headManager && headManager.mountedInstances) {\n            const headElements = _react.Children.toArray(Array.from(headManager.mountedInstances).filter(Boolean));\n            headManager.updateHead(reduceComponentsToState(headElements, props));\n        }\n    }\n    if (isServer) {\n        var _headManager_mountedInstances;\n        headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);\n        emitChange();\n    }\n    useClientOnlyLayoutEffect(()=>{\n        var _headManager_mountedInstances;\n        headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);\n        return ()=>{\n            var _headManager_mountedInstances;\n            headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.delete(props.children);\n        };\n    });\n    // We need to call `updateHead` method whenever the `SideEffect` is trigger in all\n    // life-cycles: mount, update, unmount. However, if there are multiple `SideEffect`s\n    // being rendered, we only trigger the method from the last one.\n    // This is ensured by keeping the last unflushed `updateHead` in the `_pendingUpdate`\n    // singleton in the layout effect pass, and actually trigger it in the effect pass.\n    useClientOnlyLayoutEffect(()=>{\n        if (headManager) {\n            headManager._pendingUpdate = emitChange;\n        }\n        return ()=>{\n            if (headManager) {\n                headManager._pendingUpdate = emitChange;\n            }\n        };\n    });\n    useClientOnlyEffect(()=>{\n        if (headManager && headManager._pendingUpdate) {\n            headManager._pendingUpdate();\n            headManager._pendingUpdate = null;\n        }\n        return ()=>{\n            if (headManager && headManager._pendingUpdate) {\n                headManager._pendingUpdate();\n                headManager._pendingUpdate = null;\n            }\n        };\n    });\n    return null;\n} //# sourceMappingURL=side-effect.js.map\n_s(SideEffect, \"gHVkikNHNxjVdD11eJBzaqkCiPY=\", false, function() {\n    return [\n        useClientOnlyLayoutEffect,\n        useClientOnlyLayoutEffect,\n        useClientOnlyEffect\n    ];\n});\n_c = SideEffect;\nvar _c;\n$RefreshReg$(_c, \"SideEffect\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9zaWRlLWVmZmVjdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7MkNBb0JBOzs7ZUFBd0JBOzs7bUNBbkI2QjtBQWVyRCxNQUFNQyxXQUFXLE9BQU9DLFdBQVc7QUFDbkMsTUFBTUMsNEJBQTRCRixXQUFXLEtBQU8sSUFBSUcsT0FBQUEsZUFBZTtBQUN2RSxNQUFNQyxzQkFBc0JKLFdBQVcsS0FBTyxJQUFJSyxPQUFBQSxTQUFTO0FBRTVDLFNBQVNOLFdBQVdPLEtBQXNCOztJQUN2RCxNQUFNLEVBQUVDLFdBQVcsRUFBRUMsdUJBQXVCLEVBQUUsR0FBR0Y7SUFFakQsU0FBU0c7UUFDUCxJQUFJRixlQUFlQSxZQUFZRyxnQkFBZ0IsRUFBRTtZQUMvQyxNQUFNQyxlQUFlQyxPQUFBQSxRQUFRLENBQUNDLE9BQU8sQ0FDbkNDLE1BQU1DLElBQUksQ0FBQ1IsWUFBWUcsZ0JBQWdCLEVBQTBCTSxNQUFNLENBQ3JFQztZQUdKVixZQUFZVyxVQUFVLENBQUNWLHdCQUF3QkcsY0FBY0w7UUFDL0Q7SUFDRjtJQUVBLElBQUlOLFVBQVU7WUFDWk87UUFBQUEsZUFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsQ0FBQUEsZ0NBQUFBLFlBQWFHLGdCQUFnQixxQkFBN0JILDhCQUErQlksR0FBRyxDQUFDYixNQUFNYyxRQUFRO1FBQ2pEWDtJQUNGO0lBRUFQLDBCQUEwQjtZQUN4Qks7UUFBQUEsZUFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsQ0FBQUEsZ0NBQUFBLFlBQWFHLGdCQUFnQixxQkFBN0JILDhCQUErQlksR0FBRyxDQUFDYixNQUFNYyxRQUFRO1FBQ2pELE9BQU87Z0JBQ0xiO1lBQUFBLGVBQUFBLE9BQUFBLEtBQUFBLElBQUFBLENBQUFBLGdDQUFBQSxZQUFhRyxnQkFBZ0IscUJBQTdCSCw4QkFBK0JjLE1BQU0sQ0FBQ2YsTUFBTWMsUUFBUTtRQUN0RDtJQUNGO0lBRUEsa0ZBQWtGO0lBQ2xGLG9GQUFvRjtJQUNwRixnRUFBZ0U7SUFDaEUscUZBQXFGO0lBQ3JGLG1GQUFtRjtJQUNuRmxCLDBCQUEwQjtRQUN4QixJQUFJSyxhQUFhO1lBQ2ZBLFlBQVllLGNBQWMsR0FBR2I7UUFDL0I7UUFDQSxPQUFPO1lBQ0wsSUFBSUYsYUFBYTtnQkFDZkEsWUFBWWUsY0FBYyxHQUFHYjtZQUMvQjtRQUNGO0lBQ0Y7SUFFQUwsb0JBQW9CO1FBQ2xCLElBQUlHLGVBQWVBLFlBQVllLGNBQWMsRUFBRTtZQUM3Q2YsWUFBWWUsY0FBYztZQUMxQmYsWUFBWWUsY0FBYyxHQUFHO1FBQy9CO1FBQ0EsT0FBTztZQUNMLElBQUlmLGVBQWVBLFlBQVllLGNBQWMsRUFBRTtnQkFDN0NmLFlBQVllLGNBQWM7Z0JBQzFCZixZQUFZZSxjQUFjLEdBQUc7WUFDL0I7UUFDRjtJQUNGO0lBRUEsT0FBTztBQUNUO0dBeER3QnZCOztRQW1CdEJHO1FBWUFBO1FBV0FFOzs7S0ExQ3NCTCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvc2lkZS1lZmZlY3QudHN4P2U4ZGQiXSwibmFtZXMiOlsiU2lkZUVmZmVjdCIsImlzU2VydmVyIiwid2luZG93IiwidXNlQ2xpZW50T25seUxheW91dEVmZmVjdCIsInVzZUxheW91dEVmZmVjdCIsInVzZUNsaWVudE9ubHlFZmZlY3QiLCJ1c2VFZmZlY3QiLCJwcm9wcyIsImhlYWRNYW5hZ2VyIiwicmVkdWNlQ29tcG9uZW50c1RvU3RhdGUiLCJlbWl0Q2hhbmdlIiwibW91bnRlZEluc3RhbmNlcyIsImhlYWRFbGVtZW50cyIsIkNoaWxkcmVuIiwidG9BcnJheSIsIkFycmF5IiwiZnJvbSIsImZpbHRlciIsIkJvb2xlYW4iLCJ1cGRhdGVIZWFkIiwiYWRkIiwiY2hpbGRyZW4iLCJkZWxldGUiLCJfcGVuZGluZ1VwZGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/side-effect.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/Hero.tsx":
/*!*********************************!*\
  !*** ./src/components/Hero.tsx ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_i18next__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-i18next */ \"(app-pages-browser)/../../node_modules/react-i18next/dist/es/index.js\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/image */ \"(app-pages-browser)/./node_modules/next/dist/api/image.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _hooks_useTokenMetrics__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/hooks/useTokenMetrics */ \"(app-pages-browser)/./src/hooks/useTokenMetrics.ts\");\n/* eslint-disable @next/next/no-img-element */ /* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\nconst InfoCard = (param)=>{\n    let { iconSrc, iconAlt, text, value, loading } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n        className: \"flex h-10 px-4 pl-2 min-w-full md:min-w-0 justify-center items-center rounded-3xl border gap-[8px] mx-2 border-[#D3B872] bg-white\",\n        children: [\n            iconSrc && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_image__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                src: iconSrc,\n                alt: iconAlt,\n                width: 24,\n                height: 24,\n                className: \"w-[24px] h-[24px] flex-shrink-0\"\n            }, void 0, false, {\n                fileName: \"D:\\\\Bity\\\\gldt-swap\\\\client\\\\gld_landing_page\\\\src\\\\components\\\\Hero.tsx\",\n                lineNumber: 27,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                className: \"font-inter font-normal leading-[16px] text-[#262C2E]\",\n                children: text\n            }, void 0, false, {\n                fileName: \"D:\\\\Bity\\\\gldt-swap\\\\client\\\\gld_landing_page\\\\src\\\\components\\\\Hero.tsx\",\n                lineNumber: 35,\n                columnNumber: 5\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                className: \"h-full w-0.5 bg-[#D3B872] rounded-3xl mx-[8px]\"\n            }, void 0, false, {\n                fileName: \"D:\\\\Bity\\\\gldt-swap\\\\client\\\\gld_landing_page\\\\src\\\\components\\\\Hero.tsx\",\n                lineNumber: 38,\n                columnNumber: 5\n            }, undefined),\n            loading ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                className: \"loading-skeleton\"\n            }, void 0, false, {\n                fileName: \"D:\\\\Bity\\\\gldt-swap\\\\client\\\\gld_landing_page\\\\src\\\\components\\\\Hero.tsx\",\n                lineNumber: 40,\n                columnNumber: 7\n            }, undefined) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                className: \"font-bold\",\n                children: value\n            }, void 0, false, {\n                fileName: \"D:\\\\Bity\\\\gldt-swap\\\\client\\\\gld_landing_page\\\\src\\\\components\\\\Hero.tsx\",\n                lineNumber: 42,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"D:\\\\Bity\\\\gldt-swap\\\\client\\\\gld_landing_page\\\\src\\\\components\\\\Hero.tsx\",\n        lineNumber: 25,\n        columnNumber: 3\n    }, undefined);\n};\n_c = InfoCard;\nconst Hero = ()=>{\n    _s();\n    const videoRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    const { data, isLoading, error } = (0,_hooks_useTokenMetrics__WEBPACK_IMPORTED_MODULE_4__.useTokenMetrics)();\n    const { t } = (0,react_i18next__WEBPACK_IMPORTED_MODULE_1__.useTranslation)(\"hero\");\n    const totalGoldLockedKg = data ? data.total_gold_kg.toFixed(2) : null;\n    const marketCapUSD = data ? \"\".concat(data.tvl.toLocaleString(\"en-US\")) : null;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"h-[100vh] md:h-[75vh] w-full flex flex-col items-center justify-center px-2 md:px-10 \",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"video\", {\n                ref: videoRef,\n                autoPlay: true,\n                loop: true,\n                muted: true,\n                preload: \"auto\",\n                playsInline: true,\n                className: \"absolute inset-0 w-full h-[100vh] md:h-3/4 object-cover transition-opacity duration-500\",\n                src: \"https://daolink-gold-dao-website-medias.sos-ch-gva-2.exo.io/Gold_DAO_bg_video.mp4\"\n            }, void 0, false, {\n                fileName: \"D:\\\\Bity\\\\gldt-swap\\\\client\\\\gld_landing_page\\\\src\\\\components\\\\Hero.tsx\",\n                lineNumber: 58,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"relative text-center\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                        className: \"text-[53px] md:text-[82px] font-inter font-bold text-white leading-[90px] text-shadow-lg md:max-w-2xl mx-auto\",\n                        style: {\n                            textShadow: \"0px 10px 15px rgba(0, 0, 0, 0.10), 0px 4px 6px rgba(0, 0, 0, 0.05)\"\n                        },\n                        children: t(\"title\")\n                    }, void 0, false, {\n                        fileName: \"D:\\\\Bity\\\\gldt-swap\\\\client\\\\gld_landing_page\\\\src\\\\components\\\\Hero.tsx\",\n                        lineNumber: 69,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"text-[40px] md:text-[82px] font-inter font-light leading-[90px] text-[rgba(0,0,0,0.80)]  w-3/4 md:w-full mx-auto  md:max-w-2xl\",\n                        style: {\n                            textShadow: \"0px 10px 15px rgba(0, 0, 0, 0.10), 0px 4px 6px rgba(0, 0, 0, 0.05)\"\n                        },\n                        children: t(\"subtitle\")\n                    }, void 0, false, {\n                        fileName: \"D:\\\\Bity\\\\gldt-swap\\\\client\\\\gld_landing_page\\\\src\\\\components\\\\Hero.tsx\",\n                        lineNumber: 78,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"D:\\\\Bity\\\\gldt-swap\\\\client\\\\gld_landing_page\\\\src\\\\components\\\\Hero.tsx\",\n                lineNumber: 68,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"D:\\\\Bity\\\\gldt-swap\\\\client\\\\gld_landing_page\\\\src\\\\components\\\\Hero.tsx\",\n        lineNumber: 57,\n        columnNumber: 5\n    }, undefined);\n};\n_s(Hero, \"8YanuyKCP0NR9IOaNKt7TWKo4gs=\", false, function() {\n    return [\n        _hooks_useTokenMetrics__WEBPACK_IMPORTED_MODULE_4__.useTokenMetrics,\n        react_i18next__WEBPACK_IMPORTED_MODULE_1__.useTranslation\n    ];\n});\n_c1 = Hero;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Hero);\nvar _c, _c1;\n$RefreshReg$(_c, \"InfoCard\");\n$RefreshReg$(_c1, \"Hero\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0hlcm8udHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSw0Q0FBNEM7O0FBR0U7QUFDaEI7QUFFcUI7QUFDTTtBQVV6RCxNQUFNSSxXQUFXO1FBQUMsRUFDaEJDLE9BQU8sRUFDUEMsT0FBTyxFQUNQQyxJQUFJLEVBQ0pDLEtBQUssRUFDTEMsT0FBTyxFQUNPO3lCQUNkLDhEQUFDQztRQUFRQyxXQUFVOztZQUNoQk4seUJBQ0MsOERBQUNKLGtEQUFLQTtnQkFDSlcsS0FBS1A7Z0JBQ0xRLEtBQUtQO2dCQUNMUSxPQUFPO2dCQUNQQyxRQUFRO2dCQUNSSixXQUFVOzs7Ozs7MEJBR2QsOERBQUNLO2dCQUFLTCxXQUFVOzBCQUNiSjs7Ozs7OzBCQUVILDhEQUFDUztnQkFBS0wsV0FBVTs7Ozs7O1lBQ2ZGLHdCQUNDLDhEQUFDTztnQkFBS0wsV0FBVTs7Ozs7MENBRWhCLDhEQUFDSztnQkFBS0wsV0FBVTswQkFBYUg7Ozs7Ozs7Ozs7Ozs7S0F4QjdCSjtBQTZCTixNQUFNYSxPQUFPOztJQUNYLE1BQU1DLFdBQVdoQiw2Q0FBTUEsQ0FBMEI7SUFDakQsTUFBTSxFQUFFaUIsSUFBSSxFQUFFQyxTQUFTLEVBQUVDLEtBQUssRUFBRSxHQUFHbEIsdUVBQWVBO0lBRWxELE1BQU0sRUFBRW1CLENBQUMsRUFBRSxHQUFHdEIsNkRBQWNBLENBQUM7SUFFN0IsTUFBTXVCLG9CQUFvQkosT0FBT0EsS0FBS0ssYUFBYSxDQUFDQyxPQUFPLENBQUMsS0FBSztJQUNqRSxNQUFNQyxlQUFlUCxPQUFPLEdBQW9DLE9BQWpDQSxLQUFLUSxHQUFHLENBQUNDLGNBQWMsQ0FBQyxZQUFhO0lBRXBFLHFCQUNFLDhEQUFDQztRQUFJbEIsV0FBVTs7MEJBQ2IsOERBQUNtQjtnQkFDQ0MsS0FBS2I7Z0JBQ0xjLFFBQVE7Z0JBQ1JDLElBQUk7Z0JBQ0pDLEtBQUs7Z0JBQ0xDLFNBQVE7Z0JBQ1JDLFdBQVc7Z0JBQ1h6QixXQUFZO2dCQUNaQyxLQUFJOzs7Ozs7MEJBRU4sOERBQUNpQjtnQkFBSWxCLFdBQVU7O2tDQUNiLDhEQUFDMEI7d0JBQ0MxQixXQUFVO3dCQUNWMkIsT0FBTzs0QkFDTEMsWUFDRTt3QkFDSjtrQ0FFQ2pCLEVBQUU7Ozs7OztrQ0FFTCw4REFBQ2tCO3dCQUNDN0IsV0FBVTt3QkFDVjJCLE9BQU87NEJBQ0xDLFlBQ0U7d0JBQ0o7a0NBRUNqQixFQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQmI7R0EzRE1MOztRQUUrQmQsbUVBQWVBO1FBRXBDSCx5REFBY0E7OztNQUp4QmlCO0FBNkROLCtEQUFlQSxJQUFJQSxFQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL0hlcm8udHN4PzY2OTAiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgQG5leHQvbmV4dC9uby1pbWctZWxlbWVudCAqL1xyXG4ndXNlIGNsaWVudCdcclxuXHJcbmltcG9ydCB7IHVzZVRyYW5zbGF0aW9uIH0gZnJvbSAncmVhY3QtaTE4bmV4dCdcclxuaW1wb3J0IEltYWdlIGZyb20gJ25leHQvaW1hZ2UnXHJcbmltcG9ydCB7IHVzZVF1ZXJ5IH0gZnJvbSAnQHRhbnN0YWNrL3JlYWN0LXF1ZXJ5J1xyXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCdcclxuaW1wb3J0IHsgdXNlVG9rZW5NZXRyaWNzIH0gZnJvbSAnQC9ob29rcy91c2VUb2tlbk1ldHJpY3MnXHJcblxyXG5pbnRlcmZhY2UgSW5mb0NhcmRQcm9wcyB7XHJcbiAgaWNvblNyYzogc3RyaW5nXHJcbiAgaWNvbkFsdDogc3RyaW5nXHJcbiAgdGV4dDogc3RyaW5nXHJcbiAgdmFsdWU6IHN0cmluZ1xyXG4gIGxvYWRpbmc6IGJvb2xlYW5cclxufVxyXG5cclxuY29uc3QgSW5mb0NhcmQgPSAoe1xyXG4gIGljb25TcmMsXHJcbiAgaWNvbkFsdCxcclxuICB0ZXh0LFxyXG4gIHZhbHVlLFxyXG4gIGxvYWRpbmdcclxufTogSW5mb0NhcmRQcm9wcykgPT4gKFxyXG4gIDxzZWN0aW9uIGNsYXNzTmFtZT0nZmxleCBoLTEwIHB4LTQgcGwtMiBtaW4tdy1mdWxsIG1kOm1pbi13LTAganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyIHJvdW5kZWQtM3hsIGJvcmRlciBnYXAtWzhweF0gbXgtMiBib3JkZXItWyNEM0I4NzJdIGJnLXdoaXRlJz5cclxuICAgIHtpY29uU3JjICYmIChcclxuICAgICAgPEltYWdlXHJcbiAgICAgICAgc3JjPXtpY29uU3JjfVxyXG4gICAgICAgIGFsdD17aWNvbkFsdH1cclxuICAgICAgICB3aWR0aD17MjR9XHJcbiAgICAgICAgaGVpZ2h0PXsyNH1cclxuICAgICAgICBjbGFzc05hbWU9J3ctWzI0cHhdIGgtWzI0cHhdIGZsZXgtc2hyaW5rLTAnXHJcbiAgICAgIC8+XHJcbiAgICApfVxyXG4gICAgPHNwYW4gY2xhc3NOYW1lPSdmb250LWludGVyIGZvbnQtbm9ybWFsIGxlYWRpbmctWzE2cHhdIHRleHQtWyMyNjJDMkVdJz5cclxuICAgICAge3RleHR9XHJcbiAgICA8L3NwYW4+XHJcbiAgICA8c3BhbiBjbGFzc05hbWU9J2gtZnVsbCB3LTAuNSBiZy1bI0QzQjg3Ml0gcm91bmRlZC0zeGwgbXgtWzhweF0nPjwvc3Bhbj5cclxuICAgIHtsb2FkaW5nID8gKFxyXG4gICAgICA8c3BhbiBjbGFzc05hbWU9J2xvYWRpbmctc2tlbGV0b24nPjwvc3Bhbj5cclxuICAgICkgOiAoXHJcbiAgICAgIDxzcGFuIGNsYXNzTmFtZT0nZm9udC1ib2xkJz57dmFsdWV9PC9zcGFuPlxyXG4gICAgKX1cclxuICA8L3NlY3Rpb24+XHJcbilcclxuXHJcbmNvbnN0IEhlcm8gPSAoKSA9PiB7XHJcbiAgY29uc3QgdmlkZW9SZWYgPSB1c2VSZWY8SFRNTFZpZGVvRWxlbWVudCB8IG51bGw+KG51bGwpXHJcbiAgY29uc3QgeyBkYXRhLCBpc0xvYWRpbmcsIGVycm9yIH0gPSB1c2VUb2tlbk1ldHJpY3MoKVxyXG5cclxuICBjb25zdCB7IHQgfSA9IHVzZVRyYW5zbGF0aW9uKCdoZXJvJylcclxuXHJcbiAgY29uc3QgdG90YWxHb2xkTG9ja2VkS2cgPSBkYXRhID8gZGF0YS50b3RhbF9nb2xkX2tnLnRvRml4ZWQoMikgOiBudWxsXHJcbiAgY29uc3QgbWFya2V0Q2FwVVNEID0gZGF0YSA/IGAke2RhdGEudHZsLnRvTG9jYWxlU3RyaW5nKCdlbi1VUycpfWAgOiBudWxsXHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8ZGl2IGNsYXNzTmFtZT0naC1bMTAwdmhdIG1kOmgtWzc1dmhdIHctZnVsbCBmbGV4IGZsZXgtY29sIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBweC0yIG1kOnB4LTEwICc+XHJcbiAgICAgIDx2aWRlb1xyXG4gICAgICAgIHJlZj17dmlkZW9SZWZ9XHJcbiAgICAgICAgYXV0b1BsYXlcclxuICAgICAgICBsb29wXHJcbiAgICAgICAgbXV0ZWRcclxuICAgICAgICBwcmVsb2FkPSdhdXRvJ1xyXG4gICAgICAgIHBsYXlzSW5saW5lXHJcbiAgICAgICAgY2xhc3NOYW1lPXtgYWJzb2x1dGUgaW5zZXQtMCB3LWZ1bGwgaC1bMTAwdmhdIG1kOmgtMy80IG9iamVjdC1jb3ZlciB0cmFuc2l0aW9uLW9wYWNpdHkgZHVyYXRpb24tNTAwYH1cclxuICAgICAgICBzcmM9J2h0dHBzOi8vZGFvbGluay1nb2xkLWRhby13ZWJzaXRlLW1lZGlhcy5zb3MtY2gtZ3ZhLTIuZXhvLmlvL0dvbGRfREFPX2JnX3ZpZGVvLm1wNCdcclxuICAgICAgLz5cclxuICAgICAgPGRpdiBjbGFzc05hbWU9J3JlbGF0aXZlIHRleHQtY2VudGVyJz5cclxuICAgICAgICA8aDFcclxuICAgICAgICAgIGNsYXNzTmFtZT0ndGV4dC1bNTNweF0gbWQ6dGV4dC1bODJweF0gZm9udC1pbnRlciBmb250LWJvbGQgdGV4dC13aGl0ZSBsZWFkaW5nLVs5MHB4XSB0ZXh0LXNoYWRvdy1sZyBtZDptYXgtdy0yeGwgbXgtYXV0bydcclxuICAgICAgICAgIHN0eWxlPXt7XHJcbiAgICAgICAgICAgIHRleHRTaGFkb3c6XHJcbiAgICAgICAgICAgICAgJzBweCAxMHB4IDE1cHggcmdiYSgwLCAwLCAwLCAwLjEwKSwgMHB4IDRweCA2cHggcmdiYSgwLCAwLCAwLCAwLjA1KSdcclxuICAgICAgICAgIH19XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAge3QoJ3RpdGxlJyl9XHJcbiAgICAgICAgPC9oMT5cclxuICAgICAgICA8cFxyXG4gICAgICAgICAgY2xhc3NOYW1lPSd0ZXh0LVs0MHB4XSBtZDp0ZXh0LVs4MnB4XSBmb250LWludGVyIGZvbnQtbGlnaHQgbGVhZGluZy1bOTBweF0gdGV4dC1bcmdiYSgwLDAsMCwwLjgwKV0gIHctMy80IG1kOnctZnVsbCBteC1hdXRvICBtZDptYXgtdy0yeGwnXHJcbiAgICAgICAgICBzdHlsZT17e1xyXG4gICAgICAgICAgICB0ZXh0U2hhZG93OlxyXG4gICAgICAgICAgICAgICcwcHggMTBweCAxNXB4IHJnYmEoMCwgMCwgMCwgMC4xMCksIDBweCA0cHggNnB4IHJnYmEoMCwgMCwgMCwgMC4wNSknXHJcbiAgICAgICAgICB9fVxyXG4gICAgICAgID5cclxuICAgICAgICAgIHt0KCdzdWJ0aXRsZScpfVxyXG4gICAgICAgIDwvcD5cclxuICAgICAgICB7LyogPGRpdiBjbGFzc05hbWU9J210LTEwIHNtOm10LVs2NHB4XSBmbGV4LWNvbCBzcGFjZS15LTYgeGw6c3BhY2UteS0wIHhsOnctZnVsbCBmbGV4IGxnOmZsZXgtcm93IGp1c3RpZnktYXJvdW5kIGl0ZW1zLWNlbnRlcic+XHJcbiAgICAgICAgICA8SW5mb0NhcmRcclxuICAgICAgICAgICAgaWNvblNyYz0nL3N0YXRpYy9pY29ucy9Hb2xkLUxpZ2h0LTFnLnN2ZydcclxuICAgICAgICAgICAgaWNvbkFsdD0nVG90YWwgR29sZCBJY29uJ1xyXG4gICAgICAgICAgICB0ZXh0PXt0KCd0b3RhbF9nb2xkX2xvY2tlZCcpfVxyXG4gICAgICAgICAgICB2YWx1ZT17YCR7dG90YWxHb2xkTG9ja2VkS2d9IGtnYH1cclxuICAgICAgICAgICAgbG9hZGluZz17aXNMb2FkaW5nfVxyXG4gICAgICAgICAgLz5cclxuICAgICAgICAgIDxJbmZvQ2FyZFxyXG4gICAgICAgICAgICBpY29uU3JjPScvc3RhdGljL2ljb25zL0dvbGQtTWFya2V0Y2FwLnN2ZydcclxuICAgICAgICAgICAgaWNvbkFsdD0nTWFya2V0Y2FwIEljb24nXHJcbiAgICAgICAgICAgIHRleHQ9e3QoJ2dsZHRfbWFya2V0Y2FwJyl9XHJcbiAgICAgICAgICAgIHZhbHVlPXtgJCR7bWFya2V0Q2FwVVNEfWB9XHJcbiAgICAgICAgICAgIGxvYWRpbmc9e2lzTG9hZGluZ31cclxuICAgICAgICAgIC8+XHJcbiAgICAgICAgPC9kaXY+ICovfVxyXG4gICAgICA8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG4gIClcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgSGVyb1xyXG4iXSwibmFtZXMiOlsidXNlVHJhbnNsYXRpb24iLCJJbWFnZSIsInVzZVJlZiIsInVzZVRva2VuTWV0cmljcyIsIkluZm9DYXJkIiwiaWNvblNyYyIsImljb25BbHQiLCJ0ZXh0IiwidmFsdWUiLCJsb2FkaW5nIiwic2VjdGlvbiIsImNsYXNzTmFtZSIsInNyYyIsImFsdCIsIndpZHRoIiwiaGVpZ2h0Iiwic3BhbiIsIkhlcm8iLCJ2aWRlb1JlZiIsImRhdGEiLCJpc0xvYWRpbmciLCJlcnJvciIsInQiLCJ0b3RhbEdvbGRMb2NrZWRLZyIsInRvdGFsX2dvbGRfa2ciLCJ0b0ZpeGVkIiwibWFya2V0Q2FwVVNEIiwidHZsIiwidG9Mb2NhbGVTdHJpbmciLCJkaXYiLCJ2aWRlbyIsInJlZiIsImF1dG9QbGF5IiwibG9vcCIsIm11dGVkIiwicHJlbG9hZCIsInBsYXlzSW5saW5lIiwiaDEiLCJzdHlsZSIsInRleHRTaGFkb3ciLCJwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Hero.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/data/canisters/gold/did.js":
/*!****************************************!*\
  !*** ./src/data/canisters/gold/did.js ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   idlFactory: function() { return /* binding */ idlFactory; },\n/* harmony export */   init: function() { return /* binding */ init; }\n/* harmony export */ });\nconst idlFactory = (param)=>{\n    let { IDL } = param;\n    const ArchivedTransactionResponse = IDL.Rec();\n    const CandyShared = IDL.Rec();\n    const ManageSaleResponse = IDL.Rec();\n    const UpdateShared = IDL.Rec();\n    const Value = IDL.Rec();\n    const Value__1 = IDL.Rec();\n    const Vec = IDL.Rec();\n    const PropertyShared = IDL.Record({\n        value: CandyShared,\n        name: IDL.Text,\n        immutable: IDL.Bool\n    });\n    CandyShared.fill(IDL.Variant({\n        Int: IDL.Int,\n        Map: IDL.Vec(IDL.Tuple(CandyShared, CandyShared)),\n        Nat: IDL.Nat,\n        Set: IDL.Vec(CandyShared),\n        Nat16: IDL.Nat16,\n        Nat32: IDL.Nat32,\n        Nat64: IDL.Nat64,\n        Blob: IDL.Vec(IDL.Nat8),\n        Bool: IDL.Bool,\n        Int8: IDL.Int8,\n        Ints: IDL.Vec(IDL.Int),\n        Nat8: IDL.Nat8,\n        Nats: IDL.Vec(IDL.Nat),\n        Text: IDL.Text,\n        Bytes: IDL.Vec(IDL.Nat8),\n        Int16: IDL.Int16,\n        Int32: IDL.Int32,\n        Int64: IDL.Int64,\n        Option: IDL.Opt(CandyShared),\n        Floats: IDL.Vec(IDL.Float64),\n        Float: IDL.Float64,\n        Principal: IDL.Principal,\n        Array: IDL.Vec(CandyShared),\n        Class: IDL.Vec(PropertyShared)\n    }));\n    const Account__1 = IDL.Variant({\n        account_id: IDL.Text,\n        principal: IDL.Principal,\n        extensible: CandyShared,\n        account: IDL.Record({\n            owner: IDL.Principal,\n            sub_account: IDL.Opt(IDL.Vec(IDL.Nat8))\n        })\n    });\n    const ICTokenSpec__1 = IDL.Record({\n        id: IDL.Opt(IDL.Nat),\n        fee: IDL.Opt(IDL.Nat),\n        decimals: IDL.Nat,\n        canister: IDL.Principal,\n        standard: IDL.Variant({\n            ICRC1: IDL.Null,\n            EXTFungible: IDL.Null,\n            DIP20: IDL.Null,\n            Other: CandyShared,\n            Ledger: IDL.Null\n        }),\n        symbol: IDL.Text\n    });\n    const TokenSpec__1 = IDL.Variant({\n        ic: ICTokenSpec__1,\n        extensible: CandyShared\n    });\n    const EscrowRecord__1 = IDL.Record({\n        token: TokenSpec__1,\n        token_id: IDL.Text,\n        seller: Account__1,\n        lock_to_date: IDL.Opt(IDL.Int),\n        buyer: Account__1,\n        amount: IDL.Nat,\n        sale_id: IDL.Opt(IDL.Text),\n        account_hash: IDL.Opt(IDL.Vec(IDL.Nat8))\n    });\n    const StableSalesBalances = IDL.Vec(IDL.Tuple(Account__1, Account__1, IDL.Text, EscrowRecord__1));\n    const StableOffers = IDL.Vec(IDL.Tuple(Account__1, Account__1, IDL.Int));\n    const StableCollectionData = IDL.Record({\n        active_bucket: IDL.Opt(IDL.Principal),\n        managers: IDL.Vec(IDL.Principal),\n        owner: IDL.Principal,\n        metadata: IDL.Opt(CandyShared),\n        logo: IDL.Opt(IDL.Text),\n        name: IDL.Opt(IDL.Text),\n        network: IDL.Opt(IDL.Principal),\n        available_space: IDL.Nat,\n        symbol: IDL.Opt(IDL.Text),\n        allocated_storage: IDL.Nat\n    });\n    const ICTokenSpec = IDL.Record({\n        id: IDL.Opt(IDL.Nat),\n        fee: IDL.Opt(IDL.Nat),\n        decimals: IDL.Nat,\n        canister: IDL.Principal,\n        standard: IDL.Variant({\n            ICRC1: IDL.Null,\n            EXTFungible: IDL.Null,\n            DIP20: IDL.Null,\n            Other: CandyShared,\n            Ledger: IDL.Null\n        }),\n        symbol: IDL.Text\n    });\n    const TokenSpec = IDL.Variant({\n        ic: ICTokenSpec,\n        extensible: CandyShared\n    });\n    const TransactionID = IDL.Variant({\n        nat: IDL.Nat,\n        text: IDL.Text,\n        extensible: CandyShared\n    });\n    const Account__2 = IDL.Variant({\n        account_id: IDL.Text,\n        principal: IDL.Principal,\n        extensible: CandyShared,\n        account: IDL.Record({\n            owner: IDL.Principal,\n            sub_account: IDL.Opt(IDL.Vec(IDL.Nat8))\n        })\n    });\n    const WaitForQuietType = IDL.Record({\n        max: IDL.Nat,\n        fade: IDL.Float64,\n        extension: IDL.Nat64\n    });\n    const MinIncreaseType = IDL.Variant({\n        amount: IDL.Nat,\n        percentage: IDL.Float64\n    });\n    const FeeName = IDL.Text;\n    const FeeAccountsParams = IDL.Vec(FeeName);\n    const NiftySettlementType = IDL.Record({\n        fixed: IDL.Bool,\n        interestRatePerSecond: IDL.Float64,\n        duration: IDL.Opt(IDL.Int),\n        expiration: IDL.Opt(IDL.Int),\n        lenderOffer: IDL.Bool\n    });\n    const DutchParams = IDL.Record({\n        time_unit: IDL.Variant({\n            day: IDL.Nat,\n            hour: IDL.Nat,\n            minute: IDL.Nat\n        }),\n        decay_type: IDL.Variant({\n            flat: IDL.Nat,\n            percent: IDL.Float64\n        })\n    });\n    const EndingType = IDL.Variant({\n        date: IDL.Int,\n        timeout: IDL.Nat\n    });\n    const AskFeature = IDL.Variant({\n        kyc: IDL.Principal,\n        start_price: IDL.Nat,\n        token: TokenSpec,\n        fee_schema: IDL.Text,\n        notify: IDL.Vec(IDL.Principal),\n        wait_for_quiet: WaitForQuietType,\n        reserve: IDL.Nat,\n        start_date: IDL.Int,\n        min_increase: MinIncreaseType,\n        allow_list: IDL.Vec(IDL.Principal),\n        buy_now: IDL.Nat,\n        fee_accounts: FeeAccountsParams,\n        nifty_settlement: NiftySettlementType,\n        atomic: IDL.Null,\n        dutch: DutchParams,\n        ending: EndingType\n    });\n    const AskFeatureArray = IDL.Vec(AskFeature);\n    const AskConfigShared = IDL.Opt(AskFeatureArray);\n    const InstantFeature = IDL.Variant({\n        fee_schema: IDL.Text,\n        fee_accounts: FeeAccountsParams,\n        transfer: IDL.Null\n    });\n    const InstantConfigShared = IDL.Opt(IDL.Vec(InstantFeature));\n    const AuctionConfig = IDL.Record({\n        start_price: IDL.Nat,\n        token: TokenSpec,\n        reserve: IDL.Opt(IDL.Nat),\n        start_date: IDL.Int,\n        min_increase: MinIncreaseType,\n        allow_list: IDL.Opt(IDL.Vec(IDL.Principal)),\n        buy_now: IDL.Opt(IDL.Nat),\n        ending: IDL.Variant({\n            date: IDL.Int,\n            wait_for_quiet: IDL.Record({\n                max: IDL.Nat,\n                date: IDL.Int,\n                fade: IDL.Float64,\n                extension: IDL.Nat64\n            })\n        })\n    });\n    const PricingConfigShared = IDL.Variant({\n        ask: AskConfigShared,\n        extensible: CandyShared,\n        instant: InstantConfigShared,\n        auction: AuctionConfig\n    });\n    const TransactionRecord = IDL.Record({\n        token_id: IDL.Text,\n        txn_type: IDL.Variant({\n            escrow_deposit: IDL.Record({\n                token: TokenSpec,\n                token_id: IDL.Text,\n                trx_id: TransactionID,\n                seller: Account__2,\n                extensible: CandyShared,\n                buyer: Account__2,\n                amount: IDL.Nat\n            }),\n            fee_deposit: IDL.Record({\n                token: TokenSpec,\n                extensible: CandyShared,\n                account: Account__2,\n                amount: IDL.Nat\n            }),\n            canister_network_updated: IDL.Record({\n                network: IDL.Principal,\n                extensible: CandyShared\n            }),\n            escrow_withdraw: IDL.Record({\n                fee: IDL.Nat,\n                token: TokenSpec,\n                token_id: IDL.Text,\n                trx_id: TransactionID,\n                seller: Account__2,\n                extensible: CandyShared,\n                buyer: Account__2,\n                amount: IDL.Nat\n            }),\n            canister_managers_updated: IDL.Record({\n                managers: IDL.Vec(IDL.Principal),\n                extensible: CandyShared\n            }),\n            auction_bid: IDL.Record({\n                token: TokenSpec,\n                extensible: CandyShared,\n                buyer: Account__2,\n                amount: IDL.Nat,\n                sale_id: IDL.Text\n            }),\n            burn: IDL.Record({\n                from: IDL.Opt(Account__2),\n                extensible: CandyShared\n            }),\n            data: IDL.Record({\n                hash: IDL.Opt(IDL.Vec(IDL.Nat8)),\n                extensible: CandyShared,\n                data_dapp: IDL.Opt(IDL.Text),\n                data_path: IDL.Opt(IDL.Text)\n            }),\n            sale_ended: IDL.Record({\n                token: TokenSpec,\n                seller: Account__2,\n                extensible: CandyShared,\n                buyer: Account__2,\n                amount: IDL.Nat,\n                sale_id: IDL.Opt(IDL.Text)\n            }),\n            mint: IDL.Record({\n                to: Account__2,\n                from: Account__2,\n                sale: IDL.Opt(IDL.Record({\n                    token: TokenSpec,\n                    amount: IDL.Nat\n                })),\n                extensible: CandyShared\n            }),\n            royalty_paid: IDL.Record({\n                tag: IDL.Text,\n                token: TokenSpec,\n                seller: Account__2,\n                extensible: CandyShared,\n                buyer: Account__2,\n                amount: IDL.Nat,\n                receiver: Account__2,\n                sale_id: IDL.Opt(IDL.Text)\n            }),\n            extensible: CandyShared,\n            fee_deposit_withdraw: IDL.Record({\n                fee: IDL.Nat,\n                token: TokenSpec,\n                trx_id: TransactionID,\n                extensible: CandyShared,\n                account: Account__2,\n                amount: IDL.Nat\n            }),\n            owner_transfer: IDL.Record({\n                to: Account__2,\n                from: Account__2,\n                extensible: CandyShared\n            }),\n            sale_opened: IDL.Record({\n                pricing: PricingConfigShared,\n                extensible: CandyShared,\n                sale_id: IDL.Text\n            }),\n            canister_owner_updated: IDL.Record({\n                owner: IDL.Principal,\n                extensible: CandyShared\n            }),\n            sale_withdraw: IDL.Record({\n                fee: IDL.Nat,\n                token: TokenSpec,\n                token_id: IDL.Text,\n                trx_id: TransactionID,\n                seller: Account__2,\n                extensible: CandyShared,\n                buyer: Account__2,\n                amount: IDL.Nat\n            }),\n            deposit_withdraw: IDL.Record({\n                fee: IDL.Nat,\n                token: TokenSpec,\n                trx_id: TransactionID,\n                extensible: CandyShared,\n                buyer: Account__2,\n                amount: IDL.Nat\n            })\n        }),\n        timestamp: IDL.Int,\n        index: IDL.Nat\n    });\n    const StableNftLedger = IDL.Vec(IDL.Tuple(IDL.Text, TransactionRecord));\n    const AllocationRecordStable = IDL.Record({\n        allocated_space: IDL.Nat,\n        token_id: IDL.Text,\n        available_space: IDL.Nat,\n        canister: IDL.Principal,\n        chunks: IDL.Vec(IDL.Nat),\n        library_id: IDL.Text\n    });\n    const BidFeature = IDL.Variant({\n        fee_schema: IDL.Text,\n        broker: Account__2,\n        fee_accounts: FeeAccountsParams\n    });\n    const BidConfigShared = IDL.Opt(IDL.Vec(BidFeature));\n    const EscrowReceipt = IDL.Record({\n        token: TokenSpec,\n        token_id: IDL.Text,\n        seller: Account__2,\n        buyer: Account__2,\n        amount: IDL.Nat\n    });\n    const PricingConfigShared__1 = IDL.Variant({\n        ask: AskConfigShared,\n        extensible: CandyShared,\n        instant: InstantConfigShared,\n        auction: AuctionConfig\n    });\n    const AuctionStateShared = IDL.Record({\n        status: IDL.Variant({\n            closed: IDL.Null,\n            open: IDL.Null,\n            not_started: IDL.Null\n        }),\n        participants: IDL.Vec(IDL.Tuple(IDL.Principal, IDL.Int)),\n        token: TokenSpec__1,\n        current_bid_amount: IDL.Nat,\n        winner: IDL.Opt(Account__1),\n        end_date: IDL.Int,\n        current_config: BidConfigShared,\n        start_date: IDL.Int,\n        wait_for_quiet_count: IDL.Opt(IDL.Nat),\n        current_escrow: IDL.Opt(EscrowReceipt),\n        allow_list: IDL.Opt(IDL.Vec(IDL.Tuple(IDL.Principal, IDL.Bool))),\n        min_next_bid: IDL.Nat,\n        config: PricingConfigShared__1\n    });\n    const SaleStatusShared = IDL.Record({\n        token_id: IDL.Text,\n        sale_type: IDL.Variant({\n            auction: AuctionStateShared\n        }),\n        broker_id: IDL.Opt(IDL.Principal),\n        original_broker_id: IDL.Opt(IDL.Principal),\n        sale_id: IDL.Text\n    });\n    const StableBucketData = IDL.Record({\n        principal: IDL.Principal,\n        allocated_space: IDL.Nat,\n        date_added: IDL.Int,\n        version: IDL.Tuple(IDL.Nat, IDL.Nat, IDL.Nat),\n        b_gateway: IDL.Bool,\n        available_space: IDL.Nat,\n        allocations: IDL.Vec(IDL.Tuple(IDL.Tuple(IDL.Text, IDL.Text), IDL.Int))\n    });\n    const StableEscrowBalances = IDL.Vec(IDL.Tuple(Account__1, Account__1, IDL.Text, EscrowRecord__1));\n    const NFTBackupChunk = IDL.Record({\n        sales_balances: StableSalesBalances,\n        offers: StableOffers,\n        collection_data: StableCollectionData,\n        nft_ledgers: StableNftLedger,\n        canister: IDL.Principal,\n        allocations: IDL.Vec(IDL.Tuple(IDL.Tuple(IDL.Text, IDL.Text), AllocationRecordStable)),\n        nft_sales: IDL.Vec(IDL.Tuple(IDL.Text, SaleStatusShared)),\n        buckets: IDL.Vec(IDL.Tuple(IDL.Principal, StableBucketData)),\n        escrow_balances: StableEscrowBalances\n    });\n    const EXTTokenIdentifier = IDL.Text;\n    const EXTUser = IDL.Variant({\n        principal: IDL.Principal,\n        address: IDL.Text\n    });\n    const EXTBalanceRequest = IDL.Record({\n        token: EXTTokenIdentifier,\n        user: EXTUser\n    });\n    const EXTBalance = IDL.Nat;\n    const EXTCommonError = IDL.Variant({\n        InvalidToken: EXTTokenIdentifier,\n        Other: IDL.Text\n    });\n    const EXTBalanceResult = IDL.Variant({\n        ok: EXTBalance,\n        err: EXTCommonError\n    });\n    const StakeRecord = IDL.Record({\n        staker: Account__1,\n        token_id: IDL.Text,\n        amount: IDL.Nat\n    });\n    const BalanceResponse = IDL.Record({\n        nfts: IDL.Vec(IDL.Text),\n        offers: IDL.Vec(EscrowRecord__1),\n        sales: IDL.Vec(EscrowRecord__1),\n        stake: IDL.Vec(StakeRecord),\n        multi_canister: IDL.Opt(IDL.Vec(IDL.Principal)),\n        escrow: IDL.Vec(EscrowRecord__1)\n    });\n    const Errors = IDL.Variant({\n        nyi: IDL.Null,\n        storage_configuration_error: IDL.Null,\n        escrow_withdraw_payment_failed: IDL.Null,\n        token_not_found: IDL.Null,\n        owner_not_found: IDL.Null,\n        content_not_found: IDL.Null,\n        auction_ended: IDL.Null,\n        out_of_range: IDL.Null,\n        sale_id_does_not_match: IDL.Null,\n        sale_not_found: IDL.Null,\n        kyc_fail: IDL.Null,\n        item_not_owned: IDL.Null,\n        property_not_found: IDL.Null,\n        validate_trx_wrong_host: IDL.Null,\n        withdraw_too_large: IDL.Null,\n        content_not_deserializable: IDL.Null,\n        bid_too_low: IDL.Null,\n        validate_deposit_wrong_amount: IDL.Null,\n        existing_sale_found: IDL.Null,\n        noop: IDL.Null,\n        asset_mismatch: IDL.Null,\n        escrow_cannot_be_removed: IDL.Null,\n        deposit_burned: IDL.Null,\n        cannot_restage_minted_token: IDL.Null,\n        cannot_find_status_in_metadata: IDL.Null,\n        receipt_data_mismatch: IDL.Null,\n        validate_deposit_failed: IDL.Null,\n        unreachable: IDL.Null,\n        unauthorized_access: IDL.Null,\n        item_already_minted: IDL.Null,\n        no_escrow_found: IDL.Null,\n        escrow_owner_not_the_owner: IDL.Null,\n        improper_interface: IDL.Null,\n        app_id_not_found: IDL.Null,\n        token_non_transferable: IDL.Null,\n        kyc_error: IDL.Null,\n        sale_not_over: IDL.Null,\n        escrow_not_large_enough: IDL.Null,\n        update_class_error: IDL.Null,\n        malformed_metadata: IDL.Null,\n        token_id_mismatch: IDL.Null,\n        id_not_found_in_metadata: IDL.Null,\n        auction_not_started: IDL.Null,\n        low_fee_balance: IDL.Null,\n        library_not_found: IDL.Null,\n        attempt_to_stage_system_data: IDL.Null,\n        no_fee_accounts_provided: IDL.Null,\n        validate_deposit_wrong_buyer: IDL.Null,\n        not_enough_storage: IDL.Null,\n        sales_withdraw_payment_failed: IDL.Null\n    });\n    const OrigynError = IDL.Record({\n        text: IDL.Text,\n        error: Errors,\n        number: IDL.Nat32,\n        flag_point: IDL.Text\n    });\n    const BalanceResult = IDL.Variant({\n        ok: BalanceResponse,\n        err: OrigynError\n    });\n    const EXTAccountIdentifier = IDL.Text;\n    const EXTBearerResult = IDL.Variant({\n        ok: EXTAccountIdentifier,\n        err: EXTCommonError\n    });\n    const BearerResult = IDL.Variant({\n        ok: Account__1,\n        err: OrigynError\n    });\n    const canister_id = IDL.Principal;\n    const definite_canister_settings = IDL.Record({\n        freezing_threshold: IDL.Nat,\n        controllers: IDL.Opt(IDL.Vec(IDL.Principal)),\n        memory_allocation: IDL.Nat,\n        compute_allocation: IDL.Nat\n    });\n    const canister_status = IDL.Record({\n        status: IDL.Variant({\n            stopped: IDL.Null,\n            stopping: IDL.Null,\n            running: IDL.Null\n        }),\n        memory_size: IDL.Nat,\n        cycles: IDL.Nat,\n        settings: definite_canister_settings,\n        module_hash: IDL.Opt(IDL.Vec(IDL.Nat8))\n    });\n    const ChunkRequest = IDL.Record({\n        token_id: IDL.Text,\n        chunk: IDL.Opt(IDL.Nat),\n        library_id: IDL.Text\n    });\n    const ChunkContent = IDL.Variant({\n        remote: IDL.Record({\n            args: ChunkRequest,\n            canister: IDL.Principal\n        }),\n        chunk: IDL.Record({\n            total_chunks: IDL.Nat,\n            content: IDL.Vec(IDL.Nat8),\n            storage_allocation: AllocationRecordStable,\n            current_chunk: IDL.Opt(IDL.Nat)\n        })\n    });\n    const ChunkResult = IDL.Variant({\n        ok: ChunkContent,\n        err: OrigynError\n    });\n    const CollectionInfo = IDL.Record({\n        multi_canister_count: IDL.Opt(IDL.Nat),\n        managers: IDL.Opt(IDL.Vec(IDL.Principal)),\n        owner: IDL.Opt(IDL.Principal),\n        metadata: IDL.Opt(CandyShared),\n        logo: IDL.Opt(IDL.Text),\n        name: IDL.Opt(IDL.Text),\n        network: IDL.Opt(IDL.Principal),\n        created_at: IDL.Opt(IDL.Nat64),\n        fields: IDL.Opt(IDL.Vec(IDL.Tuple(IDL.Text, IDL.Opt(IDL.Nat), IDL.Opt(IDL.Nat)))),\n        upgraded_at: IDL.Opt(IDL.Nat64),\n        token_ids_count: IDL.Opt(IDL.Nat),\n        available_space: IDL.Opt(IDL.Nat),\n        multi_canister: IDL.Opt(IDL.Vec(IDL.Principal)),\n        token_ids: IDL.Opt(IDL.Vec(IDL.Text)),\n        transaction_count: IDL.Opt(IDL.Nat),\n        unique_holders: IDL.Opt(IDL.Nat),\n        total_supply: IDL.Opt(IDL.Nat),\n        symbol: IDL.Opt(IDL.Text),\n        allocated_storage: IDL.Opt(IDL.Nat)\n    });\n    const CollectionResult = IDL.Variant({\n        ok: CollectionInfo,\n        err: OrigynError\n    });\n    const ManageCollectionCommand = IDL.Variant({\n        UpdateOwner: IDL.Principal,\n        UpdateManagers: IDL.Vec(IDL.Principal),\n        UpdateMetadata: IDL.Tuple(IDL.Text, IDL.Opt(CandyShared), IDL.Bool),\n        UpdateAnnounceCanister: IDL.Opt(IDL.Principal),\n        UpdateNetwork: IDL.Opt(IDL.Principal),\n        UpdateSymbol: IDL.Opt(IDL.Text),\n        UpdateLogo: IDL.Opt(IDL.Text),\n        UpdateName: IDL.Opt(IDL.Text)\n    });\n    const OrigynBoolResult = IDL.Variant({\n        ok: IDL.Bool,\n        err: OrigynError\n    });\n    const Subaccount = IDL.Vec(IDL.Nat8);\n    const Account = IDL.Record({\n        owner: IDL.Principal,\n        subaccount: IDL.Opt(Subaccount)\n    });\n    const NftError = IDL.Variant({\n        UnauthorizedOperator: IDL.Null,\n        SelfTransfer: IDL.Null,\n        TokenNotFound: IDL.Null,\n        UnauthorizedOwner: IDL.Null,\n        TxNotFound: IDL.Null,\n        SelfApprove: IDL.Null,\n        OperatorNotFound: IDL.Null,\n        ExistedNFT: IDL.Null,\n        OwnerNotFound: IDL.Null,\n        Other: IDL.Text\n    });\n    const DIP721BoolResult = IDL.Variant({\n        Ok: IDL.Bool,\n        Err: NftError\n    });\n    const DIP721Metadata = IDL.Record({\n        logo: IDL.Opt(IDL.Text),\n        name: IDL.Opt(IDL.Text),\n        created_at: IDL.Nat64,\n        upgraded_at: IDL.Nat64,\n        custodians: IDL.Vec(IDL.Principal),\n        symbol: IDL.Opt(IDL.Text)\n    });\n    const DIP721TokensListMetadata = IDL.Variant({\n        Ok: IDL.Vec(IDL.Nat),\n        Err: NftError\n    });\n    Vec.fill(IDL.Vec(IDL.Tuple(IDL.Text, IDL.Variant({\n        Nat64Content: IDL.Nat64,\n        Nat32Content: IDL.Nat32,\n        BoolContent: IDL.Bool,\n        Nat8Content: IDL.Nat8,\n        Int64Content: IDL.Int64,\n        IntContent: IDL.Int,\n        NatContent: IDL.Nat,\n        Nat16Content: IDL.Nat16,\n        Int32Content: IDL.Int32,\n        Int8Content: IDL.Int8,\n        FloatContent: IDL.Float64,\n        Int16Content: IDL.Int16,\n        BlobContent: IDL.Vec(IDL.Nat8),\n        NestedContent: Vec,\n        Principal: IDL.Principal,\n        TextContent: IDL.Text\n    }))));\n    const GenericValue = IDL.Variant({\n        Nat64Content: IDL.Nat64,\n        Nat32Content: IDL.Nat32,\n        BoolContent: IDL.Bool,\n        Nat8Content: IDL.Nat8,\n        Int64Content: IDL.Int64,\n        IntContent: IDL.Int,\n        NatContent: IDL.Nat,\n        Nat16Content: IDL.Nat16,\n        Int32Content: IDL.Int32,\n        Int8Content: IDL.Int8,\n        FloatContent: IDL.Float64,\n        Int16Content: IDL.Int16,\n        BlobContent: IDL.Vec(IDL.Nat8),\n        NestedContent: Vec,\n        Principal: IDL.Principal,\n        TextContent: IDL.Text\n    });\n    const TokenMetadata = IDL.Record({\n        transferred_at: IDL.Opt(IDL.Nat64),\n        transferred_by: IDL.Opt(IDL.Principal),\n        owner: IDL.Opt(IDL.Principal),\n        operator: IDL.Opt(IDL.Principal),\n        approved_at: IDL.Opt(IDL.Nat64),\n        approved_by: IDL.Opt(IDL.Principal),\n        properties: IDL.Vec(IDL.Tuple(IDL.Text, GenericValue)),\n        is_burned: IDL.Bool,\n        token_identifier: IDL.Nat,\n        burned_at: IDL.Opt(IDL.Nat64),\n        burned_by: IDL.Opt(IDL.Principal),\n        minted_at: IDL.Nat64,\n        minted_by: IDL.Principal\n    });\n    const DIP721TokensMetadata = IDL.Variant({\n        Ok: IDL.Vec(TokenMetadata),\n        Err: NftError\n    });\n    const OwnerOfResponse = IDL.Variant({\n        Ok: IDL.Opt(IDL.Principal),\n        Err: NftError\n    });\n    const DIP721Stats = IDL.Record({\n        cycles: IDL.Nat,\n        total_transactions: IDL.Nat,\n        total_unique_holders: IDL.Nat,\n        total_supply: IDL.Nat\n    });\n    const DIP721SupportedInterface = IDL.Variant({\n        Burn: IDL.Null,\n        Mint: IDL.Null,\n        Approval: IDL.Null,\n        TransactionHistory: IDL.Null\n    });\n    const DIP721TokenMetadata = IDL.Variant({\n        Ok: TokenMetadata,\n        Err: NftError\n    });\n    const DIP721NatResult = IDL.Variant({\n        Ok: IDL.Nat,\n        Err: NftError\n    });\n    const GetLogMessagesFilter = IDL.Record({\n        analyzeCount: IDL.Nat32,\n        messageRegex: IDL.Opt(IDL.Text),\n        messageContains: IDL.Opt(IDL.Text)\n    });\n    const Nanos = IDL.Nat64;\n    const GetLogMessagesParameters = IDL.Record({\n        count: IDL.Nat32,\n        filter: IDL.Opt(GetLogMessagesFilter),\n        fromTimeNanos: IDL.Opt(Nanos)\n    });\n    const GetLatestLogMessagesParameters = IDL.Record({\n        upToTimeNanos: IDL.Opt(Nanos),\n        count: IDL.Nat32,\n        filter: IDL.Opt(GetLogMessagesFilter)\n    });\n    const CanisterLogRequest = IDL.Variant({\n        getMessagesInfo: IDL.Null,\n        getMessages: GetLogMessagesParameters,\n        getLatestMessages: GetLatestLogMessagesParameters\n    });\n    const CanisterLogFeature = IDL.Variant({\n        filterMessageByContains: IDL.Null,\n        filterMessageByRegex: IDL.Null\n    });\n    const CanisterLogMessagesInfo = IDL.Record({\n        features: IDL.Vec(IDL.Opt(CanisterLogFeature)),\n        lastTimeNanos: IDL.Opt(Nanos),\n        count: IDL.Nat32,\n        firstTimeNanos: IDL.Opt(Nanos)\n    });\n    const Data = IDL.Variant({\n        Int: IDL.Int,\n        Map: IDL.Vec(IDL.Tuple(CandyShared, CandyShared)),\n        Nat: IDL.Nat,\n        Set: IDL.Vec(CandyShared),\n        Nat16: IDL.Nat16,\n        Nat32: IDL.Nat32,\n        Nat64: IDL.Nat64,\n        Blob: IDL.Vec(IDL.Nat8),\n        Bool: IDL.Bool,\n        Int8: IDL.Int8,\n        Ints: IDL.Vec(IDL.Int),\n        Nat8: IDL.Nat8,\n        Nats: IDL.Vec(IDL.Nat),\n        Text: IDL.Text,\n        Bytes: IDL.Vec(IDL.Nat8),\n        Int16: IDL.Int16,\n        Int32: IDL.Int32,\n        Int64: IDL.Int64,\n        Option: IDL.Opt(CandyShared),\n        Floats: IDL.Vec(IDL.Float64),\n        Float: IDL.Float64,\n        Principal: IDL.Principal,\n        Array: IDL.Vec(CandyShared),\n        Class: IDL.Vec(PropertyShared)\n    });\n    const Caller = IDL.Opt(IDL.Principal);\n    const LogMessagesData = IDL.Record({\n        data: Data,\n        timeNanos: Nanos,\n        message: IDL.Text,\n        caller: Caller\n    });\n    const CanisterLogMessages = IDL.Record({\n        data: IDL.Vec(LogMessagesData),\n        lastAnalyzedMessageTimeNanos: IDL.Opt(Nanos)\n    });\n    const CanisterLogResponse = IDL.Variant({\n        messagesInfo: CanisterLogMessagesInfo,\n        messages: CanisterLogMessages\n    });\n    const MetricsGranularity = IDL.Variant({\n        hourly: IDL.Null,\n        daily: IDL.Null\n    });\n    const GetMetricsParameters = IDL.Record({\n        dateToMillis: IDL.Nat,\n        granularity: MetricsGranularity,\n        dateFromMillis: IDL.Nat\n    });\n    const UpdateCallsAggregatedData = IDL.Vec(IDL.Nat64);\n    const CanisterHeapMemoryAggregatedData = IDL.Vec(IDL.Nat64);\n    const CanisterCyclesAggregatedData = IDL.Vec(IDL.Nat64);\n    const CanisterMemoryAggregatedData = IDL.Vec(IDL.Nat64);\n    const HourlyMetricsData = IDL.Record({\n        updateCalls: UpdateCallsAggregatedData,\n        canisterHeapMemorySize: CanisterHeapMemoryAggregatedData,\n        canisterCycles: CanisterCyclesAggregatedData,\n        canisterMemorySize: CanisterMemoryAggregatedData,\n        timeMillis: IDL.Int\n    });\n    const NumericEntity = IDL.Record({\n        avg: IDL.Nat64,\n        max: IDL.Nat64,\n        min: IDL.Nat64,\n        first: IDL.Nat64,\n        last: IDL.Nat64\n    });\n    const DailyMetricsData = IDL.Record({\n        updateCalls: IDL.Nat64,\n        canisterHeapMemorySize: NumericEntity,\n        canisterCycles: NumericEntity,\n        canisterMemorySize: NumericEntity,\n        timeMillis: IDL.Int\n    });\n    const CanisterMetricsData = IDL.Variant({\n        hourly: IDL.Vec(HourlyMetricsData),\n        daily: IDL.Vec(DailyMetricsData)\n    });\n    const CanisterMetrics = IDL.Record({\n        data: CanisterMetricsData\n    });\n    const OrigynTextResult = IDL.Variant({\n        ok: IDL.Text,\n        err: OrigynError\n    });\n    const Tip = IDL.Record({\n        last_block_index: IDL.Vec(IDL.Nat8),\n        hash_tree: IDL.Vec(IDL.Nat8),\n        last_block_hash: IDL.Vec(IDL.Nat8)\n    });\n    const GovernanceRequest = IDL.Variant({\n        update_system_var: IDL.Record({\n            key: IDL.Text,\n            val: CandyShared,\n            token_id: IDL.Text\n        }),\n        clear_shared_wallets: IDL.Text\n    });\n    const GovernanceResponse = IDL.Variant({\n        update_system_var: IDL.Bool,\n        clear_shared_wallets: IDL.Bool\n    });\n    const GovernanceResult = IDL.Variant({\n        ok: GovernanceResponse,\n        err: OrigynError\n    });\n    const HistoryResult = IDL.Variant({\n        ok: IDL.Vec(TransactionRecord),\n        err: OrigynError\n    });\n    const HeaderField = IDL.Tuple(IDL.Text, IDL.Text);\n    const HttpRequest = IDL.Record({\n        url: IDL.Text,\n        method: IDL.Text,\n        body: IDL.Vec(IDL.Nat8),\n        headers: IDL.Vec(HeaderField)\n    });\n    const StreamingCallbackToken = IDL.Record({\n        key: IDL.Text,\n        index: IDL.Nat,\n        content_encoding: IDL.Text\n    });\n    const StreamingStrategy = IDL.Variant({\n        Callback: IDL.Record({\n            token: StreamingCallbackToken,\n            callback: IDL.Func([], [], [])\n        })\n    });\n    const HTTPResponse = IDL.Record({\n        body: IDL.Vec(IDL.Nat8),\n        headers: IDL.Vec(HeaderField),\n        streaming_strategy: IDL.Opt(StreamingStrategy),\n        status_code: IDL.Nat16\n    });\n    const StreamingCallbackResponse = IDL.Record({\n        token: IDL.Opt(StreamingCallbackToken),\n        body: IDL.Vec(IDL.Nat8)\n    });\n    const GetArchivesArgs = IDL.Record({\n        from: IDL.Opt(IDL.Principal)\n    });\n    const GetArchivesResultItem = IDL.Record({\n        end: IDL.Nat,\n        canister_id: IDL.Principal,\n        start: IDL.Nat\n    });\n    const GetArchivesResult = IDL.Vec(GetArchivesResultItem);\n    const TransactionRange = IDL.Record({\n        start: IDL.Nat,\n        length: IDL.Nat\n    });\n    Value__1.fill(IDL.Variant({\n        Int: IDL.Int,\n        Map: IDL.Vec(IDL.Tuple(IDL.Text, Value__1)),\n        Nat: IDL.Nat,\n        Blob: IDL.Vec(IDL.Nat8),\n        Text: IDL.Text,\n        Array: IDL.Vec(Value__1)\n    }));\n    const TransactionRange__1 = IDL.Record({\n        start: IDL.Nat,\n        length: IDL.Nat\n    });\n    const GetTransactionsResult__1 = IDL.Record({\n        log_length: IDL.Nat,\n        blocks: IDL.Vec(IDL.Record({\n            id: IDL.Nat,\n            block: Value__1\n        })),\n        archived_blocks: IDL.Vec(ArchivedTransactionResponse)\n    });\n    const GetTransactionsFn = IDL.Func([\n        IDL.Vec(TransactionRange__1)\n    ], [\n        GetTransactionsResult__1\n    ], [\n        \"query\"\n    ]);\n    ArchivedTransactionResponse.fill(IDL.Record({\n        args: IDL.Vec(TransactionRange__1),\n        callback: GetTransactionsFn\n    }));\n    const GetTransactionsResult = IDL.Record({\n        log_length: IDL.Nat,\n        blocks: IDL.Vec(IDL.Record({\n            id: IDL.Nat,\n            block: Value__1\n        })),\n        archived_blocks: IDL.Vec(ArchivedTransactionResponse)\n    });\n    const DataCertificate = IDL.Record({\n        certificate: IDL.Vec(IDL.Nat8),\n        hash_tree: IDL.Vec(IDL.Nat8)\n    });\n    const BlockType = IDL.Record({\n        url: IDL.Text,\n        block_type: IDL.Text\n    });\n    const ApprovalArgs = IDL.Record({\n        memo: IDL.Opt(IDL.Vec(IDL.Nat8)),\n        from_subaccount: IDL.Opt(IDL.Vec(IDL.Nat8)),\n        created_at_time: IDL.Opt(IDL.Nat64),\n        expires_at: IDL.Opt(IDL.Nat64),\n        spender: Account\n    });\n    const ApprovalError = IDL.Variant({\n        GenericError: IDL.Record({\n            message: IDL.Text,\n            error_code: IDL.Nat\n        }),\n        CreatexInFuture: IDL.Record({\n            ledger_time: IDL.Nat64\n        }),\n        NonExistingTokenId: IDL.Null,\n        Unauthorized: IDL.Null,\n        TooOld: IDL.Null\n    });\n    const ApprovalResult = IDL.Vec(IDL.Record({\n        token_id: IDL.Nat,\n        approval_result: IDL.Variant({\n            Ok: IDL.Nat,\n            Err: ApprovalError\n        })\n    }));\n    Value.fill(IDL.Variant({\n        Int: IDL.Int,\n        Map: IDL.Vec(IDL.Tuple(IDL.Text, Value)),\n        Nat: IDL.Nat,\n        Blob: IDL.Vec(IDL.Nat8),\n        Text: IDL.Text,\n        Array: IDL.Vec(Value)\n    }));\n    const CollectionMetadata = IDL.Vec(IDL.Tuple(IDL.Text, Value));\n    const SupportedStandard = IDL.Record({\n        url: IDL.Text,\n        name: IDL.Text\n    });\n    const TransferArgs = IDL.Record({\n        to: Account,\n        token_id: IDL.Nat,\n        memo: IDL.Opt(IDL.Vec(IDL.Nat8)),\n        from_subaccount: IDL.Opt(IDL.Vec(IDL.Nat8)),\n        created_at_time: IDL.Opt(IDL.Nat64)\n    });\n    const TransferError = IDL.Variant({\n        GenericError: IDL.Record({\n            message: IDL.Text,\n            error_code: IDL.Nat\n        }),\n        Duplicate: IDL.Record({\n            duplicate_of: IDL.Nat\n        }),\n        NonExistingTokenId: IDL.Null,\n        Unauthorized: IDL.Null,\n        CreatedInFuture: IDL.Record({\n            ledger_time: IDL.Nat64\n        }),\n        TooOld: IDL.Null\n    });\n    const TransferResultItem = IDL.Record({\n        token_id: IDL.Nat,\n        transfer_result: IDL.Variant({\n            Ok: IDL.Nat,\n            Err: TransferError\n        })\n    });\n    const TransferResult = IDL.Vec(IDL.Opt(TransferResultItem));\n    const ManageStorageRequest = IDL.Variant({\n        add_storage_canisters: IDL.Vec(IDL.Tuple(IDL.Principal, IDL.Nat, IDL.Tuple(IDL.Nat, IDL.Nat, IDL.Nat))),\n        configure_storage: IDL.Variant({\n            stableBtree: IDL.Opt(IDL.Nat),\n            heap: IDL.Opt(IDL.Nat)\n        })\n    });\n    const ManageStorageResponse = IDL.Variant({\n        add_storage_canisters: IDL.Tuple(IDL.Nat, IDL.Nat),\n        configure_storage: IDL.Tuple(IDL.Nat, IDL.Nat)\n    });\n    const ManageStorageResult = IDL.Variant({\n        ok: ManageStorageResponse,\n        err: OrigynError\n    });\n    const EscrowReceipt__1 = IDL.Record({\n        token: TokenSpec,\n        token_id: IDL.Text,\n        seller: Account__2,\n        buyer: Account__2,\n        amount: IDL.Nat\n    });\n    const SalesConfig = IDL.Record({\n        broker_id: IDL.Opt(Account__2),\n        pricing: PricingConfigShared,\n        escrow_receipt: IDL.Opt(EscrowReceipt__1)\n    });\n    const MarketTransferRequest = IDL.Record({\n        token_id: IDL.Text,\n        sales_config: SalesConfig\n    });\n    const MarketTransferRequestReponse = IDL.Record({\n        token_id: IDL.Text,\n        txn_type: IDL.Variant({\n            escrow_deposit: IDL.Record({\n                token: TokenSpec,\n                token_id: IDL.Text,\n                trx_id: TransactionID,\n                seller: Account__2,\n                extensible: CandyShared,\n                buyer: Account__2,\n                amount: IDL.Nat\n            }),\n            fee_deposit: IDL.Record({\n                token: TokenSpec,\n                extensible: CandyShared,\n                account: Account__2,\n                amount: IDL.Nat\n            }),\n            canister_network_updated: IDL.Record({\n                network: IDL.Principal,\n                extensible: CandyShared\n            }),\n            escrow_withdraw: IDL.Record({\n                fee: IDL.Nat,\n                token: TokenSpec,\n                token_id: IDL.Text,\n                trx_id: TransactionID,\n                seller: Account__2,\n                extensible: CandyShared,\n                buyer: Account__2,\n                amount: IDL.Nat\n            }),\n            canister_managers_updated: IDL.Record({\n                managers: IDL.Vec(IDL.Principal),\n                extensible: CandyShared\n            }),\n            auction_bid: IDL.Record({\n                token: TokenSpec,\n                extensible: CandyShared,\n                buyer: Account__2,\n                amount: IDL.Nat,\n                sale_id: IDL.Text\n            }),\n            burn: IDL.Record({\n                from: IDL.Opt(Account__2),\n                extensible: CandyShared\n            }),\n            data: IDL.Record({\n                hash: IDL.Opt(IDL.Vec(IDL.Nat8)),\n                extensible: CandyShared,\n                data_dapp: IDL.Opt(IDL.Text),\n                data_path: IDL.Opt(IDL.Text)\n            }),\n            sale_ended: IDL.Record({\n                token: TokenSpec,\n                seller: Account__2,\n                extensible: CandyShared,\n                buyer: Account__2,\n                amount: IDL.Nat,\n                sale_id: IDL.Opt(IDL.Text)\n            }),\n            mint: IDL.Record({\n                to: Account__2,\n                from: Account__2,\n                sale: IDL.Opt(IDL.Record({\n                    token: TokenSpec,\n                    amount: IDL.Nat\n                })),\n                extensible: CandyShared\n            }),\n            royalty_paid: IDL.Record({\n                tag: IDL.Text,\n                token: TokenSpec,\n                seller: Account__2,\n                extensible: CandyShared,\n                buyer: Account__2,\n                amount: IDL.Nat,\n                receiver: Account__2,\n                sale_id: IDL.Opt(IDL.Text)\n            }),\n            extensible: CandyShared,\n            fee_deposit_withdraw: IDL.Record({\n                fee: IDL.Nat,\n                token: TokenSpec,\n                trx_id: TransactionID,\n                extensible: CandyShared,\n                account: Account__2,\n                amount: IDL.Nat\n            }),\n            owner_transfer: IDL.Record({\n                to: Account__2,\n                from: Account__2,\n                extensible: CandyShared\n            }),\n            sale_opened: IDL.Record({\n                pricing: PricingConfigShared,\n                extensible: CandyShared,\n                sale_id: IDL.Text\n            }),\n            canister_owner_updated: IDL.Record({\n                owner: IDL.Principal,\n                extensible: CandyShared\n            }),\n            sale_withdraw: IDL.Record({\n                fee: IDL.Nat,\n                token: TokenSpec,\n                token_id: IDL.Text,\n                trx_id: TransactionID,\n                seller: Account__2,\n                extensible: CandyShared,\n                buyer: Account__2,\n                amount: IDL.Nat\n            }),\n            deposit_withdraw: IDL.Record({\n                fee: IDL.Nat,\n                token: TokenSpec,\n                trx_id: TransactionID,\n                extensible: CandyShared,\n                buyer: Account__2,\n                amount: IDL.Nat\n            })\n        }),\n        timestamp: IDL.Int,\n        index: IDL.Nat\n    });\n    const MarketTransferResult = IDL.Variant({\n        ok: MarketTransferRequestReponse,\n        err: OrigynError\n    });\n    const EXTMetadata = IDL.Variant({\n        fungible: IDL.Record({\n            decimals: IDL.Nat8,\n            metadata: IDL.Opt(IDL.Vec(IDL.Nat8)),\n            name: IDL.Text,\n            symbol: IDL.Text\n        }),\n        nonfungible: IDL.Record({\n            metadata: IDL.Opt(IDL.Vec(IDL.Nat8))\n        })\n    });\n    const EXTMetadataResult = IDL.Variant({\n        ok: EXTMetadata,\n        err: EXTCommonError\n    });\n    const NFTInfoStable = IDL.Record({\n        metadata: CandyShared,\n        current_sale: IDL.Opt(SaleStatusShared)\n    });\n    const NFTInfoResult = IDL.Variant({\n        ok: NFTInfoStable,\n        err: OrigynError\n    });\n    const TokenSpec__2 = IDL.Variant({\n        ic: ICTokenSpec,\n        extensible: CandyShared\n    });\n    const Account__3 = IDL.Variant({\n        account_id: IDL.Text,\n        principal: IDL.Principal,\n        extensible: CandyShared,\n        account: IDL.Record({\n            owner: IDL.Principal,\n            sub_account: IDL.Opt(IDL.Vec(IDL.Nat8))\n        })\n    });\n    const EscrowRecord = IDL.Record({\n        token: TokenSpec__2,\n        token_id: IDL.Text,\n        seller: Account__3,\n        lock_to_date: IDL.Opt(IDL.Int),\n        buyer: Account__3,\n        amount: IDL.Nat,\n        sale_id: IDL.Opt(IDL.Text),\n        account_hash: IDL.Opt(IDL.Vec(IDL.Nat8))\n    });\n    const BidRequest = IDL.Record({\n        config: BidConfigShared,\n        escrow_record: EscrowRecord\n    });\n    const TransactionID__1 = IDL.Variant({\n        nat: IDL.Nat,\n        text: IDL.Text,\n        extensible: CandyShared\n    });\n    const DepositDetail = IDL.Record({\n        token: TokenSpec__1,\n        trx_id: IDL.Opt(TransactionID__1),\n        seller: Account__1,\n        buyer: Account__1,\n        amount: IDL.Nat,\n        sale_id: IDL.Opt(IDL.Text)\n    });\n    const EscrowRequest = IDL.Record({\n        token_id: IDL.Text,\n        deposit: DepositDetail,\n        lock_to_date: IDL.Opt(IDL.Int)\n    });\n    const FeeDepositRequest = IDL.Record({\n        token: TokenSpec__1,\n        account: Account__1\n    });\n    const RejectDescription = IDL.Record({\n        token: TokenSpec__1,\n        token_id: IDL.Text,\n        seller: Account__1,\n        buyer: Account__1\n    });\n    const FeeDepositWithdrawDescription = IDL.Record({\n        status: IDL.Variant({\n            locked: IDL.Record({\n                token_id: IDL.Text,\n                sale_id: IDL.Text\n            }),\n            unlocked: IDL.Null\n        }),\n        token: TokenSpec__1,\n        withdraw_to: Account__1,\n        account: Account__1,\n        amount: IDL.Nat\n    });\n    const WithdrawDescription = IDL.Record({\n        token: TokenSpec__1,\n        token_id: IDL.Text,\n        seller: Account__1,\n        withdraw_to: Account__1,\n        buyer: Account__1,\n        amount: IDL.Nat\n    });\n    const DepositWithdrawDescription = IDL.Record({\n        token: TokenSpec__1,\n        withdraw_to: Account__1,\n        buyer: Account__1,\n        amount: IDL.Nat\n    });\n    const WithdrawRequest = IDL.Variant({\n        reject: RejectDescription,\n        fee_deposit: FeeDepositWithdrawDescription,\n        sale: WithdrawDescription,\n        deposit: DepositWithdrawDescription,\n        escrow: WithdrawDescription\n    });\n    const TokenSpecFilter = IDL.Record({\n        token: TokenSpec__1,\n        filter_type: IDL.Variant({\n            allow: IDL.Null,\n            block: IDL.Null\n        })\n    });\n    const TokenIDFilter = IDL.Record({\n        filter_type: IDL.Variant({\n            allow: IDL.Null,\n            block: IDL.Null\n        }),\n        token_id: IDL.Text,\n        tokens: IDL.Vec(IDL.Record({\n            token: TokenSpec__1,\n            min_amount: IDL.Opt(IDL.Nat),\n            max_amount: IDL.Opt(IDL.Nat)\n        }))\n    });\n    const AskSubscribeRequest = IDL.Variant({\n        subscribe: IDL.Record({\n            stake: IDL.Tuple(IDL.Principal, IDL.Nat),\n            filter: IDL.Opt(IDL.Record({\n                tokens: IDL.Opt(IDL.Vec(TokenSpecFilter)),\n                token_ids: IDL.Opt(IDL.Vec(TokenIDFilter))\n            }))\n        }),\n        unsubscribe: IDL.Tuple(IDL.Principal, IDL.Nat)\n    });\n    const DistributeSaleRequest = IDL.Record({\n        seller: IDL.Opt(Account__1)\n    });\n    const ManageSaleRequest = IDL.Variant({\n        bid: BidRequest,\n        escrow_deposit: EscrowRequest,\n        fee_deposit: FeeDepositRequest,\n        recognize_escrow: EscrowRequest,\n        withdraw: WithdrawRequest,\n        ask_subscribe: AskSubscribeRequest,\n        end_sale: IDL.Text,\n        refresh_offers: IDL.Opt(Account__1),\n        distribute_sale: DistributeSaleRequest,\n        open_sale: IDL.Text\n    });\n    const BidResponse = IDL.Record({\n        token_id: IDL.Text,\n        txn_type: IDL.Variant({\n            escrow_deposit: IDL.Record({\n                token: TokenSpec,\n                token_id: IDL.Text,\n                trx_id: TransactionID,\n                seller: Account__2,\n                extensible: CandyShared,\n                buyer: Account__2,\n                amount: IDL.Nat\n            }),\n            fee_deposit: IDL.Record({\n                token: TokenSpec,\n                extensible: CandyShared,\n                account: Account__2,\n                amount: IDL.Nat\n            }),\n            canister_network_updated: IDL.Record({\n                network: IDL.Principal,\n                extensible: CandyShared\n            }),\n            escrow_withdraw: IDL.Record({\n                fee: IDL.Nat,\n                token: TokenSpec,\n                token_id: IDL.Text,\n                trx_id: TransactionID,\n                seller: Account__2,\n                extensible: CandyShared,\n                buyer: Account__2,\n                amount: IDL.Nat\n            }),\n            canister_managers_updated: IDL.Record({\n                managers: IDL.Vec(IDL.Principal),\n                extensible: CandyShared\n            }),\n            auction_bid: IDL.Record({\n                token: TokenSpec,\n                extensible: CandyShared,\n                buyer: Account__2,\n                amount: IDL.Nat,\n                sale_id: IDL.Text\n            }),\n            burn: IDL.Record({\n                from: IDL.Opt(Account__2),\n                extensible: CandyShared\n            }),\n            data: IDL.Record({\n                hash: IDL.Opt(IDL.Vec(IDL.Nat8)),\n                extensible: CandyShared,\n                data_dapp: IDL.Opt(IDL.Text),\n                data_path: IDL.Opt(IDL.Text)\n            }),\n            sale_ended: IDL.Record({\n                token: TokenSpec,\n                seller: Account__2,\n                extensible: CandyShared,\n                buyer: Account__2,\n                amount: IDL.Nat,\n                sale_id: IDL.Opt(IDL.Text)\n            }),\n            mint: IDL.Record({\n                to: Account__2,\n                from: Account__2,\n                sale: IDL.Opt(IDL.Record({\n                    token: TokenSpec,\n                    amount: IDL.Nat\n                })),\n                extensible: CandyShared\n            }),\n            royalty_paid: IDL.Record({\n                tag: IDL.Text,\n                token: TokenSpec,\n                seller: Account__2,\n                extensible: CandyShared,\n                buyer: Account__2,\n                amount: IDL.Nat,\n                receiver: Account__2,\n                sale_id: IDL.Opt(IDL.Text)\n            }),\n            extensible: CandyShared,\n            fee_deposit_withdraw: IDL.Record({\n                fee: IDL.Nat,\n                token: TokenSpec,\n                trx_id: TransactionID,\n                extensible: CandyShared,\n                account: Account__2,\n                amount: IDL.Nat\n            }),\n            owner_transfer: IDL.Record({\n                to: Account__2,\n                from: Account__2,\n                extensible: CandyShared\n            }),\n            sale_opened: IDL.Record({\n                pricing: PricingConfigShared,\n                extensible: CandyShared,\n                sale_id: IDL.Text\n            }),\n            canister_owner_updated: IDL.Record({\n                owner: IDL.Principal,\n                extensible: CandyShared\n            }),\n            sale_withdraw: IDL.Record({\n                fee: IDL.Nat,\n                token: TokenSpec,\n                token_id: IDL.Text,\n                trx_id: TransactionID,\n                seller: Account__2,\n                extensible: CandyShared,\n                buyer: Account__2,\n                amount: IDL.Nat\n            }),\n            deposit_withdraw: IDL.Record({\n                fee: IDL.Nat,\n                token: TokenSpec,\n                trx_id: TransactionID,\n                extensible: CandyShared,\n                buyer: Account__2,\n                amount: IDL.Nat\n            })\n        }),\n        timestamp: IDL.Int,\n        index: IDL.Nat\n    });\n    const EscrowResponse = IDL.Record({\n        balance: IDL.Nat,\n        receipt: EscrowReceipt,\n        transaction: TransactionRecord\n    });\n    const FeeDepositResponse = IDL.Record({\n        balance: IDL.Nat,\n        transaction: TransactionRecord\n    });\n    const RecognizeEscrowResponse = IDL.Record({\n        balance: IDL.Nat,\n        receipt: EscrowReceipt,\n        transaction: IDL.Opt(TransactionRecord)\n    });\n    const WithdrawResponse = IDL.Record({\n        token_id: IDL.Text,\n        txn_type: IDL.Variant({\n            escrow_deposit: IDL.Record({\n                token: TokenSpec,\n                token_id: IDL.Text,\n                trx_id: TransactionID,\n                seller: Account__2,\n                extensible: CandyShared,\n                buyer: Account__2,\n                amount: IDL.Nat\n            }),\n            fee_deposit: IDL.Record({\n                token: TokenSpec,\n                extensible: CandyShared,\n                account: Account__2,\n                amount: IDL.Nat\n            }),\n            canister_network_updated: IDL.Record({\n                network: IDL.Principal,\n                extensible: CandyShared\n            }),\n            escrow_withdraw: IDL.Record({\n                fee: IDL.Nat,\n                token: TokenSpec,\n                token_id: IDL.Text,\n                trx_id: TransactionID,\n                seller: Account__2,\n                extensible: CandyShared,\n                buyer: Account__2,\n                amount: IDL.Nat\n            }),\n            canister_managers_updated: IDL.Record({\n                managers: IDL.Vec(IDL.Principal),\n                extensible: CandyShared\n            }),\n            auction_bid: IDL.Record({\n                token: TokenSpec,\n                extensible: CandyShared,\n                buyer: Account__2,\n                amount: IDL.Nat,\n                sale_id: IDL.Text\n            }),\n            burn: IDL.Record({\n                from: IDL.Opt(Account__2),\n                extensible: CandyShared\n            }),\n            data: IDL.Record({\n                hash: IDL.Opt(IDL.Vec(IDL.Nat8)),\n                extensible: CandyShared,\n                data_dapp: IDL.Opt(IDL.Text),\n                data_path: IDL.Opt(IDL.Text)\n            }),\n            sale_ended: IDL.Record({\n                token: TokenSpec,\n                seller: Account__2,\n                extensible: CandyShared,\n                buyer: Account__2,\n                amount: IDL.Nat,\n                sale_id: IDL.Opt(IDL.Text)\n            }),\n            mint: IDL.Record({\n                to: Account__2,\n                from: Account__2,\n                sale: IDL.Opt(IDL.Record({\n                    token: TokenSpec,\n                    amount: IDL.Nat\n                })),\n                extensible: CandyShared\n            }),\n            royalty_paid: IDL.Record({\n                tag: IDL.Text,\n                token: TokenSpec,\n                seller: Account__2,\n                extensible: CandyShared,\n                buyer: Account__2,\n                amount: IDL.Nat,\n                receiver: Account__2,\n                sale_id: IDL.Opt(IDL.Text)\n            }),\n            extensible: CandyShared,\n            fee_deposit_withdraw: IDL.Record({\n                fee: IDL.Nat,\n                token: TokenSpec,\n                trx_id: TransactionID,\n                extensible: CandyShared,\n                account: Account__2,\n                amount: IDL.Nat\n            }),\n            owner_transfer: IDL.Record({\n                to: Account__2,\n                from: Account__2,\n                extensible: CandyShared\n            }),\n            sale_opened: IDL.Record({\n                pricing: PricingConfigShared,\n                extensible: CandyShared,\n                sale_id: IDL.Text\n            }),\n            canister_owner_updated: IDL.Record({\n                owner: IDL.Principal,\n                extensible: CandyShared\n            }),\n            sale_withdraw: IDL.Record({\n                fee: IDL.Nat,\n                token: TokenSpec,\n                token_id: IDL.Text,\n                trx_id: TransactionID,\n                seller: Account__2,\n                extensible: CandyShared,\n                buyer: Account__2,\n                amount: IDL.Nat\n            }),\n            deposit_withdraw: IDL.Record({\n                fee: IDL.Nat,\n                token: TokenSpec,\n                trx_id: TransactionID,\n                extensible: CandyShared,\n                buyer: Account__2,\n                amount: IDL.Nat\n            })\n        }),\n        timestamp: IDL.Int,\n        index: IDL.Nat\n    });\n    const AskSubscribeResponse = IDL.Bool;\n    const EndSaleResponse = IDL.Record({\n        token_id: IDL.Text,\n        txn_type: IDL.Variant({\n            escrow_deposit: IDL.Record({\n                token: TokenSpec,\n                token_id: IDL.Text,\n                trx_id: TransactionID,\n                seller: Account__2,\n                extensible: CandyShared,\n                buyer: Account__2,\n                amount: IDL.Nat\n            }),\n            fee_deposit: IDL.Record({\n                token: TokenSpec,\n                extensible: CandyShared,\n                account: Account__2,\n                amount: IDL.Nat\n            }),\n            canister_network_updated: IDL.Record({\n                network: IDL.Principal,\n                extensible: CandyShared\n            }),\n            escrow_withdraw: IDL.Record({\n                fee: IDL.Nat,\n                token: TokenSpec,\n                token_id: IDL.Text,\n                trx_id: TransactionID,\n                seller: Account__2,\n                extensible: CandyShared,\n                buyer: Account__2,\n                amount: IDL.Nat\n            }),\n            canister_managers_updated: IDL.Record({\n                managers: IDL.Vec(IDL.Principal),\n                extensible: CandyShared\n            }),\n            auction_bid: IDL.Record({\n                token: TokenSpec,\n                extensible: CandyShared,\n                buyer: Account__2,\n                amount: IDL.Nat,\n                sale_id: IDL.Text\n            }),\n            burn: IDL.Record({\n                from: IDL.Opt(Account__2),\n                extensible: CandyShared\n            }),\n            data: IDL.Record({\n                hash: IDL.Opt(IDL.Vec(IDL.Nat8)),\n                extensible: CandyShared,\n                data_dapp: IDL.Opt(IDL.Text),\n                data_path: IDL.Opt(IDL.Text)\n            }),\n            sale_ended: IDL.Record({\n                token: TokenSpec,\n                seller: Account__2,\n                extensible: CandyShared,\n                buyer: Account__2,\n                amount: IDL.Nat,\n                sale_id: IDL.Opt(IDL.Text)\n            }),\n            mint: IDL.Record({\n                to: Account__2,\n                from: Account__2,\n                sale: IDL.Opt(IDL.Record({\n                    token: TokenSpec,\n                    amount: IDL.Nat\n                })),\n                extensible: CandyShared\n            }),\n            royalty_paid: IDL.Record({\n                tag: IDL.Text,\n                token: TokenSpec,\n                seller: Account__2,\n                extensible: CandyShared,\n                buyer: Account__2,\n                amount: IDL.Nat,\n                receiver: Account__2,\n                sale_id: IDL.Opt(IDL.Text)\n            }),\n            extensible: CandyShared,\n            fee_deposit_withdraw: IDL.Record({\n                fee: IDL.Nat,\n                token: TokenSpec,\n                trx_id: TransactionID,\n                extensible: CandyShared,\n                account: Account__2,\n                amount: IDL.Nat\n            }),\n            owner_transfer: IDL.Record({\n                to: Account__2,\n                from: Account__2,\n                extensible: CandyShared\n            }),\n            sale_opened: IDL.Record({\n                pricing: PricingConfigShared,\n                extensible: CandyShared,\n                sale_id: IDL.Text\n            }),\n            canister_owner_updated: IDL.Record({\n                owner: IDL.Principal,\n                extensible: CandyShared\n            }),\n            sale_withdraw: IDL.Record({\n                fee: IDL.Nat,\n                token: TokenSpec,\n                token_id: IDL.Text,\n                trx_id: TransactionID,\n                seller: Account__2,\n                extensible: CandyShared,\n                buyer: Account__2,\n                amount: IDL.Nat\n            }),\n            deposit_withdraw: IDL.Record({\n                fee: IDL.Nat,\n                token: TokenSpec,\n                trx_id: TransactionID,\n                extensible: CandyShared,\n                buyer: Account__2,\n                amount: IDL.Nat\n            })\n        }),\n        timestamp: IDL.Int,\n        index: IDL.Nat\n    });\n    const Result = IDL.Variant({\n        ok: ManageSaleResponse,\n        err: OrigynError\n    });\n    const DistributeSaleResponse = IDL.Vec(Result);\n    ManageSaleResponse.fill(IDL.Variant({\n        bid: BidResponse,\n        escrow_deposit: EscrowResponse,\n        fee_deposit: FeeDepositResponse,\n        recognize_escrow: RecognizeEscrowResponse,\n        withdraw: WithdrawResponse,\n        ask_subscribe: AskSubscribeResponse,\n        end_sale: EndSaleResponse,\n        refresh_offers: IDL.Vec(EscrowRecord__1),\n        distribute_sale: DistributeSaleResponse,\n        open_sale: IDL.Bool\n    }));\n    const ManageSaleResult = IDL.Variant({\n        ok: ManageSaleResponse,\n        err: OrigynError\n    });\n    const SaleInfoRequest = IDL.Variant({\n        status: IDL.Text,\n        fee_deposit_info: IDL.Opt(Account__1),\n        active: IDL.Opt(IDL.Tuple(IDL.Nat, IDL.Nat)),\n        deposit_info: IDL.Opt(Account__1),\n        history: IDL.Opt(IDL.Tuple(IDL.Nat, IDL.Nat)),\n        escrow_info: EscrowReceipt\n    });\n    const SubAccountInfo = IDL.Record({\n        account_id: IDL.Vec(IDL.Nat8),\n        principal: IDL.Principal,\n        account_id_text: IDL.Text,\n        account: IDL.Record({\n            principal: IDL.Principal,\n            sub_account: IDL.Vec(IDL.Nat8)\n        })\n    });\n    const SaleInfoResponse = IDL.Variant({\n        status: IDL.Opt(SaleStatusShared),\n        fee_deposit_info: SubAccountInfo,\n        active: IDL.Record({\n            eof: IDL.Bool,\n            records: IDL.Vec(IDL.Tuple(IDL.Text, IDL.Opt(SaleStatusShared))),\n            count: IDL.Nat\n        }),\n        deposit_info: SubAccountInfo,\n        history: IDL.Record({\n            eof: IDL.Bool,\n            records: IDL.Vec(IDL.Opt(SaleStatusShared)),\n            count: IDL.Nat\n        }),\n        escrow_info: SubAccountInfo\n    });\n    const SaleInfoResult = IDL.Variant({\n        ok: SaleInfoResponse,\n        err: OrigynError\n    });\n    const ShareWalletRequest = IDL.Record({\n        to: Account__1,\n        token_id: IDL.Text,\n        from: Account__1\n    });\n    const OwnerTransferResponse = IDL.Record({\n        transaction: TransactionRecord,\n        assets: IDL.Vec(CandyShared)\n    });\n    const OwnerUpdateResult = IDL.Variant({\n        ok: OwnerTransferResponse,\n        err: OrigynError\n    });\n    const StageChunkArg = IDL.Record({\n        content: IDL.Vec(IDL.Nat8),\n        token_id: IDL.Text,\n        chunk: IDL.Nat,\n        filedata: CandyShared,\n        library_id: IDL.Text\n    });\n    const StageLibraryResponse = IDL.Record({\n        canister: IDL.Principal\n    });\n    const StageLibraryResult = IDL.Variant({\n        ok: StageLibraryResponse,\n        err: OrigynError\n    });\n    const StateSize = IDL.Record({\n        sales_balances: IDL.Nat,\n        offers: IDL.Nat,\n        nft_ledgers: IDL.Nat,\n        allocations: IDL.Nat,\n        nft_sales: IDL.Nat,\n        buckets: IDL.Nat,\n        escrow_balances: IDL.Nat\n    });\n    const StorageMetrics = IDL.Record({\n        gateway: IDL.Principal,\n        available_space: IDL.Nat,\n        allocations: IDL.Vec(AllocationRecordStable),\n        allocated_storage: IDL.Nat\n    });\n    const StorageMetricsResult = IDL.Variant({\n        ok: StorageMetrics,\n        err: OrigynError\n    });\n    const EXTTokensResponse = IDL.Tuple(IDL.Nat32, IDL.Opt(IDL.Record({\n        locked: IDL.Opt(IDL.Int),\n        seller: IDL.Principal,\n        price: IDL.Nat64\n    })), IDL.Opt(IDL.Vec(IDL.Nat8)));\n    const EXTTokensResult = IDL.Variant({\n        ok: IDL.Vec(EXTTokensResponse),\n        err: EXTCommonError\n    });\n    const EXTMemo = IDL.Vec(IDL.Nat8);\n    const EXTSubAccount = IDL.Vec(IDL.Nat8);\n    const EXTTransferRequest = IDL.Record({\n        to: EXTUser,\n        token: EXTTokenIdentifier,\n        notify: IDL.Bool,\n        from: EXTUser,\n        memo: EXTMemo,\n        subaccount: IDL.Opt(EXTSubAccount),\n        amount: EXTBalance\n    });\n    const EXTTransferResponse = IDL.Variant({\n        ok: EXTBalance,\n        err: IDL.Variant({\n            CannotNotify: EXTAccountIdentifier,\n            InsufficientBalance: IDL.Null,\n            InvalidToken: EXTTokenIdentifier,\n            Rejected: IDL.Null,\n            Unauthorized: EXTAccountIdentifier,\n            Other: IDL.Text\n        })\n    });\n    const UpdateModeShared = IDL.Variant({\n        Set: CandyShared,\n        Lock: CandyShared,\n        Next: IDL.Vec(UpdateShared)\n    });\n    UpdateShared.fill(IDL.Record({\n        mode: UpdateModeShared,\n        name: IDL.Text\n    }));\n    const UpdateRequestShared = IDL.Record({\n        id: IDL.Text,\n        update: IDL.Vec(UpdateShared)\n    });\n    const NFTUpdateRequest = IDL.Variant({\n        update: IDL.Record({\n            token_id: IDL.Text,\n            update: UpdateRequestShared,\n            app_id: IDL.Text\n        }),\n        replace: IDL.Record({\n            token_id: IDL.Text,\n            data: CandyShared\n        })\n    });\n    const NFTUpdateResponse = IDL.Bool;\n    const NFTUpdateResult = IDL.Variant({\n        ok: NFTUpdateResponse,\n        err: OrigynError\n    });\n    const IndexType = IDL.Variant({\n        Stable: IDL.Null,\n        StableTyped: IDL.Null,\n        Managed: IDL.Null\n    });\n    const UpdateSetting = IDL.Variant({\n        maxRecordsToArchive: IDL.Nat,\n        archiveIndexType: IndexType,\n        maxArchivePages: IDL.Nat,\n        settleToRecords: IDL.Nat,\n        archiveCycles: IDL.Nat,\n        maxActiveRecords: IDL.Nat,\n        maxRecordsInArchiveInstance: IDL.Nat,\n        archiveControllers: IDL.Opt(IDL.Opt(IDL.Vec(IDL.Principal)))\n    });\n    const NFTUpdateMetadataNode = IDL.Record({\n        token_id: IDL.Text,\n        value: CandyShared,\n        _system: IDL.Bool,\n        field_id: IDL.Text\n    });\n    const NFTUpdateMetadataNodeResponse = IDL.Record({\n        property_new: PropertyShared,\n        property_old: IDL.Opt(PropertyShared)\n    });\n    const NFTUpdateAppResult = IDL.Variant({\n        ok: NFTUpdateMetadataNodeResponse,\n        err: OrigynError\n    });\n    return IDL.Service({\n        __advance_time: IDL.Func([\n            IDL.Int\n        ], [\n            IDL.Int\n        ], []),\n        __set_time_mode: IDL.Func([\n            IDL.Variant({\n                test: IDL.Null,\n                standard: IDL.Null\n            })\n        ], [\n            IDL.Bool\n        ], []),\n        __supports: IDL.Func([], [\n            IDL.Vec(IDL.Tuple(IDL.Text, IDL.Text))\n        ], [\n            \"query\"\n        ]),\n        __version: IDL.Func([], [\n            IDL.Text\n        ], [\n            \"query\"\n        ]),\n        back_up: IDL.Func([\n            IDL.Nat\n        ], [\n            IDL.Variant({\n                eof: NFTBackupChunk,\n                data: NFTBackupChunk\n            })\n        ], [\n            \"query\"\n        ]),\n        balance: IDL.Func([\n            EXTBalanceRequest\n        ], [\n            EXTBalanceResult\n        ], [\n            \"query\"\n        ]),\n        balanceEXT: IDL.Func([\n            EXTBalanceRequest\n        ], [\n            EXTBalanceResult\n        ], [\n            \"query\"\n        ]),\n        balance_of_batch_nft_origyn: IDL.Func([\n            IDL.Vec(Account__1)\n        ], [\n            IDL.Vec(BalanceResult)\n        ], [\n            \"query\"\n        ]),\n        balance_of_nft_origyn: IDL.Func([\n            Account__1\n        ], [\n            BalanceResult\n        ], [\n            \"query\"\n        ]),\n        balance_of_secure_batch_nft_origyn: IDL.Func([\n            IDL.Vec(Account__1)\n        ], [\n            IDL.Vec(BalanceResult)\n        ], []),\n        balance_of_secure_nft_origyn: IDL.Func([\n            Account__1\n        ], [\n            BalanceResult\n        ], []),\n        bearer: IDL.Func([\n            EXTTokenIdentifier\n        ], [\n            EXTBearerResult\n        ], [\n            \"query\"\n        ]),\n        bearerEXT: IDL.Func([\n            EXTTokenIdentifier\n        ], [\n            EXTBearerResult\n        ], [\n            \"query\"\n        ]),\n        bearer_batch_nft_origyn: IDL.Func([\n            IDL.Vec(IDL.Text)\n        ], [\n            IDL.Vec(BearerResult)\n        ], [\n            \"query\"\n        ]),\n        bearer_batch_secure_nft_origyn: IDL.Func([\n            IDL.Vec(IDL.Text)\n        ], [\n            IDL.Vec(BearerResult)\n        ], []),\n        bearer_nft_origyn: IDL.Func([\n            IDL.Text\n        ], [\n            BearerResult\n        ], [\n            \"query\"\n        ]),\n        bearer_secure_nft_origyn: IDL.Func([\n            IDL.Text\n        ], [\n            BearerResult\n        ], []),\n        canister_status: IDL.Func([\n            IDL.Record({\n                canister_id: canister_id\n            })\n        ], [\n            canister_status\n        ], []),\n        chunk_nft_origyn: IDL.Func([\n            ChunkRequest\n        ], [\n            ChunkResult\n        ], [\n            \"query\"\n        ]),\n        chunk_secure_nft_origyn: IDL.Func([\n            ChunkRequest\n        ], [\n            ChunkResult\n        ], []),\n        collectCanisterMetrics: IDL.Func([], [], [\n            \"query\"\n        ]),\n        collection_nft_origyn: IDL.Func([\n            IDL.Opt(IDL.Vec(IDL.Tuple(IDL.Text, IDL.Opt(IDL.Nat), IDL.Opt(IDL.Nat))))\n        ], [\n            CollectionResult\n        ], [\n            \"query\"\n        ]),\n        collection_secure_nft_origyn: IDL.Func([\n            IDL.Opt(IDL.Vec(IDL.Tuple(IDL.Text, IDL.Opt(IDL.Nat), IDL.Opt(IDL.Nat))))\n        ], [\n            CollectionResult\n        ], []),\n        collection_update_batch_nft_origyn: IDL.Func([\n            IDL.Vec(ManageCollectionCommand)\n        ], [\n            IDL.Vec(OrigynBoolResult)\n        ], []),\n        collection_update_nft_origyn: IDL.Func([\n            ManageCollectionCommand\n        ], [\n            OrigynBoolResult\n        ], []),\n        count_unlisted_tokens_of: IDL.Func([\n            Account\n        ], [\n            IDL.Nat\n        ], [\n            \"query\"\n        ]),\n        cycles: IDL.Func([], [\n            IDL.Nat\n        ], [\n            \"query\"\n        ]),\n        dip721_balance_of: IDL.Func([\n            IDL.Principal\n        ], [\n            IDL.Nat\n        ], [\n            \"query\"\n        ]),\n        dip721_custodians: IDL.Func([], [\n            IDL.Vec(IDL.Principal)\n        ], [\n            \"query\"\n        ]),\n        dip721_is_approved_for_all: IDL.Func([\n            IDL.Principal,\n            IDL.Principal\n        ], [\n            DIP721BoolResult\n        ], [\n            \"query\"\n        ]),\n        dip721_logo: IDL.Func([], [\n            IDL.Opt(IDL.Text)\n        ], [\n            \"query\"\n        ]),\n        dip721_metadata: IDL.Func([], [\n            DIP721Metadata\n        ], [\n            \"query\"\n        ]),\n        dip721_name: IDL.Func([], [\n            IDL.Opt(IDL.Text)\n        ], [\n            \"query\"\n        ]),\n        dip721_operator_token_identifiers: IDL.Func([\n            IDL.Principal\n        ], [\n            DIP721TokensListMetadata\n        ], [\n            \"query\"\n        ]),\n        dip721_operator_token_metadata: IDL.Func([\n            IDL.Principal\n        ], [\n            DIP721TokensMetadata\n        ], [\n            \"query\"\n        ]),\n        dip721_owner_of: IDL.Func([\n            IDL.Nat\n        ], [\n            OwnerOfResponse\n        ], [\n            \"query\"\n        ]),\n        dip721_owner_token_identifiers: IDL.Func([\n            IDL.Principal\n        ], [\n            DIP721TokensListMetadata\n        ], [\n            \"query\"\n        ]),\n        dip721_owner_token_metadata: IDL.Func([\n            IDL.Principal\n        ], [\n            DIP721TokensMetadata\n        ], [\n            \"query\"\n        ]),\n        dip721_stats: IDL.Func([], [\n            DIP721Stats\n        ], [\n            \"query\"\n        ]),\n        dip721_supported_interfaces: IDL.Func([], [\n            IDL.Vec(DIP721SupportedInterface)\n        ], [\n            \"query\"\n        ]),\n        dip721_symbol: IDL.Func([], [\n            IDL.Opt(IDL.Text)\n        ], [\n            \"query\"\n        ]),\n        dip721_token_metadata: IDL.Func([\n            IDL.Nat\n        ], [\n            DIP721TokenMetadata\n        ], [\n            \"query\"\n        ]),\n        dip721_total_supply: IDL.Func([], [\n            IDL.Nat\n        ], [\n            \"query\"\n        ]),\n        dip721_total_transactions: IDL.Func([], [\n            IDL.Nat\n        ], [\n            \"query\"\n        ]),\n        dip721_transfer: IDL.Func([\n            IDL.Principal,\n            IDL.Nat\n        ], [\n            DIP721NatResult\n        ], []),\n        dip721_transfer_from: IDL.Func([\n            IDL.Principal,\n            IDL.Principal,\n            IDL.Nat\n        ], [\n            DIP721NatResult\n        ], []),\n        getCanisterLog: IDL.Func([\n            IDL.Opt(CanisterLogRequest)\n        ], [\n            IDL.Opt(CanisterLogResponse)\n        ], [\n            \"query\"\n        ]),\n        getCanisterMetrics: IDL.Func([\n            GetMetricsParameters\n        ], [\n            IDL.Opt(CanisterMetrics)\n        ], [\n            \"query\"\n        ]),\n        getEXTTokenIdentifier: IDL.Func([\n            IDL.Text\n        ], [\n            IDL.Text\n        ], [\n            \"query\"\n        ]),\n        get_access_key: IDL.Func([], [\n            OrigynTextResult\n        ], [\n            \"query\"\n        ]),\n        get_halt: IDL.Func([], [\n            IDL.Bool\n        ], [\n            \"query\"\n        ]),\n        get_nat_as_token_id_origyn: IDL.Func([\n            IDL.Nat\n        ], [\n            IDL.Text\n        ], [\n            \"query\"\n        ]),\n        get_tip: IDL.Func([], [\n            Tip\n        ], [\n            \"query\"\n        ]),\n        get_token_id_as_nat: IDL.Func([\n            IDL.Text\n        ], [\n            IDL.Nat\n        ], [\n            \"query\"\n        ]),\n        governance_batch_nft_origyn: IDL.Func([\n            IDL.Vec(GovernanceRequest)\n        ], [\n            IDL.Vec(GovernanceResult)\n        ], []),\n        governance_nft_origyn: IDL.Func([\n            GovernanceRequest\n        ], [\n            GovernanceResult\n        ], []),\n        history_batch_nft_origyn: IDL.Func([\n            IDL.Vec(IDL.Tuple(IDL.Text, IDL.Opt(IDL.Nat), IDL.Opt(IDL.Nat)))\n        ], [\n            IDL.Vec(HistoryResult)\n        ], [\n            \"query\"\n        ]),\n        history_batch_secure_nft_origyn: IDL.Func([\n            IDL.Vec(IDL.Tuple(IDL.Text, IDL.Opt(IDL.Nat), IDL.Opt(IDL.Nat)))\n        ], [\n            IDL.Vec(HistoryResult)\n        ], []),\n        history_nft_origyn: IDL.Func([\n            IDL.Text,\n            IDL.Opt(IDL.Nat),\n            IDL.Opt(IDL.Nat)\n        ], [\n            HistoryResult\n        ], [\n            \"query\"\n        ]),\n        history_secure_nft_origyn: IDL.Func([\n            IDL.Text,\n            IDL.Opt(IDL.Nat),\n            IDL.Opt(IDL.Nat)\n        ], [\n            HistoryResult\n        ], []),\n        http_access_key: IDL.Func([], [\n            OrigynTextResult\n        ], []),\n        http_request: IDL.Func([\n            HttpRequest\n        ], [\n            HTTPResponse\n        ], [\n            \"query\"\n        ]),\n        http_request_streaming_callback: IDL.Func([\n            StreamingCallbackToken\n        ], [\n            StreamingCallbackResponse\n        ], [\n            \"query\"\n        ]),\n        icrc3_get_archives: IDL.Func([\n            GetArchivesArgs\n        ], [\n            GetArchivesResult\n        ], [\n            \"query\"\n        ]),\n        icrc3_get_blocks: IDL.Func([\n            IDL.Vec(TransactionRange)\n        ], [\n            GetTransactionsResult\n        ], [\n            \"query\"\n        ]),\n        icrc3_get_tip_certificate: IDL.Func([], [\n            IDL.Opt(DataCertificate)\n        ], [\n            \"query\"\n        ]),\n        icrc3_supported_block_types: IDL.Func([], [\n            IDL.Vec(BlockType)\n        ], [\n            \"query\"\n        ]),\n        icrc7_approve: IDL.Func([\n            ApprovalArgs\n        ], [\n            ApprovalResult\n        ], []),\n        icrc7_atomic_batch_transfers: IDL.Func([], [\n            IDL.Opt(IDL.Bool)\n        ], [\n            \"query\"\n        ]),\n        icrc7_balance_of: IDL.Func([\n            IDL.Vec(Account)\n        ], [\n            IDL.Vec(IDL.Nat)\n        ], [\n            \"query\"\n        ]),\n        icrc7_collection_metadata: IDL.Func([], [\n            CollectionMetadata\n        ], [\n            \"query\"\n        ]),\n        icrc7_default_take_value: IDL.Func([], [\n            IDL.Opt(IDL.Nat)\n        ], [\n            \"query\"\n        ]),\n        icrc7_description: IDL.Func([], [\n            IDL.Opt(IDL.Text)\n        ], [\n            \"query\"\n        ]),\n        icrc7_logo: IDL.Func([], [\n            IDL.Opt(IDL.Text)\n        ], [\n            \"query\"\n        ]),\n        icrc7_max_approvals_per_token_or_collection: IDL.Func([], [\n            IDL.Opt(IDL.Nat)\n        ], [\n            \"query\"\n        ]),\n        icrc7_max_memo_size: IDL.Func([], [\n            IDL.Opt(IDL.Nat)\n        ], [\n            \"query\"\n        ]),\n        icrc7_max_query_batch_size: IDL.Func([], [\n            IDL.Opt(IDL.Nat)\n        ], [\n            \"query\"\n        ]),\n        icrc7_max_revoke_approvals: IDL.Func([], [\n            IDL.Opt(IDL.Nat)\n        ], [\n            \"query\"\n        ]),\n        icrc7_max_take_value: IDL.Func([], [\n            IDL.Opt(IDL.Nat)\n        ], [\n            \"query\"\n        ]),\n        icrc7_max_update_batch_size: IDL.Func([], [\n            IDL.Opt(IDL.Nat)\n        ], [\n            \"query\"\n        ]),\n        icrc7_name: IDL.Func([], [\n            IDL.Text\n        ], [\n            \"query\"\n        ]),\n        icrc7_owner_of: IDL.Func([\n            IDL.Vec(IDL.Nat)\n        ], [\n            IDL.Vec(IDL.Opt(Account))\n        ], [\n            \"query\"\n        ]),\n        icrc7_permitted_drift: IDL.Func([], [\n            IDL.Opt(IDL.Nat)\n        ], [\n            \"query\"\n        ]),\n        icrc7_supply_cap: IDL.Func([], [\n            IDL.Opt(IDL.Nat)\n        ], [\n            \"query\"\n        ]),\n        icrc7_supported_standards: IDL.Func([], [\n            IDL.Vec(SupportedStandard)\n        ], [\n            \"query\"\n        ]),\n        icrc7_symbol: IDL.Func([], [\n            IDL.Text\n        ], [\n            \"query\"\n        ]),\n        icrc7_token_metadata: IDL.Func([\n            IDL.Vec(IDL.Nat)\n        ], [\n            IDL.Vec(IDL.Opt(IDL.Vec(IDL.Tuple(IDL.Text, Value))))\n        ], [\n            \"query\"\n        ]),\n        icrc7_tokens: IDL.Func([\n            IDL.Opt(IDL.Nat),\n            IDL.Opt(IDL.Nat32)\n        ], [\n            IDL.Vec(IDL.Nat)\n        ], [\n            \"query\"\n        ]),\n        icrc7_tokens_of: IDL.Func([\n            Account,\n            IDL.Opt(IDL.Nat),\n            IDL.Opt(IDL.Nat32)\n        ], [\n            IDL.Vec(IDL.Nat)\n        ], [\n            \"query\"\n        ]),\n        icrc7_total_supply: IDL.Func([], [\n            IDL.Nat\n        ], [\n            \"query\"\n        ]),\n        icrc7_transfer: IDL.Func([\n            IDL.Vec(TransferArgs)\n        ], [\n            TransferResult\n        ], []),\n        icrc7_transfer_fee: IDL.Func([\n            IDL.Nat\n        ], [\n            IDL.Opt(IDL.Nat)\n        ], [\n            \"query\"\n        ]),\n        icrc7_tx_window: IDL.Func([], [\n            IDL.Opt(IDL.Nat)\n        ], [\n            \"query\"\n        ]),\n        manage_storage_nft_origyn: IDL.Func([\n            ManageStorageRequest\n        ], [\n            ManageStorageResult\n        ], []),\n        market_transfer_batch_nft_origyn: IDL.Func([\n            IDL.Vec(MarketTransferRequest)\n        ], [\n            IDL.Vec(MarketTransferResult)\n        ], []),\n        market_transfer_nft_origyn: IDL.Func([\n            MarketTransferRequest\n        ], [\n            MarketTransferResult\n        ], []),\n        metadata: IDL.Func([], [\n            DIP721Metadata\n        ], [\n            \"query\"\n        ]),\n        metadataExt: IDL.Func([\n            EXTTokenIdentifier\n        ], [\n            EXTMetadataResult\n        ], [\n            \"query\"\n        ]),\n        mint_batch_nft_origyn: IDL.Func([\n            IDL.Vec(IDL.Tuple(IDL.Text, Account__1))\n        ], [\n            IDL.Vec(OrigynTextResult)\n        ], []),\n        mint_nft_origyn: IDL.Func([\n            IDL.Text,\n            Account__1\n        ], [\n            OrigynTextResult\n        ], []),\n        nftStreamingCallback: IDL.Func([\n            StreamingCallbackToken\n        ], [\n            StreamingCallbackResponse\n        ], [\n            \"query\"\n        ]),\n        nft_batch_origyn: IDL.Func([\n            IDL.Vec(IDL.Text)\n        ], [\n            IDL.Vec(NFTInfoResult)\n        ], [\n            \"query\"\n        ]),\n        nft_batch_secure_origyn: IDL.Func([\n            IDL.Vec(IDL.Text)\n        ], [\n            IDL.Vec(NFTInfoResult)\n        ], []),\n        nft_origyn: IDL.Func([\n            IDL.Text\n        ], [\n            NFTInfoResult\n        ], [\n            \"query\"\n        ]),\n        nft_secure_origyn: IDL.Func([\n            IDL.Text\n        ], [\n            NFTInfoResult\n        ], []),\n        operaterTokenMetadata: IDL.Func([\n            IDL.Principal\n        ], [\n            DIP721TokensMetadata\n        ], [\n            \"query\"\n        ]),\n        ownerOf: IDL.Func([\n            IDL.Nat\n        ], [\n            OwnerOfResponse\n        ], [\n            \"query\"\n        ]),\n        ownerTokenMetadata: IDL.Func([\n            IDL.Principal\n        ], [\n            DIP721TokensMetadata\n        ], [\n            \"query\"\n        ]),\n        sale_batch_nft_origyn: IDL.Func([\n            IDL.Vec(ManageSaleRequest)\n        ], [\n            IDL.Vec(ManageSaleResult)\n        ], []),\n        sale_info_batch_nft_origyn: IDL.Func([\n            IDL.Vec(SaleInfoRequest)\n        ], [\n            IDL.Vec(SaleInfoResult)\n        ], [\n            \"query\"\n        ]),\n        sale_info_batch_secure_nft_origyn: IDL.Func([\n            IDL.Vec(SaleInfoRequest)\n        ], [\n            IDL.Vec(SaleInfoResult)\n        ], []),\n        sale_info_nft_origyn: IDL.Func([\n            SaleInfoRequest\n        ], [\n            SaleInfoResult\n        ], [\n            \"query\"\n        ]),\n        sale_info_secure_nft_origyn: IDL.Func([\n            SaleInfoRequest\n        ], [\n            SaleInfoResult\n        ], []),\n        sale_nft_origyn: IDL.Func([\n            ManageSaleRequest\n        ], [\n            ManageSaleResult\n        ], []),\n        set_data_harvester: IDL.Func([\n            IDL.Nat\n        ], [], []),\n        set_halt: IDL.Func([\n            IDL.Bool\n        ], [], []),\n        share_wallet_nft_origyn: IDL.Func([\n            ShareWalletRequest\n        ], [\n            OwnerUpdateResult\n        ], []),\n        stage_batch_nft_origyn: IDL.Func([\n            IDL.Vec(IDL.Record({\n                metadata: CandyShared\n            }))\n        ], [\n            IDL.Vec(OrigynTextResult)\n        ], []),\n        stage_library_batch_nft_origyn: IDL.Func([\n            IDL.Vec(StageChunkArg)\n        ], [\n            IDL.Vec(StageLibraryResult)\n        ], []),\n        stage_library_nft_origyn: IDL.Func([\n            StageChunkArg\n        ], [\n            StageLibraryResult\n        ], []),\n        stage_nft_origyn: IDL.Func([\n            IDL.Record({\n                metadata: CandyShared\n            })\n        ], [\n            OrigynTextResult\n        ], []),\n        state_size: IDL.Func([], [\n            StateSize\n        ], [\n            \"query\"\n        ]),\n        storage_info_nft_origyn: IDL.Func([], [\n            StorageMetricsResult\n        ], [\n            \"query\"\n        ]),\n        storage_info_secure_nft_origyn: IDL.Func([], [\n            StorageMetricsResult\n        ], []),\n        tokens_ext: IDL.Func([\n            IDL.Text\n        ], [\n            EXTTokensResult\n        ], [\n            \"query\"\n        ]),\n        transfer: IDL.Func([\n            EXTTransferRequest\n        ], [\n            EXTTransferResponse\n        ], []),\n        transferDip721: IDL.Func([\n            IDL.Principal,\n            IDL.Nat\n        ], [\n            DIP721NatResult\n        ], []),\n        transferEXT: IDL.Func([\n            EXTTransferRequest\n        ], [\n            EXTTransferResponse\n        ], []),\n        transferFrom: IDL.Func([\n            IDL.Principal,\n            IDL.Principal,\n            IDL.Nat\n        ], [\n            DIP721NatResult\n        ], []),\n        transferFromDip721: IDL.Func([\n            IDL.Principal,\n            IDL.Principal,\n            IDL.Nat\n        ], [\n            DIP721NatResult\n        ], []),\n        unlisted_tokens_of: IDL.Func([\n            Account,\n            IDL.Opt(IDL.Nat),\n            IDL.Opt(IDL.Nat32)\n        ], [\n            IDL.Vec(IDL.Nat)\n        ], [\n            \"query\"\n        ]),\n        update_app_nft_origyn: IDL.Func([\n            NFTUpdateRequest\n        ], [\n            NFTUpdateResult\n        ], []),\n        update_icrc3: IDL.Func([\n            IDL.Vec(UpdateSetting)\n        ], [\n            IDL.Vec(IDL.Bool)\n        ], []),\n        update_metadata_node: IDL.Func([\n            NFTUpdateMetadataNode\n        ], [\n            NFTUpdateAppResult\n        ], []),\n        wallet_receive: IDL.Func([], [\n            IDL.Nat\n        ], []),\n        whoami: IDL.Func([], [\n            IDL.Principal\n        ], [\n            \"query\"\n        ])\n    });\n};\nconst init = (param)=>{\n    let { IDL } = param;\n    return [];\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9kYXRhL2NhbmlzdGVycy9nb2xkL2RpZC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFPLE1BQU1BLGFBQWE7UUFBQyxFQUFFQyxHQUFHLEVBQUU7SUFDaEMsTUFBTUMsOEJBQThCRCxJQUFJRSxHQUFHO0lBQzNDLE1BQU1DLGNBQWNILElBQUlFLEdBQUc7SUFDM0IsTUFBTUUscUJBQXFCSixJQUFJRSxHQUFHO0lBQ2xDLE1BQU1HLGVBQWVMLElBQUlFLEdBQUc7SUFDNUIsTUFBTUksUUFBUU4sSUFBSUUsR0FBRztJQUNyQixNQUFNSyxXQUFXUCxJQUFJRSxHQUFHO0lBQ3hCLE1BQU1NLE1BQU1SLElBQUlFLEdBQUc7SUFDbkIsTUFBTU8saUJBQWlCVCxJQUFJVSxNQUFNLENBQUM7UUFDaENDLE9BQU9SO1FBQ1BTLE1BQU1aLElBQUlhLElBQUk7UUFDZEMsV0FBV2QsSUFBSWUsSUFBSTtJQUNyQjtJQUNBWixZQUFZYSxJQUFJLENBQ2RoQixJQUFJaUIsT0FBTyxDQUFDO1FBQ1ZDLEtBQUtsQixJQUFJa0IsR0FBRztRQUNaQyxLQUFLbkIsSUFBSVEsR0FBRyxDQUFDUixJQUFJb0IsS0FBSyxDQUFDakIsYUFBYUE7UUFDcENrQixLQUFLckIsSUFBSXFCLEdBQUc7UUFDWkMsS0FBS3RCLElBQUlRLEdBQUcsQ0FBQ0w7UUFDYm9CLE9BQU92QixJQUFJdUIsS0FBSztRQUNoQkMsT0FBT3hCLElBQUl3QixLQUFLO1FBQ2hCQyxPQUFPekIsSUFBSXlCLEtBQUs7UUFDaEJDLE1BQU0xQixJQUFJUSxHQUFHLENBQUNSLElBQUkyQixJQUFJO1FBQ3RCWixNQUFNZixJQUFJZSxJQUFJO1FBQ2RhLE1BQU01QixJQUFJNEIsSUFBSTtRQUNkQyxNQUFNN0IsSUFBSVEsR0FBRyxDQUFDUixJQUFJa0IsR0FBRztRQUNyQlMsTUFBTTNCLElBQUkyQixJQUFJO1FBQ2RHLE1BQU05QixJQUFJUSxHQUFHLENBQUNSLElBQUlxQixHQUFHO1FBQ3JC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QUkrZCxJQUFJLENBQUMsRUFBRSxFQUFFO1lBQUMvZCxJQUFJd0MsU0FBUztTQUFDLEVBQUU7WUFBQztTQUFRO0lBQ2pEO0FBQ0YsRUFBRTtBQUNLLE1BQU13dkIsT0FBTztRQUFDLEVBQUVoeUIsR0FBRyxFQUFFO0lBQzFCLE9BQU8sRUFBRTtBQUNYLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2RhdGEvY2FuaXN0ZXJzL2dvbGQvZGlkLmpzPzRiOTQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IGlkbEZhY3RvcnkgPSAoeyBJREwgfSkgPT4ge1xyXG4gIGNvbnN0IEFyY2hpdmVkVHJhbnNhY3Rpb25SZXNwb25zZSA9IElETC5SZWMoKTtcclxuICBjb25zdCBDYW5keVNoYXJlZCA9IElETC5SZWMoKTtcclxuICBjb25zdCBNYW5hZ2VTYWxlUmVzcG9uc2UgPSBJREwuUmVjKCk7XHJcbiAgY29uc3QgVXBkYXRlU2hhcmVkID0gSURMLlJlYygpO1xyXG4gIGNvbnN0IFZhbHVlID0gSURMLlJlYygpO1xyXG4gIGNvbnN0IFZhbHVlX18xID0gSURMLlJlYygpO1xyXG4gIGNvbnN0IFZlYyA9IElETC5SZWMoKTtcclxuICBjb25zdCBQcm9wZXJ0eVNoYXJlZCA9IElETC5SZWNvcmQoe1xyXG4gICAgdmFsdWU6IENhbmR5U2hhcmVkLFxyXG4gICAgbmFtZTogSURMLlRleHQsXHJcbiAgICBpbW11dGFibGU6IElETC5Cb29sLFxyXG4gIH0pO1xyXG4gIENhbmR5U2hhcmVkLmZpbGwoXHJcbiAgICBJREwuVmFyaWFudCh7XHJcbiAgICAgIEludDogSURMLkludCxcclxuICAgICAgTWFwOiBJREwuVmVjKElETC5UdXBsZShDYW5keVNoYXJlZCwgQ2FuZHlTaGFyZWQpKSxcclxuICAgICAgTmF0OiBJREwuTmF0LFxyXG4gICAgICBTZXQ6IElETC5WZWMoQ2FuZHlTaGFyZWQpLFxyXG4gICAgICBOYXQxNjogSURMLk5hdDE2LFxyXG4gICAgICBOYXQzMjogSURMLk5hdDMyLFxyXG4gICAgICBOYXQ2NDogSURMLk5hdDY0LFxyXG4gICAgICBCbG9iOiBJREwuVmVjKElETC5OYXQ4KSxcclxuICAgICAgQm9vbDogSURMLkJvb2wsXHJcbiAgICAgIEludDg6IElETC5JbnQ4LFxyXG4gICAgICBJbnRzOiBJREwuVmVjKElETC5JbnQpLFxyXG4gICAgICBOYXQ4OiBJREwuTmF0OCxcclxuICAgICAgTmF0czogSURMLlZlYyhJREwuTmF0KSxcclxuICAgICAgVGV4dDogSURMLlRleHQsXHJcbiAgICAgIEJ5dGVzOiBJREwuVmVjKElETC5OYXQ4KSxcclxuICAgICAgSW50MTY6IElETC5JbnQxNixcclxuICAgICAgSW50MzI6IElETC5JbnQzMixcclxuICAgICAgSW50NjQ6IElETC5JbnQ2NCxcclxuICAgICAgT3B0aW9uOiBJREwuT3B0KENhbmR5U2hhcmVkKSxcclxuICAgICAgRmxvYXRzOiBJREwuVmVjKElETC5GbG9hdDY0KSxcclxuICAgICAgRmxvYXQ6IElETC5GbG9hdDY0LFxyXG4gICAgICBQcmluY2lwYWw6IElETC5QcmluY2lwYWwsXHJcbiAgICAgIEFycmF5OiBJREwuVmVjKENhbmR5U2hhcmVkKSxcclxuICAgICAgQ2xhc3M6IElETC5WZWMoUHJvcGVydHlTaGFyZWQpLFxyXG4gICAgfSlcclxuICApO1xyXG4gIGNvbnN0IEFjY291bnRfXzEgPSBJREwuVmFyaWFudCh7XHJcbiAgICBhY2NvdW50X2lkOiBJREwuVGV4dCxcclxuICAgIHByaW5jaXBhbDogSURMLlByaW5jaXBhbCxcclxuICAgIGV4dGVuc2libGU6IENhbmR5U2hhcmVkLFxyXG4gICAgYWNjb3VudDogSURMLlJlY29yZCh7XHJcbiAgICAgIG93bmVyOiBJREwuUHJpbmNpcGFsLFxyXG4gICAgICBzdWJfYWNjb3VudDogSURMLk9wdChJREwuVmVjKElETC5OYXQ4KSksXHJcbiAgICB9KSxcclxuICB9KTtcclxuICBjb25zdCBJQ1Rva2VuU3BlY19fMSA9IElETC5SZWNvcmQoe1xyXG4gICAgaWQ6IElETC5PcHQoSURMLk5hdCksXHJcbiAgICBmZWU6IElETC5PcHQoSURMLk5hdCksXHJcbiAgICBkZWNpbWFsczogSURMLk5hdCxcclxuICAgIGNhbmlzdGVyOiBJREwuUHJpbmNpcGFsLFxyXG4gICAgc3RhbmRhcmQ6IElETC5WYXJpYW50KHtcclxuICAgICAgSUNSQzE6IElETC5OdWxsLFxyXG4gICAgICBFWFRGdW5naWJsZTogSURMLk51bGwsXHJcbiAgICAgIERJUDIwOiBJREwuTnVsbCxcclxuICAgICAgT3RoZXI6IENhbmR5U2hhcmVkLFxyXG4gICAgICBMZWRnZXI6IElETC5OdWxsLFxyXG4gICAgfSksXHJcbiAgICBzeW1ib2w6IElETC5UZXh0LFxyXG4gIH0pO1xyXG4gIGNvbnN0IFRva2VuU3BlY19fMSA9IElETC5WYXJpYW50KHtcclxuICAgIGljOiBJQ1Rva2VuU3BlY19fMSxcclxuICAgIGV4dGVuc2libGU6IENhbmR5U2hhcmVkLFxyXG4gIH0pO1xyXG4gIGNvbnN0IEVzY3Jvd1JlY29yZF9fMSA9IElETC5SZWNvcmQoe1xyXG4gICAgdG9rZW46IFRva2VuU3BlY19fMSxcclxuICAgIHRva2VuX2lkOiBJREwuVGV4dCxcclxuICAgIHNlbGxlcjogQWNjb3VudF9fMSxcclxuICAgIGxvY2tfdG9fZGF0ZTogSURMLk9wdChJREwuSW50KSxcclxuICAgIGJ1eWVyOiBBY2NvdW50X18xLFxyXG4gICAgYW1vdW50OiBJREwuTmF0LFxyXG4gICAgc2FsZV9pZDogSURMLk9wdChJREwuVGV4dCksXHJcbiAgICBhY2NvdW50X2hhc2g6IElETC5PcHQoSURMLlZlYyhJREwuTmF0OCkpLFxyXG4gIH0pO1xyXG4gIGNvbnN0IFN0YWJsZVNhbGVzQmFsYW5jZXMgPSBJREwuVmVjKFxyXG4gICAgSURMLlR1cGxlKEFjY291bnRfXzEsIEFjY291bnRfXzEsIElETC5UZXh0LCBFc2Nyb3dSZWNvcmRfXzEpXHJcbiAgKTtcclxuICBjb25zdCBTdGFibGVPZmZlcnMgPSBJREwuVmVjKElETC5UdXBsZShBY2NvdW50X18xLCBBY2NvdW50X18xLCBJREwuSW50KSk7XHJcbiAgY29uc3QgU3RhYmxlQ29sbGVjdGlvbkRhdGEgPSBJREwuUmVjb3JkKHtcclxuICAgIGFjdGl2ZV9idWNrZXQ6IElETC5PcHQoSURMLlByaW5jaXBhbCksXHJcbiAgICBtYW5hZ2VyczogSURMLlZlYyhJREwuUHJpbmNpcGFsKSxcclxuICAgIG93bmVyOiBJREwuUHJpbmNpcGFsLFxyXG4gICAgbWV0YWRhdGE6IElETC5PcHQoQ2FuZHlTaGFyZWQpLFxyXG4gICAgbG9nbzogSURMLk9wdChJREwuVGV4dCksXHJcbiAgICBuYW1lOiBJREwuT3B0KElETC5UZXh0KSxcclxuICAgIG5ldHdvcms6IElETC5PcHQoSURMLlByaW5jaXBhbCksXHJcbiAgICBhdmFpbGFibGVfc3BhY2U6IElETC5OYXQsXHJcbiAgICBzeW1ib2w6IElETC5PcHQoSURMLlRleHQpLFxyXG4gICAgYWxsb2NhdGVkX3N0b3JhZ2U6IElETC5OYXQsXHJcbiAgfSk7XHJcbiAgY29uc3QgSUNUb2tlblNwZWMgPSBJREwuUmVjb3JkKHtcclxuICAgIGlkOiBJREwuT3B0KElETC5OYXQpLFxyXG4gICAgZmVlOiBJREwuT3B0KElETC5OYXQpLFxyXG4gICAgZGVjaW1hbHM6IElETC5OYXQsXHJcbiAgICBjYW5pc3RlcjogSURMLlByaW5jaXBhbCxcclxuICAgIHN0YW5kYXJkOiBJREwuVmFyaWFudCh7XHJcbiAgICAgIElDUkMxOiBJREwuTnVsbCxcclxuICAgICAgRVhURnVuZ2libGU6IElETC5OdWxsLFxyXG4gICAgICBESVAyMDogSURMLk51bGwsXHJcbiAgICAgIE90aGVyOiBDYW5keVNoYXJlZCxcclxuICAgICAgTGVkZ2VyOiBJREwuTnVsbCxcclxuICAgIH0pLFxyXG4gICAgc3ltYm9sOiBJREwuVGV4dCxcclxuICB9KTtcclxuICBjb25zdCBUb2tlblNwZWMgPSBJREwuVmFyaWFudCh7XHJcbiAgICBpYzogSUNUb2tlblNwZWMsXHJcbiAgICBleHRlbnNpYmxlOiBDYW5keVNoYXJlZCxcclxuICB9KTtcclxuICBjb25zdCBUcmFuc2FjdGlvbklEID0gSURMLlZhcmlhbnQoe1xyXG4gICAgbmF0OiBJREwuTmF0LFxyXG4gICAgdGV4dDogSURMLlRleHQsXHJcbiAgICBleHRlbnNpYmxlOiBDYW5keVNoYXJlZCxcclxuICB9KTtcclxuICBjb25zdCBBY2NvdW50X18yID0gSURMLlZhcmlhbnQoe1xyXG4gICAgYWNjb3VudF9pZDogSURMLlRleHQsXHJcbiAgICBwcmluY2lwYWw6IElETC5QcmluY2lwYWwsXHJcbiAgICBleHRlbnNpYmxlOiBDYW5keVNoYXJlZCxcclxuICAgIGFjY291bnQ6IElETC5SZWNvcmQoe1xyXG4gICAgICBvd25lcjogSURMLlByaW5jaXBhbCxcclxuICAgICAgc3ViX2FjY291bnQ6IElETC5PcHQoSURMLlZlYyhJREwuTmF0OCkpLFxyXG4gICAgfSksXHJcbiAgfSk7XHJcbiAgY29uc3QgV2FpdEZvclF1aWV0VHlwZSA9IElETC5SZWNvcmQoe1xyXG4gICAgbWF4OiBJREwuTmF0LFxyXG4gICAgZmFkZTogSURMLkZsb2F0NjQsXHJcbiAgICBleHRlbnNpb246IElETC5OYXQ2NCxcclxuICB9KTtcclxuICBjb25zdCBNaW5JbmNyZWFzZVR5cGUgPSBJREwuVmFyaWFudCh7XHJcbiAgICBhbW91bnQ6IElETC5OYXQsXHJcbiAgICBwZXJjZW50YWdlOiBJREwuRmxvYXQ2NCxcclxuICB9KTtcclxuICBjb25zdCBGZWVOYW1lID0gSURMLlRleHQ7XHJcbiAgY29uc3QgRmVlQWNjb3VudHNQYXJhbXMgPSBJREwuVmVjKEZlZU5hbWUpO1xyXG4gIGNvbnN0IE5pZnR5U2V0dGxlbWVudFR5cGUgPSBJREwuUmVjb3JkKHtcclxuICAgIGZpeGVkOiBJREwuQm9vbCxcclxuICAgIGludGVyZXN0UmF0ZVBlclNlY29uZDogSURMLkZsb2F0NjQsXHJcbiAgICBkdXJhdGlvbjogSURMLk9wdChJREwuSW50KSxcclxuICAgIGV4cGlyYXRpb246IElETC5PcHQoSURMLkludCksXHJcbiAgICBsZW5kZXJPZmZlcjogSURMLkJvb2wsXHJcbiAgfSk7XHJcbiAgY29uc3QgRHV0Y2hQYXJhbXMgPSBJREwuUmVjb3JkKHtcclxuICAgIHRpbWVfdW5pdDogSURMLlZhcmlhbnQoe1xyXG4gICAgICBkYXk6IElETC5OYXQsXHJcbiAgICAgIGhvdXI6IElETC5OYXQsXHJcbiAgICAgIG1pbnV0ZTogSURMLk5hdCxcclxuICAgIH0pLFxyXG4gICAgZGVjYXlfdHlwZTogSURMLlZhcmlhbnQoeyBmbGF0OiBJREwuTmF0LCBwZXJjZW50OiBJREwuRmxvYXQ2NCB9KSxcclxuICB9KTtcclxuICBjb25zdCBFbmRpbmdUeXBlID0gSURMLlZhcmlhbnQoeyBkYXRlOiBJREwuSW50LCB0aW1lb3V0OiBJREwuTmF0IH0pO1xyXG4gIGNvbnN0IEFza0ZlYXR1cmUgPSBJREwuVmFyaWFudCh7XHJcbiAgICBreWM6IElETC5QcmluY2lwYWwsXHJcbiAgICBzdGFydF9wcmljZTogSURMLk5hdCxcclxuICAgIHRva2VuOiBUb2tlblNwZWMsXHJcbiAgICBmZWVfc2NoZW1hOiBJREwuVGV4dCxcclxuICAgIG5vdGlmeTogSURMLlZlYyhJREwuUHJpbmNpcGFsKSxcclxuICAgIHdhaXRfZm9yX3F1aWV0OiBXYWl0Rm9yUXVpZXRUeXBlLFxyXG4gICAgcmVzZXJ2ZTogSURMLk5hdCxcclxuICAgIHN0YXJ0X2RhdGU6IElETC5JbnQsXHJcbiAgICBtaW5faW5jcmVhc2U6IE1pbkluY3JlYXNlVHlwZSxcclxuICAgIGFsbG93X2xpc3Q6IElETC5WZWMoSURMLlByaW5jaXBhbCksXHJcbiAgICBidXlfbm93OiBJREwuTmF0LFxyXG4gICAgZmVlX2FjY291bnRzOiBGZWVBY2NvdW50c1BhcmFtcyxcclxuICAgIG5pZnR5X3NldHRsZW1lbnQ6IE5pZnR5U2V0dGxlbWVudFR5cGUsXHJcbiAgICBhdG9taWM6IElETC5OdWxsLFxyXG4gICAgZHV0Y2g6IER1dGNoUGFyYW1zLFxyXG4gICAgZW5kaW5nOiBFbmRpbmdUeXBlLFxyXG4gIH0pO1xyXG4gIGNvbnN0IEFza0ZlYXR1cmVBcnJheSA9IElETC5WZWMoQXNrRmVhdHVyZSk7XHJcbiAgY29uc3QgQXNrQ29uZmlnU2hhcmVkID0gSURMLk9wdChBc2tGZWF0dXJlQXJyYXkpO1xyXG4gIGNvbnN0IEluc3RhbnRGZWF0dXJlID0gSURMLlZhcmlhbnQoe1xyXG4gICAgZmVlX3NjaGVtYTogSURMLlRleHQsXHJcbiAgICBmZWVfYWNjb3VudHM6IEZlZUFjY291bnRzUGFyYW1zLFxyXG4gICAgdHJhbnNmZXI6IElETC5OdWxsLFxyXG4gIH0pO1xyXG4gIGNvbnN0IEluc3RhbnRDb25maWdTaGFyZWQgPSBJREwuT3B0KElETC5WZWMoSW5zdGFudEZlYXR1cmUpKTtcclxuICBjb25zdCBBdWN0aW9uQ29uZmlnID0gSURMLlJlY29yZCh7XHJcbiAgICBzdGFydF9wcmljZTogSURMLk5hdCxcclxuICAgIHRva2VuOiBUb2tlblNwZWMsXHJcbiAgICByZXNlcnZlOiBJREwuT3B0KElETC5OYXQpLFxyXG4gICAgc3RhcnRfZGF0ZTogSURMLkludCxcclxuICAgIG1pbl9pbmNyZWFzZTogTWluSW5jcmVhc2VUeXBlLFxyXG4gICAgYWxsb3dfbGlzdDogSURMLk9wdChJREwuVmVjKElETC5QcmluY2lwYWwpKSxcclxuICAgIGJ1eV9ub3c6IElETC5PcHQoSURMLk5hdCksXHJcbiAgICBlbmRpbmc6IElETC5WYXJpYW50KHtcclxuICAgICAgZGF0ZTogSURMLkludCxcclxuICAgICAgd2FpdF9mb3JfcXVpZXQ6IElETC5SZWNvcmQoe1xyXG4gICAgICAgIG1heDogSURMLk5hdCxcclxuICAgICAgICBkYXRlOiBJREwuSW50LFxyXG4gICAgICAgIGZhZGU6IElETC5GbG9hdDY0LFxyXG4gICAgICAgIGV4dGVuc2lvbjogSURMLk5hdDY0LFxyXG4gICAgICB9KSxcclxuICAgIH0pLFxyXG4gIH0pO1xyXG4gIGNvbnN0IFByaWNpbmdDb25maWdTaGFyZWQgPSBJREwuVmFyaWFudCh7XHJcbiAgICBhc2s6IEFza0NvbmZpZ1NoYXJlZCxcclxuICAgIGV4dGVuc2libGU6IENhbmR5U2hhcmVkLFxyXG4gICAgaW5zdGFudDogSW5zdGFudENvbmZpZ1NoYXJlZCxcclxuICAgIGF1Y3Rpb246IEF1Y3Rpb25Db25maWcsXHJcbiAgfSk7XHJcbiAgY29uc3QgVHJhbnNhY3Rpb25SZWNvcmQgPSBJREwuUmVjb3JkKHtcclxuICAgIHRva2VuX2lkOiBJREwuVGV4dCxcclxuICAgIHR4bl90eXBlOiBJREwuVmFyaWFudCh7XHJcbiAgICAgIGVzY3Jvd19kZXBvc2l0OiBJREwuUmVjb3JkKHtcclxuICAgICAgICB0b2tlbjogVG9rZW5TcGVjLFxyXG4gICAgICAgIHRva2VuX2lkOiBJREwuVGV4dCxcclxuICAgICAgICB0cnhfaWQ6IFRyYW5zYWN0aW9uSUQsXHJcbiAgICAgICAgc2VsbGVyOiBBY2NvdW50X18yLFxyXG4gICAgICAgIGV4dGVuc2libGU6IENhbmR5U2hhcmVkLFxyXG4gICAgICAgIGJ1eWVyOiBBY2NvdW50X18yLFxyXG4gICAgICAgIGFtb3VudDogSURMLk5hdCxcclxuICAgICAgfSksXHJcbiAgICAgIGZlZV9kZXBvc2l0OiBJREwuUmVjb3JkKHtcclxuICAgICAgICB0b2tlbjogVG9rZW5TcGVjLFxyXG4gICAgICAgIGV4dGVuc2libGU6IENhbmR5U2hhcmVkLFxyXG4gICAgICAgIGFjY291bnQ6IEFjY291bnRfXzIsXHJcbiAgICAgICAgYW1vdW50OiBJREwuTmF0LFxyXG4gICAgICB9KSxcclxuICAgICAgY2FuaXN0ZXJfbmV0d29ya191cGRhdGVkOiBJREwuUmVjb3JkKHtcclxuICAgICAgICBuZXR3b3JrOiBJREwuUHJpbmNpcGFsLFxyXG4gICAgICAgIGV4dGVuc2libGU6IENhbmR5U2hhcmVkLFxyXG4gICAgICB9KSxcclxuICAgICAgZXNjcm93X3dpdGhkcmF3OiBJREwuUmVjb3JkKHtcclxuICAgICAgICBmZWU6IElETC5OYXQsXHJcbiAgICAgICAgdG9rZW46IFRva2VuU3BlYyxcclxuICAgICAgICB0b2tlbl9pZDogSURMLlRleHQsXHJcbiAgICAgICAgdHJ4X2lkOiBUcmFuc2FjdGlvbklELFxyXG4gICAgICAgIHNlbGxlcjogQWNjb3VudF9fMixcclxuICAgICAgICBleHRlbnNpYmxlOiBDYW5keVNoYXJlZCxcclxuICAgICAgICBidXllcjogQWNjb3VudF9fMixcclxuICAgICAgICBhbW91bnQ6IElETC5OYXQsXHJcbiAgICAgIH0pLFxyXG4gICAgICBjYW5pc3Rlcl9tYW5hZ2Vyc191cGRhdGVkOiBJREwuUmVjb3JkKHtcclxuICAgICAgICBtYW5hZ2VyczogSURMLlZlYyhJREwuUHJpbmNpcGFsKSxcclxuICAgICAgICBleHRlbnNpYmxlOiBDYW5keVNoYXJlZCxcclxuICAgICAgfSksXHJcbiAgICAgIGF1Y3Rpb25fYmlkOiBJREwuUmVjb3JkKHtcclxuICAgICAgICB0b2tlbjogVG9rZW5TcGVjLFxyXG4gICAgICAgIGV4dGVuc2libGU6IENhbmR5U2hhcmVkLFxyXG4gICAgICAgIGJ1eWVyOiBBY2NvdW50X18yLFxyXG4gICAgICAgIGFtb3VudDogSURMLk5hdCxcclxuICAgICAgICBzYWxlX2lkOiBJREwuVGV4dCxcclxuICAgICAgfSksXHJcbiAgICAgIGJ1cm46IElETC5SZWNvcmQoe1xyXG4gICAgICAgIGZyb206IElETC5PcHQoQWNjb3VudF9fMiksXHJcbiAgICAgICAgZXh0ZW5zaWJsZTogQ2FuZHlTaGFyZWQsXHJcbiAgICAgIH0pLFxyXG4gICAgICBkYXRhOiBJREwuUmVjb3JkKHtcclxuICAgICAgICBoYXNoOiBJREwuT3B0KElETC5WZWMoSURMLk5hdDgpKSxcclxuICAgICAgICBleHRlbnNpYmxlOiBDYW5keVNoYXJlZCxcclxuICAgICAgICBkYXRhX2RhcHA6IElETC5PcHQoSURMLlRleHQpLFxyXG4gICAgICAgIGRhdGFfcGF0aDogSURMLk9wdChJREwuVGV4dCksXHJcbiAgICAgIH0pLFxyXG4gICAgICBzYWxlX2VuZGVkOiBJREwuUmVjb3JkKHtcclxuICAgICAgICB0b2tlbjogVG9rZW5TcGVjLFxyXG4gICAgICAgIHNlbGxlcjogQWNjb3VudF9fMixcclxuICAgICAgICBleHRlbnNpYmxlOiBDYW5keVNoYXJlZCxcclxuICAgICAgICBidXllcjogQWNjb3VudF9fMixcclxuICAgICAgICBhbW91bnQ6IElETC5OYXQsXHJcbiAgICAgICAgc2FsZV9pZDogSURMLk9wdChJREwuVGV4dCksXHJcbiAgICAgIH0pLFxyXG4gICAgICBtaW50OiBJREwuUmVjb3JkKHtcclxuICAgICAgICB0bzogQWNjb3VudF9fMixcclxuICAgICAgICBmcm9tOiBBY2NvdW50X18yLFxyXG4gICAgICAgIHNhbGU6IElETC5PcHQoSURMLlJlY29yZCh7IHRva2VuOiBUb2tlblNwZWMsIGFtb3VudDogSURMLk5hdCB9KSksXHJcbiAgICAgICAgZXh0ZW5zaWJsZTogQ2FuZHlTaGFyZWQsXHJcbiAgICAgIH0pLFxyXG4gICAgICByb3lhbHR5X3BhaWQ6IElETC5SZWNvcmQoe1xyXG4gICAgICAgIHRhZzogSURMLlRleHQsXHJcbiAgICAgICAgdG9rZW46IFRva2VuU3BlYyxcclxuICAgICAgICBzZWxsZXI6IEFjY291bnRfXzIsXHJcbiAgICAgICAgZXh0ZW5zaWJsZTogQ2FuZHlTaGFyZWQsXHJcbiAgICAgICAgYnV5ZXI6IEFjY291bnRfXzIsXHJcbiAgICAgICAgYW1vdW50OiBJREwuTmF0LFxyXG4gICAgICAgIHJlY2VpdmVyOiBBY2NvdW50X18yLFxyXG4gICAgICAgIHNhbGVfaWQ6IElETC5PcHQoSURMLlRleHQpLFxyXG4gICAgICB9KSxcclxuICAgICAgZXh0ZW5zaWJsZTogQ2FuZHlTaGFyZWQsXHJcbiAgICAgIGZlZV9kZXBvc2l0X3dpdGhkcmF3OiBJREwuUmVjb3JkKHtcclxuICAgICAgICBmZWU6IElETC5OYXQsXHJcbiAgICAgICAgdG9rZW46IFRva2VuU3BlYyxcclxuICAgICAgICB0cnhfaWQ6IFRyYW5zYWN0aW9uSUQsXHJcbiAgICAgICAgZXh0ZW5zaWJsZTogQ2FuZHlTaGFyZWQsXHJcbiAgICAgICAgYWNjb3VudDogQWNjb3VudF9fMixcclxuICAgICAgICBhbW91bnQ6IElETC5OYXQsXHJcbiAgICAgIH0pLFxyXG4gICAgICBvd25lcl90cmFuc2ZlcjogSURMLlJlY29yZCh7XHJcbiAgICAgICAgdG86IEFjY291bnRfXzIsXHJcbiAgICAgICAgZnJvbTogQWNjb3VudF9fMixcclxuICAgICAgICBleHRlbnNpYmxlOiBDYW5keVNoYXJlZCxcclxuICAgICAgfSksXHJcbiAgICAgIHNhbGVfb3BlbmVkOiBJREwuUmVjb3JkKHtcclxuICAgICAgICBwcmljaW5nOiBQcmljaW5nQ29uZmlnU2hhcmVkLFxyXG4gICAgICAgIGV4dGVuc2libGU6IENhbmR5U2hhcmVkLFxyXG4gICAgICAgIHNhbGVfaWQ6IElETC5UZXh0LFxyXG4gICAgICB9KSxcclxuICAgICAgY2FuaXN0ZXJfb3duZXJfdXBkYXRlZDogSURMLlJlY29yZCh7XHJcbiAgICAgICAgb3duZXI6IElETC5QcmluY2lwYWwsXHJcbiAgICAgICAgZXh0ZW5zaWJsZTogQ2FuZHlTaGFyZWQsXHJcbiAgICAgIH0pLFxyXG4gICAgICBzYWxlX3dpdGhkcmF3OiBJREwuUmVjb3JkKHtcclxuICAgICAgICBmZWU6IElETC5OYXQsXHJcbiAgICAgICAgdG9rZW46IFRva2VuU3BlYyxcclxuICAgICAgICB0b2tlbl9pZDogSURMLlRleHQsXHJcbiAgICAgICAgdHJ4X2lkOiBUcmFuc2FjdGlvbklELFxyXG4gICAgICAgIHNlbGxlcjogQWNjb3VudF9fMixcclxuICAgICAgICBleHRlbnNpYmxlOiBDYW5keVNoYXJlZCxcclxuICAgICAgICBidXllcjogQWNjb3VudF9fMixcclxuICAgICAgICBhbW91bnQ6IElETC5OYXQsXHJcbiAgICAgIH0pLFxyXG4gICAgICBkZXBvc2l0X3dpdGhkcmF3OiBJREwuUmVjb3JkKHtcclxuICAgICAgICBmZWU6IElETC5OYXQsXHJcbiAgICAgICAgdG9rZW46IFRva2VuU3BlYyxcclxuICAgICAgICB0cnhfaWQ6IFRyYW5zYWN0aW9uSUQsXHJcbiAgICAgICAgZXh0ZW5zaWJsZTogQ2FuZHlTaGFyZWQsXHJcbiAgICAgICAgYnV5ZXI6IEFjY291bnRfXzIsXHJcbiAgICAgICAgYW1vdW50OiBJREwuTmF0LFxyXG4gICAgICB9KSxcclxuICAgIH0pLFxyXG4gICAgdGltZXN0YW1wOiBJREwuSW50LFxyXG4gICAgaW5kZXg6IElETC5OYXQsXHJcbiAgfSk7XHJcbiAgY29uc3QgU3RhYmxlTmZ0TGVkZ2VyID0gSURMLlZlYyhJREwuVHVwbGUoSURMLlRleHQsIFRyYW5zYWN0aW9uUmVjb3JkKSk7XHJcbiAgY29uc3QgQWxsb2NhdGlvblJlY29yZFN0YWJsZSA9IElETC5SZWNvcmQoe1xyXG4gICAgYWxsb2NhdGVkX3NwYWNlOiBJREwuTmF0LFxyXG4gICAgdG9rZW5faWQ6IElETC5UZXh0LFxyXG4gICAgYXZhaWxhYmxlX3NwYWNlOiBJREwuTmF0LFxyXG4gICAgY2FuaXN0ZXI6IElETC5QcmluY2lwYWwsXHJcbiAgICBjaHVua3M6IElETC5WZWMoSURMLk5hdCksXHJcbiAgICBsaWJyYXJ5X2lkOiBJREwuVGV4dCxcclxuICB9KTtcclxuICBjb25zdCBCaWRGZWF0dXJlID0gSURMLlZhcmlhbnQoe1xyXG4gICAgZmVlX3NjaGVtYTogSURMLlRleHQsXHJcbiAgICBicm9rZXI6IEFjY291bnRfXzIsXHJcbiAgICBmZWVfYWNjb3VudHM6IEZlZUFjY291bnRzUGFyYW1zLFxyXG4gIH0pO1xyXG4gIGNvbnN0IEJpZENvbmZpZ1NoYXJlZCA9IElETC5PcHQoSURMLlZlYyhCaWRGZWF0dXJlKSk7XHJcbiAgY29uc3QgRXNjcm93UmVjZWlwdCA9IElETC5SZWNvcmQoe1xyXG4gICAgdG9rZW46IFRva2VuU3BlYyxcclxuICAgIHRva2VuX2lkOiBJREwuVGV4dCxcclxuICAgIHNlbGxlcjogQWNjb3VudF9fMixcclxuICAgIGJ1eWVyOiBBY2NvdW50X18yLFxyXG4gICAgYW1vdW50OiBJREwuTmF0LFxyXG4gIH0pO1xyXG4gIGNvbnN0IFByaWNpbmdDb25maWdTaGFyZWRfXzEgPSBJREwuVmFyaWFudCh7XHJcbiAgICBhc2s6IEFza0NvbmZpZ1NoYXJlZCxcclxuICAgIGV4dGVuc2libGU6IENhbmR5U2hhcmVkLFxyXG4gICAgaW5zdGFudDogSW5zdGFudENvbmZpZ1NoYXJlZCxcclxuICAgIGF1Y3Rpb246IEF1Y3Rpb25Db25maWcsXHJcbiAgfSk7XHJcbiAgY29uc3QgQXVjdGlvblN0YXRlU2hhcmVkID0gSURMLlJlY29yZCh7XHJcbiAgICBzdGF0dXM6IElETC5WYXJpYW50KHtcclxuICAgICAgY2xvc2VkOiBJREwuTnVsbCxcclxuICAgICAgb3BlbjogSURMLk51bGwsXHJcbiAgICAgIG5vdF9zdGFydGVkOiBJREwuTnVsbCxcclxuICAgIH0pLFxyXG4gICAgcGFydGljaXBhbnRzOiBJREwuVmVjKElETC5UdXBsZShJREwuUHJpbmNpcGFsLCBJREwuSW50KSksXHJcbiAgICB0b2tlbjogVG9rZW5TcGVjX18xLFxyXG4gICAgY3VycmVudF9iaWRfYW1vdW50OiBJREwuTmF0LFxyXG4gICAgd2lubmVyOiBJREwuT3B0KEFjY291bnRfXzEpLFxyXG4gICAgZW5kX2RhdGU6IElETC5JbnQsXHJcbiAgICBjdXJyZW50X2NvbmZpZzogQmlkQ29uZmlnU2hhcmVkLFxyXG4gICAgc3RhcnRfZGF0ZTogSURMLkludCxcclxuICAgIHdhaXRfZm9yX3F1aWV0X2NvdW50OiBJREwuT3B0KElETC5OYXQpLFxyXG4gICAgY3VycmVudF9lc2Nyb3c6IElETC5PcHQoRXNjcm93UmVjZWlwdCksXHJcbiAgICBhbGxvd19saXN0OiBJREwuT3B0KElETC5WZWMoSURMLlR1cGxlKElETC5QcmluY2lwYWwsIElETC5Cb29sKSkpLFxyXG4gICAgbWluX25leHRfYmlkOiBJREwuTmF0LFxyXG4gICAgY29uZmlnOiBQcmljaW5nQ29uZmlnU2hhcmVkX18xLFxyXG4gIH0pO1xyXG4gIGNvbnN0IFNhbGVTdGF0dXNTaGFyZWQgPSBJREwuUmVjb3JkKHtcclxuICAgIHRva2VuX2lkOiBJREwuVGV4dCxcclxuICAgIHNhbGVfdHlwZTogSURMLlZhcmlhbnQoeyBhdWN0aW9uOiBBdWN0aW9uU3RhdGVTaGFyZWQgfSksXHJcbiAgICBicm9rZXJfaWQ6IElETC5PcHQoSURMLlByaW5jaXBhbCksXHJcbiAgICBvcmlnaW5hbF9icm9rZXJfaWQ6IElETC5PcHQoSURMLlByaW5jaXBhbCksXHJcbiAgICBzYWxlX2lkOiBJREwuVGV4dCxcclxuICB9KTtcclxuICBjb25zdCBTdGFibGVCdWNrZXREYXRhID0gSURMLlJlY29yZCh7XHJcbiAgICBwcmluY2lwYWw6IElETC5QcmluY2lwYWwsXHJcbiAgICBhbGxvY2F0ZWRfc3BhY2U6IElETC5OYXQsXHJcbiAgICBkYXRlX2FkZGVkOiBJREwuSW50LFxyXG4gICAgdmVyc2lvbjogSURMLlR1cGxlKElETC5OYXQsIElETC5OYXQsIElETC5OYXQpLFxyXG4gICAgYl9nYXRld2F5OiBJREwuQm9vbCxcclxuICAgIGF2YWlsYWJsZV9zcGFjZTogSURMLk5hdCxcclxuICAgIGFsbG9jYXRpb25zOiBJREwuVmVjKElETC5UdXBsZShJREwuVHVwbGUoSURMLlRleHQsIElETC5UZXh0KSwgSURMLkludCkpLFxyXG4gIH0pO1xyXG4gIGNvbnN0IFN0YWJsZUVzY3Jvd0JhbGFuY2VzID0gSURMLlZlYyhcclxuICAgIElETC5UdXBsZShBY2NvdW50X18xLCBBY2NvdW50X18xLCBJREwuVGV4dCwgRXNjcm93UmVjb3JkX18xKVxyXG4gICk7XHJcbiAgY29uc3QgTkZUQmFja3VwQ2h1bmsgPSBJREwuUmVjb3JkKHtcclxuICAgIHNhbGVzX2JhbGFuY2VzOiBTdGFibGVTYWxlc0JhbGFuY2VzLFxyXG4gICAgb2ZmZXJzOiBTdGFibGVPZmZlcnMsXHJcbiAgICBjb2xsZWN0aW9uX2RhdGE6IFN0YWJsZUNvbGxlY3Rpb25EYXRhLFxyXG4gICAgbmZ0X2xlZGdlcnM6IFN0YWJsZU5mdExlZGdlcixcclxuICAgIGNhbmlzdGVyOiBJREwuUHJpbmNpcGFsLFxyXG4gICAgYWxsb2NhdGlvbnM6IElETC5WZWMoXHJcbiAgICAgIElETC5UdXBsZShJREwuVHVwbGUoSURMLlRleHQsIElETC5UZXh0KSwgQWxsb2NhdGlvblJlY29yZFN0YWJsZSlcclxuICAgICksXHJcbiAgICBuZnRfc2FsZXM6IElETC5WZWMoSURMLlR1cGxlKElETC5UZXh0LCBTYWxlU3RhdHVzU2hhcmVkKSksXHJcbiAgICBidWNrZXRzOiBJREwuVmVjKElETC5UdXBsZShJREwuUHJpbmNpcGFsLCBTdGFibGVCdWNrZXREYXRhKSksXHJcbiAgICBlc2Nyb3dfYmFsYW5jZXM6IFN0YWJsZUVzY3Jvd0JhbGFuY2VzLFxyXG4gIH0pO1xyXG4gIGNvbnN0IEVYVFRva2VuSWRlbnRpZmllciA9IElETC5UZXh0O1xyXG4gIGNvbnN0IEVYVFVzZXIgPSBJREwuVmFyaWFudCh7XHJcbiAgICBwcmluY2lwYWw6IElETC5QcmluY2lwYWwsXHJcbiAgICBhZGRyZXNzOiBJREwuVGV4dCxcclxuICB9KTtcclxuICBjb25zdCBFWFRCYWxhbmNlUmVxdWVzdCA9IElETC5SZWNvcmQoe1xyXG4gICAgdG9rZW46IEVYVFRva2VuSWRlbnRpZmllcixcclxuICAgIHVzZXI6IEVYVFVzZXIsXHJcbiAgfSk7XHJcbiAgY29uc3QgRVhUQmFsYW5jZSA9IElETC5OYXQ7XHJcbiAgY29uc3QgRVhUQ29tbW9uRXJyb3IgPSBJREwuVmFyaWFudCh7XHJcbiAgICBJbnZhbGlkVG9rZW46IEVYVFRva2VuSWRlbnRpZmllcixcclxuICAgIE90aGVyOiBJREwuVGV4dCxcclxuICB9KTtcclxuICBjb25zdCBFWFRCYWxhbmNlUmVzdWx0ID0gSURMLlZhcmlhbnQoe1xyXG4gICAgb2s6IEVYVEJhbGFuY2UsXHJcbiAgICBlcnI6IEVYVENvbW1vbkVycm9yLFxyXG4gIH0pO1xyXG4gIGNvbnN0IFN0YWtlUmVjb3JkID0gSURMLlJlY29yZCh7XHJcbiAgICBzdGFrZXI6IEFjY291bnRfXzEsXHJcbiAgICB0b2tlbl9pZDogSURMLlRleHQsXHJcbiAgICBhbW91bnQ6IElETC5OYXQsXHJcbiAgfSk7XHJcbiAgY29uc3QgQmFsYW5jZVJlc3BvbnNlID0gSURMLlJlY29yZCh7XHJcbiAgICBuZnRzOiBJREwuVmVjKElETC5UZXh0KSxcclxuICAgIG9mZmVyczogSURMLlZlYyhFc2Nyb3dSZWNvcmRfXzEpLFxyXG4gICAgc2FsZXM6IElETC5WZWMoRXNjcm93UmVjb3JkX18xKSxcclxuICAgIHN0YWtlOiBJREwuVmVjKFN0YWtlUmVjb3JkKSxcclxuICAgIG11bHRpX2NhbmlzdGVyOiBJREwuT3B0KElETC5WZWMoSURMLlByaW5jaXBhbCkpLFxyXG4gICAgZXNjcm93OiBJREwuVmVjKEVzY3Jvd1JlY29yZF9fMSksXHJcbiAgfSk7XHJcbiAgY29uc3QgRXJyb3JzID0gSURMLlZhcmlhbnQoe1xyXG4gICAgbnlpOiBJREwuTnVsbCxcclxuICAgIHN0b3JhZ2VfY29uZmlndXJhdGlvbl9lcnJvcjogSURMLk51bGwsXHJcbiAgICBlc2Nyb3dfd2l0aGRyYXdfcGF5bWVudF9mYWlsZWQ6IElETC5OdWxsLFxyXG4gICAgdG9rZW5fbm90X2ZvdW5kOiBJREwuTnVsbCxcclxuICAgIG93bmVyX25vdF9mb3VuZDogSURMLk51bGwsXHJcbiAgICBjb250ZW50X25vdF9mb3VuZDogSURMLk51bGwsXHJcbiAgICBhdWN0aW9uX2VuZGVkOiBJREwuTnVsbCxcclxuICAgIG91dF9vZl9yYW5nZTogSURMLk51bGwsXHJcbiAgICBzYWxlX2lkX2RvZXNfbm90X21hdGNoOiBJREwuTnVsbCxcclxuICAgIHNhbGVfbm90X2ZvdW5kOiBJREwuTnVsbCxcclxuICAgIGt5Y19mYWlsOiBJREwuTnVsbCxcclxuICAgIGl0ZW1fbm90X293bmVkOiBJREwuTnVsbCxcclxuICAgIHByb3BlcnR5X25vdF9mb3VuZDogSURMLk51bGwsXHJcbiAgICB2YWxpZGF0ZV90cnhfd3JvbmdfaG9zdDogSURMLk51bGwsXHJcbiAgICB3aXRoZHJhd190b29fbGFyZ2U6IElETC5OdWxsLFxyXG4gICAgY29udGVudF9ub3RfZGVzZXJpYWxpemFibGU6IElETC5OdWxsLFxyXG4gICAgYmlkX3Rvb19sb3c6IElETC5OdWxsLFxyXG4gICAgdmFsaWRhdGVfZGVwb3NpdF93cm9uZ19hbW91bnQ6IElETC5OdWxsLFxyXG4gICAgZXhpc3Rpbmdfc2FsZV9mb3VuZDogSURMLk51bGwsXHJcbiAgICBub29wOiBJREwuTnVsbCxcclxuICAgIGFzc2V0X21pc21hdGNoOiBJREwuTnVsbCxcclxuICAgIGVzY3Jvd19jYW5ub3RfYmVfcmVtb3ZlZDogSURMLk51bGwsXHJcbiAgICBkZXBvc2l0X2J1cm5lZDogSURMLk51bGwsXHJcbiAgICBjYW5ub3RfcmVzdGFnZV9taW50ZWRfdG9rZW46IElETC5OdWxsLFxyXG4gICAgY2Fubm90X2ZpbmRfc3RhdHVzX2luX21ldGFkYXRhOiBJREwuTnVsbCxcclxuICAgIHJlY2VpcHRfZGF0YV9taXNtYXRjaDogSURMLk51bGwsXHJcbiAgICB2YWxpZGF0ZV9kZXBvc2l0X2ZhaWxlZDogSURMLk51bGwsXHJcbiAgICB1bnJlYWNoYWJsZTogSURMLk51bGwsXHJcbiAgICB1bmF1dGhvcml6ZWRfYWNjZXNzOiBJREwuTnVsbCxcclxuICAgIGl0ZW1fYWxyZWFkeV9taW50ZWQ6IElETC5OdWxsLFxyXG4gICAgbm9fZXNjcm93X2ZvdW5kOiBJREwuTnVsbCxcclxuICAgIGVzY3Jvd19vd25lcl9ub3RfdGhlX293bmVyOiBJREwuTnVsbCxcclxuICAgIGltcHJvcGVyX2ludGVyZmFjZTogSURMLk51bGwsXHJcbiAgICBhcHBfaWRfbm90X2ZvdW5kOiBJREwuTnVsbCxcclxuICAgIHRva2VuX25vbl90cmFuc2ZlcmFibGU6IElETC5OdWxsLFxyXG4gICAga3ljX2Vycm9yOiBJREwuTnVsbCxcclxuICAgIHNhbGVfbm90X292ZXI6IElETC5OdWxsLFxyXG4gICAgZXNjcm93X25vdF9sYXJnZV9lbm91Z2g6IElETC5OdWxsLFxyXG4gICAgdXBkYXRlX2NsYXNzX2Vycm9yOiBJREwuTnVsbCxcclxuICAgIG1hbGZvcm1lZF9tZXRhZGF0YTogSURMLk51bGwsXHJcbiAgICB0b2tlbl9pZF9taXNtYXRjaDogSURMLk51bGwsXHJcbiAgICBpZF9ub3RfZm91bmRfaW5fbWV0YWRhdGE6IElETC5OdWxsLFxyXG4gICAgYXVjdGlvbl9ub3Rfc3RhcnRlZDogSURMLk51bGwsXHJcbiAgICBsb3dfZmVlX2JhbGFuY2U6IElETC5OdWxsLFxyXG4gICAgbGlicmFyeV9ub3RfZm91bmQ6IElETC5OdWxsLFxyXG4gICAgYXR0ZW1wdF90b19zdGFnZV9zeXN0ZW1fZGF0YTogSURMLk51bGwsXHJcbiAgICBub19mZWVfYWNjb3VudHNfcHJvdmlkZWQ6IElETC5OdWxsLFxyXG4gICAgdmFsaWRhdGVfZGVwb3NpdF93cm9uZ19idXllcjogSURMLk51bGwsXHJcbiAgICBub3RfZW5vdWdoX3N0b3JhZ2U6IElETC5OdWxsLFxyXG4gICAgc2FsZXNfd2l0aGRyYXdfcGF5bWVudF9mYWlsZWQ6IElETC5OdWxsLFxyXG4gIH0pO1xyXG4gIGNvbnN0IE9yaWd5bkVycm9yID0gSURMLlJlY29yZCh7XHJcbiAgICB0ZXh0OiBJREwuVGV4dCxcclxuICAgIGVycm9yOiBFcnJvcnMsXHJcbiAgICBudW1iZXI6IElETC5OYXQzMixcclxuICAgIGZsYWdfcG9pbnQ6IElETC5UZXh0LFxyXG4gIH0pO1xyXG4gIGNvbnN0IEJhbGFuY2VSZXN1bHQgPSBJREwuVmFyaWFudCh7XHJcbiAgICBvazogQmFsYW5jZVJlc3BvbnNlLFxyXG4gICAgZXJyOiBPcmlneW5FcnJvcixcclxuICB9KTtcclxuICBjb25zdCBFWFRBY2NvdW50SWRlbnRpZmllciA9IElETC5UZXh0O1xyXG4gIGNvbnN0IEVYVEJlYXJlclJlc3VsdCA9IElETC5WYXJpYW50KHtcclxuICAgIG9rOiBFWFRBY2NvdW50SWRlbnRpZmllcixcclxuICAgIGVycjogRVhUQ29tbW9uRXJyb3IsXHJcbiAgfSk7XHJcbiAgY29uc3QgQmVhcmVyUmVzdWx0ID0gSURMLlZhcmlhbnQoeyBvazogQWNjb3VudF9fMSwgZXJyOiBPcmlneW5FcnJvciB9KTtcclxuICBjb25zdCBjYW5pc3Rlcl9pZCA9IElETC5QcmluY2lwYWw7XHJcbiAgY29uc3QgZGVmaW5pdGVfY2FuaXN0ZXJfc2V0dGluZ3MgPSBJREwuUmVjb3JkKHtcclxuICAgIGZyZWV6aW5nX3RocmVzaG9sZDogSURMLk5hdCxcclxuICAgIGNvbnRyb2xsZXJzOiBJREwuT3B0KElETC5WZWMoSURMLlByaW5jaXBhbCkpLFxyXG4gICAgbWVtb3J5X2FsbG9jYXRpb246IElETC5OYXQsXHJcbiAgICBjb21wdXRlX2FsbG9jYXRpb246IElETC5OYXQsXHJcbiAgfSk7XHJcbiAgY29uc3QgY2FuaXN0ZXJfc3RhdHVzID0gSURMLlJlY29yZCh7XHJcbiAgICBzdGF0dXM6IElETC5WYXJpYW50KHtcclxuICAgICAgc3RvcHBlZDogSURMLk51bGwsXHJcbiAgICAgIHN0b3BwaW5nOiBJREwuTnVsbCxcclxuICAgICAgcnVubmluZzogSURMLk51bGwsXHJcbiAgICB9KSxcclxuICAgIG1lbW9yeV9zaXplOiBJREwuTmF0LFxyXG4gICAgY3ljbGVzOiBJREwuTmF0LFxyXG4gICAgc2V0dGluZ3M6IGRlZmluaXRlX2NhbmlzdGVyX3NldHRpbmdzLFxyXG4gICAgbW9kdWxlX2hhc2g6IElETC5PcHQoSURMLlZlYyhJREwuTmF0OCkpLFxyXG4gIH0pO1xyXG4gIGNvbnN0IENodW5rUmVxdWVzdCA9IElETC5SZWNvcmQoe1xyXG4gICAgdG9rZW5faWQ6IElETC5UZXh0LFxyXG4gICAgY2h1bms6IElETC5PcHQoSURMLk5hdCksXHJcbiAgICBsaWJyYXJ5X2lkOiBJREwuVGV4dCxcclxuICB9KTtcclxuICBjb25zdCBDaHVua0NvbnRlbnQgPSBJREwuVmFyaWFudCh7XHJcbiAgICByZW1vdGU6IElETC5SZWNvcmQoe1xyXG4gICAgICBhcmdzOiBDaHVua1JlcXVlc3QsXHJcbiAgICAgIGNhbmlzdGVyOiBJREwuUHJpbmNpcGFsLFxyXG4gICAgfSksXHJcbiAgICBjaHVuazogSURMLlJlY29yZCh7XHJcbiAgICAgIHRvdGFsX2NodW5rczogSURMLk5hdCxcclxuICAgICAgY29udGVudDogSURMLlZlYyhJREwuTmF0OCksXHJcbiAgICAgIHN0b3JhZ2VfYWxsb2NhdGlvbjogQWxsb2NhdGlvblJlY29yZFN0YWJsZSxcclxuICAgICAgY3VycmVudF9jaHVuazogSURMLk9wdChJREwuTmF0KSxcclxuICAgIH0pLFxyXG4gIH0pO1xyXG4gIGNvbnN0IENodW5rUmVzdWx0ID0gSURMLlZhcmlhbnQoeyBvazogQ2h1bmtDb250ZW50LCBlcnI6IE9yaWd5bkVycm9yIH0pO1xyXG4gIGNvbnN0IENvbGxlY3Rpb25JbmZvID0gSURMLlJlY29yZCh7XHJcbiAgICBtdWx0aV9jYW5pc3Rlcl9jb3VudDogSURMLk9wdChJREwuTmF0KSxcclxuICAgIG1hbmFnZXJzOiBJREwuT3B0KElETC5WZWMoSURMLlByaW5jaXBhbCkpLFxyXG4gICAgb3duZXI6IElETC5PcHQoSURMLlByaW5jaXBhbCksXHJcbiAgICBtZXRhZGF0YTogSURMLk9wdChDYW5keVNoYXJlZCksXHJcbiAgICBsb2dvOiBJREwuT3B0KElETC5UZXh0KSxcclxuICAgIG5hbWU6IElETC5PcHQoSURMLlRleHQpLFxyXG4gICAgbmV0d29yazogSURMLk9wdChJREwuUHJpbmNpcGFsKSxcclxuICAgIGNyZWF0ZWRfYXQ6IElETC5PcHQoSURMLk5hdDY0KSxcclxuICAgIGZpZWxkczogSURMLk9wdChcclxuICAgICAgSURMLlZlYyhJREwuVHVwbGUoSURMLlRleHQsIElETC5PcHQoSURMLk5hdCksIElETC5PcHQoSURMLk5hdCkpKVxyXG4gICAgKSxcclxuICAgIHVwZ3JhZGVkX2F0OiBJREwuT3B0KElETC5OYXQ2NCksXHJcbiAgICB0b2tlbl9pZHNfY291bnQ6IElETC5PcHQoSURMLk5hdCksXHJcbiAgICBhdmFpbGFibGVfc3BhY2U6IElETC5PcHQoSURMLk5hdCksXHJcbiAgICBtdWx0aV9jYW5pc3RlcjogSURMLk9wdChJREwuVmVjKElETC5QcmluY2lwYWwpKSxcclxuICAgIHRva2VuX2lkczogSURMLk9wdChJREwuVmVjKElETC5UZXh0KSksXHJcbiAgICB0cmFuc2FjdGlvbl9jb3VudDogSURMLk9wdChJREwuTmF0KSxcclxuICAgIHVuaXF1ZV9ob2xkZXJzOiBJREwuT3B0KElETC5OYXQpLFxyXG4gICAgdG90YWxfc3VwcGx5OiBJREwuT3B0KElETC5OYXQpLFxyXG4gICAgc3ltYm9sOiBJREwuT3B0KElETC5UZXh0KSxcclxuICAgIGFsbG9jYXRlZF9zdG9yYWdlOiBJREwuT3B0KElETC5OYXQpLFxyXG4gIH0pO1xyXG4gIGNvbnN0IENvbGxlY3Rpb25SZXN1bHQgPSBJREwuVmFyaWFudCh7XHJcbiAgICBvazogQ29sbGVjdGlvbkluZm8sXHJcbiAgICBlcnI6IE9yaWd5bkVycm9yLFxyXG4gIH0pO1xyXG4gIGNvbnN0IE1hbmFnZUNvbGxlY3Rpb25Db21tYW5kID0gSURMLlZhcmlhbnQoe1xyXG4gICAgVXBkYXRlT3duZXI6IElETC5QcmluY2lwYWwsXHJcbiAgICBVcGRhdGVNYW5hZ2VyczogSURMLlZlYyhJREwuUHJpbmNpcGFsKSxcclxuICAgIFVwZGF0ZU1ldGFkYXRhOiBJREwuVHVwbGUoSURMLlRleHQsIElETC5PcHQoQ2FuZHlTaGFyZWQpLCBJREwuQm9vbCksXHJcbiAgICBVcGRhdGVBbm5vdW5jZUNhbmlzdGVyOiBJREwuT3B0KElETC5QcmluY2lwYWwpLFxyXG4gICAgVXBkYXRlTmV0d29yazogSURMLk9wdChJREwuUHJpbmNpcGFsKSxcclxuICAgIFVwZGF0ZVN5bWJvbDogSURMLk9wdChJREwuVGV4dCksXHJcbiAgICBVcGRhdGVMb2dvOiBJREwuT3B0KElETC5UZXh0KSxcclxuICAgIFVwZGF0ZU5hbWU6IElETC5PcHQoSURMLlRleHQpLFxyXG4gIH0pO1xyXG4gIGNvbnN0IE9yaWd5bkJvb2xSZXN1bHQgPSBJREwuVmFyaWFudCh7XHJcbiAgICBvazogSURMLkJvb2wsXHJcbiAgICBlcnI6IE9yaWd5bkVycm9yLFxyXG4gIH0pO1xyXG4gIGNvbnN0IFN1YmFjY291bnQgPSBJREwuVmVjKElETC5OYXQ4KTtcclxuICBjb25zdCBBY2NvdW50ID0gSURMLlJlY29yZCh7XHJcbiAgICBvd25lcjogSURMLlByaW5jaXBhbCxcclxuICAgIHN1YmFjY291bnQ6IElETC5PcHQoU3ViYWNjb3VudCksXHJcbiAgfSk7XHJcbiAgY29uc3QgTmZ0RXJyb3IgPSBJREwuVmFyaWFudCh7XHJcbiAgICBVbmF1dGhvcml6ZWRPcGVyYXRvcjogSURMLk51bGwsXHJcbiAgICBTZWxmVHJhbnNmZXI6IElETC5OdWxsLFxyXG4gICAgVG9rZW5Ob3RGb3VuZDogSURMLk51bGwsXHJcbiAgICBVbmF1dGhvcml6ZWRPd25lcjogSURMLk51bGwsXHJcbiAgICBUeE5vdEZvdW5kOiBJREwuTnVsbCxcclxuICAgIFNlbGZBcHByb3ZlOiBJREwuTnVsbCxcclxuICAgIE9wZXJhdG9yTm90Rm91bmQ6IElETC5OdWxsLFxyXG4gICAgRXhpc3RlZE5GVDogSURMLk51bGwsXHJcbiAgICBPd25lck5vdEZvdW5kOiBJREwuTnVsbCxcclxuICAgIE90aGVyOiBJREwuVGV4dCxcclxuICB9KTtcclxuICBjb25zdCBESVA3MjFCb29sUmVzdWx0ID0gSURMLlZhcmlhbnQoeyBPazogSURMLkJvb2wsIEVycjogTmZ0RXJyb3IgfSk7XHJcbiAgY29uc3QgRElQNzIxTWV0YWRhdGEgPSBJREwuUmVjb3JkKHtcclxuICAgIGxvZ286IElETC5PcHQoSURMLlRleHQpLFxyXG4gICAgbmFtZTogSURMLk9wdChJREwuVGV4dCksXHJcbiAgICBjcmVhdGVkX2F0OiBJREwuTmF0NjQsXHJcbiAgICB1cGdyYWRlZF9hdDogSURMLk5hdDY0LFxyXG4gICAgY3VzdG9kaWFuczogSURMLlZlYyhJREwuUHJpbmNpcGFsKSxcclxuICAgIHN5bWJvbDogSURMLk9wdChJREwuVGV4dCksXHJcbiAgfSk7XHJcbiAgY29uc3QgRElQNzIxVG9rZW5zTGlzdE1ldGFkYXRhID0gSURMLlZhcmlhbnQoe1xyXG4gICAgT2s6IElETC5WZWMoSURMLk5hdCksXHJcbiAgICBFcnI6IE5mdEVycm9yLFxyXG4gIH0pO1xyXG4gIFZlYy5maWxsKFxyXG4gICAgSURMLlZlYyhcclxuICAgICAgSURMLlR1cGxlKFxyXG4gICAgICAgIElETC5UZXh0LFxyXG4gICAgICAgIElETC5WYXJpYW50KHtcclxuICAgICAgICAgIE5hdDY0Q29udGVudDogSURMLk5hdDY0LFxyXG4gICAgICAgICAgTmF0MzJDb250ZW50OiBJREwuTmF0MzIsXHJcbiAgICAgICAgICBCb29sQ29udGVudDogSURMLkJvb2wsXHJcbiAgICAgICAgICBOYXQ4Q29udGVudDogSURMLk5hdDgsXHJcbiAgICAgICAgICBJbnQ2NENvbnRlbnQ6IElETC5JbnQ2NCxcclxuICAgICAgICAgIEludENvbnRlbnQ6IElETC5JbnQsXHJcbiAgICAgICAgICBOYXRDb250ZW50OiBJREwuTmF0LFxyXG4gICAgICAgICAgTmF0MTZDb250ZW50OiBJREwuTmF0MTYsXHJcbiAgICAgICAgICBJbnQzMkNvbnRlbnQ6IElETC5JbnQzMixcclxuICAgICAgICAgIEludDhDb250ZW50OiBJREwuSW50OCxcclxuICAgICAgICAgIEZsb2F0Q29udGVudDogSURMLkZsb2F0NjQsXHJcbiAgICAgICAgICBJbnQxNkNvbnRlbnQ6IElETC5JbnQxNixcclxuICAgICAgICAgIEJsb2JDb250ZW50OiBJREwuVmVjKElETC5OYXQ4KSxcclxuICAgICAgICAgIE5lc3RlZENvbnRlbnQ6IFZlYyxcclxuICAgICAgICAgIFByaW5jaXBhbDogSURMLlByaW5jaXBhbCxcclxuICAgICAgICAgIFRleHRDb250ZW50OiBJREwuVGV4dCxcclxuICAgICAgICB9KVxyXG4gICAgICApXHJcbiAgICApXHJcbiAgKTtcclxuICBjb25zdCBHZW5lcmljVmFsdWUgPSBJREwuVmFyaWFudCh7XHJcbiAgICBOYXQ2NENvbnRlbnQ6IElETC5OYXQ2NCxcclxuICAgIE5hdDMyQ29udGVudDogSURMLk5hdDMyLFxyXG4gICAgQm9vbENvbnRlbnQ6IElETC5Cb29sLFxyXG4gICAgTmF0OENvbnRlbnQ6IElETC5OYXQ4LFxyXG4gICAgSW50NjRDb250ZW50OiBJREwuSW50NjQsXHJcbiAgICBJbnRDb250ZW50OiBJREwuSW50LFxyXG4gICAgTmF0Q29udGVudDogSURMLk5hdCxcclxuICAgIE5hdDE2Q29udGVudDogSURMLk5hdDE2LFxyXG4gICAgSW50MzJDb250ZW50OiBJREwuSW50MzIsXHJcbiAgICBJbnQ4Q29udGVudDogSURMLkludDgsXHJcbiAgICBGbG9hdENvbnRlbnQ6IElETC5GbG9hdDY0LFxyXG4gICAgSW50MTZDb250ZW50OiBJREwuSW50MTYsXHJcbiAgICBCbG9iQ29udGVudDogSURMLlZlYyhJREwuTmF0OCksXHJcbiAgICBOZXN0ZWRDb250ZW50OiBWZWMsXHJcbiAgICBQcmluY2lwYWw6IElETC5QcmluY2lwYWwsXHJcbiAgICBUZXh0Q29udGVudDogSURMLlRleHQsXHJcbiAgfSk7XHJcbiAgY29uc3QgVG9rZW5NZXRhZGF0YSA9IElETC5SZWNvcmQoe1xyXG4gICAgdHJhbnNmZXJyZWRfYXQ6IElETC5PcHQoSURMLk5hdDY0KSxcclxuICAgIHRyYW5zZmVycmVkX2J5OiBJREwuT3B0KElETC5QcmluY2lwYWwpLFxyXG4gICAgb3duZXI6IElETC5PcHQoSURMLlByaW5jaXBhbCksXHJcbiAgICBvcGVyYXRvcjogSURMLk9wdChJREwuUHJpbmNpcGFsKSxcclxuICAgIGFwcHJvdmVkX2F0OiBJREwuT3B0KElETC5OYXQ2NCksXHJcbiAgICBhcHByb3ZlZF9ieTogSURMLk9wdChJREwuUHJpbmNpcGFsKSxcclxuICAgIHByb3BlcnRpZXM6IElETC5WZWMoSURMLlR1cGxlKElETC5UZXh0LCBHZW5lcmljVmFsdWUpKSxcclxuICAgIGlzX2J1cm5lZDogSURMLkJvb2wsXHJcbiAgICB0b2tlbl9pZGVudGlmaWVyOiBJREwuTmF0LFxyXG4gICAgYnVybmVkX2F0OiBJREwuT3B0KElETC5OYXQ2NCksXHJcbiAgICBidXJuZWRfYnk6IElETC5PcHQoSURMLlByaW5jaXBhbCksXHJcbiAgICBtaW50ZWRfYXQ6IElETC5OYXQ2NCxcclxuICAgIG1pbnRlZF9ieTogSURMLlByaW5jaXBhbCxcclxuICB9KTtcclxuICBjb25zdCBESVA3MjFUb2tlbnNNZXRhZGF0YSA9IElETC5WYXJpYW50KHtcclxuICAgIE9rOiBJREwuVmVjKFRva2VuTWV0YWRhdGEpLFxyXG4gICAgRXJyOiBOZnRFcnJvcixcclxuICB9KTtcclxuICBjb25zdCBPd25lck9mUmVzcG9uc2UgPSBJREwuVmFyaWFudCh7XHJcbiAgICBPazogSURMLk9wdChJREwuUHJpbmNpcGFsKSxcclxuICAgIEVycjogTmZ0RXJyb3IsXHJcbiAgfSk7XHJcbiAgY29uc3QgRElQNzIxU3RhdHMgPSBJREwuUmVjb3JkKHtcclxuICAgIGN5Y2xlczogSURMLk5hdCxcclxuICAgIHRvdGFsX3RyYW5zYWN0aW9uczogSURMLk5hdCxcclxuICAgIHRvdGFsX3VuaXF1ZV9ob2xkZXJzOiBJREwuTmF0LFxyXG4gICAgdG90YWxfc3VwcGx5OiBJREwuTmF0LFxyXG4gIH0pO1xyXG4gIGNvbnN0IERJUDcyMVN1cHBvcnRlZEludGVyZmFjZSA9IElETC5WYXJpYW50KHtcclxuICAgIEJ1cm46IElETC5OdWxsLFxyXG4gICAgTWludDogSURMLk51bGwsXHJcbiAgICBBcHByb3ZhbDogSURMLk51bGwsXHJcbiAgICBUcmFuc2FjdGlvbkhpc3Rvcnk6IElETC5OdWxsLFxyXG4gIH0pO1xyXG4gIGNvbnN0IERJUDcyMVRva2VuTWV0YWRhdGEgPSBJREwuVmFyaWFudCh7XHJcbiAgICBPazogVG9rZW5NZXRhZGF0YSxcclxuICAgIEVycjogTmZ0RXJyb3IsXHJcbiAgfSk7XHJcbiAgY29uc3QgRElQNzIxTmF0UmVzdWx0ID0gSURMLlZhcmlhbnQoeyBPazogSURMLk5hdCwgRXJyOiBOZnRFcnJvciB9KTtcclxuICBjb25zdCBHZXRMb2dNZXNzYWdlc0ZpbHRlciA9IElETC5SZWNvcmQoe1xyXG4gICAgYW5hbHl6ZUNvdW50OiBJREwuTmF0MzIsXHJcbiAgICBtZXNzYWdlUmVnZXg6IElETC5PcHQoSURMLlRleHQpLFxyXG4gICAgbWVzc2FnZUNvbnRhaW5zOiBJREwuT3B0KElETC5UZXh0KSxcclxuICB9KTtcclxuICBjb25zdCBOYW5vcyA9IElETC5OYXQ2NDtcclxuICBjb25zdCBHZXRMb2dNZXNzYWdlc1BhcmFtZXRlcnMgPSBJREwuUmVjb3JkKHtcclxuICAgIGNvdW50OiBJREwuTmF0MzIsXHJcbiAgICBmaWx0ZXI6IElETC5PcHQoR2V0TG9nTWVzc2FnZXNGaWx0ZXIpLFxyXG4gICAgZnJvbVRpbWVOYW5vczogSURMLk9wdChOYW5vcyksXHJcbiAgfSk7XHJcbiAgY29uc3QgR2V0TGF0ZXN0TG9nTWVzc2FnZXNQYXJhbWV0ZXJzID0gSURMLlJlY29yZCh7XHJcbiAgICB1cFRvVGltZU5hbm9zOiBJREwuT3B0KE5hbm9zKSxcclxuICAgIGNvdW50OiBJREwuTmF0MzIsXHJcbiAgICBmaWx0ZXI6IElETC5PcHQoR2V0TG9nTWVzc2FnZXNGaWx0ZXIpLFxyXG4gIH0pO1xyXG4gIGNvbnN0IENhbmlzdGVyTG9nUmVxdWVzdCA9IElETC5WYXJpYW50KHtcclxuICAgIGdldE1lc3NhZ2VzSW5mbzogSURMLk51bGwsXHJcbiAgICBnZXRNZXNzYWdlczogR2V0TG9nTWVzc2FnZXNQYXJhbWV0ZXJzLFxyXG4gICAgZ2V0TGF0ZXN0TWVzc2FnZXM6IEdldExhdGVzdExvZ01lc3NhZ2VzUGFyYW1ldGVycyxcclxuICB9KTtcclxuICBjb25zdCBDYW5pc3RlckxvZ0ZlYXR1cmUgPSBJREwuVmFyaWFudCh7XHJcbiAgICBmaWx0ZXJNZXNzYWdlQnlDb250YWluczogSURMLk51bGwsXHJcbiAgICBmaWx0ZXJNZXNzYWdlQnlSZWdleDogSURMLk51bGwsXHJcbiAgfSk7XHJcbiAgY29uc3QgQ2FuaXN0ZXJMb2dNZXNzYWdlc0luZm8gPSBJREwuUmVjb3JkKHtcclxuICAgIGZlYXR1cmVzOiBJREwuVmVjKElETC5PcHQoQ2FuaXN0ZXJMb2dGZWF0dXJlKSksXHJcbiAgICBsYXN0VGltZU5hbm9zOiBJREwuT3B0KE5hbm9zKSxcclxuICAgIGNvdW50OiBJREwuTmF0MzIsXHJcbiAgICBmaXJzdFRpbWVOYW5vczogSURMLk9wdChOYW5vcyksXHJcbiAgfSk7XHJcbiAgY29uc3QgRGF0YSA9IElETC5WYXJpYW50KHtcclxuICAgIEludDogSURMLkludCxcclxuICAgIE1hcDogSURMLlZlYyhJREwuVHVwbGUoQ2FuZHlTaGFyZWQsIENhbmR5U2hhcmVkKSksXHJcbiAgICBOYXQ6IElETC5OYXQsXHJcbiAgICBTZXQ6IElETC5WZWMoQ2FuZHlTaGFyZWQpLFxyXG4gICAgTmF0MTY6IElETC5OYXQxNixcclxuICAgIE5hdDMyOiBJREwuTmF0MzIsXHJcbiAgICBOYXQ2NDogSURMLk5hdDY0LFxyXG4gICAgQmxvYjogSURMLlZlYyhJREwuTmF0OCksXHJcbiAgICBCb29sOiBJREwuQm9vbCxcclxuICAgIEludDg6IElETC5JbnQ4LFxyXG4gICAgSW50czogSURMLlZlYyhJREwuSW50KSxcclxuICAgIE5hdDg6IElETC5OYXQ4LFxyXG4gICAgTmF0czogSURMLlZlYyhJREwuTmF0KSxcclxuICAgIFRleHQ6IElETC5UZXh0LFxyXG4gICAgQnl0ZXM6IElETC5WZWMoSURMLk5hdDgpLFxyXG4gICAgSW50MTY6IElETC5JbnQxNixcclxuICAgIEludDMyOiBJREwuSW50MzIsXHJcbiAgICBJbnQ2NDogSURMLkludDY0LFxyXG4gICAgT3B0aW9uOiBJREwuT3B0KENhbmR5U2hhcmVkKSxcclxuICAgIEZsb2F0czogSURMLlZlYyhJREwuRmxvYXQ2NCksXHJcbiAgICBGbG9hdDogSURMLkZsb2F0NjQsXHJcbiAgICBQcmluY2lwYWw6IElETC5QcmluY2lwYWwsXHJcbiAgICBBcnJheTogSURMLlZlYyhDYW5keVNoYXJlZCksXHJcbiAgICBDbGFzczogSURMLlZlYyhQcm9wZXJ0eVNoYXJlZCksXHJcbiAgfSk7XHJcbiAgY29uc3QgQ2FsbGVyID0gSURMLk9wdChJREwuUHJpbmNpcGFsKTtcclxuICBjb25zdCBMb2dNZXNzYWdlc0RhdGEgPSBJREwuUmVjb3JkKHtcclxuICAgIGRhdGE6IERhdGEsXHJcbiAgICB0aW1lTmFub3M6IE5hbm9zLFxyXG4gICAgbWVzc2FnZTogSURMLlRleHQsXHJcbiAgICBjYWxsZXI6IENhbGxlcixcclxuICB9KTtcclxuICBjb25zdCBDYW5pc3RlckxvZ01lc3NhZ2VzID0gSURMLlJlY29yZCh7XHJcbiAgICBkYXRhOiBJREwuVmVjKExvZ01lc3NhZ2VzRGF0YSksXHJcbiAgICBsYXN0QW5hbHl6ZWRNZXNzYWdlVGltZU5hbm9zOiBJREwuT3B0KE5hbm9zKSxcclxuICB9KTtcclxuICBjb25zdCBDYW5pc3RlckxvZ1Jlc3BvbnNlID0gSURMLlZhcmlhbnQoe1xyXG4gICAgbWVzc2FnZXNJbmZvOiBDYW5pc3RlckxvZ01lc3NhZ2VzSW5mbyxcclxuICAgIG1lc3NhZ2VzOiBDYW5pc3RlckxvZ01lc3NhZ2VzLFxyXG4gIH0pO1xyXG4gIGNvbnN0IE1ldHJpY3NHcmFudWxhcml0eSA9IElETC5WYXJpYW50KHtcclxuICAgIGhvdXJseTogSURMLk51bGwsXHJcbiAgICBkYWlseTogSURMLk51bGwsXHJcbiAgfSk7XHJcbiAgY29uc3QgR2V0TWV0cmljc1BhcmFtZXRlcnMgPSBJREwuUmVjb3JkKHtcclxuICAgIGRhdGVUb01pbGxpczogSURMLk5hdCxcclxuICAgIGdyYW51bGFyaXR5OiBNZXRyaWNzR3JhbnVsYXJpdHksXHJcbiAgICBkYXRlRnJvbU1pbGxpczogSURMLk5hdCxcclxuICB9KTtcclxuICBjb25zdCBVcGRhdGVDYWxsc0FnZ3JlZ2F0ZWREYXRhID0gSURMLlZlYyhJREwuTmF0NjQpO1xyXG4gIGNvbnN0IENhbmlzdGVySGVhcE1lbW9yeUFnZ3JlZ2F0ZWREYXRhID0gSURMLlZlYyhJREwuTmF0NjQpO1xyXG4gIGNvbnN0IENhbmlzdGVyQ3ljbGVzQWdncmVnYXRlZERhdGEgPSBJREwuVmVjKElETC5OYXQ2NCk7XHJcbiAgY29uc3QgQ2FuaXN0ZXJNZW1vcnlBZ2dyZWdhdGVkRGF0YSA9IElETC5WZWMoSURMLk5hdDY0KTtcclxuICBjb25zdCBIb3VybHlNZXRyaWNzRGF0YSA9IElETC5SZWNvcmQoe1xyXG4gICAgdXBkYXRlQ2FsbHM6IFVwZGF0ZUNhbGxzQWdncmVnYXRlZERhdGEsXHJcbiAgICBjYW5pc3RlckhlYXBNZW1vcnlTaXplOiBDYW5pc3RlckhlYXBNZW1vcnlBZ2dyZWdhdGVkRGF0YSxcclxuICAgIGNhbmlzdGVyQ3ljbGVzOiBDYW5pc3RlckN5Y2xlc0FnZ3JlZ2F0ZWREYXRhLFxyXG4gICAgY2FuaXN0ZXJNZW1vcnlTaXplOiBDYW5pc3Rlck1lbW9yeUFnZ3JlZ2F0ZWREYXRhLFxyXG4gICAgdGltZU1pbGxpczogSURMLkludCxcclxuICB9KTtcclxuICBjb25zdCBOdW1lcmljRW50aXR5ID0gSURMLlJlY29yZCh7XHJcbiAgICBhdmc6IElETC5OYXQ2NCxcclxuICAgIG1heDogSURMLk5hdDY0LFxyXG4gICAgbWluOiBJREwuTmF0NjQsXHJcbiAgICBmaXJzdDogSURMLk5hdDY0LFxyXG4gICAgbGFzdDogSURMLk5hdDY0LFxyXG4gIH0pO1xyXG4gIGNvbnN0IERhaWx5TWV0cmljc0RhdGEgPSBJREwuUmVjb3JkKHtcclxuICAgIHVwZGF0ZUNhbGxzOiBJREwuTmF0NjQsXHJcbiAgICBjYW5pc3RlckhlYXBNZW1vcnlTaXplOiBOdW1lcmljRW50aXR5LFxyXG4gICAgY2FuaXN0ZXJDeWNsZXM6IE51bWVyaWNFbnRpdHksXHJcbiAgICBjYW5pc3Rlck1lbW9yeVNpemU6IE51bWVyaWNFbnRpdHksXHJcbiAgICB0aW1lTWlsbGlzOiBJREwuSW50LFxyXG4gIH0pO1xyXG4gIGNvbnN0IENhbmlzdGVyTWV0cmljc0RhdGEgPSBJREwuVmFyaWFudCh7XHJcbiAgICBob3VybHk6IElETC5WZWMoSG91cmx5TWV0cmljc0RhdGEpLFxyXG4gICAgZGFpbHk6IElETC5WZWMoRGFpbHlNZXRyaWNzRGF0YSksXHJcbiAgfSk7XHJcbiAgY29uc3QgQ2FuaXN0ZXJNZXRyaWNzID0gSURMLlJlY29yZCh7IGRhdGE6IENhbmlzdGVyTWV0cmljc0RhdGEgfSk7XHJcbiAgY29uc3QgT3JpZ3luVGV4dFJlc3VsdCA9IElETC5WYXJpYW50KHtcclxuICAgIG9rOiBJREwuVGV4dCxcclxuICAgIGVycjogT3JpZ3luRXJyb3IsXHJcbiAgfSk7XHJcbiAgY29uc3QgVGlwID0gSURMLlJlY29yZCh7XHJcbiAgICBsYXN0X2Jsb2NrX2luZGV4OiBJREwuVmVjKElETC5OYXQ4KSxcclxuICAgIGhhc2hfdHJlZTogSURMLlZlYyhJREwuTmF0OCksXHJcbiAgICBsYXN0X2Jsb2NrX2hhc2g6IElETC5WZWMoSURMLk5hdDgpLFxyXG4gIH0pO1xyXG4gIGNvbnN0IEdvdmVybmFuY2VSZXF1ZXN0ID0gSURMLlZhcmlhbnQoe1xyXG4gICAgdXBkYXRlX3N5c3RlbV92YXI6IElETC5SZWNvcmQoe1xyXG4gICAgICBrZXk6IElETC5UZXh0LFxyXG4gICAgICB2YWw6IENhbmR5U2hhcmVkLFxyXG4gICAgICB0b2tlbl9pZDogSURMLlRleHQsXHJcbiAgICB9KSxcclxuICAgIGNsZWFyX3NoYXJlZF93YWxsZXRzOiBJREwuVGV4dCxcclxuICB9KTtcclxuICBjb25zdCBHb3Zlcm5hbmNlUmVzcG9uc2UgPSBJREwuVmFyaWFudCh7XHJcbiAgICB1cGRhdGVfc3lzdGVtX3ZhcjogSURMLkJvb2wsXHJcbiAgICBjbGVhcl9zaGFyZWRfd2FsbGV0czogSURMLkJvb2wsXHJcbiAgfSk7XHJcbiAgY29uc3QgR292ZXJuYW5jZVJlc3VsdCA9IElETC5WYXJpYW50KHtcclxuICAgIG9rOiBHb3Zlcm5hbmNlUmVzcG9uc2UsXHJcbiAgICBlcnI6IE9yaWd5bkVycm9yLFxyXG4gIH0pO1xyXG4gIGNvbnN0IEhpc3RvcnlSZXN1bHQgPSBJREwuVmFyaWFudCh7XHJcbiAgICBvazogSURMLlZlYyhUcmFuc2FjdGlvblJlY29yZCksXHJcbiAgICBlcnI6IE9yaWd5bkVycm9yLFxyXG4gIH0pO1xyXG4gIGNvbnN0IEhlYWRlckZpZWxkID0gSURMLlR1cGxlKElETC5UZXh0LCBJREwuVGV4dCk7XHJcbiAgY29uc3QgSHR0cFJlcXVlc3QgPSBJREwuUmVjb3JkKHtcclxuICAgIHVybDogSURMLlRleHQsXHJcbiAgICBtZXRob2Q6IElETC5UZXh0LFxyXG4gICAgYm9keTogSURMLlZlYyhJREwuTmF0OCksXHJcbiAgICBoZWFkZXJzOiBJREwuVmVjKEhlYWRlckZpZWxkKSxcclxuICB9KTtcclxuICBjb25zdCBTdHJlYW1pbmdDYWxsYmFja1Rva2VuID0gSURMLlJlY29yZCh7XHJcbiAgICBrZXk6IElETC5UZXh0LFxyXG4gICAgaW5kZXg6IElETC5OYXQsXHJcbiAgICBjb250ZW50X2VuY29kaW5nOiBJREwuVGV4dCxcclxuICB9KTtcclxuICBjb25zdCBTdHJlYW1pbmdTdHJhdGVneSA9IElETC5WYXJpYW50KHtcclxuICAgIENhbGxiYWNrOiBJREwuUmVjb3JkKHtcclxuICAgICAgdG9rZW46IFN0cmVhbWluZ0NhbGxiYWNrVG9rZW4sXHJcbiAgICAgIGNhbGxiYWNrOiBJREwuRnVuYyhbXSwgW10sIFtdKSxcclxuICAgIH0pLFxyXG4gIH0pO1xyXG4gIGNvbnN0IEhUVFBSZXNwb25zZSA9IElETC5SZWNvcmQoe1xyXG4gICAgYm9keTogSURMLlZlYyhJREwuTmF0OCksXHJcbiAgICBoZWFkZXJzOiBJREwuVmVjKEhlYWRlckZpZWxkKSxcclxuICAgIHN0cmVhbWluZ19zdHJhdGVneTogSURMLk9wdChTdHJlYW1pbmdTdHJhdGVneSksXHJcbiAgICBzdGF0dXNfY29kZTogSURMLk5hdDE2LFxyXG4gIH0pO1xyXG4gIGNvbnN0IFN0cmVhbWluZ0NhbGxiYWNrUmVzcG9uc2UgPSBJREwuUmVjb3JkKHtcclxuICAgIHRva2VuOiBJREwuT3B0KFN0cmVhbWluZ0NhbGxiYWNrVG9rZW4pLFxyXG4gICAgYm9keTogSURMLlZlYyhJREwuTmF0OCksXHJcbiAgfSk7XHJcbiAgY29uc3QgR2V0QXJjaGl2ZXNBcmdzID0gSURMLlJlY29yZCh7IGZyb206IElETC5PcHQoSURMLlByaW5jaXBhbCkgfSk7XHJcbiAgY29uc3QgR2V0QXJjaGl2ZXNSZXN1bHRJdGVtID0gSURMLlJlY29yZCh7XHJcbiAgICBlbmQ6IElETC5OYXQsXHJcbiAgICBjYW5pc3Rlcl9pZDogSURMLlByaW5jaXBhbCxcclxuICAgIHN0YXJ0OiBJREwuTmF0LFxyXG4gIH0pO1xyXG4gIGNvbnN0IEdldEFyY2hpdmVzUmVzdWx0ID0gSURMLlZlYyhHZXRBcmNoaXZlc1Jlc3VsdEl0ZW0pO1xyXG4gIGNvbnN0IFRyYW5zYWN0aW9uUmFuZ2UgPSBJREwuUmVjb3JkKHtcclxuICAgIHN0YXJ0OiBJREwuTmF0LFxyXG4gICAgbGVuZ3RoOiBJREwuTmF0LFxyXG4gIH0pO1xyXG4gIFZhbHVlX18xLmZpbGwoXHJcbiAgICBJREwuVmFyaWFudCh7XHJcbiAgICAgIEludDogSURMLkludCxcclxuICAgICAgTWFwOiBJREwuVmVjKElETC5UdXBsZShJREwuVGV4dCwgVmFsdWVfXzEpKSxcclxuICAgICAgTmF0OiBJREwuTmF0LFxyXG4gICAgICBCbG9iOiBJREwuVmVjKElETC5OYXQ4KSxcclxuICAgICAgVGV4dDogSURMLlRleHQsXHJcbiAgICAgIEFycmF5OiBJREwuVmVjKFZhbHVlX18xKSxcclxuICAgIH0pXHJcbiAgKTtcclxuICBjb25zdCBUcmFuc2FjdGlvblJhbmdlX18xID0gSURMLlJlY29yZCh7XHJcbiAgICBzdGFydDogSURMLk5hdCxcclxuICAgIGxlbmd0aDogSURMLk5hdCxcclxuICB9KTtcclxuICBjb25zdCBHZXRUcmFuc2FjdGlvbnNSZXN1bHRfXzEgPSBJREwuUmVjb3JkKHtcclxuICAgIGxvZ19sZW5ndGg6IElETC5OYXQsXHJcbiAgICBibG9ja3M6IElETC5WZWMoSURMLlJlY29yZCh7IGlkOiBJREwuTmF0LCBibG9jazogVmFsdWVfXzEgfSkpLFxyXG4gICAgYXJjaGl2ZWRfYmxvY2tzOiBJREwuVmVjKEFyY2hpdmVkVHJhbnNhY3Rpb25SZXNwb25zZSksXHJcbiAgfSk7XHJcbiAgY29uc3QgR2V0VHJhbnNhY3Rpb25zRm4gPSBJREwuRnVuYyhcclxuICAgIFtJREwuVmVjKFRyYW5zYWN0aW9uUmFuZ2VfXzEpXSxcclxuICAgIFtHZXRUcmFuc2FjdGlvbnNSZXN1bHRfXzFdLFxyXG4gICAgW1wicXVlcnlcIl1cclxuICApO1xyXG4gIEFyY2hpdmVkVHJhbnNhY3Rpb25SZXNwb25zZS5maWxsKFxyXG4gICAgSURMLlJlY29yZCh7XHJcbiAgICAgIGFyZ3M6IElETC5WZWMoVHJhbnNhY3Rpb25SYW5nZV9fMSksXHJcbiAgICAgIGNhbGxiYWNrOiBHZXRUcmFuc2FjdGlvbnNGbixcclxuICAgIH0pXHJcbiAgKTtcclxuICBjb25zdCBHZXRUcmFuc2FjdGlvbnNSZXN1bHQgPSBJREwuUmVjb3JkKHtcclxuICAgIGxvZ19sZW5ndGg6IElETC5OYXQsXHJcbiAgICBibG9ja3M6IElETC5WZWMoSURMLlJlY29yZCh7IGlkOiBJREwuTmF0LCBibG9jazogVmFsdWVfXzEgfSkpLFxyXG4gICAgYXJjaGl2ZWRfYmxvY2tzOiBJREwuVmVjKEFyY2hpdmVkVHJhbnNhY3Rpb25SZXNwb25zZSksXHJcbiAgfSk7XHJcbiAgY29uc3QgRGF0YUNlcnRpZmljYXRlID0gSURMLlJlY29yZCh7XHJcbiAgICBjZXJ0aWZpY2F0ZTogSURMLlZlYyhJREwuTmF0OCksXHJcbiAgICBoYXNoX3RyZWU6IElETC5WZWMoSURMLk5hdDgpLFxyXG4gIH0pO1xyXG4gIGNvbnN0IEJsb2NrVHlwZSA9IElETC5SZWNvcmQoeyB1cmw6IElETC5UZXh0LCBibG9ja190eXBlOiBJREwuVGV4dCB9KTtcclxuICBjb25zdCBBcHByb3ZhbEFyZ3MgPSBJREwuUmVjb3JkKHtcclxuICAgIG1lbW86IElETC5PcHQoSURMLlZlYyhJREwuTmF0OCkpLFxyXG4gICAgZnJvbV9zdWJhY2NvdW50OiBJREwuT3B0KElETC5WZWMoSURMLk5hdDgpKSxcclxuICAgIGNyZWF0ZWRfYXRfdGltZTogSURMLk9wdChJREwuTmF0NjQpLFxyXG4gICAgZXhwaXJlc19hdDogSURMLk9wdChJREwuTmF0NjQpLFxyXG4gICAgc3BlbmRlcjogQWNjb3VudCxcclxuICB9KTtcclxuICBjb25zdCBBcHByb3ZhbEVycm9yID0gSURMLlZhcmlhbnQoe1xyXG4gICAgR2VuZXJpY0Vycm9yOiBJREwuUmVjb3JkKHtcclxuICAgICAgbWVzc2FnZTogSURMLlRleHQsXHJcbiAgICAgIGVycm9yX2NvZGU6IElETC5OYXQsXHJcbiAgICB9KSxcclxuICAgIENyZWF0ZXhJbkZ1dHVyZTogSURMLlJlY29yZCh7IGxlZGdlcl90aW1lOiBJREwuTmF0NjQgfSksXHJcbiAgICBOb25FeGlzdGluZ1Rva2VuSWQ6IElETC5OdWxsLFxyXG4gICAgVW5hdXRob3JpemVkOiBJREwuTnVsbCxcclxuICAgIFRvb09sZDogSURMLk51bGwsXHJcbiAgfSk7XHJcbiAgY29uc3QgQXBwcm92YWxSZXN1bHQgPSBJREwuVmVjKFxyXG4gICAgSURMLlJlY29yZCh7XHJcbiAgICAgIHRva2VuX2lkOiBJREwuTmF0LFxyXG4gICAgICBhcHByb3ZhbF9yZXN1bHQ6IElETC5WYXJpYW50KHtcclxuICAgICAgICBPazogSURMLk5hdCxcclxuICAgICAgICBFcnI6IEFwcHJvdmFsRXJyb3IsXHJcbiAgICAgIH0pLFxyXG4gICAgfSlcclxuICApO1xyXG4gIFZhbHVlLmZpbGwoXHJcbiAgICBJREwuVmFyaWFudCh7XHJcbiAgICAgIEludDogSURMLkludCxcclxuICAgICAgTWFwOiBJREwuVmVjKElETC5UdXBsZShJREwuVGV4dCwgVmFsdWUpKSxcclxuICAgICAgTmF0OiBJREwuTmF0LFxyXG4gICAgICBCbG9iOiBJREwuVmVjKElETC5OYXQ4KSxcclxuICAgICAgVGV4dDogSURMLlRleHQsXHJcbiAgICAgIEFycmF5OiBJREwuVmVjKFZhbHVlKSxcclxuICAgIH0pXHJcbiAgKTtcclxuICBjb25zdCBDb2xsZWN0aW9uTWV0YWRhdGEgPSBJREwuVmVjKElETC5UdXBsZShJREwuVGV4dCwgVmFsdWUpKTtcclxuICBjb25zdCBTdXBwb3J0ZWRTdGFuZGFyZCA9IElETC5SZWNvcmQoeyB1cmw6IElETC5UZXh0LCBuYW1lOiBJREwuVGV4dCB9KTtcclxuICBjb25zdCBUcmFuc2ZlckFyZ3MgPSBJREwuUmVjb3JkKHtcclxuICAgIHRvOiBBY2NvdW50LFxyXG4gICAgdG9rZW5faWQ6IElETC5OYXQsXHJcbiAgICBtZW1vOiBJREwuT3B0KElETC5WZWMoSURMLk5hdDgpKSxcclxuICAgIGZyb21fc3ViYWNjb3VudDogSURMLk9wdChJREwuVmVjKElETC5OYXQ4KSksXHJcbiAgICBjcmVhdGVkX2F0X3RpbWU6IElETC5PcHQoSURMLk5hdDY0KSxcclxuICB9KTtcclxuICBjb25zdCBUcmFuc2ZlckVycm9yID0gSURMLlZhcmlhbnQoe1xyXG4gICAgR2VuZXJpY0Vycm9yOiBJREwuUmVjb3JkKHtcclxuICAgICAgbWVzc2FnZTogSURMLlRleHQsXHJcbiAgICAgIGVycm9yX2NvZGU6IElETC5OYXQsXHJcbiAgICB9KSxcclxuICAgIER1cGxpY2F0ZTogSURMLlJlY29yZCh7IGR1cGxpY2F0ZV9vZjogSURMLk5hdCB9KSxcclxuICAgIE5vbkV4aXN0aW5nVG9rZW5JZDogSURMLk51bGwsXHJcbiAgICBVbmF1dGhvcml6ZWQ6IElETC5OdWxsLFxyXG4gICAgQ3JlYXRlZEluRnV0dXJlOiBJREwuUmVjb3JkKHsgbGVkZ2VyX3RpbWU6IElETC5OYXQ2NCB9KSxcclxuICAgIFRvb09sZDogSURMLk51bGwsXHJcbiAgfSk7XHJcbiAgY29uc3QgVHJhbnNmZXJSZXN1bHRJdGVtID0gSURMLlJlY29yZCh7XHJcbiAgICB0b2tlbl9pZDogSURMLk5hdCxcclxuICAgIHRyYW5zZmVyX3Jlc3VsdDogSURMLlZhcmlhbnQoeyBPazogSURMLk5hdCwgRXJyOiBUcmFuc2ZlckVycm9yIH0pLFxyXG4gIH0pO1xyXG4gIGNvbnN0IFRyYW5zZmVyUmVzdWx0ID0gSURMLlZlYyhJREwuT3B0KFRyYW5zZmVyUmVzdWx0SXRlbSkpO1xyXG4gIGNvbnN0IE1hbmFnZVN0b3JhZ2VSZXF1ZXN0ID0gSURMLlZhcmlhbnQoe1xyXG4gICAgYWRkX3N0b3JhZ2VfY2FuaXN0ZXJzOiBJREwuVmVjKFxyXG4gICAgICBJREwuVHVwbGUoSURMLlByaW5jaXBhbCwgSURMLk5hdCwgSURMLlR1cGxlKElETC5OYXQsIElETC5OYXQsIElETC5OYXQpKVxyXG4gICAgKSxcclxuICAgIGNvbmZpZ3VyZV9zdG9yYWdlOiBJREwuVmFyaWFudCh7XHJcbiAgICAgIHN0YWJsZUJ0cmVlOiBJREwuT3B0KElETC5OYXQpLFxyXG4gICAgICBoZWFwOiBJREwuT3B0KElETC5OYXQpLFxyXG4gICAgfSksXHJcbiAgfSk7XHJcbiAgY29uc3QgTWFuYWdlU3RvcmFnZVJlc3BvbnNlID0gSURMLlZhcmlhbnQoe1xyXG4gICAgYWRkX3N0b3JhZ2VfY2FuaXN0ZXJzOiBJREwuVHVwbGUoSURMLk5hdCwgSURMLk5hdCksXHJcbiAgICBjb25maWd1cmVfc3RvcmFnZTogSURMLlR1cGxlKElETC5OYXQsIElETC5OYXQpLFxyXG4gIH0pO1xyXG4gIGNvbnN0IE1hbmFnZVN0b3JhZ2VSZXN1bHQgPSBJREwuVmFyaWFudCh7XHJcbiAgICBvazogTWFuYWdlU3RvcmFnZVJlc3BvbnNlLFxyXG4gICAgZXJyOiBPcmlneW5FcnJvcixcclxuICB9KTtcclxuICBjb25zdCBFc2Nyb3dSZWNlaXB0X18xID0gSURMLlJlY29yZCh7XHJcbiAgICB0b2tlbjogVG9rZW5TcGVjLFxyXG4gICAgdG9rZW5faWQ6IElETC5UZXh0LFxyXG4gICAgc2VsbGVyOiBBY2NvdW50X18yLFxyXG4gICAgYnV5ZXI6IEFjY291bnRfXzIsXHJcbiAgICBhbW91bnQ6IElETC5OYXQsXHJcbiAgfSk7XHJcbiAgY29uc3QgU2FsZXNDb25maWcgPSBJREwuUmVjb3JkKHtcclxuICAgIGJyb2tlcl9pZDogSURMLk9wdChBY2NvdW50X18yKSxcclxuICAgIHByaWNpbmc6IFByaWNpbmdDb25maWdTaGFyZWQsXHJcbiAgICBlc2Nyb3dfcmVjZWlwdDogSURMLk9wdChFc2Nyb3dSZWNlaXB0X18xKSxcclxuICB9KTtcclxuICBjb25zdCBNYXJrZXRUcmFuc2ZlclJlcXVlc3QgPSBJREwuUmVjb3JkKHtcclxuICAgIHRva2VuX2lkOiBJREwuVGV4dCxcclxuICAgIHNhbGVzX2NvbmZpZzogU2FsZXNDb25maWcsXHJcbiAgfSk7XHJcbiAgY29uc3QgTWFya2V0VHJhbnNmZXJSZXF1ZXN0UmVwb25zZSA9IElETC5SZWNvcmQoe1xyXG4gICAgdG9rZW5faWQ6IElETC5UZXh0LFxyXG4gICAgdHhuX3R5cGU6IElETC5WYXJpYW50KHtcclxuICAgICAgZXNjcm93X2RlcG9zaXQ6IElETC5SZWNvcmQoe1xyXG4gICAgICAgIHRva2VuOiBUb2tlblNwZWMsXHJcbiAgICAgICAgdG9rZW5faWQ6IElETC5UZXh0LFxyXG4gICAgICAgIHRyeF9pZDogVHJhbnNhY3Rpb25JRCxcclxuICAgICAgICBzZWxsZXI6IEFjY291bnRfXzIsXHJcbiAgICAgICAgZXh0ZW5zaWJsZTogQ2FuZHlTaGFyZWQsXHJcbiAgICAgICAgYnV5ZXI6IEFjY291bnRfXzIsXHJcbiAgICAgICAgYW1vdW50OiBJREwuTmF0LFxyXG4gICAgICB9KSxcclxuICAgICAgZmVlX2RlcG9zaXQ6IElETC5SZWNvcmQoe1xyXG4gICAgICAgIHRva2VuOiBUb2tlblNwZWMsXHJcbiAgICAgICAgZXh0ZW5zaWJsZTogQ2FuZHlTaGFyZWQsXHJcbiAgICAgICAgYWNjb3VudDogQWNjb3VudF9fMixcclxuICAgICAgICBhbW91bnQ6IElETC5OYXQsXHJcbiAgICAgIH0pLFxyXG4gICAgICBjYW5pc3Rlcl9uZXR3b3JrX3VwZGF0ZWQ6IElETC5SZWNvcmQoe1xyXG4gICAgICAgIG5ldHdvcms6IElETC5QcmluY2lwYWwsXHJcbiAgICAgICAgZXh0ZW5zaWJsZTogQ2FuZHlTaGFyZWQsXHJcbiAgICAgIH0pLFxyXG4gICAgICBlc2Nyb3dfd2l0aGRyYXc6IElETC5SZWNvcmQoe1xyXG4gICAgICAgIGZlZTogSURMLk5hdCxcclxuICAgICAgICB0b2tlbjogVG9rZW5TcGVjLFxyXG4gICAgICAgIHRva2VuX2lkOiBJREwuVGV4dCxcclxuICAgICAgICB0cnhfaWQ6IFRyYW5zYWN0aW9uSUQsXHJcbiAgICAgICAgc2VsbGVyOiBBY2NvdW50X18yLFxyXG4gICAgICAgIGV4dGVuc2libGU6IENhbmR5U2hhcmVkLFxyXG4gICAgICAgIGJ1eWVyOiBBY2NvdW50X18yLFxyXG4gICAgICAgIGFtb3VudDogSURMLk5hdCxcclxuICAgICAgfSksXHJcbiAgICAgIGNhbmlzdGVyX21hbmFnZXJzX3VwZGF0ZWQ6IElETC5SZWNvcmQoe1xyXG4gICAgICAgIG1hbmFnZXJzOiBJREwuVmVjKElETC5QcmluY2lwYWwpLFxyXG4gICAgICAgIGV4dGVuc2libGU6IENhbmR5U2hhcmVkLFxyXG4gICAgICB9KSxcclxuICAgICAgYXVjdGlvbl9iaWQ6IElETC5SZWNvcmQoe1xyXG4gICAgICAgIHRva2VuOiBUb2tlblNwZWMsXHJcbiAgICAgICAgZXh0ZW5zaWJsZTogQ2FuZHlTaGFyZWQsXHJcbiAgICAgICAgYnV5ZXI6IEFjY291bnRfXzIsXHJcbiAgICAgICAgYW1vdW50OiBJREwuTmF0LFxyXG4gICAgICAgIHNhbGVfaWQ6IElETC5UZXh0LFxyXG4gICAgICB9KSxcclxuICAgICAgYnVybjogSURMLlJlY29yZCh7XHJcbiAgICAgICAgZnJvbTogSURMLk9wdChBY2NvdW50X18yKSxcclxuICAgICAgICBleHRlbnNpYmxlOiBDYW5keVNoYXJlZCxcclxuICAgICAgfSksXHJcbiAgICAgIGRhdGE6IElETC5SZWNvcmQoe1xyXG4gICAgICAgIGhhc2g6IElETC5PcHQoSURMLlZlYyhJREwuTmF0OCkpLFxyXG4gICAgICAgIGV4dGVuc2libGU6IENhbmR5U2hhcmVkLFxyXG4gICAgICAgIGRhdGFfZGFwcDogSURMLk9wdChJREwuVGV4dCksXHJcbiAgICAgICAgZGF0YV9wYXRoOiBJREwuT3B0KElETC5UZXh0KSxcclxuICAgICAgfSksXHJcbiAgICAgIHNhbGVfZW5kZWQ6IElETC5SZWNvcmQoe1xyXG4gICAgICAgIHRva2VuOiBUb2tlblNwZWMsXHJcbiAgICAgICAgc2VsbGVyOiBBY2NvdW50X18yLFxyXG4gICAgICAgIGV4dGVuc2libGU6IENhbmR5U2hhcmVkLFxyXG4gICAgICAgIGJ1eWVyOiBBY2NvdW50X18yLFxyXG4gICAgICAgIGFtb3VudDogSURMLk5hdCxcclxuICAgICAgICBzYWxlX2lkOiBJREwuT3B0KElETC5UZXh0KSxcclxuICAgICAgfSksXHJcbiAgICAgIG1pbnQ6IElETC5SZWNvcmQoe1xyXG4gICAgICAgIHRvOiBBY2NvdW50X18yLFxyXG4gICAgICAgIGZyb206IEFjY291bnRfXzIsXHJcbiAgICAgICAgc2FsZTogSURMLk9wdChJREwuUmVjb3JkKHsgdG9rZW46IFRva2VuU3BlYywgYW1vdW50OiBJREwuTmF0IH0pKSxcclxuICAgICAgICBleHRlbnNpYmxlOiBDYW5keVNoYXJlZCxcclxuICAgICAgfSksXHJcbiAgICAgIHJveWFsdHlfcGFpZDogSURMLlJlY29yZCh7XHJcbiAgICAgICAgdGFnOiBJREwuVGV4dCxcclxuICAgICAgICB0b2tlbjogVG9rZW5TcGVjLFxyXG4gICAgICAgIHNlbGxlcjogQWNjb3VudF9fMixcclxuICAgICAgICBleHRlbnNpYmxlOiBDYW5keVNoYXJlZCxcclxuICAgICAgICBidXllcjogQWNjb3VudF9fMixcclxuICAgICAgICBhbW91bnQ6IElETC5OYXQsXHJcbiAgICAgICAgcmVjZWl2ZXI6IEFjY291bnRfXzIsXHJcbiAgICAgICAgc2FsZV9pZDogSURMLk9wdChJREwuVGV4dCksXHJcbiAgICAgIH0pLFxyXG4gICAgICBleHRlbnNpYmxlOiBDYW5keVNoYXJlZCxcclxuICAgICAgZmVlX2RlcG9zaXRfd2l0aGRyYXc6IElETC5SZWNvcmQoe1xyXG4gICAgICAgIGZlZTogSURMLk5hdCxcclxuICAgICAgICB0b2tlbjogVG9rZW5TcGVjLFxyXG4gICAgICAgIHRyeF9pZDogVHJhbnNhY3Rpb25JRCxcclxuICAgICAgICBleHRlbnNpYmxlOiBDYW5keVNoYXJlZCxcclxuICAgICAgICBhY2NvdW50OiBBY2NvdW50X18yLFxyXG4gICAgICAgIGFtb3VudDogSURMLk5hdCxcclxuICAgICAgfSksXHJcbiAgICAgIG93bmVyX3RyYW5zZmVyOiBJREwuUmVjb3JkKHtcclxuICAgICAgICB0bzogQWNjb3VudF9fMixcclxuICAgICAgICBmcm9tOiBBY2NvdW50X18yLFxyXG4gICAgICAgIGV4dGVuc2libGU6IENhbmR5U2hhcmVkLFxyXG4gICAgICB9KSxcclxuICAgICAgc2FsZV9vcGVuZWQ6IElETC5SZWNvcmQoe1xyXG4gICAgICAgIHByaWNpbmc6IFByaWNpbmdDb25maWdTaGFyZWQsXHJcbiAgICAgICAgZXh0ZW5zaWJsZTogQ2FuZHlTaGFyZWQsXHJcbiAgICAgICAgc2FsZV9pZDogSURMLlRleHQsXHJcbiAgICAgIH0pLFxyXG4gICAgICBjYW5pc3Rlcl9vd25lcl91cGRhdGVkOiBJREwuUmVjb3JkKHtcclxuICAgICAgICBvd25lcjogSURMLlByaW5jaXBhbCxcclxuICAgICAgICBleHRlbnNpYmxlOiBDYW5keVNoYXJlZCxcclxuICAgICAgfSksXHJcbiAgICAgIHNhbGVfd2l0aGRyYXc6IElETC5SZWNvcmQoe1xyXG4gICAgICAgIGZlZTogSURMLk5hdCxcclxuICAgICAgICB0b2tlbjogVG9rZW5TcGVjLFxyXG4gICAgICAgIHRva2VuX2lkOiBJREwuVGV4dCxcclxuICAgICAgICB0cnhfaWQ6IFRyYW5zYWN0aW9uSUQsXHJcbiAgICAgICAgc2VsbGVyOiBBY2NvdW50X18yLFxyXG4gICAgICAgIGV4dGVuc2libGU6IENhbmR5U2hhcmVkLFxyXG4gICAgICAgIGJ1eWVyOiBBY2NvdW50X18yLFxyXG4gICAgICAgIGFtb3VudDogSURMLk5hdCxcclxuICAgICAgfSksXHJcbiAgICAgIGRlcG9zaXRfd2l0aGRyYXc6IElETC5SZWNvcmQoe1xyXG4gICAgICAgIGZlZTogSURMLk5hdCxcclxuICAgICAgICB0b2tlbjogVG9rZW5TcGVjLFxyXG4gICAgICAgIHRyeF9pZDogVHJhbnNhY3Rpb25JRCxcclxuICAgICAgICBleHRlbnNpYmxlOiBDYW5keVNoYXJlZCxcclxuICAgICAgICBidXllcjogQWNjb3VudF9fMixcclxuICAgICAgICBhbW91bnQ6IElETC5OYXQsXHJcbiAgICAgIH0pLFxyXG4gICAgfSksXHJcbiAgICB0aW1lc3RhbXA6IElETC5JbnQsXHJcbiAgICBpbmRleDogSURMLk5hdCxcclxuICB9KTtcclxuICBjb25zdCBNYXJrZXRUcmFuc2ZlclJlc3VsdCA9IElETC5WYXJpYW50KHtcclxuICAgIG9rOiBNYXJrZXRUcmFuc2ZlclJlcXVlc3RSZXBvbnNlLFxyXG4gICAgZXJyOiBPcmlneW5FcnJvcixcclxuICB9KTtcclxuICBjb25zdCBFWFRNZXRhZGF0YSA9IElETC5WYXJpYW50KHtcclxuICAgIGZ1bmdpYmxlOiBJREwuUmVjb3JkKHtcclxuICAgICAgZGVjaW1hbHM6IElETC5OYXQ4LFxyXG4gICAgICBtZXRhZGF0YTogSURMLk9wdChJREwuVmVjKElETC5OYXQ4KSksXHJcbiAgICAgIG5hbWU6IElETC5UZXh0LFxyXG4gICAgICBzeW1ib2w6IElETC5UZXh0LFxyXG4gICAgfSksXHJcbiAgICBub25mdW5naWJsZTogSURMLlJlY29yZCh7IG1ldGFkYXRhOiBJREwuT3B0KElETC5WZWMoSURMLk5hdDgpKSB9KSxcclxuICB9KTtcclxuICBjb25zdCBFWFRNZXRhZGF0YVJlc3VsdCA9IElETC5WYXJpYW50KHtcclxuICAgIG9rOiBFWFRNZXRhZGF0YSxcclxuICAgIGVycjogRVhUQ29tbW9uRXJyb3IsXHJcbiAgfSk7XHJcbiAgY29uc3QgTkZUSW5mb1N0YWJsZSA9IElETC5SZWNvcmQoe1xyXG4gICAgbWV0YWRhdGE6IENhbmR5U2hhcmVkLFxyXG4gICAgY3VycmVudF9zYWxlOiBJREwuT3B0KFNhbGVTdGF0dXNTaGFyZWQpLFxyXG4gIH0pO1xyXG4gIGNvbnN0IE5GVEluZm9SZXN1bHQgPSBJREwuVmFyaWFudCh7XHJcbiAgICBvazogTkZUSW5mb1N0YWJsZSxcclxuICAgIGVycjogT3JpZ3luRXJyb3IsXHJcbiAgfSk7XHJcbiAgY29uc3QgVG9rZW5TcGVjX18yID0gSURMLlZhcmlhbnQoe1xyXG4gICAgaWM6IElDVG9rZW5TcGVjLFxyXG4gICAgZXh0ZW5zaWJsZTogQ2FuZHlTaGFyZWQsXHJcbiAgfSk7XHJcbiAgY29uc3QgQWNjb3VudF9fMyA9IElETC5WYXJpYW50KHtcclxuICAgIGFjY291bnRfaWQ6IElETC5UZXh0LFxyXG4gICAgcHJpbmNpcGFsOiBJREwuUHJpbmNpcGFsLFxyXG4gICAgZXh0ZW5zaWJsZTogQ2FuZHlTaGFyZWQsXHJcbiAgICBhY2NvdW50OiBJREwuUmVjb3JkKHtcclxuICAgICAgb3duZXI6IElETC5QcmluY2lwYWwsXHJcbiAgICAgIHN1Yl9hY2NvdW50OiBJREwuT3B0KElETC5WZWMoSURMLk5hdDgpKSxcclxuICAgIH0pLFxyXG4gIH0pO1xyXG4gIGNvbnN0IEVzY3Jvd1JlY29yZCA9IElETC5SZWNvcmQoe1xyXG4gICAgdG9rZW46IFRva2VuU3BlY19fMixcclxuICAgIHRva2VuX2lkOiBJREwuVGV4dCxcclxuICAgIHNlbGxlcjogQWNjb3VudF9fMyxcclxuICAgIGxvY2tfdG9fZGF0ZTogSURMLk9wdChJREwuSW50KSxcclxuICAgIGJ1eWVyOiBBY2NvdW50X18zLFxyXG4gICAgYW1vdW50OiBJREwuTmF0LFxyXG4gICAgc2FsZV9pZDogSURMLk9wdChJREwuVGV4dCksXHJcbiAgICBhY2NvdW50X2hhc2g6IElETC5PcHQoSURMLlZlYyhJREwuTmF0OCkpLFxyXG4gIH0pO1xyXG4gIGNvbnN0IEJpZFJlcXVlc3QgPSBJREwuUmVjb3JkKHtcclxuICAgIGNvbmZpZzogQmlkQ29uZmlnU2hhcmVkLFxyXG4gICAgZXNjcm93X3JlY29yZDogRXNjcm93UmVjb3JkLFxyXG4gIH0pO1xyXG4gIGNvbnN0IFRyYW5zYWN0aW9uSURfXzEgPSBJREwuVmFyaWFudCh7XHJcbiAgICBuYXQ6IElETC5OYXQsXHJcbiAgICB0ZXh0OiBJREwuVGV4dCxcclxuICAgIGV4dGVuc2libGU6IENhbmR5U2hhcmVkLFxyXG4gIH0pO1xyXG4gIGNvbnN0IERlcG9zaXREZXRhaWwgPSBJREwuUmVjb3JkKHtcclxuICAgIHRva2VuOiBUb2tlblNwZWNfXzEsXHJcbiAgICB0cnhfaWQ6IElETC5PcHQoVHJhbnNhY3Rpb25JRF9fMSksXHJcbiAgICBzZWxsZXI6IEFjY291bnRfXzEsXHJcbiAgICBidXllcjogQWNjb3VudF9fMSxcclxuICAgIGFtb3VudDogSURMLk5hdCxcclxuICAgIHNhbGVfaWQ6IElETC5PcHQoSURMLlRleHQpLFxyXG4gIH0pO1xyXG4gIGNvbnN0IEVzY3Jvd1JlcXVlc3QgPSBJREwuUmVjb3JkKHtcclxuICAgIHRva2VuX2lkOiBJREwuVGV4dCxcclxuICAgIGRlcG9zaXQ6IERlcG9zaXREZXRhaWwsXHJcbiAgICBsb2NrX3RvX2RhdGU6IElETC5PcHQoSURMLkludCksXHJcbiAgfSk7XHJcbiAgY29uc3QgRmVlRGVwb3NpdFJlcXVlc3QgPSBJREwuUmVjb3JkKHtcclxuICAgIHRva2VuOiBUb2tlblNwZWNfXzEsXHJcbiAgICBhY2NvdW50OiBBY2NvdW50X18xLFxyXG4gIH0pO1xyXG4gIGNvbnN0IFJlamVjdERlc2NyaXB0aW9uID0gSURMLlJlY29yZCh7XHJcbiAgICB0b2tlbjogVG9rZW5TcGVjX18xLFxyXG4gICAgdG9rZW5faWQ6IElETC5UZXh0LFxyXG4gICAgc2VsbGVyOiBBY2NvdW50X18xLFxyXG4gICAgYnV5ZXI6IEFjY291bnRfXzEsXHJcbiAgfSk7XHJcbiAgY29uc3QgRmVlRGVwb3NpdFdpdGhkcmF3RGVzY3JpcHRpb24gPSBJREwuUmVjb3JkKHtcclxuICAgIHN0YXR1czogSURMLlZhcmlhbnQoe1xyXG4gICAgICBsb2NrZWQ6IElETC5SZWNvcmQoeyB0b2tlbl9pZDogSURMLlRleHQsIHNhbGVfaWQ6IElETC5UZXh0IH0pLFxyXG4gICAgICB1bmxvY2tlZDogSURMLk51bGwsXHJcbiAgICB9KSxcclxuICAgIHRva2VuOiBUb2tlblNwZWNfXzEsXHJcbiAgICB3aXRoZHJhd190bzogQWNjb3VudF9fMSxcclxuICAgIGFjY291bnQ6IEFjY291bnRfXzEsXHJcbiAgICBhbW91bnQ6IElETC5OYXQsXHJcbiAgfSk7XHJcbiAgY29uc3QgV2l0aGRyYXdEZXNjcmlwdGlvbiA9IElETC5SZWNvcmQoe1xyXG4gICAgdG9rZW46IFRva2VuU3BlY19fMSxcclxuICAgIHRva2VuX2lkOiBJREwuVGV4dCxcclxuICAgIHNlbGxlcjogQWNjb3VudF9fMSxcclxuICAgIHdpdGhkcmF3X3RvOiBBY2NvdW50X18xLFxyXG4gICAgYnV5ZXI6IEFjY291bnRfXzEsXHJcbiAgICBhbW91bnQ6IElETC5OYXQsXHJcbiAgfSk7XHJcbiAgY29uc3QgRGVwb3NpdFdpdGhkcmF3RGVzY3JpcHRpb24gPSBJREwuUmVjb3JkKHtcclxuICAgIHRva2VuOiBUb2tlblNwZWNfXzEsXHJcbiAgICB3aXRoZHJhd190bzogQWNjb3VudF9fMSxcclxuICAgIGJ1eWVyOiBBY2NvdW50X18xLFxyXG4gICAgYW1vdW50OiBJREwuTmF0LFxyXG4gIH0pO1xyXG4gIGNvbnN0IFdpdGhkcmF3UmVxdWVzdCA9IElETC5WYXJpYW50KHtcclxuICAgIHJlamVjdDogUmVqZWN0RGVzY3JpcHRpb24sXHJcbiAgICBmZWVfZGVwb3NpdDogRmVlRGVwb3NpdFdpdGhkcmF3RGVzY3JpcHRpb24sXHJcbiAgICBzYWxlOiBXaXRoZHJhd0Rlc2NyaXB0aW9uLFxyXG4gICAgZGVwb3NpdDogRGVwb3NpdFdpdGhkcmF3RGVzY3JpcHRpb24sXHJcbiAgICBlc2Nyb3c6IFdpdGhkcmF3RGVzY3JpcHRpb24sXHJcbiAgfSk7XHJcbiAgY29uc3QgVG9rZW5TcGVjRmlsdGVyID0gSURMLlJlY29yZCh7XHJcbiAgICB0b2tlbjogVG9rZW5TcGVjX18xLFxyXG4gICAgZmlsdGVyX3R5cGU6IElETC5WYXJpYW50KHsgYWxsb3c6IElETC5OdWxsLCBibG9jazogSURMLk51bGwgfSksXHJcbiAgfSk7XHJcbiAgY29uc3QgVG9rZW5JREZpbHRlciA9IElETC5SZWNvcmQoe1xyXG4gICAgZmlsdGVyX3R5cGU6IElETC5WYXJpYW50KHsgYWxsb3c6IElETC5OdWxsLCBibG9jazogSURMLk51bGwgfSksXHJcbiAgICB0b2tlbl9pZDogSURMLlRleHQsXHJcbiAgICB0b2tlbnM6IElETC5WZWMoXHJcbiAgICAgIElETC5SZWNvcmQoe1xyXG4gICAgICAgIHRva2VuOiBUb2tlblNwZWNfXzEsXHJcbiAgICAgICAgbWluX2Ftb3VudDogSURMLk9wdChJREwuTmF0KSxcclxuICAgICAgICBtYXhfYW1vdW50OiBJREwuT3B0KElETC5OYXQpLFxyXG4gICAgICB9KVxyXG4gICAgKSxcclxuICB9KTtcclxuICBjb25zdCBBc2tTdWJzY3JpYmVSZXF1ZXN0ID0gSURMLlZhcmlhbnQoe1xyXG4gICAgc3Vic2NyaWJlOiBJREwuUmVjb3JkKHtcclxuICAgICAgc3Rha2U6IElETC5UdXBsZShJREwuUHJpbmNpcGFsLCBJREwuTmF0KSxcclxuICAgICAgZmlsdGVyOiBJREwuT3B0KFxyXG4gICAgICAgIElETC5SZWNvcmQoe1xyXG4gICAgICAgICAgdG9rZW5zOiBJREwuT3B0KElETC5WZWMoVG9rZW5TcGVjRmlsdGVyKSksXHJcbiAgICAgICAgICB0b2tlbl9pZHM6IElETC5PcHQoSURMLlZlYyhUb2tlbklERmlsdGVyKSksXHJcbiAgICAgICAgfSlcclxuICAgICAgKSxcclxuICAgIH0pLFxyXG4gICAgdW5zdWJzY3JpYmU6IElETC5UdXBsZShJREwuUHJpbmNpcGFsLCBJREwuTmF0KSxcclxuICB9KTtcclxuICBjb25zdCBEaXN0cmlidXRlU2FsZVJlcXVlc3QgPSBJREwuUmVjb3JkKHsgc2VsbGVyOiBJREwuT3B0KEFjY291bnRfXzEpIH0pO1xyXG4gIGNvbnN0IE1hbmFnZVNhbGVSZXF1ZXN0ID0gSURMLlZhcmlhbnQoe1xyXG4gICAgYmlkOiBCaWRSZXF1ZXN0LFxyXG4gICAgZXNjcm93X2RlcG9zaXQ6IEVzY3Jvd1JlcXVlc3QsXHJcbiAgICBmZWVfZGVwb3NpdDogRmVlRGVwb3NpdFJlcXVlc3QsXHJcbiAgICByZWNvZ25pemVfZXNjcm93OiBFc2Nyb3dSZXF1ZXN0LFxyXG4gICAgd2l0aGRyYXc6IFdpdGhkcmF3UmVxdWVzdCxcclxuICAgIGFza19zdWJzY3JpYmU6IEFza1N1YnNjcmliZVJlcXVlc3QsXHJcbiAgICBlbmRfc2FsZTogSURMLlRleHQsXHJcbiAgICByZWZyZXNoX29mZmVyczogSURMLk9wdChBY2NvdW50X18xKSxcclxuICAgIGRpc3RyaWJ1dGVfc2FsZTogRGlzdHJpYnV0ZVNhbGVSZXF1ZXN0LFxyXG4gICAgb3Blbl9zYWxlOiBJREwuVGV4dCxcclxuICB9KTtcclxuICBjb25zdCBCaWRSZXNwb25zZSA9IElETC5SZWNvcmQoe1xyXG4gICAgdG9rZW5faWQ6IElETC5UZXh0LFxyXG4gICAgdHhuX3R5cGU6IElETC5WYXJpYW50KHtcclxuICAgICAgZXNjcm93X2RlcG9zaXQ6IElETC5SZWNvcmQoe1xyXG4gICAgICAgIHRva2VuOiBUb2tlblNwZWMsXHJcbiAgICAgICAgdG9rZW5faWQ6IElETC5UZXh0LFxyXG4gICAgICAgIHRyeF9pZDogVHJhbnNhY3Rpb25JRCxcclxuICAgICAgICBzZWxsZXI6IEFjY291bnRfXzIsXHJcbiAgICAgICAgZXh0ZW5zaWJsZTogQ2FuZHlTaGFyZWQsXHJcbiAgICAgICAgYnV5ZXI6IEFjY291bnRfXzIsXHJcbiAgICAgICAgYW1vdW50OiBJREwuTmF0LFxyXG4gICAgICB9KSxcclxuICAgICAgZmVlX2RlcG9zaXQ6IElETC5SZWNvcmQoe1xyXG4gICAgICAgIHRva2VuOiBUb2tlblNwZWMsXHJcbiAgICAgICAgZXh0ZW5zaWJsZTogQ2FuZHlTaGFyZWQsXHJcbiAgICAgICAgYWNjb3VudDogQWNjb3VudF9fMixcclxuICAgICAgICBhbW91bnQ6IElETC5OYXQsXHJcbiAgICAgIH0pLFxyXG4gICAgICBjYW5pc3Rlcl9uZXR3b3JrX3VwZGF0ZWQ6IElETC5SZWNvcmQoe1xyXG4gICAgICAgIG5ldHdvcms6IElETC5QcmluY2lwYWwsXHJcbiAgICAgICAgZXh0ZW5zaWJsZTogQ2FuZHlTaGFyZWQsXHJcbiAgICAgIH0pLFxyXG4gICAgICBlc2Nyb3dfd2l0aGRyYXc6IElETC5SZWNvcmQoe1xyXG4gICAgICAgIGZlZTogSURMLk5hdCxcclxuICAgICAgICB0b2tlbjogVG9rZW5TcGVjLFxyXG4gICAgICAgIHRva2VuX2lkOiBJREwuVGV4dCxcclxuICAgICAgICB0cnhfaWQ6IFRyYW5zYWN0aW9uSUQsXHJcbiAgICAgICAgc2VsbGVyOiBBY2NvdW50X18yLFxyXG4gICAgICAgIGV4dGVuc2libGU6IENhbmR5U2hhcmVkLFxyXG4gICAgICAgIGJ1eWVyOiBBY2NvdW50X18yLFxyXG4gICAgICAgIGFtb3VudDogSURMLk5hdCxcclxuICAgICAgfSksXHJcbiAgICAgIGNhbmlzdGVyX21hbmFnZXJzX3VwZGF0ZWQ6IElETC5SZWNvcmQoe1xyXG4gICAgICAgIG1hbmFnZXJzOiBJREwuVmVjKElETC5QcmluY2lwYWwpLFxyXG4gICAgICAgIGV4dGVuc2libGU6IENhbmR5U2hhcmVkLFxyXG4gICAgICB9KSxcclxuICAgICAgYXVjdGlvbl9iaWQ6IElETC5SZWNvcmQoe1xyXG4gICAgICAgIHRva2VuOiBUb2tlblNwZWMsXHJcbiAgICAgICAgZXh0ZW5zaWJsZTogQ2FuZHlTaGFyZWQsXHJcbiAgICAgICAgYnV5ZXI6IEFjY291bnRfXzIsXHJcbiAgICAgICAgYW1vdW50OiBJREwuTmF0LFxyXG4gICAgICAgIHNhbGVfaWQ6IElETC5UZXh0LFxyXG4gICAgICB9KSxcclxuICAgICAgYnVybjogSURMLlJlY29yZCh7XHJcbiAgICAgICAgZnJvbTogSURMLk9wdChBY2NvdW50X18yKSxcclxuICAgICAgICBleHRlbnNpYmxlOiBDYW5keVNoYXJlZCxcclxuICAgICAgfSksXHJcbiAgICAgIGRhdGE6IElETC5SZWNvcmQoe1xyXG4gICAgICAgIGhhc2g6IElETC5PcHQoSURMLlZlYyhJREwuTmF0OCkpLFxyXG4gICAgICAgIGV4dGVuc2libGU6IENhbmR5U2hhcmVkLFxyXG4gICAgICAgIGRhdGFfZGFwcDogSURMLk9wdChJREwuVGV4dCksXHJcbiAgICAgICAgZGF0YV9wYXRoOiBJREwuT3B0KElETC5UZXh0KSxcclxuICAgICAgfSksXHJcbiAgICAgIHNhbGVfZW5kZWQ6IElETC5SZWNvcmQoe1xyXG4gICAgICAgIHRva2VuOiBUb2tlblNwZWMsXHJcbiAgICAgICAgc2VsbGVyOiBBY2NvdW50X18yLFxyXG4gICAgICAgIGV4dGVuc2libGU6IENhbmR5U2hhcmVkLFxyXG4gICAgICAgIGJ1eWVyOiBBY2NvdW50X18yLFxyXG4gICAgICAgIGFtb3VudDogSURMLk5hdCxcclxuICAgICAgICBzYWxlX2lkOiBJREwuT3B0KElETC5UZXh0KSxcclxuICAgICAgfSksXHJcbiAgICAgIG1pbnQ6IElETC5SZWNvcmQoe1xyXG4gICAgICAgIHRvOiBBY2NvdW50X18yLFxyXG4gICAgICAgIGZyb206IEFjY291bnRfXzIsXHJcbiAgICAgICAgc2FsZTogSURMLk9wdChJREwuUmVjb3JkKHsgdG9rZW46IFRva2VuU3BlYywgYW1vdW50OiBJREwuTmF0IH0pKSxcclxuICAgICAgICBleHRlbnNpYmxlOiBDYW5keVNoYXJlZCxcclxuICAgICAgfSksXHJcbiAgICAgIHJveWFsdHlfcGFpZDogSURMLlJlY29yZCh7XHJcbiAgICAgICAgdGFnOiBJREwuVGV4dCxcclxuICAgICAgICB0b2tlbjogVG9rZW5TcGVjLFxyXG4gICAgICAgIHNlbGxlcjogQWNjb3VudF9fMixcclxuICAgICAgICBleHRlbnNpYmxlOiBDYW5keVNoYXJlZCxcclxuICAgICAgICBidXllcjogQWNjb3VudF9fMixcclxuICAgICAgICBhbW91bnQ6IElETC5OYXQsXHJcbiAgICAgICAgcmVjZWl2ZXI6IEFjY291bnRfXzIsXHJcbiAgICAgICAgc2FsZV9pZDogSURMLk9wdChJREwuVGV4dCksXHJcbiAgICAgIH0pLFxyXG4gICAgICBleHRlbnNpYmxlOiBDYW5keVNoYXJlZCxcclxuICAgICAgZmVlX2RlcG9zaXRfd2l0aGRyYXc6IElETC5SZWNvcmQoe1xyXG4gICAgICAgIGZlZTogSURMLk5hdCxcclxuICAgICAgICB0b2tlbjogVG9rZW5TcGVjLFxyXG4gICAgICAgIHRyeF9pZDogVHJhbnNhY3Rpb25JRCxcclxuICAgICAgICBleHRlbnNpYmxlOiBDYW5keVNoYXJlZCxcclxuICAgICAgICBhY2NvdW50OiBBY2NvdW50X18yLFxyXG4gICAgICAgIGFtb3VudDogSURMLk5hdCxcclxuICAgICAgfSksXHJcbiAgICAgIG93bmVyX3RyYW5zZmVyOiBJREwuUmVjb3JkKHtcclxuICAgICAgICB0bzogQWNjb3VudF9fMixcclxuICAgICAgICBmcm9tOiBBY2NvdW50X18yLFxyXG4gICAgICAgIGV4dGVuc2libGU6IENhbmR5U2hhcmVkLFxyXG4gICAgICB9KSxcclxuICAgICAgc2FsZV9vcGVuZWQ6IElETC5SZWNvcmQoe1xyXG4gICAgICAgIHByaWNpbmc6IFByaWNpbmdDb25maWdTaGFyZWQsXHJcbiAgICAgICAgZXh0ZW5zaWJsZTogQ2FuZHlTaGFyZWQsXHJcbiAgICAgICAgc2FsZV9pZDogSURMLlRleHQsXHJcbiAgICAgIH0pLFxyXG4gICAgICBjYW5pc3Rlcl9vd25lcl91cGRhdGVkOiBJREwuUmVjb3JkKHtcclxuICAgICAgICBvd25lcjogSURMLlByaW5jaXBhbCxcclxuICAgICAgICBleHRlbnNpYmxlOiBDYW5keVNoYXJlZCxcclxuICAgICAgfSksXHJcbiAgICAgIHNhbGVfd2l0aGRyYXc6IElETC5SZWNvcmQoe1xyXG4gICAgICAgIGZlZTogSURMLk5hdCxcclxuICAgICAgICB0b2tlbjogVG9rZW5TcGVjLFxyXG4gICAgICAgIHRva2VuX2lkOiBJREwuVGV4dCxcclxuICAgICAgICB0cnhfaWQ6IFRyYW5zYWN0aW9uSUQsXHJcbiAgICAgICAgc2VsbGVyOiBBY2NvdW50X18yLFxyXG4gICAgICAgIGV4dGVuc2libGU6IENhbmR5U2hhcmVkLFxyXG4gICAgICAgIGJ1eWVyOiBBY2NvdW50X18yLFxyXG4gICAgICAgIGFtb3VudDogSURMLk5hdCxcclxuICAgICAgfSksXHJcbiAgICAgIGRlcG9zaXRfd2l0aGRyYXc6IElETC5SZWNvcmQoe1xyXG4gICAgICAgIGZlZTogSURMLk5hdCxcclxuICAgICAgICB0b2tlbjogVG9rZW5TcGVjLFxyXG4gICAgICAgIHRyeF9pZDogVHJhbnNhY3Rpb25JRCxcclxuICAgICAgICBleHRlbnNpYmxlOiBDYW5keVNoYXJlZCxcclxuICAgICAgICBidXllcjogQWNjb3VudF9fMixcclxuICAgICAgICBhbW91bnQ6IElETC5OYXQsXHJcbiAgICAgIH0pLFxyXG4gICAgfSksXHJcbiAgICB0aW1lc3RhbXA6IElETC5JbnQsXHJcbiAgICBpbmRleDogSURMLk5hdCxcclxuICB9KTtcclxuICBjb25zdCBFc2Nyb3dSZXNwb25zZSA9IElETC5SZWNvcmQoe1xyXG4gICAgYmFsYW5jZTogSURMLk5hdCxcclxuICAgIHJlY2VpcHQ6IEVzY3Jvd1JlY2VpcHQsXHJcbiAgICB0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb25SZWNvcmQsXHJcbiAgfSk7XHJcbiAgY29uc3QgRmVlRGVwb3NpdFJlc3BvbnNlID0gSURMLlJlY29yZCh7XHJcbiAgICBiYWxhbmNlOiBJREwuTmF0LFxyXG4gICAgdHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uUmVjb3JkLFxyXG4gIH0pO1xyXG4gIGNvbnN0IFJlY29nbml6ZUVzY3Jvd1Jlc3BvbnNlID0gSURMLlJlY29yZCh7XHJcbiAgICBiYWxhbmNlOiBJREwuTmF0LFxyXG4gICAgcmVjZWlwdDogRXNjcm93UmVjZWlwdCxcclxuICAgIHRyYW5zYWN0aW9uOiBJREwuT3B0KFRyYW5zYWN0aW9uUmVjb3JkKSxcclxuICB9KTtcclxuICBjb25zdCBXaXRoZHJhd1Jlc3BvbnNlID0gSURMLlJlY29yZCh7XHJcbiAgICB0b2tlbl9pZDogSURMLlRleHQsXHJcbiAgICB0eG5fdHlwZTogSURMLlZhcmlhbnQoe1xyXG4gICAgICBlc2Nyb3dfZGVwb3NpdDogSURMLlJlY29yZCh7XHJcbiAgICAgICAgdG9rZW46IFRva2VuU3BlYyxcclxuICAgICAgICB0b2tlbl9pZDogSURMLlRleHQsXHJcbiAgICAgICAgdHJ4X2lkOiBUcmFuc2FjdGlvbklELFxyXG4gICAgICAgIHNlbGxlcjogQWNjb3VudF9fMixcclxuICAgICAgICBleHRlbnNpYmxlOiBDYW5keVNoYXJlZCxcclxuICAgICAgICBidXllcjogQWNjb3VudF9fMixcclxuICAgICAgICBhbW91bnQ6IElETC5OYXQsXHJcbiAgICAgIH0pLFxyXG4gICAgICBmZWVfZGVwb3NpdDogSURMLlJlY29yZCh7XHJcbiAgICAgICAgdG9rZW46IFRva2VuU3BlYyxcclxuICAgICAgICBleHRlbnNpYmxlOiBDYW5keVNoYXJlZCxcclxuICAgICAgICBhY2NvdW50OiBBY2NvdW50X18yLFxyXG4gICAgICAgIGFtb3VudDogSURMLk5hdCxcclxuICAgICAgfSksXHJcbiAgICAgIGNhbmlzdGVyX25ldHdvcmtfdXBkYXRlZDogSURMLlJlY29yZCh7XHJcbiAgICAgICAgbmV0d29yazogSURMLlByaW5jaXBhbCxcclxuICAgICAgICBleHRlbnNpYmxlOiBDYW5keVNoYXJlZCxcclxuICAgICAgfSksXHJcbiAgICAgIGVzY3Jvd193aXRoZHJhdzogSURMLlJlY29yZCh7XHJcbiAgICAgICAgZmVlOiBJREwuTmF0LFxyXG4gICAgICAgIHRva2VuOiBUb2tlblNwZWMsXHJcbiAgICAgICAgdG9rZW5faWQ6IElETC5UZXh0LFxyXG4gICAgICAgIHRyeF9pZDogVHJhbnNhY3Rpb25JRCxcclxuICAgICAgICBzZWxsZXI6IEFjY291bnRfXzIsXHJcbiAgICAgICAgZXh0ZW5zaWJsZTogQ2FuZHlTaGFyZWQsXHJcbiAgICAgICAgYnV5ZXI6IEFjY291bnRfXzIsXHJcbiAgICAgICAgYW1vdW50OiBJREwuTmF0LFxyXG4gICAgICB9KSxcclxuICAgICAgY2FuaXN0ZXJfbWFuYWdlcnNfdXBkYXRlZDogSURMLlJlY29yZCh7XHJcbiAgICAgICAgbWFuYWdlcnM6IElETC5WZWMoSURMLlByaW5jaXBhbCksXHJcbiAgICAgICAgZXh0ZW5zaWJsZTogQ2FuZHlTaGFyZWQsXHJcbiAgICAgIH0pLFxyXG4gICAgICBhdWN0aW9uX2JpZDogSURMLlJlY29yZCh7XHJcbiAgICAgICAgdG9rZW46IFRva2VuU3BlYyxcclxuICAgICAgICBleHRlbnNpYmxlOiBDYW5keVNoYXJlZCxcclxuICAgICAgICBidXllcjogQWNjb3VudF9fMixcclxuICAgICAgICBhbW91bnQ6IElETC5OYXQsXHJcbiAgICAgICAgc2FsZV9pZDogSURMLlRleHQsXHJcbiAgICAgIH0pLFxyXG4gICAgICBidXJuOiBJREwuUmVjb3JkKHtcclxuICAgICAgICBmcm9tOiBJREwuT3B0KEFjY291bnRfXzIpLFxyXG4gICAgICAgIGV4dGVuc2libGU6IENhbmR5U2hhcmVkLFxyXG4gICAgICB9KSxcclxuICAgICAgZGF0YTogSURMLlJlY29yZCh7XHJcbiAgICAgICAgaGFzaDogSURMLk9wdChJREwuVmVjKElETC5OYXQ4KSksXHJcbiAgICAgICAgZXh0ZW5zaWJsZTogQ2FuZHlTaGFyZWQsXHJcbiAgICAgICAgZGF0YV9kYXBwOiBJREwuT3B0KElETC5UZXh0KSxcclxuICAgICAgICBkYXRhX3BhdGg6IElETC5PcHQoSURMLlRleHQpLFxyXG4gICAgICB9KSxcclxuICAgICAgc2FsZV9lbmRlZDogSURMLlJlY29yZCh7XHJcbiAgICAgICAgdG9rZW46IFRva2VuU3BlYyxcclxuICAgICAgICBzZWxsZXI6IEFjY291bnRfXzIsXHJcbiAgICAgICAgZXh0ZW5zaWJsZTogQ2FuZHlTaGFyZWQsXHJcbiAgICAgICAgYnV5ZXI6IEFjY291bnRfXzIsXHJcbiAgICAgICAgYW1vdW50OiBJREwuTmF0LFxyXG4gICAgICAgIHNhbGVfaWQ6IElETC5PcHQoSURMLlRleHQpLFxyXG4gICAgICB9KSxcclxuICAgICAgbWludDogSURMLlJlY29yZCh7XHJcbiAgICAgICAgdG86IEFjY291bnRfXzIsXHJcbiAgICAgICAgZnJvbTogQWNjb3VudF9fMixcclxuICAgICAgICBzYWxlOiBJREwuT3B0KElETC5SZWNvcmQoeyB0b2tlbjogVG9rZW5TcGVjLCBhbW91bnQ6IElETC5OYXQgfSkpLFxyXG4gICAgICAgIGV4dGVuc2libGU6IENhbmR5U2hhcmVkLFxyXG4gICAgICB9KSxcclxuICAgICAgcm95YWx0eV9wYWlkOiBJREwuUmVjb3JkKHtcclxuICAgICAgICB0YWc6IElETC5UZXh0LFxyXG4gICAgICAgIHRva2VuOiBUb2tlblNwZWMsXHJcbiAgICAgICAgc2VsbGVyOiBBY2NvdW50X18yLFxyXG4gICAgICAgIGV4dGVuc2libGU6IENhbmR5U2hhcmVkLFxyXG4gICAgICAgIGJ1eWVyOiBBY2NvdW50X18yLFxyXG4gICAgICAgIGFtb3VudDogSURMLk5hdCxcclxuICAgICAgICByZWNlaXZlcjogQWNjb3VudF9fMixcclxuICAgICAgICBzYWxlX2lkOiBJREwuT3B0KElETC5UZXh0KSxcclxuICAgICAgfSksXHJcbiAgICAgIGV4dGVuc2libGU6IENhbmR5U2hhcmVkLFxyXG4gICAgICBmZWVfZGVwb3NpdF93aXRoZHJhdzogSURMLlJlY29yZCh7XHJcbiAgICAgICAgZmVlOiBJREwuTmF0LFxyXG4gICAgICAgIHRva2VuOiBUb2tlblNwZWMsXHJcbiAgICAgICAgdHJ4X2lkOiBUcmFuc2FjdGlvbklELFxyXG4gICAgICAgIGV4dGVuc2libGU6IENhbmR5U2hhcmVkLFxyXG4gICAgICAgIGFjY291bnQ6IEFjY291bnRfXzIsXHJcbiAgICAgICAgYW1vdW50OiBJREwuTmF0LFxyXG4gICAgICB9KSxcclxuICAgICAgb3duZXJfdHJhbnNmZXI6IElETC5SZWNvcmQoe1xyXG4gICAgICAgIHRvOiBBY2NvdW50X18yLFxyXG4gICAgICAgIGZyb206IEFjY291bnRfXzIsXHJcbiAgICAgICAgZXh0ZW5zaWJsZTogQ2FuZHlTaGFyZWQsXHJcbiAgICAgIH0pLFxyXG4gICAgICBzYWxlX29wZW5lZDogSURMLlJlY29yZCh7XHJcbiAgICAgICAgcHJpY2luZzogUHJpY2luZ0NvbmZpZ1NoYXJlZCxcclxuICAgICAgICBleHRlbnNpYmxlOiBDYW5keVNoYXJlZCxcclxuICAgICAgICBzYWxlX2lkOiBJREwuVGV4dCxcclxuICAgICAgfSksXHJcbiAgICAgIGNhbmlzdGVyX293bmVyX3VwZGF0ZWQ6IElETC5SZWNvcmQoe1xyXG4gICAgICAgIG93bmVyOiBJREwuUHJpbmNpcGFsLFxyXG4gICAgICAgIGV4dGVuc2libGU6IENhbmR5U2hhcmVkLFxyXG4gICAgICB9KSxcclxuICAgICAgc2FsZV93aXRoZHJhdzogSURMLlJlY29yZCh7XHJcbiAgICAgICAgZmVlOiBJREwuTmF0LFxyXG4gICAgICAgIHRva2VuOiBUb2tlblNwZWMsXHJcbiAgICAgICAgdG9rZW5faWQ6IElETC5UZXh0LFxyXG4gICAgICAgIHRyeF9pZDogVHJhbnNhY3Rpb25JRCxcclxuICAgICAgICBzZWxsZXI6IEFjY291bnRfXzIsXHJcbiAgICAgICAgZXh0ZW5zaWJsZTogQ2FuZHlTaGFyZWQsXHJcbiAgICAgICAgYnV5ZXI6IEFjY291bnRfXzIsXHJcbiAgICAgICAgYW1vdW50OiBJREwuTmF0LFxyXG4gICAgICB9KSxcclxuICAgICAgZGVwb3NpdF93aXRoZHJhdzogSURMLlJlY29yZCh7XHJcbiAgICAgICAgZmVlOiBJREwuTmF0LFxyXG4gICAgICAgIHRva2VuOiBUb2tlblNwZWMsXHJcbiAgICAgICAgdHJ4X2lkOiBUcmFuc2FjdGlvbklELFxyXG4gICAgICAgIGV4dGVuc2libGU6IENhbmR5U2hhcmVkLFxyXG4gICAgICAgIGJ1eWVyOiBBY2NvdW50X18yLFxyXG4gICAgICAgIGFtb3VudDogSURMLk5hdCxcclxuICAgICAgfSksXHJcbiAgICB9KSxcclxuICAgIHRpbWVzdGFtcDogSURMLkludCxcclxuICAgIGluZGV4OiBJREwuTmF0LFxyXG4gIH0pO1xyXG4gIGNvbnN0IEFza1N1YnNjcmliZVJlc3BvbnNlID0gSURMLkJvb2w7XHJcbiAgY29uc3QgRW5kU2FsZVJlc3BvbnNlID0gSURMLlJlY29yZCh7XHJcbiAgICB0b2tlbl9pZDogSURMLlRleHQsXHJcbiAgICB0eG5fdHlwZTogSURMLlZhcmlhbnQoe1xyXG4gICAgICBlc2Nyb3dfZGVwb3NpdDogSURMLlJlY29yZCh7XHJcbiAgICAgICAgdG9rZW46IFRva2VuU3BlYyxcclxuICAgICAgICB0b2tlbl9pZDogSURMLlRleHQsXHJcbiAgICAgICAgdHJ4X2lkOiBUcmFuc2FjdGlvbklELFxyXG4gICAgICAgIHNlbGxlcjogQWNjb3VudF9fMixcclxuICAgICAgICBleHRlbnNpYmxlOiBDYW5keVNoYXJlZCxcclxuICAgICAgICBidXllcjogQWNjb3VudF9fMixcclxuICAgICAgICBhbW91bnQ6IElETC5OYXQsXHJcbiAgICAgIH0pLFxyXG4gICAgICBmZWVfZGVwb3NpdDogSURMLlJlY29yZCh7XHJcbiAgICAgICAgdG9rZW46IFRva2VuU3BlYyxcclxuICAgICAgICBleHRlbnNpYmxlOiBDYW5keVNoYXJlZCxcclxuICAgICAgICBhY2NvdW50OiBBY2NvdW50X18yLFxyXG4gICAgICAgIGFtb3VudDogSURMLk5hdCxcclxuICAgICAgfSksXHJcbiAgICAgIGNhbmlzdGVyX25ldHdvcmtfdXBkYXRlZDogSURMLlJlY29yZCh7XHJcbiAgICAgICAgbmV0d29yazogSURMLlByaW5jaXBhbCxcclxuICAgICAgICBleHRlbnNpYmxlOiBDYW5keVNoYXJlZCxcclxuICAgICAgfSksXHJcbiAgICAgIGVzY3Jvd193aXRoZHJhdzogSURMLlJlY29yZCh7XHJcbiAgICAgICAgZmVlOiBJREwuTmF0LFxyXG4gICAgICAgIHRva2VuOiBUb2tlblNwZWMsXHJcbiAgICAgICAgdG9rZW5faWQ6IElETC5UZXh0LFxyXG4gICAgICAgIHRyeF9pZDogVHJhbnNhY3Rpb25JRCxcclxuICAgICAgICBzZWxsZXI6IEFjY291bnRfXzIsXHJcbiAgICAgICAgZXh0ZW5zaWJsZTogQ2FuZHlTaGFyZWQsXHJcbiAgICAgICAgYnV5ZXI6IEFjY291bnRfXzIsXHJcbiAgICAgICAgYW1vdW50OiBJREwuTmF0LFxyXG4gICAgICB9KSxcclxuICAgICAgY2FuaXN0ZXJfbWFuYWdlcnNfdXBkYXRlZDogSURMLlJlY29yZCh7XHJcbiAgICAgICAgbWFuYWdlcnM6IElETC5WZWMoSURMLlByaW5jaXBhbCksXHJcbiAgICAgICAgZXh0ZW5zaWJsZTogQ2FuZHlTaGFyZWQsXHJcbiAgICAgIH0pLFxyXG4gICAgICBhdWN0aW9uX2JpZDogSURMLlJlY29yZCh7XHJcbiAgICAgICAgdG9rZW46IFRva2VuU3BlYyxcclxuICAgICAgICBleHRlbnNpYmxlOiBDYW5keVNoYXJlZCxcclxuICAgICAgICBidXllcjogQWNjb3VudF9fMixcclxuICAgICAgICBhbW91bnQ6IElETC5OYXQsXHJcbiAgICAgICAgc2FsZV9pZDogSURMLlRleHQsXHJcbiAgICAgIH0pLFxyXG4gICAgICBidXJuOiBJREwuUmVjb3JkKHtcclxuICAgICAgICBmcm9tOiBJREwuT3B0KEFjY291bnRfXzIpLFxyXG4gICAgICAgIGV4dGVuc2libGU6IENhbmR5U2hhcmVkLFxyXG4gICAgICB9KSxcclxuICAgICAgZGF0YTogSURMLlJlY29yZCh7XHJcbiAgICAgICAgaGFzaDogSURMLk9wdChJREwuVmVjKElETC5OYXQ4KSksXHJcbiAgICAgICAgZXh0ZW5zaWJsZTogQ2FuZHlTaGFyZWQsXHJcbiAgICAgICAgZGF0YV9kYXBwOiBJREwuT3B0KElETC5UZXh0KSxcclxuICAgICAgICBkYXRhX3BhdGg6IElETC5PcHQoSURMLlRleHQpLFxyXG4gICAgICB9KSxcclxuICAgICAgc2FsZV9lbmRlZDogSURMLlJlY29yZCh7XHJcbiAgICAgICAgdG9rZW46IFRva2VuU3BlYyxcclxuICAgICAgICBzZWxsZXI6IEFjY291bnRfXzIsXHJcbiAgICAgICAgZXh0ZW5zaWJsZTogQ2FuZHlTaGFyZWQsXHJcbiAgICAgICAgYnV5ZXI6IEFjY291bnRfXzIsXHJcbiAgICAgICAgYW1vdW50OiBJREwuTmF0LFxyXG4gICAgICAgIHNhbGVfaWQ6IElETC5PcHQoSURMLlRleHQpLFxyXG4gICAgICB9KSxcclxuICAgICAgbWludDogSURMLlJlY29yZCh7XHJcbiAgICAgICAgdG86IEFjY291bnRfXzIsXHJcbiAgICAgICAgZnJvbTogQWNjb3VudF9fMixcclxuICAgICAgICBzYWxlOiBJREwuT3B0KElETC5SZWNvcmQoeyB0b2tlbjogVG9rZW5TcGVjLCBhbW91bnQ6IElETC5OYXQgfSkpLFxyXG4gICAgICAgIGV4dGVuc2libGU6IENhbmR5U2hhcmVkLFxyXG4gICAgICB9KSxcclxuICAgICAgcm95YWx0eV9wYWlkOiBJREwuUmVjb3JkKHtcclxuICAgICAgICB0YWc6IElETC5UZXh0LFxyXG4gICAgICAgIHRva2VuOiBUb2tlblNwZWMsXHJcbiAgICAgICAgc2VsbGVyOiBBY2NvdW50X18yLFxyXG4gICAgICAgIGV4dGVuc2libGU6IENhbmR5U2hhcmVkLFxyXG4gICAgICAgIGJ1eWVyOiBBY2NvdW50X18yLFxyXG4gICAgICAgIGFtb3VudDogSURMLk5hdCxcclxuICAgICAgICByZWNlaXZlcjogQWNjb3VudF9fMixcclxuICAgICAgICBzYWxlX2lkOiBJREwuT3B0KElETC5UZXh0KSxcclxuICAgICAgfSksXHJcbiAgICAgIGV4dGVuc2libGU6IENhbmR5U2hhcmVkLFxyXG4gICAgICBmZWVfZGVwb3NpdF93aXRoZHJhdzogSURMLlJlY29yZCh7XHJcbiAgICAgICAgZmVlOiBJREwuTmF0LFxyXG4gICAgICAgIHRva2VuOiBUb2tlblNwZWMsXHJcbiAgICAgICAgdHJ4X2lkOiBUcmFuc2FjdGlvbklELFxyXG4gICAgICAgIGV4dGVuc2libGU6IENhbmR5U2hhcmVkLFxyXG4gICAgICAgIGFjY291bnQ6IEFjY291bnRfXzIsXHJcbiAgICAgICAgYW1vdW50OiBJREwuTmF0LFxyXG4gICAgICB9KSxcclxuICAgICAgb3duZXJfdHJhbnNmZXI6IElETC5SZWNvcmQoe1xyXG4gICAgICAgIHRvOiBBY2NvdW50X18yLFxyXG4gICAgICAgIGZyb206IEFjY291bnRfXzIsXHJcbiAgICAgICAgZXh0ZW5zaWJsZTogQ2FuZHlTaGFyZWQsXHJcbiAgICAgIH0pLFxyXG4gICAgICBzYWxlX29wZW5lZDogSURMLlJlY29yZCh7XHJcbiAgICAgICAgcHJpY2luZzogUHJpY2luZ0NvbmZpZ1NoYXJlZCxcclxuICAgICAgICBleHRlbnNpYmxlOiBDYW5keVNoYXJlZCxcclxuICAgICAgICBzYWxlX2lkOiBJREwuVGV4dCxcclxuICAgICAgfSksXHJcbiAgICAgIGNhbmlzdGVyX293bmVyX3VwZGF0ZWQ6IElETC5SZWNvcmQoe1xyXG4gICAgICAgIG93bmVyOiBJREwuUHJpbmNpcGFsLFxyXG4gICAgICAgIGV4dGVuc2libGU6IENhbmR5U2hhcmVkLFxyXG4gICAgICB9KSxcclxuICAgICAgc2FsZV93aXRoZHJhdzogSURMLlJlY29yZCh7XHJcbiAgICAgICAgZmVlOiBJREwuTmF0LFxyXG4gICAgICAgIHRva2VuOiBUb2tlblNwZWMsXHJcbiAgICAgICAgdG9rZW5faWQ6IElETC5UZXh0LFxyXG4gICAgICAgIHRyeF9pZDogVHJhbnNhY3Rpb25JRCxcclxuICAgICAgICBzZWxsZXI6IEFjY291bnRfXzIsXHJcbiAgICAgICAgZXh0ZW5zaWJsZTogQ2FuZHlTaGFyZWQsXHJcbiAgICAgICAgYnV5ZXI6IEFjY291bnRfXzIsXHJcbiAgICAgICAgYW1vdW50OiBJREwuTmF0LFxyXG4gICAgICB9KSxcclxuICAgICAgZGVwb3NpdF93aXRoZHJhdzogSURMLlJlY29yZCh7XHJcbiAgICAgICAgZmVlOiBJREwuTmF0LFxyXG4gICAgICAgIHRva2VuOiBUb2tlblNwZWMsXHJcbiAgICAgICAgdHJ4X2lkOiBUcmFuc2FjdGlvbklELFxyXG4gICAgICAgIGV4dGVuc2libGU6IENhbmR5U2hhcmVkLFxyXG4gICAgICAgIGJ1eWVyOiBBY2NvdW50X18yLFxyXG4gICAgICAgIGFtb3VudDogSURMLk5hdCxcclxuICAgICAgfSksXHJcbiAgICB9KSxcclxuICAgIHRpbWVzdGFtcDogSURMLkludCxcclxuICAgIGluZGV4OiBJREwuTmF0LFxyXG4gIH0pO1xyXG4gIGNvbnN0IFJlc3VsdCA9IElETC5WYXJpYW50KHtcclxuICAgIG9rOiBNYW5hZ2VTYWxlUmVzcG9uc2UsXHJcbiAgICBlcnI6IE9yaWd5bkVycm9yLFxyXG4gIH0pO1xyXG4gIGNvbnN0IERpc3RyaWJ1dGVTYWxlUmVzcG9uc2UgPSBJREwuVmVjKFJlc3VsdCk7XHJcbiAgTWFuYWdlU2FsZVJlc3BvbnNlLmZpbGwoXHJcbiAgICBJREwuVmFyaWFudCh7XHJcbiAgICAgIGJpZDogQmlkUmVzcG9uc2UsXHJcbiAgICAgIGVzY3Jvd19kZXBvc2l0OiBFc2Nyb3dSZXNwb25zZSxcclxuICAgICAgZmVlX2RlcG9zaXQ6IEZlZURlcG9zaXRSZXNwb25zZSxcclxuICAgICAgcmVjb2duaXplX2VzY3JvdzogUmVjb2duaXplRXNjcm93UmVzcG9uc2UsXHJcbiAgICAgIHdpdGhkcmF3OiBXaXRoZHJhd1Jlc3BvbnNlLFxyXG4gICAgICBhc2tfc3Vic2NyaWJlOiBBc2tTdWJzY3JpYmVSZXNwb25zZSxcclxuICAgICAgZW5kX3NhbGU6IEVuZFNhbGVSZXNwb25zZSxcclxuICAgICAgcmVmcmVzaF9vZmZlcnM6IElETC5WZWMoRXNjcm93UmVjb3JkX18xKSxcclxuICAgICAgZGlzdHJpYnV0ZV9zYWxlOiBEaXN0cmlidXRlU2FsZVJlc3BvbnNlLFxyXG4gICAgICBvcGVuX3NhbGU6IElETC5Cb29sLFxyXG4gICAgfSlcclxuICApO1xyXG4gIGNvbnN0IE1hbmFnZVNhbGVSZXN1bHQgPSBJREwuVmFyaWFudCh7XHJcbiAgICBvazogTWFuYWdlU2FsZVJlc3BvbnNlLFxyXG4gICAgZXJyOiBPcmlneW5FcnJvcixcclxuICB9KTtcclxuICBjb25zdCBTYWxlSW5mb1JlcXVlc3QgPSBJREwuVmFyaWFudCh7XHJcbiAgICBzdGF0dXM6IElETC5UZXh0LFxyXG4gICAgZmVlX2RlcG9zaXRfaW5mbzogSURMLk9wdChBY2NvdW50X18xKSxcclxuICAgIGFjdGl2ZTogSURMLk9wdChJREwuVHVwbGUoSURMLk5hdCwgSURMLk5hdCkpLFxyXG4gICAgZGVwb3NpdF9pbmZvOiBJREwuT3B0KEFjY291bnRfXzEpLFxyXG4gICAgaGlzdG9yeTogSURMLk9wdChJREwuVHVwbGUoSURMLk5hdCwgSURMLk5hdCkpLFxyXG4gICAgZXNjcm93X2luZm86IEVzY3Jvd1JlY2VpcHQsXHJcbiAgfSk7XHJcbiAgY29uc3QgU3ViQWNjb3VudEluZm8gPSBJREwuUmVjb3JkKHtcclxuICAgIGFjY291bnRfaWQ6IElETC5WZWMoSURMLk5hdDgpLFxyXG4gICAgcHJpbmNpcGFsOiBJREwuUHJpbmNpcGFsLFxyXG4gICAgYWNjb3VudF9pZF90ZXh0OiBJREwuVGV4dCxcclxuICAgIGFjY291bnQ6IElETC5SZWNvcmQoe1xyXG4gICAgICBwcmluY2lwYWw6IElETC5QcmluY2lwYWwsXHJcbiAgICAgIHN1Yl9hY2NvdW50OiBJREwuVmVjKElETC5OYXQ4KSxcclxuICAgIH0pLFxyXG4gIH0pO1xyXG4gIGNvbnN0IFNhbGVJbmZvUmVzcG9uc2UgPSBJREwuVmFyaWFudCh7XHJcbiAgICBzdGF0dXM6IElETC5PcHQoU2FsZVN0YXR1c1NoYXJlZCksXHJcbiAgICBmZWVfZGVwb3NpdF9pbmZvOiBTdWJBY2NvdW50SW5mbyxcclxuICAgIGFjdGl2ZTogSURMLlJlY29yZCh7XHJcbiAgICAgIGVvZjogSURMLkJvb2wsXHJcbiAgICAgIHJlY29yZHM6IElETC5WZWMoSURMLlR1cGxlKElETC5UZXh0LCBJREwuT3B0KFNhbGVTdGF0dXNTaGFyZWQpKSksXHJcbiAgICAgIGNvdW50OiBJREwuTmF0LFxyXG4gICAgfSksXHJcbiAgICBkZXBvc2l0X2luZm86IFN1YkFjY291bnRJbmZvLFxyXG4gICAgaGlzdG9yeTogSURMLlJlY29yZCh7XHJcbiAgICAgIGVvZjogSURMLkJvb2wsXHJcbiAgICAgIHJlY29yZHM6IElETC5WZWMoSURMLk9wdChTYWxlU3RhdHVzU2hhcmVkKSksXHJcbiAgICAgIGNvdW50OiBJREwuTmF0LFxyXG4gICAgfSksXHJcbiAgICBlc2Nyb3dfaW5mbzogU3ViQWNjb3VudEluZm8sXHJcbiAgfSk7XHJcbiAgY29uc3QgU2FsZUluZm9SZXN1bHQgPSBJREwuVmFyaWFudCh7XHJcbiAgICBvazogU2FsZUluZm9SZXNwb25zZSxcclxuICAgIGVycjogT3JpZ3luRXJyb3IsXHJcbiAgfSk7XHJcbiAgY29uc3QgU2hhcmVXYWxsZXRSZXF1ZXN0ID0gSURMLlJlY29yZCh7XHJcbiAgICB0bzogQWNjb3VudF9fMSxcclxuICAgIHRva2VuX2lkOiBJREwuVGV4dCxcclxuICAgIGZyb206IEFjY291bnRfXzEsXHJcbiAgfSk7XHJcbiAgY29uc3QgT3duZXJUcmFuc2ZlclJlc3BvbnNlID0gSURMLlJlY29yZCh7XHJcbiAgICB0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb25SZWNvcmQsXHJcbiAgICBhc3NldHM6IElETC5WZWMoQ2FuZHlTaGFyZWQpLFxyXG4gIH0pO1xyXG4gIGNvbnN0IE93bmVyVXBkYXRlUmVzdWx0ID0gSURMLlZhcmlhbnQoe1xyXG4gICAgb2s6IE93bmVyVHJhbnNmZXJSZXNwb25zZSxcclxuICAgIGVycjogT3JpZ3luRXJyb3IsXHJcbiAgfSk7XHJcbiAgY29uc3QgU3RhZ2VDaHVua0FyZyA9IElETC5SZWNvcmQoe1xyXG4gICAgY29udGVudDogSURMLlZlYyhJREwuTmF0OCksXHJcbiAgICB0b2tlbl9pZDogSURMLlRleHQsXHJcbiAgICBjaHVuazogSURMLk5hdCxcclxuICAgIGZpbGVkYXRhOiBDYW5keVNoYXJlZCxcclxuICAgIGxpYnJhcnlfaWQ6IElETC5UZXh0LFxyXG4gIH0pO1xyXG4gIGNvbnN0IFN0YWdlTGlicmFyeVJlc3BvbnNlID0gSURMLlJlY29yZCh7IGNhbmlzdGVyOiBJREwuUHJpbmNpcGFsIH0pO1xyXG4gIGNvbnN0IFN0YWdlTGlicmFyeVJlc3VsdCA9IElETC5WYXJpYW50KHtcclxuICAgIG9rOiBTdGFnZUxpYnJhcnlSZXNwb25zZSxcclxuICAgIGVycjogT3JpZ3luRXJyb3IsXHJcbiAgfSk7XHJcbiAgY29uc3QgU3RhdGVTaXplID0gSURMLlJlY29yZCh7XHJcbiAgICBzYWxlc19iYWxhbmNlczogSURMLk5hdCxcclxuICAgIG9mZmVyczogSURMLk5hdCxcclxuICAgIG5mdF9sZWRnZXJzOiBJREwuTmF0LFxyXG4gICAgYWxsb2NhdGlvbnM6IElETC5OYXQsXHJcbiAgICBuZnRfc2FsZXM6IElETC5OYXQsXHJcbiAgICBidWNrZXRzOiBJREwuTmF0LFxyXG4gICAgZXNjcm93X2JhbGFuY2VzOiBJREwuTmF0LFxyXG4gIH0pO1xyXG4gIGNvbnN0IFN0b3JhZ2VNZXRyaWNzID0gSURMLlJlY29yZCh7XHJcbiAgICBnYXRld2F5OiBJREwuUHJpbmNpcGFsLFxyXG4gICAgYXZhaWxhYmxlX3NwYWNlOiBJREwuTmF0LFxyXG4gICAgYWxsb2NhdGlvbnM6IElETC5WZWMoQWxsb2NhdGlvblJlY29yZFN0YWJsZSksXHJcbiAgICBhbGxvY2F0ZWRfc3RvcmFnZTogSURMLk5hdCxcclxuICB9KTtcclxuICBjb25zdCBTdG9yYWdlTWV0cmljc1Jlc3VsdCA9IElETC5WYXJpYW50KHtcclxuICAgIG9rOiBTdG9yYWdlTWV0cmljcyxcclxuICAgIGVycjogT3JpZ3luRXJyb3IsXHJcbiAgfSk7XHJcbiAgY29uc3QgRVhUVG9rZW5zUmVzcG9uc2UgPSBJREwuVHVwbGUoXHJcbiAgICBJREwuTmF0MzIsXHJcbiAgICBJREwuT3B0KFxyXG4gICAgICBJREwuUmVjb3JkKHtcclxuICAgICAgICBsb2NrZWQ6IElETC5PcHQoSURMLkludCksXHJcbiAgICAgICAgc2VsbGVyOiBJREwuUHJpbmNpcGFsLFxyXG4gICAgICAgIHByaWNlOiBJREwuTmF0NjQsXHJcbiAgICAgIH0pXHJcbiAgICApLFxyXG4gICAgSURMLk9wdChJREwuVmVjKElETC5OYXQ4KSlcclxuICApO1xyXG4gIGNvbnN0IEVYVFRva2Vuc1Jlc3VsdCA9IElETC5WYXJpYW50KHtcclxuICAgIG9rOiBJREwuVmVjKEVYVFRva2Vuc1Jlc3BvbnNlKSxcclxuICAgIGVycjogRVhUQ29tbW9uRXJyb3IsXHJcbiAgfSk7XHJcbiAgY29uc3QgRVhUTWVtbyA9IElETC5WZWMoSURMLk5hdDgpO1xyXG4gIGNvbnN0IEVYVFN1YkFjY291bnQgPSBJREwuVmVjKElETC5OYXQ4KTtcclxuICBjb25zdCBFWFRUcmFuc2ZlclJlcXVlc3QgPSBJREwuUmVjb3JkKHtcclxuICAgIHRvOiBFWFRVc2VyLFxyXG4gICAgdG9rZW46IEVYVFRva2VuSWRlbnRpZmllcixcclxuICAgIG5vdGlmeTogSURMLkJvb2wsXHJcbiAgICBmcm9tOiBFWFRVc2VyLFxyXG4gICAgbWVtbzogRVhUTWVtbyxcclxuICAgIHN1YmFjY291bnQ6IElETC5PcHQoRVhUU3ViQWNjb3VudCksXHJcbiAgICBhbW91bnQ6IEVYVEJhbGFuY2UsXHJcbiAgfSk7XHJcbiAgY29uc3QgRVhUVHJhbnNmZXJSZXNwb25zZSA9IElETC5WYXJpYW50KHtcclxuICAgIG9rOiBFWFRCYWxhbmNlLFxyXG4gICAgZXJyOiBJREwuVmFyaWFudCh7XHJcbiAgICAgIENhbm5vdE5vdGlmeTogRVhUQWNjb3VudElkZW50aWZpZXIsXHJcbiAgICAgIEluc3VmZmljaWVudEJhbGFuY2U6IElETC5OdWxsLFxyXG4gICAgICBJbnZhbGlkVG9rZW46IEVYVFRva2VuSWRlbnRpZmllcixcclxuICAgICAgUmVqZWN0ZWQ6IElETC5OdWxsLFxyXG4gICAgICBVbmF1dGhvcml6ZWQ6IEVYVEFjY291bnRJZGVudGlmaWVyLFxyXG4gICAgICBPdGhlcjogSURMLlRleHQsXHJcbiAgICB9KSxcclxuICB9KTtcclxuICBjb25zdCBVcGRhdGVNb2RlU2hhcmVkID0gSURMLlZhcmlhbnQoe1xyXG4gICAgU2V0OiBDYW5keVNoYXJlZCxcclxuICAgIExvY2s6IENhbmR5U2hhcmVkLFxyXG4gICAgTmV4dDogSURMLlZlYyhVcGRhdGVTaGFyZWQpLFxyXG4gIH0pO1xyXG4gIFVwZGF0ZVNoYXJlZC5maWxsKElETC5SZWNvcmQoeyBtb2RlOiBVcGRhdGVNb2RlU2hhcmVkLCBuYW1lOiBJREwuVGV4dCB9KSk7XHJcbiAgY29uc3QgVXBkYXRlUmVxdWVzdFNoYXJlZCA9IElETC5SZWNvcmQoe1xyXG4gICAgaWQ6IElETC5UZXh0LFxyXG4gICAgdXBkYXRlOiBJREwuVmVjKFVwZGF0ZVNoYXJlZCksXHJcbiAgfSk7XHJcbiAgY29uc3QgTkZUVXBkYXRlUmVxdWVzdCA9IElETC5WYXJpYW50KHtcclxuICAgIHVwZGF0ZTogSURMLlJlY29yZCh7XHJcbiAgICAgIHRva2VuX2lkOiBJREwuVGV4dCxcclxuICAgICAgdXBkYXRlOiBVcGRhdGVSZXF1ZXN0U2hhcmVkLFxyXG4gICAgICBhcHBfaWQ6IElETC5UZXh0LFxyXG4gICAgfSksXHJcbiAgICByZXBsYWNlOiBJREwuUmVjb3JkKHsgdG9rZW5faWQ6IElETC5UZXh0LCBkYXRhOiBDYW5keVNoYXJlZCB9KSxcclxuICB9KTtcclxuICBjb25zdCBORlRVcGRhdGVSZXNwb25zZSA9IElETC5Cb29sO1xyXG4gIGNvbnN0IE5GVFVwZGF0ZVJlc3VsdCA9IElETC5WYXJpYW50KHtcclxuICAgIG9rOiBORlRVcGRhdGVSZXNwb25zZSxcclxuICAgIGVycjogT3JpZ3luRXJyb3IsXHJcbiAgfSk7XHJcbiAgY29uc3QgSW5kZXhUeXBlID0gSURMLlZhcmlhbnQoe1xyXG4gICAgU3RhYmxlOiBJREwuTnVsbCxcclxuICAgIFN0YWJsZVR5cGVkOiBJREwuTnVsbCxcclxuICAgIE1hbmFnZWQ6IElETC5OdWxsLFxyXG4gIH0pO1xyXG4gIGNvbnN0IFVwZGF0ZVNldHRpbmcgPSBJREwuVmFyaWFudCh7XHJcbiAgICBtYXhSZWNvcmRzVG9BcmNoaXZlOiBJREwuTmF0LFxyXG4gICAgYXJjaGl2ZUluZGV4VHlwZTogSW5kZXhUeXBlLFxyXG4gICAgbWF4QXJjaGl2ZVBhZ2VzOiBJREwuTmF0LFxyXG4gICAgc2V0dGxlVG9SZWNvcmRzOiBJREwuTmF0LFxyXG4gICAgYXJjaGl2ZUN5Y2xlczogSURMLk5hdCxcclxuICAgIG1heEFjdGl2ZVJlY29yZHM6IElETC5OYXQsXHJcbiAgICBtYXhSZWNvcmRzSW5BcmNoaXZlSW5zdGFuY2U6IElETC5OYXQsXHJcbiAgICBhcmNoaXZlQ29udHJvbGxlcnM6IElETC5PcHQoSURMLk9wdChJREwuVmVjKElETC5QcmluY2lwYWwpKSksXHJcbiAgfSk7XHJcbiAgY29uc3QgTkZUVXBkYXRlTWV0YWRhdGFOb2RlID0gSURMLlJlY29yZCh7XHJcbiAgICB0b2tlbl9pZDogSURMLlRleHQsXHJcbiAgICB2YWx1ZTogQ2FuZHlTaGFyZWQsXHJcbiAgICBfc3lzdGVtOiBJREwuQm9vbCxcclxuICAgIGZpZWxkX2lkOiBJREwuVGV4dCxcclxuICB9KTtcclxuICBjb25zdCBORlRVcGRhdGVNZXRhZGF0YU5vZGVSZXNwb25zZSA9IElETC5SZWNvcmQoe1xyXG4gICAgcHJvcGVydHlfbmV3OiBQcm9wZXJ0eVNoYXJlZCxcclxuICAgIHByb3BlcnR5X29sZDogSURMLk9wdChQcm9wZXJ0eVNoYXJlZCksXHJcbiAgfSk7XHJcbiAgY29uc3QgTkZUVXBkYXRlQXBwUmVzdWx0ID0gSURMLlZhcmlhbnQoe1xyXG4gICAgb2s6IE5GVFVwZGF0ZU1ldGFkYXRhTm9kZVJlc3BvbnNlLFxyXG4gICAgZXJyOiBPcmlneW5FcnJvcixcclxuICB9KTtcclxuICByZXR1cm4gSURMLlNlcnZpY2Uoe1xyXG4gICAgX19hZHZhbmNlX3RpbWU6IElETC5GdW5jKFtJREwuSW50XSwgW0lETC5JbnRdLCBbXSksXHJcbiAgICBfX3NldF90aW1lX21vZGU6IElETC5GdW5jKFxyXG4gICAgICBbSURMLlZhcmlhbnQoeyB0ZXN0OiBJREwuTnVsbCwgc3RhbmRhcmQ6IElETC5OdWxsIH0pXSxcclxuICAgICAgW0lETC5Cb29sXSxcclxuICAgICAgW11cclxuICAgICksXHJcbiAgICBfX3N1cHBvcnRzOiBJREwuRnVuYyhcclxuICAgICAgW10sXHJcbiAgICAgIFtJREwuVmVjKElETC5UdXBsZShJREwuVGV4dCwgSURMLlRleHQpKV0sXHJcbiAgICAgIFtcInF1ZXJ5XCJdXHJcbiAgICApLFxyXG4gICAgX192ZXJzaW9uOiBJREwuRnVuYyhbXSwgW0lETC5UZXh0XSwgW1wicXVlcnlcIl0pLFxyXG4gICAgYmFja191cDogSURMLkZ1bmMoXHJcbiAgICAgIFtJREwuTmF0XSxcclxuICAgICAgW0lETC5WYXJpYW50KHsgZW9mOiBORlRCYWNrdXBDaHVuaywgZGF0YTogTkZUQmFja3VwQ2h1bmsgfSldLFxyXG4gICAgICBbXCJxdWVyeVwiXVxyXG4gICAgKSxcclxuICAgIGJhbGFuY2U6IElETC5GdW5jKFtFWFRCYWxhbmNlUmVxdWVzdF0sIFtFWFRCYWxhbmNlUmVzdWx0XSwgW1wicXVlcnlcIl0pLFxyXG4gICAgYmFsYW5jZUVYVDogSURMLkZ1bmMoW0VYVEJhbGFuY2VSZXF1ZXN0XSwgW0VYVEJhbGFuY2VSZXN1bHRdLCBbXCJxdWVyeVwiXSksXHJcbiAgICBiYWxhbmNlX29mX2JhdGNoX25mdF9vcmlneW46IElETC5GdW5jKFxyXG4gICAgICBbSURMLlZlYyhBY2NvdW50X18xKV0sXHJcbiAgICAgIFtJREwuVmVjKEJhbGFuY2VSZXN1bHQpXSxcclxuICAgICAgW1wicXVlcnlcIl1cclxuICAgICksXHJcbiAgICBiYWxhbmNlX29mX25mdF9vcmlneW46IElETC5GdW5jKFtBY2NvdW50X18xXSwgW0JhbGFuY2VSZXN1bHRdLCBbXCJxdWVyeVwiXSksXHJcbiAgICBiYWxhbmNlX29mX3NlY3VyZV9iYXRjaF9uZnRfb3JpZ3luOiBJREwuRnVuYyhcclxuICAgICAgW0lETC5WZWMoQWNjb3VudF9fMSldLFxyXG4gICAgICBbSURMLlZlYyhCYWxhbmNlUmVzdWx0KV0sXHJcbiAgICAgIFtdXHJcbiAgICApLFxyXG4gICAgYmFsYW5jZV9vZl9zZWN1cmVfbmZ0X29yaWd5bjogSURMLkZ1bmMoW0FjY291bnRfXzFdLCBbQmFsYW5jZVJlc3VsdF0sIFtdKSxcclxuICAgIGJlYXJlcjogSURMLkZ1bmMoW0VYVFRva2VuSWRlbnRpZmllcl0sIFtFWFRCZWFyZXJSZXN1bHRdLCBbXCJxdWVyeVwiXSksXHJcbiAgICBiZWFyZXJFWFQ6IElETC5GdW5jKFtFWFRUb2tlbklkZW50aWZpZXJdLCBbRVhUQmVhcmVyUmVzdWx0XSwgW1wicXVlcnlcIl0pLFxyXG4gICAgYmVhcmVyX2JhdGNoX25mdF9vcmlneW46IElETC5GdW5jKFxyXG4gICAgICBbSURMLlZlYyhJREwuVGV4dCldLFxyXG4gICAgICBbSURMLlZlYyhCZWFyZXJSZXN1bHQpXSxcclxuICAgICAgW1wicXVlcnlcIl1cclxuICAgICksXHJcbiAgICBiZWFyZXJfYmF0Y2hfc2VjdXJlX25mdF9vcmlneW46IElETC5GdW5jKFxyXG4gICAgICBbSURMLlZlYyhJREwuVGV4dCldLFxyXG4gICAgICBbSURMLlZlYyhCZWFyZXJSZXN1bHQpXSxcclxuICAgICAgW11cclxuICAgICksXHJcbiAgICBiZWFyZXJfbmZ0X29yaWd5bjogSURMLkZ1bmMoW0lETC5UZXh0XSwgW0JlYXJlclJlc3VsdF0sIFtcInF1ZXJ5XCJdKSxcclxuICAgIGJlYXJlcl9zZWN1cmVfbmZ0X29yaWd5bjogSURMLkZ1bmMoW0lETC5UZXh0XSwgW0JlYXJlclJlc3VsdF0sIFtdKSxcclxuICAgIGNhbmlzdGVyX3N0YXR1czogSURMLkZ1bmMoXHJcbiAgICAgIFtJREwuUmVjb3JkKHsgY2FuaXN0ZXJfaWQ6IGNhbmlzdGVyX2lkIH0pXSxcclxuICAgICAgW2NhbmlzdGVyX3N0YXR1c10sXHJcbiAgICAgIFtdXHJcbiAgICApLFxyXG4gICAgY2h1bmtfbmZ0X29yaWd5bjogSURMLkZ1bmMoW0NodW5rUmVxdWVzdF0sIFtDaHVua1Jlc3VsdF0sIFtcInF1ZXJ5XCJdKSxcclxuICAgIGNodW5rX3NlY3VyZV9uZnRfb3JpZ3luOiBJREwuRnVuYyhbQ2h1bmtSZXF1ZXN0XSwgW0NodW5rUmVzdWx0XSwgW10pLFxyXG4gICAgY29sbGVjdENhbmlzdGVyTWV0cmljczogSURMLkZ1bmMoW10sIFtdLCBbXCJxdWVyeVwiXSksXHJcbiAgICBjb2xsZWN0aW9uX25mdF9vcmlneW46IElETC5GdW5jKFxyXG4gICAgICBbXHJcbiAgICAgICAgSURMLk9wdChcclxuICAgICAgICAgIElETC5WZWMoSURMLlR1cGxlKElETC5UZXh0LCBJREwuT3B0KElETC5OYXQpLCBJREwuT3B0KElETC5OYXQpKSlcclxuICAgICAgICApLFxyXG4gICAgICBdLFxyXG4gICAgICBbQ29sbGVjdGlvblJlc3VsdF0sXHJcbiAgICAgIFtcInF1ZXJ5XCJdXHJcbiAgICApLFxyXG4gICAgY29sbGVjdGlvbl9zZWN1cmVfbmZ0X29yaWd5bjogSURMLkZ1bmMoXHJcbiAgICAgIFtcclxuICAgICAgICBJREwuT3B0KFxyXG4gICAgICAgICAgSURMLlZlYyhJREwuVHVwbGUoSURMLlRleHQsIElETC5PcHQoSURMLk5hdCksIElETC5PcHQoSURMLk5hdCkpKVxyXG4gICAgICAgICksXHJcbiAgICAgIF0sXHJcbiAgICAgIFtDb2xsZWN0aW9uUmVzdWx0XSxcclxuICAgICAgW11cclxuICAgICksXHJcbiAgICBjb2xsZWN0aW9uX3VwZGF0ZV9iYXRjaF9uZnRfb3JpZ3luOiBJREwuRnVuYyhcclxuICAgICAgW0lETC5WZWMoTWFuYWdlQ29sbGVjdGlvbkNvbW1hbmQpXSxcclxuICAgICAgW0lETC5WZWMoT3JpZ3luQm9vbFJlc3VsdCldLFxyXG4gICAgICBbXVxyXG4gICAgKSxcclxuICAgIGNvbGxlY3Rpb25fdXBkYXRlX25mdF9vcmlneW46IElETC5GdW5jKFxyXG4gICAgICBbTWFuYWdlQ29sbGVjdGlvbkNvbW1hbmRdLFxyXG4gICAgICBbT3JpZ3luQm9vbFJlc3VsdF0sXHJcbiAgICAgIFtdXHJcbiAgICApLFxyXG4gICAgY291bnRfdW5saXN0ZWRfdG9rZW5zX29mOiBJREwuRnVuYyhbQWNjb3VudF0sIFtJREwuTmF0XSwgW1wicXVlcnlcIl0pLFxyXG4gICAgY3ljbGVzOiBJREwuRnVuYyhbXSwgW0lETC5OYXRdLCBbXCJxdWVyeVwiXSksXHJcbiAgICBkaXA3MjFfYmFsYW5jZV9vZjogSURMLkZ1bmMoW0lETC5QcmluY2lwYWxdLCBbSURMLk5hdF0sIFtcInF1ZXJ5XCJdKSxcclxuICAgIGRpcDcyMV9jdXN0b2RpYW5zOiBJREwuRnVuYyhbXSwgW0lETC5WZWMoSURMLlByaW5jaXBhbCldLCBbXCJxdWVyeVwiXSksXHJcbiAgICBkaXA3MjFfaXNfYXBwcm92ZWRfZm9yX2FsbDogSURMLkZ1bmMoXHJcbiAgICAgIFtJREwuUHJpbmNpcGFsLCBJREwuUHJpbmNpcGFsXSxcclxuICAgICAgW0RJUDcyMUJvb2xSZXN1bHRdLFxyXG4gICAgICBbXCJxdWVyeVwiXVxyXG4gICAgKSxcclxuICAgIGRpcDcyMV9sb2dvOiBJREwuRnVuYyhbXSwgW0lETC5PcHQoSURMLlRleHQpXSwgW1wicXVlcnlcIl0pLFxyXG4gICAgZGlwNzIxX21ldGFkYXRhOiBJREwuRnVuYyhbXSwgW0RJUDcyMU1ldGFkYXRhXSwgW1wicXVlcnlcIl0pLFxyXG4gICAgZGlwNzIxX25hbWU6IElETC5GdW5jKFtdLCBbSURMLk9wdChJREwuVGV4dCldLCBbXCJxdWVyeVwiXSksXHJcbiAgICBkaXA3MjFfb3BlcmF0b3JfdG9rZW5faWRlbnRpZmllcnM6IElETC5GdW5jKFxyXG4gICAgICBbSURMLlByaW5jaXBhbF0sXHJcbiAgICAgIFtESVA3MjFUb2tlbnNMaXN0TWV0YWRhdGFdLFxyXG4gICAgICBbXCJxdWVyeVwiXVxyXG4gICAgKSxcclxuICAgIGRpcDcyMV9vcGVyYXRvcl90b2tlbl9tZXRhZGF0YTogSURMLkZ1bmMoXHJcbiAgICAgIFtJREwuUHJpbmNpcGFsXSxcclxuICAgICAgW0RJUDcyMVRva2Vuc01ldGFkYXRhXSxcclxuICAgICAgW1wicXVlcnlcIl1cclxuICAgICksXHJcbiAgICBkaXA3MjFfb3duZXJfb2Y6IElETC5GdW5jKFtJREwuTmF0XSwgW093bmVyT2ZSZXNwb25zZV0sIFtcInF1ZXJ5XCJdKSxcclxuICAgIGRpcDcyMV9vd25lcl90b2tlbl9pZGVudGlmaWVyczogSURMLkZ1bmMoXHJcbiAgICAgIFtJREwuUHJpbmNpcGFsXSxcclxuICAgICAgW0RJUDcyMVRva2Vuc0xpc3RNZXRhZGF0YV0sXHJcbiAgICAgIFtcInF1ZXJ5XCJdXHJcbiAgICApLFxyXG4gICAgZGlwNzIxX293bmVyX3Rva2VuX21ldGFkYXRhOiBJREwuRnVuYyhcclxuICAgICAgW0lETC5QcmluY2lwYWxdLFxyXG4gICAgICBbRElQNzIxVG9rZW5zTWV0YWRhdGFdLFxyXG4gICAgICBbXCJxdWVyeVwiXVxyXG4gICAgKSxcclxuICAgIGRpcDcyMV9zdGF0czogSURMLkZ1bmMoW10sIFtESVA3MjFTdGF0c10sIFtcInF1ZXJ5XCJdKSxcclxuICAgIGRpcDcyMV9zdXBwb3J0ZWRfaW50ZXJmYWNlczogSURMLkZ1bmMoXHJcbiAgICAgIFtdLFxyXG4gICAgICBbSURMLlZlYyhESVA3MjFTdXBwb3J0ZWRJbnRlcmZhY2UpXSxcclxuICAgICAgW1wicXVlcnlcIl1cclxuICAgICksXHJcbiAgICBkaXA3MjFfc3ltYm9sOiBJREwuRnVuYyhbXSwgW0lETC5PcHQoSURMLlRleHQpXSwgW1wicXVlcnlcIl0pLFxyXG4gICAgZGlwNzIxX3Rva2VuX21ldGFkYXRhOiBJREwuRnVuYyhcclxuICAgICAgW0lETC5OYXRdLFxyXG4gICAgICBbRElQNzIxVG9rZW5NZXRhZGF0YV0sXHJcbiAgICAgIFtcInF1ZXJ5XCJdXHJcbiAgICApLFxyXG4gICAgZGlwNzIxX3RvdGFsX3N1cHBseTogSURMLkZ1bmMoW10sIFtJREwuTmF0XSwgW1wicXVlcnlcIl0pLFxyXG4gICAgZGlwNzIxX3RvdGFsX3RyYW5zYWN0aW9uczogSURMLkZ1bmMoW10sIFtJREwuTmF0XSwgW1wicXVlcnlcIl0pLFxyXG4gICAgZGlwNzIxX3RyYW5zZmVyOiBJREwuRnVuYyhbSURMLlByaW5jaXBhbCwgSURMLk5hdF0sIFtESVA3MjFOYXRSZXN1bHRdLCBbXSksXHJcbiAgICBkaXA3MjFfdHJhbnNmZXJfZnJvbTogSURMLkZ1bmMoXHJcbiAgICAgIFtJREwuUHJpbmNpcGFsLCBJREwuUHJpbmNpcGFsLCBJREwuTmF0XSxcclxuICAgICAgW0RJUDcyMU5hdFJlc3VsdF0sXHJcbiAgICAgIFtdXHJcbiAgICApLFxyXG4gICAgZ2V0Q2FuaXN0ZXJMb2c6IElETC5GdW5jKFxyXG4gICAgICBbSURMLk9wdChDYW5pc3RlckxvZ1JlcXVlc3QpXSxcclxuICAgICAgW0lETC5PcHQoQ2FuaXN0ZXJMb2dSZXNwb25zZSldLFxyXG4gICAgICBbXCJxdWVyeVwiXVxyXG4gICAgKSxcclxuICAgIGdldENhbmlzdGVyTWV0cmljczogSURMLkZ1bmMoXHJcbiAgICAgIFtHZXRNZXRyaWNzUGFyYW1ldGVyc10sXHJcbiAgICAgIFtJREwuT3B0KENhbmlzdGVyTWV0cmljcyldLFxyXG4gICAgICBbXCJxdWVyeVwiXVxyXG4gICAgKSxcclxuICAgIGdldEVYVFRva2VuSWRlbnRpZmllcjogSURMLkZ1bmMoW0lETC5UZXh0XSwgW0lETC5UZXh0XSwgW1wicXVlcnlcIl0pLFxyXG4gICAgZ2V0X2FjY2Vzc19rZXk6IElETC5GdW5jKFtdLCBbT3JpZ3luVGV4dFJlc3VsdF0sIFtcInF1ZXJ5XCJdKSxcclxuICAgIGdldF9oYWx0OiBJREwuRnVuYyhbXSwgW0lETC5Cb29sXSwgW1wicXVlcnlcIl0pLFxyXG4gICAgZ2V0X25hdF9hc190b2tlbl9pZF9vcmlneW46IElETC5GdW5jKFtJREwuTmF0XSwgW0lETC5UZXh0XSwgW1wicXVlcnlcIl0pLFxyXG4gICAgZ2V0X3RpcDogSURMLkZ1bmMoW10sIFtUaXBdLCBbXCJxdWVyeVwiXSksXHJcbiAgICBnZXRfdG9rZW5faWRfYXNfbmF0OiBJREwuRnVuYyhbSURMLlRleHRdLCBbSURMLk5hdF0sIFtcInF1ZXJ5XCJdKSxcclxuICAgIGdvdmVybmFuY2VfYmF0Y2hfbmZ0X29yaWd5bjogSURMLkZ1bmMoXHJcbiAgICAgIFtJREwuVmVjKEdvdmVybmFuY2VSZXF1ZXN0KV0sXHJcbiAgICAgIFtJREwuVmVjKEdvdmVybmFuY2VSZXN1bHQpXSxcclxuICAgICAgW11cclxuICAgICksXHJcbiAgICBnb3Zlcm5hbmNlX25mdF9vcmlneW46IElETC5GdW5jKFxyXG4gICAgICBbR292ZXJuYW5jZVJlcXVlc3RdLFxyXG4gICAgICBbR292ZXJuYW5jZVJlc3VsdF0sXHJcbiAgICAgIFtdXHJcbiAgICApLFxyXG4gICAgaGlzdG9yeV9iYXRjaF9uZnRfb3JpZ3luOiBJREwuRnVuYyhcclxuICAgICAgW0lETC5WZWMoSURMLlR1cGxlKElETC5UZXh0LCBJREwuT3B0KElETC5OYXQpLCBJREwuT3B0KElETC5OYXQpKSldLFxyXG4gICAgICBbSURMLlZlYyhIaXN0b3J5UmVzdWx0KV0sXHJcbiAgICAgIFtcInF1ZXJ5XCJdXHJcbiAgICApLFxyXG4gICAgaGlzdG9yeV9iYXRjaF9zZWN1cmVfbmZ0X29yaWd5bjogSURMLkZ1bmMoXHJcbiAgICAgIFtJREwuVmVjKElETC5UdXBsZShJREwuVGV4dCwgSURMLk9wdChJREwuTmF0KSwgSURMLk9wdChJREwuTmF0KSkpXSxcclxuICAgICAgW0lETC5WZWMoSGlzdG9yeVJlc3VsdCldLFxyXG4gICAgICBbXVxyXG4gICAgKSxcclxuICAgIGhpc3RvcnlfbmZ0X29yaWd5bjogSURMLkZ1bmMoXHJcbiAgICAgIFtJREwuVGV4dCwgSURMLk9wdChJREwuTmF0KSwgSURMLk9wdChJREwuTmF0KV0sXHJcbiAgICAgIFtIaXN0b3J5UmVzdWx0XSxcclxuICAgICAgW1wicXVlcnlcIl1cclxuICAgICksXHJcbiAgICBoaXN0b3J5X3NlY3VyZV9uZnRfb3JpZ3luOiBJREwuRnVuYyhcclxuICAgICAgW0lETC5UZXh0LCBJREwuT3B0KElETC5OYXQpLCBJREwuT3B0KElETC5OYXQpXSxcclxuICAgICAgW0hpc3RvcnlSZXN1bHRdLFxyXG4gICAgICBbXVxyXG4gICAgKSxcclxuICAgIGh0dHBfYWNjZXNzX2tleTogSURMLkZ1bmMoW10sIFtPcmlneW5UZXh0UmVzdWx0XSwgW10pLFxyXG4gICAgaHR0cF9yZXF1ZXN0OiBJREwuRnVuYyhbSHR0cFJlcXVlc3RdLCBbSFRUUFJlc3BvbnNlXSwgW1wicXVlcnlcIl0pLFxyXG4gICAgaHR0cF9yZXF1ZXN0X3N0cmVhbWluZ19jYWxsYmFjazogSURMLkZ1bmMoXHJcbiAgICAgIFtTdHJlYW1pbmdDYWxsYmFja1Rva2VuXSxcclxuICAgICAgW1N0cmVhbWluZ0NhbGxiYWNrUmVzcG9uc2VdLFxyXG4gICAgICBbXCJxdWVyeVwiXVxyXG4gICAgKSxcclxuICAgIGljcmMzX2dldF9hcmNoaXZlczogSURMLkZ1bmMoXHJcbiAgICAgIFtHZXRBcmNoaXZlc0FyZ3NdLFxyXG4gICAgICBbR2V0QXJjaGl2ZXNSZXN1bHRdLFxyXG4gICAgICBbXCJxdWVyeVwiXVxyXG4gICAgKSxcclxuICAgIGljcmMzX2dldF9ibG9ja3M6IElETC5GdW5jKFxyXG4gICAgICBbSURMLlZlYyhUcmFuc2FjdGlvblJhbmdlKV0sXHJcbiAgICAgIFtHZXRUcmFuc2FjdGlvbnNSZXN1bHRdLFxyXG4gICAgICBbXCJxdWVyeVwiXVxyXG4gICAgKSxcclxuICAgIGljcmMzX2dldF90aXBfY2VydGlmaWNhdGU6IElETC5GdW5jKFxyXG4gICAgICBbXSxcclxuICAgICAgW0lETC5PcHQoRGF0YUNlcnRpZmljYXRlKV0sXHJcbiAgICAgIFtcInF1ZXJ5XCJdXHJcbiAgICApLFxyXG4gICAgaWNyYzNfc3VwcG9ydGVkX2Jsb2NrX3R5cGVzOiBJREwuRnVuYyhbXSwgW0lETC5WZWMoQmxvY2tUeXBlKV0sIFtcInF1ZXJ5XCJdKSxcclxuICAgIGljcmM3X2FwcHJvdmU6IElETC5GdW5jKFtBcHByb3ZhbEFyZ3NdLCBbQXBwcm92YWxSZXN1bHRdLCBbXSksXHJcbiAgICBpY3JjN19hdG9taWNfYmF0Y2hfdHJhbnNmZXJzOiBJREwuRnVuYyhbXSwgW0lETC5PcHQoSURMLkJvb2wpXSwgW1wicXVlcnlcIl0pLFxyXG4gICAgaWNyYzdfYmFsYW5jZV9vZjogSURMLkZ1bmMoXHJcbiAgICAgIFtJREwuVmVjKEFjY291bnQpXSxcclxuICAgICAgW0lETC5WZWMoSURMLk5hdCldLFxyXG4gICAgICBbXCJxdWVyeVwiXVxyXG4gICAgKSxcclxuICAgIGljcmM3X2NvbGxlY3Rpb25fbWV0YWRhdGE6IElETC5GdW5jKFtdLCBbQ29sbGVjdGlvbk1ldGFkYXRhXSwgW1wicXVlcnlcIl0pLFxyXG4gICAgaWNyYzdfZGVmYXVsdF90YWtlX3ZhbHVlOiBJREwuRnVuYyhbXSwgW0lETC5PcHQoSURMLk5hdCldLCBbXCJxdWVyeVwiXSksXHJcbiAgICBpY3JjN19kZXNjcmlwdGlvbjogSURMLkZ1bmMoW10sIFtJREwuT3B0KElETC5UZXh0KV0sIFtcInF1ZXJ5XCJdKSxcclxuICAgIGljcmM3X2xvZ286IElETC5GdW5jKFtdLCBbSURMLk9wdChJREwuVGV4dCldLCBbXCJxdWVyeVwiXSksXHJcbiAgICBpY3JjN19tYXhfYXBwcm92YWxzX3Blcl90b2tlbl9vcl9jb2xsZWN0aW9uOiBJREwuRnVuYyhcclxuICAgICAgW10sXHJcbiAgICAgIFtJREwuT3B0KElETC5OYXQpXSxcclxuICAgICAgW1wicXVlcnlcIl1cclxuICAgICksXHJcbiAgICBpY3JjN19tYXhfbWVtb19zaXplOiBJREwuRnVuYyhbXSwgW0lETC5PcHQoSURMLk5hdCldLCBbXCJxdWVyeVwiXSksXHJcbiAgICBpY3JjN19tYXhfcXVlcnlfYmF0Y2hfc2l6ZTogSURMLkZ1bmMoW10sIFtJREwuT3B0KElETC5OYXQpXSwgW1wicXVlcnlcIl0pLFxyXG4gICAgaWNyYzdfbWF4X3Jldm9rZV9hcHByb3ZhbHM6IElETC5GdW5jKFtdLCBbSURMLk9wdChJREwuTmF0KV0sIFtcInF1ZXJ5XCJdKSxcclxuICAgIGljcmM3X21heF90YWtlX3ZhbHVlOiBJREwuRnVuYyhbXSwgW0lETC5PcHQoSURMLk5hdCldLCBbXCJxdWVyeVwiXSksXHJcbiAgICBpY3JjN19tYXhfdXBkYXRlX2JhdGNoX3NpemU6IElETC5GdW5jKFtdLCBbSURMLk9wdChJREwuTmF0KV0sIFtcInF1ZXJ5XCJdKSxcclxuICAgIGljcmM3X25hbWU6IElETC5GdW5jKFtdLCBbSURMLlRleHRdLCBbXCJxdWVyeVwiXSksXHJcbiAgICBpY3JjN19vd25lcl9vZjogSURMLkZ1bmMoXHJcbiAgICAgIFtJREwuVmVjKElETC5OYXQpXSxcclxuICAgICAgW0lETC5WZWMoSURMLk9wdChBY2NvdW50KSldLFxyXG4gICAgICBbXCJxdWVyeVwiXVxyXG4gICAgKSxcclxuICAgIGljcmM3X3Blcm1pdHRlZF9kcmlmdDogSURMLkZ1bmMoW10sIFtJREwuT3B0KElETC5OYXQpXSwgW1wicXVlcnlcIl0pLFxyXG4gICAgaWNyYzdfc3VwcGx5X2NhcDogSURMLkZ1bmMoW10sIFtJREwuT3B0KElETC5OYXQpXSwgW1wicXVlcnlcIl0pLFxyXG4gICAgaWNyYzdfc3VwcG9ydGVkX3N0YW5kYXJkczogSURMLkZ1bmMoXHJcbiAgICAgIFtdLFxyXG4gICAgICBbSURMLlZlYyhTdXBwb3J0ZWRTdGFuZGFyZCldLFxyXG4gICAgICBbXCJxdWVyeVwiXVxyXG4gICAgKSxcclxuICAgIGljcmM3X3N5bWJvbDogSURMLkZ1bmMoW10sIFtJREwuVGV4dF0sIFtcInF1ZXJ5XCJdKSxcclxuICAgIGljcmM3X3Rva2VuX21ldGFkYXRhOiBJREwuRnVuYyhcclxuICAgICAgW0lETC5WZWMoSURMLk5hdCldLFxyXG4gICAgICBbSURMLlZlYyhJREwuT3B0KElETC5WZWMoSURMLlR1cGxlKElETC5UZXh0LCBWYWx1ZSkpKSldLFxyXG4gICAgICBbXCJxdWVyeVwiXVxyXG4gICAgKSxcclxuICAgIGljcmM3X3Rva2VuczogSURMLkZ1bmMoXHJcbiAgICAgIFtJREwuT3B0KElETC5OYXQpLCBJREwuT3B0KElETC5OYXQzMildLFxyXG4gICAgICBbSURMLlZlYyhJREwuTmF0KV0sXHJcbiAgICAgIFtcInF1ZXJ5XCJdXHJcbiAgICApLFxyXG4gICAgaWNyYzdfdG9rZW5zX29mOiBJREwuRnVuYyhcclxuICAgICAgW0FjY291bnQsIElETC5PcHQoSURMLk5hdCksIElETC5PcHQoSURMLk5hdDMyKV0sXHJcbiAgICAgIFtJREwuVmVjKElETC5OYXQpXSxcclxuICAgICAgW1wicXVlcnlcIl1cclxuICAgICksXHJcbiAgICBpY3JjN190b3RhbF9zdXBwbHk6IElETC5GdW5jKFtdLCBbSURMLk5hdF0sIFtcInF1ZXJ5XCJdKSxcclxuICAgIGljcmM3X3RyYW5zZmVyOiBJREwuRnVuYyhbSURMLlZlYyhUcmFuc2ZlckFyZ3MpXSwgW1RyYW5zZmVyUmVzdWx0XSwgW10pLFxyXG4gICAgaWNyYzdfdHJhbnNmZXJfZmVlOiBJREwuRnVuYyhbSURMLk5hdF0sIFtJREwuT3B0KElETC5OYXQpXSwgW1wicXVlcnlcIl0pLFxyXG4gICAgaWNyYzdfdHhfd2luZG93OiBJREwuRnVuYyhbXSwgW0lETC5PcHQoSURMLk5hdCldLCBbXCJxdWVyeVwiXSksXHJcbiAgICBtYW5hZ2Vfc3RvcmFnZV9uZnRfb3JpZ3luOiBJREwuRnVuYyhcclxuICAgICAgW01hbmFnZVN0b3JhZ2VSZXF1ZXN0XSxcclxuICAgICAgW01hbmFnZVN0b3JhZ2VSZXN1bHRdLFxyXG4gICAgICBbXVxyXG4gICAgKSxcclxuICAgIG1hcmtldF90cmFuc2Zlcl9iYXRjaF9uZnRfb3JpZ3luOiBJREwuRnVuYyhcclxuICAgICAgW0lETC5WZWMoTWFya2V0VHJhbnNmZXJSZXF1ZXN0KV0sXHJcbiAgICAgIFtJREwuVmVjKE1hcmtldFRyYW5zZmVyUmVzdWx0KV0sXHJcbiAgICAgIFtdXHJcbiAgICApLFxyXG4gICAgbWFya2V0X3RyYW5zZmVyX25mdF9vcmlneW46IElETC5GdW5jKFxyXG4gICAgICBbTWFya2V0VHJhbnNmZXJSZXF1ZXN0XSxcclxuICAgICAgW01hcmtldFRyYW5zZmVyUmVzdWx0XSxcclxuICAgICAgW11cclxuICAgICksXHJcbiAgICBtZXRhZGF0YTogSURMLkZ1bmMoW10sIFtESVA3MjFNZXRhZGF0YV0sIFtcInF1ZXJ5XCJdKSxcclxuICAgIG1ldGFkYXRhRXh0OiBJREwuRnVuYyhbRVhUVG9rZW5JZGVudGlmaWVyXSwgW0VYVE1ldGFkYXRhUmVzdWx0XSwgW1wicXVlcnlcIl0pLFxyXG4gICAgbWludF9iYXRjaF9uZnRfb3JpZ3luOiBJREwuRnVuYyhcclxuICAgICAgW0lETC5WZWMoSURMLlR1cGxlKElETC5UZXh0LCBBY2NvdW50X18xKSldLFxyXG4gICAgICBbSURMLlZlYyhPcmlneW5UZXh0UmVzdWx0KV0sXHJcbiAgICAgIFtdXHJcbiAgICApLFxyXG4gICAgbWludF9uZnRfb3JpZ3luOiBJREwuRnVuYyhbSURMLlRleHQsIEFjY291bnRfXzFdLCBbT3JpZ3luVGV4dFJlc3VsdF0sIFtdKSxcclxuICAgIG5mdFN0cmVhbWluZ0NhbGxiYWNrOiBJREwuRnVuYyhcclxuICAgICAgW1N0cmVhbWluZ0NhbGxiYWNrVG9rZW5dLFxyXG4gICAgICBbU3RyZWFtaW5nQ2FsbGJhY2tSZXNwb25zZV0sXHJcbiAgICAgIFtcInF1ZXJ5XCJdXHJcbiAgICApLFxyXG4gICAgbmZ0X2JhdGNoX29yaWd5bjogSURMLkZ1bmMoXHJcbiAgICAgIFtJREwuVmVjKElETC5UZXh0KV0sXHJcbiAgICAgIFtJREwuVmVjKE5GVEluZm9SZXN1bHQpXSxcclxuICAgICAgW1wicXVlcnlcIl1cclxuICAgICksXHJcbiAgICBuZnRfYmF0Y2hfc2VjdXJlX29yaWd5bjogSURMLkZ1bmMoXHJcbiAgICAgIFtJREwuVmVjKElETC5UZXh0KV0sXHJcbiAgICAgIFtJREwuVmVjKE5GVEluZm9SZXN1bHQpXSxcclxuICAgICAgW11cclxuICAgICksXHJcbiAgICBuZnRfb3JpZ3luOiBJREwuRnVuYyhbSURMLlRleHRdLCBbTkZUSW5mb1Jlc3VsdF0sIFtcInF1ZXJ5XCJdKSxcclxuICAgIG5mdF9zZWN1cmVfb3JpZ3luOiBJREwuRnVuYyhbSURMLlRleHRdLCBbTkZUSW5mb1Jlc3VsdF0sIFtdKSxcclxuICAgIG9wZXJhdGVyVG9rZW5NZXRhZGF0YTogSURMLkZ1bmMoXHJcbiAgICAgIFtJREwuUHJpbmNpcGFsXSxcclxuICAgICAgW0RJUDcyMVRva2Vuc01ldGFkYXRhXSxcclxuICAgICAgW1wicXVlcnlcIl1cclxuICAgICksXHJcbiAgICBvd25lck9mOiBJREwuRnVuYyhbSURMLk5hdF0sIFtPd25lck9mUmVzcG9uc2VdLCBbXCJxdWVyeVwiXSksXHJcbiAgICBvd25lclRva2VuTWV0YWRhdGE6IElETC5GdW5jKFxyXG4gICAgICBbSURMLlByaW5jaXBhbF0sXHJcbiAgICAgIFtESVA3MjFUb2tlbnNNZXRhZGF0YV0sXHJcbiAgICAgIFtcInF1ZXJ5XCJdXHJcbiAgICApLFxyXG4gICAgc2FsZV9iYXRjaF9uZnRfb3JpZ3luOiBJREwuRnVuYyhcclxuICAgICAgW0lETC5WZWMoTWFuYWdlU2FsZVJlcXVlc3QpXSxcclxuICAgICAgW0lETC5WZWMoTWFuYWdlU2FsZVJlc3VsdCldLFxyXG4gICAgICBbXVxyXG4gICAgKSxcclxuICAgIHNhbGVfaW5mb19iYXRjaF9uZnRfb3JpZ3luOiBJREwuRnVuYyhcclxuICAgICAgW0lETC5WZWMoU2FsZUluZm9SZXF1ZXN0KV0sXHJcbiAgICAgIFtJREwuVmVjKFNhbGVJbmZvUmVzdWx0KV0sXHJcbiAgICAgIFtcInF1ZXJ5XCJdXHJcbiAgICApLFxyXG4gICAgc2FsZV9pbmZvX2JhdGNoX3NlY3VyZV9uZnRfb3JpZ3luOiBJREwuRnVuYyhcclxuICAgICAgW0lETC5WZWMoU2FsZUluZm9SZXF1ZXN0KV0sXHJcbiAgICAgIFtJREwuVmVjKFNhbGVJbmZvUmVzdWx0KV0sXHJcbiAgICAgIFtdXHJcbiAgICApLFxyXG4gICAgc2FsZV9pbmZvX25mdF9vcmlneW46IElETC5GdW5jKFxyXG4gICAgICBbU2FsZUluZm9SZXF1ZXN0XSxcclxuICAgICAgW1NhbGVJbmZvUmVzdWx0XSxcclxuICAgICAgW1wicXVlcnlcIl1cclxuICAgICksXHJcbiAgICBzYWxlX2luZm9fc2VjdXJlX25mdF9vcmlneW46IElETC5GdW5jKFxyXG4gICAgICBbU2FsZUluZm9SZXF1ZXN0XSxcclxuICAgICAgW1NhbGVJbmZvUmVzdWx0XSxcclxuICAgICAgW11cclxuICAgICksXHJcbiAgICBzYWxlX25mdF9vcmlneW46IElETC5GdW5jKFtNYW5hZ2VTYWxlUmVxdWVzdF0sIFtNYW5hZ2VTYWxlUmVzdWx0XSwgW10pLFxyXG4gICAgc2V0X2RhdGFfaGFydmVzdGVyOiBJREwuRnVuYyhbSURMLk5hdF0sIFtdLCBbXSksXHJcbiAgICBzZXRfaGFsdDogSURMLkZ1bmMoW0lETC5Cb29sXSwgW10sIFtdKSxcclxuICAgIHNoYXJlX3dhbGxldF9uZnRfb3JpZ3luOiBJREwuRnVuYyhcclxuICAgICAgW1NoYXJlV2FsbGV0UmVxdWVzdF0sXHJcbiAgICAgIFtPd25lclVwZGF0ZVJlc3VsdF0sXHJcbiAgICAgIFtdXHJcbiAgICApLFxyXG4gICAgc3RhZ2VfYmF0Y2hfbmZ0X29yaWd5bjogSURMLkZ1bmMoXHJcbiAgICAgIFtJREwuVmVjKElETC5SZWNvcmQoeyBtZXRhZGF0YTogQ2FuZHlTaGFyZWQgfSkpXSxcclxuICAgICAgW0lETC5WZWMoT3JpZ3luVGV4dFJlc3VsdCldLFxyXG4gICAgICBbXVxyXG4gICAgKSxcclxuICAgIHN0YWdlX2xpYnJhcnlfYmF0Y2hfbmZ0X29yaWd5bjogSURMLkZ1bmMoXHJcbiAgICAgIFtJREwuVmVjKFN0YWdlQ2h1bmtBcmcpXSxcclxuICAgICAgW0lETC5WZWMoU3RhZ2VMaWJyYXJ5UmVzdWx0KV0sXHJcbiAgICAgIFtdXHJcbiAgICApLFxyXG4gICAgc3RhZ2VfbGlicmFyeV9uZnRfb3JpZ3luOiBJREwuRnVuYyhcclxuICAgICAgW1N0YWdlQ2h1bmtBcmddLFxyXG4gICAgICBbU3RhZ2VMaWJyYXJ5UmVzdWx0XSxcclxuICAgICAgW11cclxuICAgICksXHJcbiAgICBzdGFnZV9uZnRfb3JpZ3luOiBJREwuRnVuYyhcclxuICAgICAgW0lETC5SZWNvcmQoeyBtZXRhZGF0YTogQ2FuZHlTaGFyZWQgfSldLFxyXG4gICAgICBbT3JpZ3luVGV4dFJlc3VsdF0sXHJcbiAgICAgIFtdXHJcbiAgICApLFxyXG4gICAgc3RhdGVfc2l6ZTogSURMLkZ1bmMoW10sIFtTdGF0ZVNpemVdLCBbXCJxdWVyeVwiXSksXHJcbiAgICBzdG9yYWdlX2luZm9fbmZ0X29yaWd5bjogSURMLkZ1bmMoW10sIFtTdG9yYWdlTWV0cmljc1Jlc3VsdF0sIFtcInF1ZXJ5XCJdKSxcclxuICAgIHN0b3JhZ2VfaW5mb19zZWN1cmVfbmZ0X29yaWd5bjogSURMLkZ1bmMoW10sIFtTdG9yYWdlTWV0cmljc1Jlc3VsdF0sIFtdKSxcclxuICAgIHRva2Vuc19leHQ6IElETC5GdW5jKFtJREwuVGV4dF0sIFtFWFRUb2tlbnNSZXN1bHRdLCBbXCJxdWVyeVwiXSksXHJcbiAgICB0cmFuc2ZlcjogSURMLkZ1bmMoW0VYVFRyYW5zZmVyUmVxdWVzdF0sIFtFWFRUcmFuc2ZlclJlc3BvbnNlXSwgW10pLFxyXG4gICAgdHJhbnNmZXJEaXA3MjE6IElETC5GdW5jKFtJREwuUHJpbmNpcGFsLCBJREwuTmF0XSwgW0RJUDcyMU5hdFJlc3VsdF0sIFtdKSxcclxuICAgIHRyYW5zZmVyRVhUOiBJREwuRnVuYyhbRVhUVHJhbnNmZXJSZXF1ZXN0XSwgW0VYVFRyYW5zZmVyUmVzcG9uc2VdLCBbXSksXHJcbiAgICB0cmFuc2ZlckZyb206IElETC5GdW5jKFxyXG4gICAgICBbSURMLlByaW5jaXBhbCwgSURMLlByaW5jaXBhbCwgSURMLk5hdF0sXHJcbiAgICAgIFtESVA3MjFOYXRSZXN1bHRdLFxyXG4gICAgICBbXVxyXG4gICAgKSxcclxuICAgIHRyYW5zZmVyRnJvbURpcDcyMTogSURMLkZ1bmMoXHJcbiAgICAgIFtJREwuUHJpbmNpcGFsLCBJREwuUHJpbmNpcGFsLCBJREwuTmF0XSxcclxuICAgICAgW0RJUDcyMU5hdFJlc3VsdF0sXHJcbiAgICAgIFtdXHJcbiAgICApLFxyXG4gICAgdW5saXN0ZWRfdG9rZW5zX29mOiBJREwuRnVuYyhcclxuICAgICAgW0FjY291bnQsIElETC5PcHQoSURMLk5hdCksIElETC5PcHQoSURMLk5hdDMyKV0sXHJcbiAgICAgIFtJREwuVmVjKElETC5OYXQpXSxcclxuICAgICAgW1wicXVlcnlcIl1cclxuICAgICksXHJcbiAgICB1cGRhdGVfYXBwX25mdF9vcmlneW46IElETC5GdW5jKFtORlRVcGRhdGVSZXF1ZXN0XSwgW05GVFVwZGF0ZVJlc3VsdF0sIFtdKSxcclxuICAgIHVwZGF0ZV9pY3JjMzogSURMLkZ1bmMoW0lETC5WZWMoVXBkYXRlU2V0dGluZyldLCBbSURMLlZlYyhJREwuQm9vbCldLCBbXSksXHJcbiAgICB1cGRhdGVfbWV0YWRhdGFfbm9kZTogSURMLkZ1bmMoXHJcbiAgICAgIFtORlRVcGRhdGVNZXRhZGF0YU5vZGVdLFxyXG4gICAgICBbTkZUVXBkYXRlQXBwUmVzdWx0XSxcclxuICAgICAgW11cclxuICAgICksXHJcbiAgICB3YWxsZXRfcmVjZWl2ZTogSURMLkZ1bmMoW10sIFtJREwuTmF0XSwgW10pLFxyXG4gICAgd2hvYW1pOiBJREwuRnVuYyhbXSwgW0lETC5QcmluY2lwYWxdLCBbXCJxdWVyeVwiXSksXHJcbiAgfSk7XHJcbn07XHJcbmV4cG9ydCBjb25zdCBpbml0ID0gKHsgSURMIH0pID0+IHtcclxuICByZXR1cm4gW107XHJcbn07XHJcbiJdLCJuYW1lcyI6WyJpZGxGYWN0b3J5IiwiSURMIiwiQXJjaGl2ZWRUcmFuc2FjdGlvblJlc3BvbnNlIiwiUmVjIiwiQ2FuZHlTaGFyZWQiLCJNYW5hZ2VTYWxlUmVzcG9uc2UiLCJVcGRhdGVTaGFyZWQiLCJWYWx1ZSIsIlZhbHVlX18xIiwiVmVjIiwiUHJvcGVydHlTaGFyZWQiLCJSZWNvcmQiLCJ2YWx1ZSIsIm5hbWUiLCJUZXh0IiwiaW1tdXRhYmxlIiwiQm9vbCIsImZpbGwiLCJWYXJpYW50IiwiSW50IiwiTWFwIiwiVHVwbGUiLCJOYXQiLCJTZXQiLCJOYXQxNiIsIk5hdDMyIiwiTmF0NjQiLCJCbG9iIiwiTmF0OCIsIkludDgiLCJJbnRzIiwiTmF0cyIsIkJ5dGVzIiwiSW50MTYiLCJJbnQzMiIsIkludDY0IiwiT3B0aW9uIiwiT3B0IiwiRmxvYXRzIiwiRmxvYXQ2NCIsIkZsb2F0IiwiUHJpbmNpcGFsIiwiQXJyYXkiLCJDbGFzcyIsIkFjY291bnRfXzEiLCJhY2NvdW50X2lkIiwicHJpbmNpcGFsIiwiZXh0ZW5zaWJsZSIsImFjY291bnQiLCJvd25lciIsInN1Yl9hY2NvdW50IiwiSUNUb2tlblNwZWNfXzEiLCJpZCIsImZlZSIsImRlY2ltYWxzIiwiY2FuaXN0ZXIiLCJzdGFuZGFyZCIsIklDUkMxIiwiTnVsbCIsIkVYVEZ1bmdpYmxlIiwiRElQMjAiLCJPdGhlciIsIkxlZGdlciIsInN5bWJvbCIsIlRva2VuU3BlY19fMSIsImljIiwiRXNjcm93UmVjb3JkX18xIiwidG9rZW4iLCJ0b2tlbl9pZCIsInNlbGxlciIsImxvY2tfdG9fZGF0ZSIsImJ1eWVyIiwiYW1vdW50Iiwic2FsZV9pZCIsImFjY291bnRfaGFzaCIsIlN0YWJsZVNhbGVzQmFsYW5jZXMiLCJTdGFibGVPZmZlcnMiLCJTdGFibGVDb2xsZWN0aW9uRGF0YSIsImFjdGl2ZV9idWNrZXQiLCJtYW5hZ2VycyIsIm1ldGFkYXRhIiwibG9nbyIsIm5ldHdvcmsiLCJhdmFpbGFibGVfc3BhY2UiLCJhbGxvY2F0ZWRfc3RvcmFnZSIsIklDVG9rZW5TcGVjIiwiVG9rZW5TcGVjIiwiVHJhbnNhY3Rpb25JRCIsIm5hdCIsInRleHQiLCJBY2NvdW50X18yIiwiV2FpdEZvclF1aWV0VHlwZSIsIm1heCIsImZhZGUiLCJleHRlbnNpb24iLCJNaW5JbmNyZWFzZVR5cGUiLCJwZXJjZW50YWdlIiwiRmVlTmFtZSIsIkZlZUFjY291bnRzUGFyYW1zIiwiTmlmdHlTZXR0bGVtZW50VHlwZSIsImZpeGVkIiwiaW50ZXJlc3RSYXRlUGVyU2Vjb25kIiwiZHVyYXRpb24iLCJleHBpcmF0aW9uIiwibGVuZGVyT2ZmZXIiLCJEdXRjaFBhcmFtcyIsInRpbWVfdW5pdCIsImRheSIsImhvdXIiLCJtaW51dGUiLCJkZWNheV90eXBlIiwiZmxhdCIsInBlcmNlbnQiLCJFbmRpbmdUeXBlIiwiZGF0ZSIsInRpbWVvdXQiLCJBc2tGZWF0dXJlIiwia3ljIiwic3RhcnRfcHJpY2UiLCJmZWVfc2NoZW1hIiwibm90aWZ5Iiwid2FpdF9mb3JfcXVpZXQiLCJyZXNlcnZlIiwic3RhcnRfZGF0ZSIsIm1pbl9pbmNyZWFzZSIsImFsbG93X2xpc3QiLCJidXlfbm93IiwiZmVlX2FjY291bnRzIiwibmlmdHlfc2V0dGxlbWVudCIsImF0b21pYyIsImR1dGNoIiwiZW5kaW5nIiwiQXNrRmVhdHVyZUFycmF5IiwiQXNrQ29uZmlnU2hhcmVkIiwiSW5zdGFudEZlYXR1cmUiLCJ0cmFuc2ZlciIsIkluc3RhbnRDb25maWdTaGFyZWQiLCJBdWN0aW9uQ29uZmlnIiwiUHJpY2luZ0NvbmZpZ1NoYXJlZCIsImFzayIsImluc3RhbnQiLCJhdWN0aW9uIiwiVHJhbnNhY3Rpb25SZWNvcmQiLCJ0eG5fdHlwZSIsImVzY3Jvd19kZXBvc2l0IiwidHJ4X2lkIiwiZmVlX2RlcG9zaXQiLCJjYW5pc3Rlcl9uZXR3b3JrX3VwZGF0ZWQiLCJlc2Nyb3dfd2l0aGRyYXciLCJjYW5pc3Rlcl9tYW5hZ2Vyc191cGRhdGVkIiwiYXVjdGlvbl9iaWQiLCJidXJuIiwiZnJvbSIsImRhdGEiLCJoYXNoIiwiZGF0YV9kYXBwIiwiZGF0YV9wYXRoIiwic2FsZV9lbmRlZCIsIm1pbnQiLCJ0byIsInNhbGUiLCJyb3lhbHR5X3BhaWQiLCJ0YWciLCJyZWNlaXZlciIsImZlZV9kZXBvc2l0X3dpdGhkcmF3Iiwib3duZXJfdHJhbnNmZXIiLCJzYWxlX29wZW5lZCIsInByaWNpbmciLCJjYW5pc3Rlcl9vd25lcl91cGRhdGVkIiwic2FsZV93aXRoZHJhdyIsImRlcG9zaXRfd2l0aGRyYXciLCJ0aW1lc3RhbXAiLCJpbmRleCIsIlN0YWJsZU5mdExlZGdlciIsIkFsbG9jYXRpb25SZWNvcmRTdGFibGUiLCJhbGxvY2F0ZWRfc3BhY2UiLCJjaHVua3MiLCJsaWJyYXJ5X2lkIiwiQmlkRmVhdHVyZSIsImJyb2tlciIsIkJpZENvbmZpZ1NoYXJlZCIsIkVzY3Jvd1JlY2VpcHQiLCJQcmljaW5nQ29uZmlnU2hhcmVkX18xIiwiQXVjdGlvblN0YXRlU2hhcmVkIiwic3RhdHVzIiwiY2xvc2VkIiwib3BlbiIsIm5vdF9zdGFydGVkIiwicGFydGljaXBhbnRzIiwiY3VycmVudF9iaWRfYW1vdW50Iiwid2lubmVyIiwiZW5kX2RhdGUiLCJjdXJyZW50X2NvbmZpZyIsIndhaXRfZm9yX3F1aWV0X2NvdW50IiwiY3VycmVudF9lc2Nyb3ciLCJtaW5fbmV4dF9iaWQiLCJjb25maWciLCJTYWxlU3RhdHVzU2hhcmVkIiwic2FsZV90eXBlIiwiYnJva2VyX2lkIiwib3JpZ2luYWxfYnJva2VyX2lkIiwiU3RhYmxlQnVja2V0RGF0YSIsImRhdGVfYWRkZWQiLCJ2ZXJzaW9uIiwiYl9nYXRld2F5IiwiYWxsb2NhdGlvbnMiLCJTdGFibGVFc2Nyb3dCYWxhbmNlcyIsIk5GVEJhY2t1cENodW5rIiwic2FsZXNfYmFsYW5jZXMiLCJvZmZlcnMiLCJjb2xsZWN0aW9uX2RhdGEiLCJuZnRfbGVkZ2VycyIsIm5mdF9zYWxlcyIsImJ1Y2tldHMiLCJlc2Nyb3dfYmFsYW5jZXMiLCJFWFRUb2tlbklkZW50aWZpZXIiLCJFWFRVc2VyIiwiYWRkcmVzcyIsIkVYVEJhbGFuY2VSZXF1ZXN0IiwidXNlciIsIkVYVEJhbGFuY2UiLCJFWFRDb21tb25FcnJvciIsIkludmFsaWRUb2tlbiIsIkVYVEJhbGFuY2VSZXN1bHQiLCJvayIsImVyciIsIlN0YWtlUmVjb3JkIiwic3Rha2VyIiwiQmFsYW5jZVJlc3BvbnNlIiwibmZ0cyIsInNhbGVzIiwic3Rha2UiLCJtdWx0aV9jYW5pc3RlciIsImVzY3JvdyIsIkVycm9ycyIsIm55aSIsInN0b3JhZ2VfY29uZmlndXJhdGlvbl9lcnJvciIsImVzY3Jvd193aXRoZHJhd19wYXltZW50X2ZhaWxlZCIsInRva2VuX25vdF9mb3VuZCIsIm93bmVyX25vdF9mb3VuZCIsImNvbnRlbnRfbm90X2ZvdW5kIiwiYXVjdGlvbl9lbmRlZCIsIm91dF9vZl9yYW5nZSIsInNhbGVfaWRfZG9lc19ub3RfbWF0Y2giLCJzYWxlX25vdF9mb3VuZCIsImt5Y19mYWlsIiwiaXRlbV9ub3Rfb3duZWQiLCJwcm9wZXJ0eV9ub3RfZm91bmQiLCJ2YWxpZGF0ZV90cnhfd3JvbmdfaG9zdCIsIndpdGhkcmF3X3Rvb19sYXJnZSIsImNvbnRlbnRfbm90X2Rlc2VyaWFsaXphYmxlIiwiYmlkX3Rvb19sb3ciLCJ2YWxpZGF0ZV9kZXBvc2l0X3dyb25nX2Ftb3VudCIsImV4aXN0aW5nX3NhbGVfZm91bmQiLCJub29wIiwiYXNzZXRfbWlzbWF0Y2giLCJlc2Nyb3dfY2Fubm90X2JlX3JlbW92ZWQiLCJkZXBvc2l0X2J1cm5lZCIsImNhbm5vdF9yZXN0YWdlX21pbnRlZF90b2tlbiIsImNhbm5vdF9maW5kX3N0YXR1c19pbl9tZXRhZGF0YSIsInJlY2VpcHRfZGF0YV9taXNtYXRjaCIsInZhbGlkYXRlX2RlcG9zaXRfZmFpbGVkIiwidW5yZWFjaGFibGUiLCJ1bmF1dGhvcml6ZWRfYWNjZXNzIiwiaXRlbV9hbHJlYWR5X21pbnRlZCIsIm5vX2VzY3Jvd19mb3VuZCIsImVzY3Jvd19vd25lcl9ub3RfdGhlX293bmVyIiwiaW1wcm9wZXJfaW50ZXJmYWNlIiwiYXBwX2lkX25vdF9mb3VuZCIsInRva2VuX25vbl90cmFuc2ZlcmFibGUiLCJreWNfZXJyb3IiLCJzYWxlX25vdF9vdmVyIiwiZXNjcm93X25vdF9sYXJnZV9lbm91Z2giLCJ1cGRhdGVfY2xhc3NfZXJyb3IiLCJtYWxmb3JtZWRfbWV0YWRhdGEiLCJ0b2tlbl9pZF9taXNtYXRjaCIsImlkX25vdF9mb3VuZF9pbl9tZXRhZGF0YSIsImF1Y3Rpb25fbm90X3N0YXJ0ZWQiLCJsb3dfZmVlX2JhbGFuY2UiLCJsaWJyYXJ5X25vdF9mb3VuZCIsImF0dGVtcHRfdG9fc3RhZ2Vfc3lzdGVtX2RhdGEiLCJub19mZWVfYWNjb3VudHNfcHJvdmlkZWQiLCJ2YWxpZGF0ZV9kZXBvc2l0X3dyb25nX2J1eWVyIiwibm90X2Vub3VnaF9zdG9yYWdlIiwic2FsZXNfd2l0aGRyYXdfcGF5bWVudF9mYWlsZWQiLCJPcmlneW5FcnJvciIsImVycm9yIiwibnVtYmVyIiwiZmxhZ19wb2ludCIsIkJhbGFuY2VSZXN1bHQiLCJFWFRBY2NvdW50SWRlbnRpZmllciIsIkVYVEJlYXJlclJlc3VsdCIsIkJlYXJlclJlc3VsdCIsImNhbmlzdGVyX2lkIiwiZGVmaW5pdGVfY2FuaXN0ZXJfc2V0dGluZ3MiLCJmcmVlemluZ190aHJlc2hvbGQiLCJjb250cm9sbGVycyIsIm1lbW9yeV9hbGxvY2F0aW9uIiwiY29tcHV0ZV9hbGxvY2F0aW9uIiwiY2FuaXN0ZXJfc3RhdHVzIiwic3RvcHBlZCIsInN0b3BwaW5nIiwicnVubmluZyIsIm1lbW9yeV9zaXplIiwiY3ljbGVzIiwic2V0dGluZ3MiLCJtb2R1bGVfaGFzaCIsIkNodW5rUmVxdWVzdCIsImNodW5rIiwiQ2h1bmtDb250ZW50IiwicmVtb3RlIiwiYXJncyIsInRvdGFsX2NodW5rcyIsImNvbnRlbnQiLCJzdG9yYWdlX2FsbG9jYXRpb24iLCJjdXJyZW50X2NodW5rIiwiQ2h1bmtSZXN1bHQiLCJDb2xsZWN0aW9uSW5mbyIsIm11bHRpX2NhbmlzdGVyX2NvdW50IiwiY3JlYXRlZF9hdCIsImZpZWxkcyIsInVwZ3JhZGVkX2F0IiwidG9rZW5faWRzX2NvdW50IiwidG9rZW5faWRzIiwidHJhbnNhY3Rpb25fY291bnQiLCJ1bmlxdWVfaG9sZGVycyIsInRvdGFsX3N1cHBseSIsIkNvbGxlY3Rpb25SZXN1bHQiLCJNYW5hZ2VDb2xsZWN0aW9uQ29tbWFuZCIsIlVwZGF0ZU93bmVyIiwiVXBkYXRlTWFuYWdlcnMiLCJVcGRhdGVNZXRhZGF0YSIsIlVwZGF0ZUFubm91bmNlQ2FuaXN0ZXIiLCJVcGRhdGVOZXR3b3JrIiwiVXBkYXRlU3ltYm9sIiwiVXBkYXRlTG9nbyIsIlVwZGF0ZU5hbWUiLCJPcmlneW5Cb29sUmVzdWx0IiwiU3ViYWNjb3VudCIsIkFjY291bnQiLCJzdWJhY2NvdW50IiwiTmZ0RXJyb3IiLCJVbmF1dGhvcml6ZWRPcGVyYXRvciIsIlNlbGZUcmFuc2ZlciIsIlRva2VuTm90Rm91bmQiLCJVbmF1dGhvcml6ZWRPd25lciIsIlR4Tm90Rm91bmQiLCJTZWxmQXBwcm92ZSIsIk9wZXJhdG9yTm90Rm91bmQiLCJFeGlzdGVkTkZUIiwiT3duZXJOb3RGb3VuZCIsIkRJUDcyMUJvb2xSZXN1bHQiLCJPayIsIkVyciIsIkRJUDcyMU1ldGFkYXRhIiwiY3VzdG9kaWFucyIsIkRJUDcyMVRva2Vuc0xpc3RNZXRhZGF0YSIsIk5hdDY0Q29udGVudCIsIk5hdDMyQ29udGVudCIsIkJvb2xDb250ZW50IiwiTmF0OENvbnRlbnQiLCJJbnQ2NENvbnRlbnQiLCJJbnRDb250ZW50IiwiTmF0Q29udGVudCIsIk5hdDE2Q29udGVudCIsIkludDMyQ29udGVudCIsIkludDhDb250ZW50IiwiRmxvYXRDb250ZW50IiwiSW50MTZDb250ZW50IiwiQmxvYkNvbnRlbnQiLCJOZXN0ZWRDb250ZW50IiwiVGV4dENvbnRlbnQiLCJHZW5lcmljVmFsdWUiLCJUb2tlbk1ldGFkYXRhIiwidHJhbnNmZXJyZWRfYXQiLCJ0cmFuc2ZlcnJlZF9ieSIsIm9wZXJhdG9yIiwiYXBwcm92ZWRfYXQiLCJhcHByb3ZlZF9ieSIsInByb3BlcnRpZXMiLCJpc19idXJuZWQiLCJ0b2tlbl9pZGVudGlmaWVyIiwiYnVybmVkX2F0IiwiYnVybmVkX2J5IiwibWludGVkX2F0IiwibWludGVkX2J5IiwiRElQNzIxVG9rZW5zTWV0YWRhdGEiLCJPd25lck9mUmVzcG9uc2UiLCJESVA3MjFTdGF0cyIsInRvdGFsX3RyYW5zYWN0aW9ucyIsInRvdGFsX3VuaXF1ZV9ob2xkZXJzIiwiRElQNzIxU3VwcG9ydGVkSW50ZXJmYWNlIiwiQnVybiIsIk1pbnQiLCJBcHByb3ZhbCIsIlRyYW5zYWN0aW9uSGlzdG9yeSIsIkRJUDcyMVRva2VuTWV0YWRhdGEiLCJESVA3MjFOYXRSZXN1bHQiLCJHZXRMb2dNZXNzYWdlc0ZpbHRlciIsImFuYWx5emVDb3VudCIsIm1lc3NhZ2VSZWdleCIsIm1lc3NhZ2VDb250YWlucyIsIk5hbm9zIiwiR2V0TG9nTWVzc2FnZXNQYXJhbWV0ZXJzIiwiY291bnQiLCJmaWx0ZXIiLCJmcm9tVGltZU5hbm9zIiwiR2V0TGF0ZXN0TG9nTWVzc2FnZXNQYXJhbWV0ZXJzIiwidXBUb1RpbWVOYW5vcyIsIkNhbmlzdGVyTG9nUmVxdWVzdCIsImdldE1lc3NhZ2VzSW5mbyIsImdldE1lc3NhZ2VzIiwiZ2V0TGF0ZXN0TWVzc2FnZXMiLCJDYW5pc3RlckxvZ0ZlYXR1cmUiLCJmaWx0ZXJNZXNzYWdlQnlDb250YWlucyIsImZpbHRlck1lc3NhZ2VCeVJlZ2V4IiwiQ2FuaXN0ZXJMb2dNZXNzYWdlc0luZm8iLCJmZWF0dXJlcyIsImxhc3RUaW1lTmFub3MiLCJmaXJzdFRpbWVOYW5vcyIsIkRhdGEiLCJDYWxsZXIiLCJMb2dNZXNzYWdlc0RhdGEiLCJ0aW1lTmFub3MiLCJtZXNzYWdlIiwiY2FsbGVyIiwiQ2FuaXN0ZXJMb2dNZXNzYWdlcyIsImxhc3RBbmFseXplZE1lc3NhZ2VUaW1lTmFub3MiLCJDYW5pc3RlckxvZ1Jlc3BvbnNlIiwibWVzc2FnZXNJbmZvIiwibWVzc2FnZXMiLCJNZXRyaWNzR3JhbnVsYXJpdHkiLCJob3VybHkiLCJkYWlseSIsIkdldE1ldHJpY3NQYXJhbWV0ZXJzIiwiZGF0ZVRvTWlsbGlzIiwiZ3JhbnVsYXJpdHkiLCJkYXRlRnJvbU1pbGxpcyIsIlVwZGF0ZUNhbGxzQWdncmVnYXRlZERhdGEiLCJDYW5pc3RlckhlYXBNZW1vcnlBZ2dyZWdhdGVkRGF0YSIsIkNhbmlzdGVyQ3ljbGVzQWdncmVnYXRlZERhdGEiLCJDYW5pc3Rlck1lbW9yeUFnZ3JlZ2F0ZWREYXRhIiwiSG91cmx5TWV0cmljc0RhdGEiLCJ1cGRhdGVDYWxscyIsImNhbmlzdGVySGVhcE1lbW9yeVNpemUiLCJjYW5pc3RlckN5Y2xlcyIsImNhbmlzdGVyTWVtb3J5U2l6ZSIsInRpbWVNaWxsaXMiLCJOdW1lcmljRW50aXR5IiwiYXZnIiwibWluIiwiZmlyc3QiLCJsYXN0IiwiRGFpbHlNZXRyaWNzRGF0YSIsIkNhbmlzdGVyTWV0cmljc0RhdGEiLCJDYW5pc3Rlck1ldHJpY3MiLCJPcmlneW5UZXh0UmVzdWx0IiwiVGlwIiwibGFzdF9ibG9ja19pbmRleCIsImhhc2hfdHJlZSIsImxhc3RfYmxvY2tfaGFzaCIsIkdvdmVybmFuY2VSZXF1ZXN0IiwidXBkYXRlX3N5c3RlbV92YXIiLCJrZXkiLCJ2YWwiLCJjbGVhcl9zaGFyZWRfd2FsbGV0cyIsIkdvdmVybmFuY2VSZXNwb25zZSIsIkdvdmVybmFuY2VSZXN1bHQiLCJIaXN0b3J5UmVzdWx0IiwiSGVhZGVyRmllbGQiLCJIdHRwUmVxdWVzdCIsInVybCIsIm1ldGhvZCIsImJvZHkiLCJoZWFkZXJzIiwiU3RyZWFtaW5nQ2FsbGJhY2tUb2tlbiIsImNvbnRlbnRfZW5jb2RpbmciLCJTdHJlYW1pbmdTdHJhdGVneSIsIkNhbGxiYWNrIiwiY2FsbGJhY2siLCJGdW5jIiwiSFRUUFJlc3BvbnNlIiwic3RyZWFtaW5nX3N0cmF0ZWd5Iiwic3RhdHVzX2NvZGUiLCJTdHJlYW1pbmdDYWxsYmFja1Jlc3BvbnNlIiwiR2V0QXJjaGl2ZXNBcmdzIiwiR2V0QXJjaGl2ZXNSZXN1bHRJdGVtIiwiZW5kIiwic3RhcnQiLCJHZXRBcmNoaXZlc1Jlc3VsdCIsIlRyYW5zYWN0aW9uUmFuZ2UiLCJsZW5ndGgiLCJUcmFuc2FjdGlvblJhbmdlX18xIiwiR2V0VHJhbnNhY3Rpb25zUmVzdWx0X18xIiwibG9nX2xlbmd0aCIsImJsb2NrcyIsImJsb2NrIiwiYXJjaGl2ZWRfYmxvY2tzIiwiR2V0VHJhbnNhY3Rpb25zRm4iLCJHZXRUcmFuc2FjdGlvbnNSZXN1bHQiLCJEYXRhQ2VydGlmaWNhdGUiLCJjZXJ0aWZpY2F0ZSIsIkJsb2NrVHlwZSIsImJsb2NrX3R5cGUiLCJBcHByb3ZhbEFyZ3MiLCJtZW1vIiwiZnJvbV9zdWJhY2NvdW50IiwiY3JlYXRlZF9hdF90aW1lIiwiZXhwaXJlc19hdCIsInNwZW5kZXIiLCJBcHByb3ZhbEVycm9yIiwiR2VuZXJpY0Vycm9yIiwiZXJyb3JfY29kZSIsIkNyZWF0ZXhJbkZ1dHVyZSIsImxlZGdlcl90aW1lIiwiTm9uRXhpc3RpbmdUb2tlbklkIiwiVW5hdXRob3JpemVkIiwiVG9vT2xkIiwiQXBwcm92YWxSZXN1bHQiLCJhcHByb3ZhbF9yZXN1bHQiLCJDb2xsZWN0aW9uTWV0YWRhdGEiLCJTdXBwb3J0ZWRTdGFuZGFyZCIsIlRyYW5zZmVyQXJncyIsIlRyYW5zZmVyRXJyb3IiLCJEdXBsaWNhdGUiLCJkdXBsaWNhdGVfb2YiLCJDcmVhdGVkSW5GdXR1cmUiLCJUcmFuc2ZlclJlc3VsdEl0ZW0iLCJ0cmFuc2Zlcl9yZXN1bHQiLCJUcmFuc2ZlclJlc3VsdCIsIk1hbmFnZVN0b3JhZ2VSZXF1ZXN0IiwiYWRkX3N0b3JhZ2VfY2FuaXN0ZXJzIiwiY29uZmlndXJlX3N0b3JhZ2UiLCJzdGFibGVCdHJlZSIsImhlYXAiLCJNYW5hZ2VTdG9yYWdlUmVzcG9uc2UiLCJNYW5hZ2VTdG9yYWdlUmVzdWx0IiwiRXNjcm93UmVjZWlwdF9fMSIsIlNhbGVzQ29uZmlnIiwiZXNjcm93X3JlY2VpcHQiLCJNYXJrZXRUcmFuc2ZlclJlcXVlc3QiLCJzYWxlc19jb25maWciLCJNYXJrZXRUcmFuc2ZlclJlcXVlc3RSZXBvbnNlIiwiTWFya2V0VHJhbnNmZXJSZXN1bHQiLCJFWFRNZXRhZGF0YSIsImZ1bmdpYmxlIiwibm9uZnVuZ2libGUiLCJFWFRNZXRhZGF0YVJlc3VsdCIsIk5GVEluZm9TdGFibGUiLCJjdXJyZW50X3NhbGUiLCJORlRJbmZvUmVzdWx0IiwiVG9rZW5TcGVjX18yIiwiQWNjb3VudF9fMyIsIkVzY3Jvd1JlY29yZCIsIkJpZFJlcXVlc3QiLCJlc2Nyb3dfcmVjb3JkIiwiVHJhbnNhY3Rpb25JRF9fMSIsIkRlcG9zaXREZXRhaWwiLCJFc2Nyb3dSZXF1ZXN0IiwiZGVwb3NpdCIsIkZlZURlcG9zaXRSZXF1ZXN0IiwiUmVqZWN0RGVzY3JpcHRpb24iLCJGZWVEZXBvc2l0V2l0aGRyYXdEZXNjcmlwdGlvbiIsImxvY2tlZCIsInVubG9ja2VkIiwid2l0aGRyYXdfdG8iLCJXaXRoZHJhd0Rlc2NyaXB0aW9uIiwiRGVwb3NpdFdpdGhkcmF3RGVzY3JpcHRpb24iLCJXaXRoZHJhd1JlcXVlc3QiLCJyZWplY3QiLCJUb2tlblNwZWNGaWx0ZXIiLCJmaWx0ZXJfdHlwZSIsImFsbG93IiwiVG9rZW5JREZpbHRlciIsInRva2VucyIsIm1pbl9hbW91bnQiLCJtYXhfYW1vdW50IiwiQXNrU3Vic2NyaWJlUmVxdWVzdCIsInN1YnNjcmliZSIsInVuc3Vic2NyaWJlIiwiRGlzdHJpYnV0ZVNhbGVSZXF1ZXN0IiwiTWFuYWdlU2FsZVJlcXVlc3QiLCJiaWQiLCJyZWNvZ25pemVfZXNjcm93Iiwid2l0aGRyYXciLCJhc2tfc3Vic2NyaWJlIiwiZW5kX3NhbGUiLCJyZWZyZXNoX29mZmVycyIsImRpc3RyaWJ1dGVfc2FsZSIsIm9wZW5fc2FsZSIsIkJpZFJlc3BvbnNlIiwiRXNjcm93UmVzcG9uc2UiLCJiYWxhbmNlIiwicmVjZWlwdCIsInRyYW5zYWN0aW9uIiwiRmVlRGVwb3NpdFJlc3BvbnNlIiwiUmVjb2duaXplRXNjcm93UmVzcG9uc2UiLCJXaXRoZHJhd1Jlc3BvbnNlIiwiQXNrU3Vic2NyaWJlUmVzcG9uc2UiLCJFbmRTYWxlUmVzcG9uc2UiLCJSZXN1bHQiLCJEaXN0cmlidXRlU2FsZVJlc3BvbnNlIiwiTWFuYWdlU2FsZVJlc3VsdCIsIlNhbGVJbmZvUmVxdWVzdCIsImZlZV9kZXBvc2l0X2luZm8iLCJhY3RpdmUiLCJkZXBvc2l0X2luZm8iLCJoaXN0b3J5IiwiZXNjcm93X2luZm8iLCJTdWJBY2NvdW50SW5mbyIsImFjY291bnRfaWRfdGV4dCIsIlNhbGVJbmZvUmVzcG9uc2UiLCJlb2YiLCJyZWNvcmRzIiwiU2FsZUluZm9SZXN1bHQiLCJTaGFyZVdhbGxldFJlcXVlc3QiLCJPd25lclRyYW5zZmVyUmVzcG9uc2UiLCJhc3NldHMiLCJPd25lclVwZGF0ZVJlc3VsdCIsIlN0YWdlQ2h1bmtBcmciLCJmaWxlZGF0YSIsIlN0YWdlTGlicmFyeVJlc3BvbnNlIiwiU3RhZ2VMaWJyYXJ5UmVzdWx0IiwiU3RhdGVTaXplIiwiU3RvcmFnZU1ldHJpY3MiLCJnYXRld2F5IiwiU3RvcmFnZU1ldHJpY3NSZXN1bHQiLCJFWFRUb2tlbnNSZXNwb25zZSIsInByaWNlIiwiRVhUVG9rZW5zUmVzdWx0IiwiRVhUTWVtbyIsIkVYVFN1YkFjY291bnQiLCJFWFRUcmFuc2ZlclJlcXVlc3QiLCJFWFRUcmFuc2ZlclJlc3BvbnNlIiwiQ2Fubm90Tm90aWZ5IiwiSW5zdWZmaWNpZW50QmFsYW5jZSIsIlJlamVjdGVkIiwiVXBkYXRlTW9kZVNoYXJlZCIsIkxvY2siLCJOZXh0IiwibW9kZSIsIlVwZGF0ZVJlcXVlc3RTaGFyZWQiLCJ1cGRhdGUiLCJORlRVcGRhdGVSZXF1ZXN0IiwiYXBwX2lkIiwicmVwbGFjZSIsIk5GVFVwZGF0ZVJlc3BvbnNlIiwiTkZUVXBkYXRlUmVzdWx0IiwiSW5kZXhUeXBlIiwiU3RhYmxlIiwiU3RhYmxlVHlwZWQiLCJNYW5hZ2VkIiwiVXBkYXRlU2V0dGluZyIsIm1heFJlY29yZHNUb0FyY2hpdmUiLCJhcmNoaXZlSW5kZXhUeXBlIiwibWF4QXJjaGl2ZVBhZ2VzIiwic2V0dGxlVG9SZWNvcmRzIiwiYXJjaGl2ZUN5Y2xlcyIsIm1heEFjdGl2ZVJlY29yZHMiLCJtYXhSZWNvcmRzSW5BcmNoaXZlSW5zdGFuY2UiLCJhcmNoaXZlQ29udHJvbGxlcnMiLCJORlRVcGRhdGVNZXRhZGF0YU5vZGUiLCJfc3lzdGVtIiwiZmllbGRfaWQiLCJORlRVcGRhdGVNZXRhZGF0YU5vZGVSZXNwb25zZSIsInByb3BlcnR5X25ldyIsInByb3BlcnR5X29sZCIsIk5GVFVwZGF0ZUFwcFJlc3VsdCIsIlNlcnZpY2UiLCJfX2FkdmFuY2VfdGltZSIsIl9fc2V0X3RpbWVfbW9kZSIsInRlc3QiLCJfX3N1cHBvcnRzIiwiX192ZXJzaW9uIiwiYmFja191cCIsImJhbGFuY2VFWFQiLCJiYWxhbmNlX29mX2JhdGNoX25mdF9vcmlneW4iLCJiYWxhbmNlX29mX25mdF9vcmlneW4iLCJiYWxhbmNlX29mX3NlY3VyZV9iYXRjaF9uZnRfb3JpZ3luIiwiYmFsYW5jZV9vZl9zZWN1cmVfbmZ0X29yaWd5biIsImJlYXJlciIsImJlYXJlckVYVCIsImJlYXJlcl9iYXRjaF9uZnRfb3JpZ3luIiwiYmVhcmVyX2JhdGNoX3NlY3VyZV9uZnRfb3JpZ3luIiwiYmVhcmVyX25mdF9vcmlneW4iLCJiZWFyZXJfc2VjdXJlX25mdF9vcmlneW4iLCJjaHVua19uZnRfb3JpZ3luIiwiY2h1bmtfc2VjdXJlX25mdF9vcmlneW4iLCJjb2xsZWN0Q2FuaXN0ZXJNZXRyaWNzIiwiY29sbGVjdGlvbl9uZnRfb3JpZ3luIiwiY29sbGVjdGlvbl9zZWN1cmVfbmZ0X29yaWd5biIsImNvbGxlY3Rpb25fdXBkYXRlX2JhdGNoX25mdF9vcmlneW4iLCJjb2xsZWN0aW9uX3VwZGF0ZV9uZnRfb3JpZ3luIiwiY291bnRfdW5saXN0ZWRfdG9rZW5zX29mIiwiZGlwNzIxX2JhbGFuY2Vfb2YiLCJkaXA3MjFfY3VzdG9kaWFucyIsImRpcDcyMV9pc19hcHByb3ZlZF9mb3JfYWxsIiwiZGlwNzIxX2xvZ28iLCJkaXA3MjFfbWV0YWRhdGEiLCJkaXA3MjFfbmFtZSIsImRpcDcyMV9vcGVyYXRvcl90b2tlbl9pZGVudGlmaWVycyIsImRpcDcyMV9vcGVyYXRvcl90b2tlbl9tZXRhZGF0YSIsImRpcDcyMV9vd25lcl9vZiIsImRpcDcyMV9vd25lcl90b2tlbl9pZGVudGlmaWVycyIsImRpcDcyMV9vd25lcl90b2tlbl9tZXRhZGF0YSIsImRpcDcyMV9zdGF0cyIsImRpcDcyMV9zdXBwb3J0ZWRfaW50ZXJmYWNlcyIsImRpcDcyMV9zeW1ib2wiLCJkaXA3MjFfdG9rZW5fbWV0YWRhdGEiLCJkaXA3MjFfdG90YWxfc3VwcGx5IiwiZGlwNzIxX3RvdGFsX3RyYW5zYWN0aW9ucyIsImRpcDcyMV90cmFuc2ZlciIsImRpcDcyMV90cmFuc2Zlcl9mcm9tIiwiZ2V0Q2FuaXN0ZXJMb2ciLCJnZXRDYW5pc3Rlck1ldHJpY3MiLCJnZXRFWFRUb2tlbklkZW50aWZpZXIiLCJnZXRfYWNjZXNzX2tleSIsImdldF9oYWx0IiwiZ2V0X25hdF9hc190b2tlbl9pZF9vcmlneW4iLCJnZXRfdGlwIiwiZ2V0X3Rva2VuX2lkX2FzX25hdCIsImdvdmVybmFuY2VfYmF0Y2hfbmZ0X29yaWd5biIsImdvdmVybmFuY2VfbmZ0X29yaWd5biIsImhpc3RvcnlfYmF0Y2hfbmZ0X29yaWd5biIsImhpc3RvcnlfYmF0Y2hfc2VjdXJlX25mdF9vcmlneW4iLCJoaXN0b3J5X25mdF9vcmlneW4iLCJoaXN0b3J5X3NlY3VyZV9uZnRfb3JpZ3luIiwiaHR0cF9hY2Nlc3Nfa2V5IiwiaHR0cF9yZXF1ZXN0IiwiaHR0cF9yZXF1ZXN0X3N0cmVhbWluZ19jYWxsYmFjayIsImljcmMzX2dldF9hcmNoaXZlcyIsImljcmMzX2dldF9ibG9ja3MiLCJpY3JjM19nZXRfdGlwX2NlcnRpZmljYXRlIiwiaWNyYzNfc3VwcG9ydGVkX2Jsb2NrX3R5cGVzIiwiaWNyYzdfYXBwcm92ZSIsImljcmM3X2F0b21pY19iYXRjaF90cmFuc2ZlcnMiLCJpY3JjN19iYWxhbmNlX29mIiwiaWNyYzdfY29sbGVjdGlvbl9tZXRhZGF0YSIsImljcmM3X2RlZmF1bHRfdGFrZV92YWx1ZSIsImljcmM3X2Rlc2NyaXB0aW9uIiwiaWNyYzdfbG9nbyIsImljcmM3X21heF9hcHByb3ZhbHNfcGVyX3Rva2VuX29yX2NvbGxlY3Rpb24iLCJpY3JjN19tYXhfbWVtb19zaXplIiwiaWNyYzdfbWF4X3F1ZXJ5X2JhdGNoX3NpemUiLCJpY3JjN19tYXhfcmV2b2tlX2FwcHJvdmFscyIsImljcmM3X21heF90YWtlX3ZhbHVlIiwiaWNyYzdfbWF4X3VwZGF0ZV9iYXRjaF9zaXplIiwiaWNyYzdfbmFtZSIsImljcmM3X293bmVyX29mIiwiaWNyYzdfcGVybWl0dGVkX2RyaWZ0IiwiaWNyYzdfc3VwcGx5X2NhcCIsImljcmM3X3N1cHBvcnRlZF9zdGFuZGFyZHMiLCJpY3JjN19zeW1ib2wiLCJpY3JjN190b2tlbl9tZXRhZGF0YSIsImljcmM3X3Rva2VucyIsImljcmM3X3Rva2Vuc19vZiIsImljcmM3X3RvdGFsX3N1cHBseSIsImljcmM3X3RyYW5zZmVyIiwiaWNyYzdfdHJhbnNmZXJfZmVlIiwiaWNyYzdfdHhfd2luZG93IiwibWFuYWdlX3N0b3JhZ2VfbmZ0X29yaWd5biIsIm1hcmtldF90cmFuc2Zlcl9iYXRjaF9uZnRfb3JpZ3luIiwibWFya2V0X3RyYW5zZmVyX25mdF9vcmlneW4iLCJtZXRhZGF0YUV4dCIsIm1pbnRfYmF0Y2hfbmZ0X29yaWd5biIsIm1pbnRfbmZ0X29yaWd5biIsIm5mdFN0cmVhbWluZ0NhbGxiYWNrIiwibmZ0X2JhdGNoX29yaWd5biIsIm5mdF9iYXRjaF9zZWN1cmVfb3JpZ3luIiwibmZ0X29yaWd5biIsIm5mdF9zZWN1cmVfb3JpZ3luIiwib3BlcmF0ZXJUb2tlbk1ldGFkYXRhIiwib3duZXJPZiIsIm93bmVyVG9rZW5NZXRhZGF0YSIsInNhbGVfYmF0Y2hfbmZ0X29yaWd5biIsInNhbGVfaW5mb19iYXRjaF9uZnRfb3JpZ3luIiwic2FsZV9pbmZvX2JhdGNoX3NlY3VyZV9uZnRfb3JpZ3luIiwic2FsZV9pbmZvX25mdF9vcmlneW4iLCJzYWxlX2luZm9fc2VjdXJlX25mdF9vcmlneW4iLCJzYWxlX25mdF9vcmlneW4iLCJzZXRfZGF0YV9oYXJ2ZXN0ZXIiLCJzZXRfaGFsdCIsInNoYXJlX3dhbGxldF9uZnRfb3JpZ3luIiwic3RhZ2VfYmF0Y2hfbmZ0X29yaWd5biIsInN0YWdlX2xpYnJhcnlfYmF0Y2hfbmZ0X29yaWd5biIsInN0YWdlX2xpYnJhcnlfbmZ0X29yaWd5biIsInN0YWdlX25mdF9vcmlneW4iLCJzdGF0ZV9zaXplIiwic3RvcmFnZV9pbmZvX25mdF9vcmlneW4iLCJzdG9yYWdlX2luZm9fc2VjdXJlX25mdF9vcmlneW4iLCJ0b2tlbnNfZXh0IiwidHJhbnNmZXJEaXA3MjEiLCJ0cmFuc2ZlckVYVCIsInRyYW5zZmVyRnJvbSIsInRyYW5zZmVyRnJvbURpcDcyMSIsInVubGlzdGVkX3Rva2Vuc19vZiIsInVwZGF0ZV9hcHBfbmZ0X29yaWd5biIsInVwZGF0ZV9pY3JjMyIsInVwZGF0ZV9tZXRhZGF0YV9ub2RlIiwid2FsbGV0X3JlY2VpdmUiLCJ3aG9hbWkiLCJpbml0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/data/canisters/gold/did.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/data/canisters/ledger/did.js":
/*!******************************************!*\
  !*** ./src/data/canisters/ledger/did.js ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   idlFactory: function() { return /* binding */ idlFactory; },\n/* harmony export */   init: function() { return /* binding */ init; }\n/* harmony export */ });\nconst idlFactory = (param)=>{\n    let { IDL } = param;\n    const GetBlocksResult = IDL.Rec();\n    const ICRC3Value = IDL.Rec();\n    const Value = IDL.Rec();\n    const Vec = IDL.Rec();\n    const ChangeArchiveOptions = IDL.Record({\n        num_blocks_to_archive: IDL.Opt(IDL.Nat64),\n        max_transactions_per_response: IDL.Opt(IDL.Nat64),\n        trigger_threshold: IDL.Opt(IDL.Nat64),\n        more_controller_ids: IDL.Opt(IDL.Vec(IDL.Principal)),\n        max_message_size_bytes: IDL.Opt(IDL.Nat64),\n        cycles_for_archive_creation: IDL.Opt(IDL.Nat64),\n        node_max_memory_size_bytes: IDL.Opt(IDL.Nat64),\n        controller_id: IDL.Opt(IDL.Principal)\n    });\n    const MetadataValue = IDL.Variant({\n        Int: IDL.Int,\n        Nat: IDL.Nat,\n        Blob: IDL.Vec(IDL.Nat8),\n        Text: IDL.Text\n    });\n    const Account = IDL.Record({\n        owner: IDL.Principal,\n        subaccount: IDL.Opt(IDL.Vec(IDL.Nat8))\n    });\n    const ChangeFeeCollector = IDL.Variant({\n        SetTo: Account,\n        Unset: IDL.Null\n    });\n    const FeatureFlags = IDL.Record({\n        icrc2: IDL.Bool\n    });\n    const UpgradeArgs = IDL.Record({\n        change_archive_options: IDL.Opt(ChangeArchiveOptions),\n        token_symbol: IDL.Opt(IDL.Text),\n        transfer_fee: IDL.Opt(IDL.Nat),\n        metadata: IDL.Opt(IDL.Vec(IDL.Tuple(IDL.Text, MetadataValue))),\n        maximum_number_of_accounts: IDL.Opt(IDL.Nat64),\n        accounts_overflow_trim_quantity: IDL.Opt(IDL.Nat64),\n        change_fee_collector: IDL.Opt(ChangeFeeCollector),\n        max_memo_length: IDL.Opt(IDL.Nat16),\n        token_name: IDL.Opt(IDL.Text),\n        feature_flags: IDL.Opt(FeatureFlags)\n    });\n    const ArchiveOptions = IDL.Record({\n        num_blocks_to_archive: IDL.Nat64,\n        max_transactions_per_response: IDL.Opt(IDL.Nat64),\n        trigger_threshold: IDL.Nat64,\n        more_controller_ids: IDL.Opt(IDL.Vec(IDL.Principal)),\n        max_message_size_bytes: IDL.Opt(IDL.Nat64),\n        cycles_for_archive_creation: IDL.Opt(IDL.Nat64),\n        node_max_memory_size_bytes: IDL.Opt(IDL.Nat64),\n        controller_id: IDL.Principal\n    });\n    const InitArgs = IDL.Record({\n        decimals: IDL.Opt(IDL.Nat8),\n        token_symbol: IDL.Text,\n        transfer_fee: IDL.Nat,\n        metadata: IDL.Vec(IDL.Tuple(IDL.Text, MetadataValue)),\n        minting_account: Account,\n        initial_balances: IDL.Vec(IDL.Tuple(Account, IDL.Nat)),\n        maximum_number_of_accounts: IDL.Opt(IDL.Nat64),\n        accounts_overflow_trim_quantity: IDL.Opt(IDL.Nat64),\n        fee_collector_account: IDL.Opt(Account),\n        archive_options: ArchiveOptions,\n        max_memo_length: IDL.Opt(IDL.Nat16),\n        token_name: IDL.Text,\n        feature_flags: IDL.Opt(FeatureFlags)\n    });\n    const LedgerArgument = IDL.Variant({\n        Upgrade: IDL.Opt(UpgradeArgs),\n        Init: InitArgs\n    });\n    const ArchiveInfo = IDL.Record({\n        block_range_end: IDL.Nat,\n        canister_id: IDL.Principal,\n        block_range_start: IDL.Nat\n    });\n    const GetBlocksRequest = IDL.Record({\n        start: IDL.Nat,\n        length: IDL.Nat\n    });\n    Vec.fill(IDL.Vec(IDL.Variant({\n        Int: IDL.Int,\n        Map: IDL.Vec(IDL.Tuple(IDL.Text, Value)),\n        Nat: IDL.Nat,\n        Nat64: IDL.Nat64,\n        Blob: IDL.Vec(IDL.Nat8),\n        Text: IDL.Text,\n        Array: Vec\n    })));\n    Value.fill(IDL.Variant({\n        Int: IDL.Int,\n        Map: IDL.Vec(IDL.Tuple(IDL.Text, Value)),\n        Nat: IDL.Nat,\n        Nat64: IDL.Nat64,\n        Blob: IDL.Vec(IDL.Nat8),\n        Text: IDL.Text,\n        Array: Vec\n    }));\n    const BlockRange = IDL.Record({\n        blocks: IDL.Vec(Value)\n    });\n    const ArchivedRange = IDL.Record({\n        callback: IDL.Func([\n            GetBlocksRequest\n        ], [\n            BlockRange\n        ], [\n            \"query\"\n        ]),\n        start: IDL.Nat,\n        length: IDL.Nat\n    });\n    const GetBlocksResponse = IDL.Record({\n        certificate: IDL.Opt(IDL.Vec(IDL.Nat8)),\n        first_index: IDL.Nat,\n        blocks: IDL.Vec(Value),\n        chain_length: IDL.Nat64,\n        archived_blocks: IDL.Vec(ArchivedRange)\n    });\n    const DataCertificate = IDL.Record({\n        certificate: IDL.Opt(IDL.Vec(IDL.Nat8)),\n        hash_tree: IDL.Vec(IDL.Nat8)\n    });\n    const Burn = IDL.Record({\n        from: Account,\n        memo: IDL.Opt(IDL.Vec(IDL.Nat8)),\n        created_at_time: IDL.Opt(IDL.Nat64),\n        amount: IDL.Nat,\n        spender: IDL.Opt(Account)\n    });\n    const Mint = IDL.Record({\n        to: Account,\n        memo: IDL.Opt(IDL.Vec(IDL.Nat8)),\n        created_at_time: IDL.Opt(IDL.Nat64),\n        amount: IDL.Nat\n    });\n    const Approve = IDL.Record({\n        fee: IDL.Opt(IDL.Nat),\n        from: Account,\n        memo: IDL.Opt(IDL.Vec(IDL.Nat8)),\n        created_at_time: IDL.Opt(IDL.Nat64),\n        amount: IDL.Nat,\n        expected_allowance: IDL.Opt(IDL.Nat),\n        expires_at: IDL.Opt(IDL.Nat64),\n        spender: Account\n    });\n    const Transfer = IDL.Record({\n        to: Account,\n        fee: IDL.Opt(IDL.Nat),\n        from: Account,\n        memo: IDL.Opt(IDL.Vec(IDL.Nat8)),\n        created_at_time: IDL.Opt(IDL.Nat64),\n        amount: IDL.Nat,\n        spender: IDL.Opt(Account)\n    });\n    const Transaction = IDL.Record({\n        burn: IDL.Opt(Burn),\n        kind: IDL.Text,\n        mint: IDL.Opt(Mint),\n        approve: IDL.Opt(Approve),\n        timestamp: IDL.Nat64,\n        transfer: IDL.Opt(Transfer)\n    });\n    const TransactionRange = IDL.Record({\n        transactions: IDL.Vec(Transaction)\n    });\n    const ArchivedRange_1 = IDL.Record({\n        callback: IDL.Func([\n            GetBlocksRequest\n        ], [\n            TransactionRange\n        ], [\n            \"query\"\n        ]),\n        start: IDL.Nat,\n        length: IDL.Nat\n    });\n    const GetTransactionsResponse = IDL.Record({\n        first_index: IDL.Nat,\n        log_length: IDL.Nat,\n        transactions: IDL.Vec(Transaction),\n        archived_transactions: IDL.Vec(ArchivedRange_1)\n    });\n    const StandardRecord = IDL.Record({\n        url: IDL.Text,\n        name: IDL.Text\n    });\n    const TransferArg = IDL.Record({\n        to: Account,\n        fee: IDL.Opt(IDL.Nat),\n        memo: IDL.Opt(IDL.Vec(IDL.Nat8)),\n        from_subaccount: IDL.Opt(IDL.Vec(IDL.Nat8)),\n        created_at_time: IDL.Opt(IDL.Nat64),\n        amount: IDL.Nat\n    });\n    const TransferError = IDL.Variant({\n        GenericError: IDL.Record({\n            message: IDL.Text,\n            error_code: IDL.Nat\n        }),\n        TemporarilyUnavailable: IDL.Null,\n        BadBurn: IDL.Record({\n            min_burn_amount: IDL.Nat\n        }),\n        Duplicate: IDL.Record({\n            duplicate_of: IDL.Nat\n        }),\n        BadFee: IDL.Record({\n            expected_fee: IDL.Nat\n        }),\n        CreatedInFuture: IDL.Record({\n            ledger_time: IDL.Nat64\n        }),\n        TooOld: IDL.Null,\n        InsufficientFunds: IDL.Record({\n            balance: IDL.Nat\n        })\n    });\n    const Result = IDL.Variant({\n        Ok: IDL.Nat,\n        Err: TransferError\n    });\n    const ConsentMessageMetadata = IDL.Record({\n        utc_offset_minutes: IDL.Opt(IDL.Int16),\n        language: IDL.Text\n    });\n    const DisplayMessageType = IDL.Variant({\n        GenericDisplay: IDL.Null,\n        LineDisplay: IDL.Record({\n            characters_per_line: IDL.Nat16,\n            lines_per_page: IDL.Nat16\n        })\n    });\n    const ConsentMessageSpec = IDL.Record({\n        metadata: ConsentMessageMetadata,\n        device_spec: IDL.Opt(DisplayMessageType)\n    });\n    const ConsentMessageRequest = IDL.Record({\n        arg: IDL.Vec(IDL.Nat8),\n        method: IDL.Text,\n        user_preferences: ConsentMessageSpec\n    });\n    const LineDisplayPage = IDL.Record({\n        lines: IDL.Vec(IDL.Text)\n    });\n    const ConsentMessage = IDL.Variant({\n        LineDisplayMessage: IDL.Record({\n            pages: IDL.Vec(LineDisplayPage)\n        }),\n        GenericDisplayMessage: IDL.Text\n    });\n    const ConsentInfo = IDL.Record({\n        metadata: ConsentMessageMetadata,\n        consent_message: ConsentMessage\n    });\n    const ErrorInfo = IDL.Record({\n        description: IDL.Text\n    });\n    const Icrc21Error = IDL.Variant({\n        GenericError: IDL.Record({\n            description: IDL.Text,\n            error_code: IDL.Nat\n        }),\n        InsufficientPayment: ErrorInfo,\n        UnsupportedCanisterCall: ErrorInfo,\n        ConsentMessageUnavailable: ErrorInfo\n    });\n    const Result_1 = IDL.Variant({\n        Ok: ConsentInfo,\n        Err: Icrc21Error\n    });\n    const AllowanceArgs = IDL.Record({\n        account: Account,\n        spender: Account\n    });\n    const Allowance = IDL.Record({\n        allowance: IDL.Nat,\n        expires_at: IDL.Opt(IDL.Nat64)\n    });\n    const ApproveArgs = IDL.Record({\n        fee: IDL.Opt(IDL.Nat),\n        memo: IDL.Opt(IDL.Vec(IDL.Nat8)),\n        from_subaccount: IDL.Opt(IDL.Vec(IDL.Nat8)),\n        created_at_time: IDL.Opt(IDL.Nat64),\n        amount: IDL.Nat,\n        expected_allowance: IDL.Opt(IDL.Nat),\n        expires_at: IDL.Opt(IDL.Nat64),\n        spender: Account\n    });\n    const ApproveError = IDL.Variant({\n        GenericError: IDL.Record({\n            message: IDL.Text,\n            error_code: IDL.Nat\n        }),\n        TemporarilyUnavailable: IDL.Null,\n        Duplicate: IDL.Record({\n            duplicate_of: IDL.Nat\n        }),\n        BadFee: IDL.Record({\n            expected_fee: IDL.Nat\n        }),\n        AllowanceChanged: IDL.Record({\n            current_allowance: IDL.Nat\n        }),\n        CreatedInFuture: IDL.Record({\n            ledger_time: IDL.Nat64\n        }),\n        TooOld: IDL.Null,\n        Expired: IDL.Record({\n            ledger_time: IDL.Nat64\n        }),\n        InsufficientFunds: IDL.Record({\n            balance: IDL.Nat\n        })\n    });\n    const Result_2 = IDL.Variant({\n        Ok: IDL.Nat,\n        Err: ApproveError\n    });\n    const TransferFromArgs = IDL.Record({\n        to: Account,\n        fee: IDL.Opt(IDL.Nat),\n        spender_subaccount: IDL.Opt(IDL.Vec(IDL.Nat8)),\n        from: Account,\n        memo: IDL.Opt(IDL.Vec(IDL.Nat8)),\n        created_at_time: IDL.Opt(IDL.Nat64),\n        amount: IDL.Nat\n    });\n    const TransferFromError = IDL.Variant({\n        GenericError: IDL.Record({\n            message: IDL.Text,\n            error_code: IDL.Nat\n        }),\n        TemporarilyUnavailable: IDL.Null,\n        InsufficientAllowance: IDL.Record({\n            allowance: IDL.Nat\n        }),\n        BadBurn: IDL.Record({\n            min_burn_amount: IDL.Nat\n        }),\n        Duplicate: IDL.Record({\n            duplicate_of: IDL.Nat\n        }),\n        BadFee: IDL.Record({\n            expected_fee: IDL.Nat\n        }),\n        CreatedInFuture: IDL.Record({\n            ledger_time: IDL.Nat64\n        }),\n        TooOld: IDL.Null,\n        InsufficientFunds: IDL.Record({\n            balance: IDL.Nat\n        })\n    });\n    const Result_3 = IDL.Variant({\n        Ok: IDL.Nat,\n        Err: TransferFromError\n    });\n    const GetArchivesArgs = IDL.Record({\n        from: IDL.Opt(IDL.Principal)\n    });\n    const ICRC3ArchiveInfo = IDL.Record({\n        end: IDL.Nat,\n        canister_id: IDL.Principal,\n        start: IDL.Nat\n    });\n    ICRC3Value.fill(IDL.Variant({\n        Int: IDL.Int,\n        Map: IDL.Vec(IDL.Tuple(IDL.Text, ICRC3Value)),\n        Nat: IDL.Nat,\n        Blob: IDL.Vec(IDL.Nat8),\n        Text: IDL.Text,\n        Array: IDL.Vec(ICRC3Value)\n    }));\n    const BlockWithId = IDL.Record({\n        id: IDL.Nat,\n        block: ICRC3Value\n    });\n    const ArchivedBlocks = IDL.Record({\n        args: IDL.Vec(GetBlocksRequest),\n        callback: IDL.Func([\n            IDL.Vec(GetBlocksRequest)\n        ], [\n            GetBlocksResult\n        ], [\n            \"query\"\n        ])\n    });\n    GetBlocksResult.fill(IDL.Record({\n        log_length: IDL.Nat,\n        blocks: IDL.Vec(BlockWithId),\n        archived_blocks: IDL.Vec(ArchivedBlocks)\n    }));\n    const ICRC3DataCertificate = IDL.Record({\n        certificate: IDL.Vec(IDL.Nat8),\n        hash_tree: IDL.Vec(IDL.Nat8)\n    });\n    const SupportedBlockType = IDL.Record({\n        url: IDL.Text,\n        block_type: IDL.Text\n    });\n    return IDL.Service({\n        archives: IDL.Func([], [\n            IDL.Vec(ArchiveInfo)\n        ], [\n            \"query\"\n        ]),\n        get_blocks: IDL.Func([\n            GetBlocksRequest\n        ], [\n            GetBlocksResponse\n        ], [\n            \"query\"\n        ]),\n        get_data_certificate: IDL.Func([], [\n            DataCertificate\n        ], [\n            \"query\"\n        ]),\n        get_transactions: IDL.Func([\n            GetBlocksRequest\n        ], [\n            GetTransactionsResponse\n        ], [\n            \"query\"\n        ]),\n        icrc10_supported_standards: IDL.Func([], [\n            IDL.Vec(StandardRecord)\n        ], [\n            \"query\"\n        ]),\n        icrc1_balance_of: IDL.Func([\n            Account\n        ], [\n            IDL.Nat\n        ], [\n            \"query\"\n        ]),\n        icrc1_decimals: IDL.Func([], [\n            IDL.Nat8\n        ], [\n            \"query\"\n        ]),\n        icrc1_fee: IDL.Func([], [\n            IDL.Nat\n        ], [\n            \"query\"\n        ]),\n        icrc1_metadata: IDL.Func([], [\n            IDL.Vec(IDL.Tuple(IDL.Text, MetadataValue))\n        ], [\n            \"query\"\n        ]),\n        icrc1_minting_account: IDL.Func([], [\n            IDL.Opt(Account)\n        ], [\n            \"query\"\n        ]),\n        icrc1_name: IDL.Func([], [\n            IDL.Text\n        ], [\n            \"query\"\n        ]),\n        icrc1_supported_standards: IDL.Func([], [\n            IDL.Vec(StandardRecord)\n        ], [\n            \"query\"\n        ]),\n        icrc1_symbol: IDL.Func([], [\n            IDL.Text\n        ], [\n            \"query\"\n        ]),\n        icrc1_total_supply: IDL.Func([], [\n            IDL.Nat\n        ], [\n            \"query\"\n        ]),\n        icrc1_transfer: IDL.Func([\n            TransferArg\n        ], [\n            Result\n        ], []),\n        icrc21_canister_call_consent_message: IDL.Func([\n            ConsentMessageRequest\n        ], [\n            Result_1\n        ], []),\n        icrc2_allowance: IDL.Func([\n            AllowanceArgs\n        ], [\n            Allowance\n        ], [\n            \"query\"\n        ]),\n        icrc2_approve: IDL.Func([\n            ApproveArgs\n        ], [\n            Result_2\n        ], []),\n        icrc2_transfer_from: IDL.Func([\n            TransferFromArgs\n        ], [\n            Result_3\n        ], []),\n        icrc3_get_archives: IDL.Func([\n            GetArchivesArgs\n        ], [\n            IDL.Vec(ICRC3ArchiveInfo)\n        ], [\n            \"query\"\n        ]),\n        icrc3_get_blocks: IDL.Func([\n            IDL.Vec(GetBlocksRequest)\n        ], [\n            GetBlocksResult\n        ], [\n            \"query\"\n        ]),\n        icrc3_get_tip_certificate: IDL.Func([], [\n            IDL.Opt(ICRC3DataCertificate)\n        ], [\n            \"query\"\n        ]),\n        icrc3_supported_block_types: IDL.Func([], [\n            IDL.Vec(SupportedBlockType)\n        ], [\n            \"query\"\n        ])\n    });\n};\nconst init = (param)=>{\n    let { IDL } = param;\n    const ChangeArchiveOptions = IDL.Record({\n        num_blocks_to_archive: IDL.Opt(IDL.Nat64),\n        max_transactions_per_response: IDL.Opt(IDL.Nat64),\n        trigger_threshold: IDL.Opt(IDL.Nat64),\n        more_controller_ids: IDL.Opt(IDL.Vec(IDL.Principal)),\n        max_message_size_bytes: IDL.Opt(IDL.Nat64),\n        cycles_for_archive_creation: IDL.Opt(IDL.Nat64),\n        node_max_memory_size_bytes: IDL.Opt(IDL.Nat64),\n        controller_id: IDL.Opt(IDL.Principal)\n    });\n    const MetadataValue = IDL.Variant({\n        Int: IDL.Int,\n        Nat: IDL.Nat,\n        Blob: IDL.Vec(IDL.Nat8),\n        Text: IDL.Text\n    });\n    const Account = IDL.Record({\n        owner: IDL.Principal,\n        subaccount: IDL.Opt(IDL.Vec(IDL.Nat8))\n    });\n    const ChangeFeeCollector = IDL.Variant({\n        SetTo: Account,\n        Unset: IDL.Null\n    });\n    const FeatureFlags = IDL.Record({\n        icrc2: IDL.Bool\n    });\n    const UpgradeArgs = IDL.Record({\n        change_archive_options: IDL.Opt(ChangeArchiveOptions),\n        token_symbol: IDL.Opt(IDL.Text),\n        transfer_fee: IDL.Opt(IDL.Nat),\n        metadata: IDL.Opt(IDL.Vec(IDL.Tuple(IDL.Text, MetadataValue))),\n        maximum_number_of_accounts: IDL.Opt(IDL.Nat64),\n        accounts_overflow_trim_quantity: IDL.Opt(IDL.Nat64),\n        change_fee_collector: IDL.Opt(ChangeFeeCollector),\n        max_memo_length: IDL.Opt(IDL.Nat16),\n        token_name: IDL.Opt(IDL.Text),\n        feature_flags: IDL.Opt(FeatureFlags)\n    });\n    const ArchiveOptions = IDL.Record({\n        num_blocks_to_archive: IDL.Nat64,\n        max_transactions_per_response: IDL.Opt(IDL.Nat64),\n        trigger_threshold: IDL.Nat64,\n        more_controller_ids: IDL.Opt(IDL.Vec(IDL.Principal)),\n        max_message_size_bytes: IDL.Opt(IDL.Nat64),\n        cycles_for_archive_creation: IDL.Opt(IDL.Nat64),\n        node_max_memory_size_bytes: IDL.Opt(IDL.Nat64),\n        controller_id: IDL.Principal\n    });\n    const InitArgs = IDL.Record({\n        decimals: IDL.Opt(IDL.Nat8),\n        token_symbol: IDL.Text,\n        transfer_fee: IDL.Nat,\n        metadata: IDL.Vec(IDL.Tuple(IDL.Text, MetadataValue)),\n        minting_account: Account,\n        initial_balances: IDL.Vec(IDL.Tuple(Account, IDL.Nat)),\n        maximum_number_of_accounts: IDL.Opt(IDL.Nat64),\n        accounts_overflow_trim_quantity: IDL.Opt(IDL.Nat64),\n        fee_collector_account: IDL.Opt(Account),\n        archive_options: ArchiveOptions,\n        max_memo_length: IDL.Opt(IDL.Nat16),\n        token_name: IDL.Text,\n        feature_flags: IDL.Opt(FeatureFlags)\n    });\n    const LedgerArgument = IDL.Variant({\n        Upgrade: IDL.Opt(UpgradeArgs),\n        Init: InitArgs\n    });\n    return [\n        LedgerArgument\n    ];\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9kYXRhL2NhbmlzdGVycy9sZWRnZXIvZGlkLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQU8sTUFBTUEsYUFBYTtRQUFDLEVBQUVDLEdBQUcsRUFBRTtJQUNoQyxNQUFNQyxrQkFBa0JELElBQUlFLEdBQUc7SUFDL0IsTUFBTUMsYUFBYUgsSUFBSUUsR0FBRztJQUMxQixNQUFNRSxRQUFRSixJQUFJRSxHQUFHO0lBQ3JCLE1BQU1HLE1BQU1MLElBQUlFLEdBQUc7SUFDbkIsTUFBTUksdUJBQXVCTixJQUFJTyxNQUFNLENBQUM7UUFDdENDLHVCQUF1QlIsSUFBSVMsR0FBRyxDQUFDVCxJQUFJVSxLQUFLO1FBQ3hDQywrQkFBK0JYLElBQUlTLEdBQUcsQ0FBQ1QsSUFBSVUsS0FBSztRQUNoREUsbUJBQW1CWixJQUFJUyxHQUFHLENBQUNULElBQUlVLEtBQUs7UUFDcENHLHFCQUFxQmIsSUFBSVMsR0FBRyxDQUFDVCxJQUFJSyxHQUFHLENBQUNMLElBQUljLFNBQVM7UUFDbERDLHdCQUF3QmYsSUFBSVMsR0FBRyxDQUFDVCxJQUFJVSxLQUFLO1FBQ3pDTSw2QkFBNkJoQixJQUFJUyxHQUFHLENBQUNULElBQUlVLEtBQUs7UUFDOUNPLDRCQUE0QmpCLElBQUlTLEdBQUcsQ0FBQ1QsSUFBSVUsS0FBSztRQUM3Q1EsZUFBZWxCLElBQUlTLEdBQUcsQ0FBQ1QsSUFBSWMsU0FBUztJQUN0QztJQUNBLE1BQU1LLGdCQUFnQm5CLElBQUlvQixPQUFPLENBQUM7UUFDaENDLEtBQUtyQixJQUFJcUIsR0FBRztRQUNaQyxLQUFLdEIsSUFBSXNCLEdBQUc7UUFDWkMsTUFBTXZCLElBQUlLLEdBQUcsQ0FBQ0wsSUFBSXdCLElBQUk7UUFDdEJDLE1BQU16QixJQUFJeUIsSUFBSTtJQUNoQjtJQUNBLE1BQU1DLFVBQVUxQixJQUFJTyxNQUFNLENBQUM7UUFDekJvQixPQUFPM0IsSUFBSWMsU0FBUztRQUNwQmMsWUFBWTVCLElBQUlTLEdBQUcs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QUFJUyxHQUFHLENBQUMyQjtRQUNqQnNCLE1BQU1SO0lBQ1I7SUFDQSxPQUFPO1FBQUNNO0tBQWU7QUFDekIsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvZGF0YS9jYW5pc3RlcnMvbGVkZ2VyL2RpZC5qcz9lMWRjIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBpZGxGYWN0b3J5ID0gKHsgSURMIH0pID0+IHtcclxuICBjb25zdCBHZXRCbG9ja3NSZXN1bHQgPSBJREwuUmVjKCk7XHJcbiAgY29uc3QgSUNSQzNWYWx1ZSA9IElETC5SZWMoKTtcclxuICBjb25zdCBWYWx1ZSA9IElETC5SZWMoKTtcclxuICBjb25zdCBWZWMgPSBJREwuUmVjKCk7XHJcbiAgY29uc3QgQ2hhbmdlQXJjaGl2ZU9wdGlvbnMgPSBJREwuUmVjb3JkKHtcclxuICAgIG51bV9ibG9ja3NfdG9fYXJjaGl2ZTogSURMLk9wdChJREwuTmF0NjQpLFxyXG4gICAgbWF4X3RyYW5zYWN0aW9uc19wZXJfcmVzcG9uc2U6IElETC5PcHQoSURMLk5hdDY0KSxcclxuICAgIHRyaWdnZXJfdGhyZXNob2xkOiBJREwuT3B0KElETC5OYXQ2NCksXHJcbiAgICBtb3JlX2NvbnRyb2xsZXJfaWRzOiBJREwuT3B0KElETC5WZWMoSURMLlByaW5jaXBhbCkpLFxyXG4gICAgbWF4X21lc3NhZ2Vfc2l6ZV9ieXRlczogSURMLk9wdChJREwuTmF0NjQpLFxyXG4gICAgY3ljbGVzX2Zvcl9hcmNoaXZlX2NyZWF0aW9uOiBJREwuT3B0KElETC5OYXQ2NCksXHJcbiAgICBub2RlX21heF9tZW1vcnlfc2l6ZV9ieXRlczogSURMLk9wdChJREwuTmF0NjQpLFxyXG4gICAgY29udHJvbGxlcl9pZDogSURMLk9wdChJREwuUHJpbmNpcGFsKSxcclxuICB9KTtcclxuICBjb25zdCBNZXRhZGF0YVZhbHVlID0gSURMLlZhcmlhbnQoe1xyXG4gICAgSW50OiBJREwuSW50LFxyXG4gICAgTmF0OiBJREwuTmF0LFxyXG4gICAgQmxvYjogSURMLlZlYyhJREwuTmF0OCksXHJcbiAgICBUZXh0OiBJREwuVGV4dCxcclxuICB9KTtcclxuICBjb25zdCBBY2NvdW50ID0gSURMLlJlY29yZCh7XHJcbiAgICBvd25lcjogSURMLlByaW5jaXBhbCxcclxuICAgIHN1YmFjY291bnQ6IElETC5PcHQoSURMLlZlYyhJREwuTmF0OCkpLFxyXG4gIH0pO1xyXG4gIGNvbnN0IENoYW5nZUZlZUNvbGxlY3RvciA9IElETC5WYXJpYW50KHtcclxuICAgIFNldFRvOiBBY2NvdW50LFxyXG4gICAgVW5zZXQ6IElETC5OdWxsLFxyXG4gIH0pO1xyXG4gIGNvbnN0IEZlYXR1cmVGbGFncyA9IElETC5SZWNvcmQoeyBpY3JjMjogSURMLkJvb2wgfSk7XHJcbiAgY29uc3QgVXBncmFkZUFyZ3MgPSBJREwuUmVjb3JkKHtcclxuICAgIGNoYW5nZV9hcmNoaXZlX29wdGlvbnM6IElETC5PcHQoQ2hhbmdlQXJjaGl2ZU9wdGlvbnMpLFxyXG4gICAgdG9rZW5fc3ltYm9sOiBJREwuT3B0KElETC5UZXh0KSxcclxuICAgIHRyYW5zZmVyX2ZlZTogSURMLk9wdChJREwuTmF0KSxcclxuICAgIG1ldGFkYXRhOiBJREwuT3B0KElETC5WZWMoSURMLlR1cGxlKElETC5UZXh0LCBNZXRhZGF0YVZhbHVlKSkpLFxyXG4gICAgbWF4aW11bV9udW1iZXJfb2ZfYWNjb3VudHM6IElETC5PcHQoSURMLk5hdDY0KSxcclxuICAgIGFjY291bnRzX292ZXJmbG93X3RyaW1fcXVhbnRpdHk6IElETC5PcHQoSURMLk5hdDY0KSxcclxuICAgIGNoYW5nZV9mZWVfY29sbGVjdG9yOiBJREwuT3B0KENoYW5nZUZlZUNvbGxlY3RvciksXHJcbiAgICBtYXhfbWVtb19sZW5ndGg6IElETC5PcHQoSURMLk5hdDE2KSxcclxuICAgIHRva2VuX25hbWU6IElETC5PcHQoSURMLlRleHQpLFxyXG4gICAgZmVhdHVyZV9mbGFnczogSURMLk9wdChGZWF0dXJlRmxhZ3MpLFxyXG4gIH0pO1xyXG4gIGNvbnN0IEFyY2hpdmVPcHRpb25zID0gSURMLlJlY29yZCh7XHJcbiAgICBudW1fYmxvY2tzX3RvX2FyY2hpdmU6IElETC5OYXQ2NCxcclxuICAgIG1heF90cmFuc2FjdGlvbnNfcGVyX3Jlc3BvbnNlOiBJREwuT3B0KElETC5OYXQ2NCksXHJcbiAgICB0cmlnZ2VyX3RocmVzaG9sZDogSURMLk5hdDY0LFxyXG4gICAgbW9yZV9jb250cm9sbGVyX2lkczogSURMLk9wdChJREwuVmVjKElETC5QcmluY2lwYWwpKSxcclxuICAgIG1heF9tZXNzYWdlX3NpemVfYnl0ZXM6IElETC5PcHQoSURMLk5hdDY0KSxcclxuICAgIGN5Y2xlc19mb3JfYXJjaGl2ZV9jcmVhdGlvbjogSURMLk9wdChJREwuTmF0NjQpLFxyXG4gICAgbm9kZV9tYXhfbWVtb3J5X3NpemVfYnl0ZXM6IElETC5PcHQoSURMLk5hdDY0KSxcclxuICAgIGNvbnRyb2xsZXJfaWQ6IElETC5QcmluY2lwYWwsXHJcbiAgfSk7XHJcbiAgY29uc3QgSW5pdEFyZ3MgPSBJREwuUmVjb3JkKHtcclxuICAgIGRlY2ltYWxzOiBJREwuT3B0KElETC5OYXQ4KSxcclxuICAgIHRva2VuX3N5bWJvbDogSURMLlRleHQsXHJcbiAgICB0cmFuc2Zlcl9mZWU6IElETC5OYXQsXHJcbiAgICBtZXRhZGF0YTogSURMLlZlYyhJREwuVHVwbGUoSURMLlRleHQsIE1ldGFkYXRhVmFsdWUpKSxcclxuICAgIG1pbnRpbmdfYWNjb3VudDogQWNjb3VudCxcclxuICAgIGluaXRpYWxfYmFsYW5jZXM6IElETC5WZWMoSURMLlR1cGxlKEFjY291bnQsIElETC5OYXQpKSxcclxuICAgIG1heGltdW1fbnVtYmVyX29mX2FjY291bnRzOiBJREwuT3B0KElETC5OYXQ2NCksXHJcbiAgICBhY2NvdW50c19vdmVyZmxvd190cmltX3F1YW50aXR5OiBJREwuT3B0KElETC5OYXQ2NCksXHJcbiAgICBmZWVfY29sbGVjdG9yX2FjY291bnQ6IElETC5PcHQoQWNjb3VudCksXHJcbiAgICBhcmNoaXZlX29wdGlvbnM6IEFyY2hpdmVPcHRpb25zLFxyXG4gICAgbWF4X21lbW9fbGVuZ3RoOiBJREwuT3B0KElETC5OYXQxNiksXHJcbiAgICB0b2tlbl9uYW1lOiBJREwuVGV4dCxcclxuICAgIGZlYXR1cmVfZmxhZ3M6IElETC5PcHQoRmVhdHVyZUZsYWdzKSxcclxuICB9KTtcclxuICBjb25zdCBMZWRnZXJBcmd1bWVudCA9IElETC5WYXJpYW50KHtcclxuICAgIFVwZ3JhZGU6IElETC5PcHQoVXBncmFkZUFyZ3MpLFxyXG4gICAgSW5pdDogSW5pdEFyZ3MsXHJcbiAgfSk7XHJcbiAgY29uc3QgQXJjaGl2ZUluZm8gPSBJREwuUmVjb3JkKHtcclxuICAgIGJsb2NrX3JhbmdlX2VuZDogSURMLk5hdCxcclxuICAgIGNhbmlzdGVyX2lkOiBJREwuUHJpbmNpcGFsLFxyXG4gICAgYmxvY2tfcmFuZ2Vfc3RhcnQ6IElETC5OYXQsXHJcbiAgfSk7XHJcbiAgY29uc3QgR2V0QmxvY2tzUmVxdWVzdCA9IElETC5SZWNvcmQoe1xyXG4gICAgc3RhcnQ6IElETC5OYXQsXHJcbiAgICBsZW5ndGg6IElETC5OYXQsXHJcbiAgfSk7XHJcbiAgVmVjLmZpbGwoXHJcbiAgICBJREwuVmVjKFxyXG4gICAgICBJREwuVmFyaWFudCh7XHJcbiAgICAgICAgSW50OiBJREwuSW50LFxyXG4gICAgICAgIE1hcDogSURMLlZlYyhJREwuVHVwbGUoSURMLlRleHQsIFZhbHVlKSksXHJcbiAgICAgICAgTmF0OiBJREwuTmF0LFxyXG4gICAgICAgIE5hdDY0OiBJREwuTmF0NjQsXHJcbiAgICAgICAgQmxvYjogSURMLlZlYyhJREwuTmF0OCksXHJcbiAgICAgICAgVGV4dDogSURMLlRleHQsXHJcbiAgICAgICAgQXJyYXk6IFZlYyxcclxuICAgICAgfSlcclxuICAgIClcclxuICApO1xyXG4gIFZhbHVlLmZpbGwoXHJcbiAgICBJREwuVmFyaWFudCh7XHJcbiAgICAgIEludDogSURMLkludCxcclxuICAgICAgTWFwOiBJREwuVmVjKElETC5UdXBsZShJREwuVGV4dCwgVmFsdWUpKSxcclxuICAgICAgTmF0OiBJREwuTmF0LFxyXG4gICAgICBOYXQ2NDogSURMLk5hdDY0LFxyXG4gICAgICBCbG9iOiBJREwuVmVjKElETC5OYXQ4KSxcclxuICAgICAgVGV4dDogSURMLlRleHQsXHJcbiAgICAgIEFycmF5OiBWZWMsXHJcbiAgICB9KVxyXG4gICk7XHJcbiAgY29uc3QgQmxvY2tSYW5nZSA9IElETC5SZWNvcmQoeyBibG9ja3M6IElETC5WZWMoVmFsdWUpIH0pO1xyXG4gIGNvbnN0IEFyY2hpdmVkUmFuZ2UgPSBJREwuUmVjb3JkKHtcclxuICAgIGNhbGxiYWNrOiBJREwuRnVuYyhbR2V0QmxvY2tzUmVxdWVzdF0sIFtCbG9ja1JhbmdlXSwgW1wicXVlcnlcIl0pLFxyXG4gICAgc3RhcnQ6IElETC5OYXQsXHJcbiAgICBsZW5ndGg6IElETC5OYXQsXHJcbiAgfSk7XHJcbiAgY29uc3QgR2V0QmxvY2tzUmVzcG9uc2UgPSBJREwuUmVjb3JkKHtcclxuICAgIGNlcnRpZmljYXRlOiBJREwuT3B0KElETC5WZWMoSURMLk5hdDgpKSxcclxuICAgIGZpcnN0X2luZGV4OiBJREwuTmF0LFxyXG4gICAgYmxvY2tzOiBJREwuVmVjKFZhbHVlKSxcclxuICAgIGNoYWluX2xlbmd0aDogSURMLk5hdDY0LFxyXG4gICAgYXJjaGl2ZWRfYmxvY2tzOiBJREwuVmVjKEFyY2hpdmVkUmFuZ2UpLFxyXG4gIH0pO1xyXG4gIGNvbnN0IERhdGFDZXJ0aWZpY2F0ZSA9IElETC5SZWNvcmQoe1xyXG4gICAgY2VydGlmaWNhdGU6IElETC5PcHQoSURMLlZlYyhJREwuTmF0OCkpLFxyXG4gICAgaGFzaF90cmVlOiBJREwuVmVjKElETC5OYXQ4KSxcclxuICB9KTtcclxuICBjb25zdCBCdXJuID0gSURMLlJlY29yZCh7XHJcbiAgICBmcm9tOiBBY2NvdW50LFxyXG4gICAgbWVtbzogSURMLk9wdChJREwuVmVjKElETC5OYXQ4KSksXHJcbiAgICBjcmVhdGVkX2F0X3RpbWU6IElETC5PcHQoSURMLk5hdDY0KSxcclxuICAgIGFtb3VudDogSURMLk5hdCxcclxuICAgIHNwZW5kZXI6IElETC5PcHQoQWNjb3VudCksXHJcbiAgfSk7XHJcbiAgY29uc3QgTWludCA9IElETC5SZWNvcmQoe1xyXG4gICAgdG86IEFjY291bnQsXHJcbiAgICBtZW1vOiBJREwuT3B0KElETC5WZWMoSURMLk5hdDgpKSxcclxuICAgIGNyZWF0ZWRfYXRfdGltZTogSURMLk9wdChJREwuTmF0NjQpLFxyXG4gICAgYW1vdW50OiBJREwuTmF0LFxyXG4gIH0pO1xyXG4gIGNvbnN0IEFwcHJvdmUgPSBJREwuUmVjb3JkKHtcclxuICAgIGZlZTogSURMLk9wdChJREwuTmF0KSxcclxuICAgIGZyb206IEFjY291bnQsXHJcbiAgICBtZW1vOiBJREwuT3B0KElETC5WZWMoSURMLk5hdDgpKSxcclxuICAgIGNyZWF0ZWRfYXRfdGltZTogSURMLk9wdChJREwuTmF0NjQpLFxyXG4gICAgYW1vdW50OiBJREwuTmF0LFxyXG4gICAgZXhwZWN0ZWRfYWxsb3dhbmNlOiBJREwuT3B0KElETC5OYXQpLFxyXG4gICAgZXhwaXJlc19hdDogSURMLk9wdChJREwuTmF0NjQpLFxyXG4gICAgc3BlbmRlcjogQWNjb3VudCxcclxuICB9KTtcclxuICBjb25zdCBUcmFuc2ZlciA9IElETC5SZWNvcmQoe1xyXG4gICAgdG86IEFjY291bnQsXHJcbiAgICBmZWU6IElETC5PcHQoSURMLk5hdCksXHJcbiAgICBmcm9tOiBBY2NvdW50LFxyXG4gICAgbWVtbzogSURMLk9wdChJREwuVmVjKElETC5OYXQ4KSksXHJcbiAgICBjcmVhdGVkX2F0X3RpbWU6IElETC5PcHQoSURMLk5hdDY0KSxcclxuICAgIGFtb3VudDogSURMLk5hdCxcclxuICAgIHNwZW5kZXI6IElETC5PcHQoQWNjb3VudCksXHJcbiAgfSk7XHJcbiAgY29uc3QgVHJhbnNhY3Rpb24gPSBJREwuUmVjb3JkKHtcclxuICAgIGJ1cm46IElETC5PcHQoQnVybiksXHJcbiAgICBraW5kOiBJREwuVGV4dCxcclxuICAgIG1pbnQ6IElETC5PcHQoTWludCksXHJcbiAgICBhcHByb3ZlOiBJREwuT3B0KEFwcHJvdmUpLFxyXG4gICAgdGltZXN0YW1wOiBJREwuTmF0NjQsXHJcbiAgICB0cmFuc2ZlcjogSURMLk9wdChUcmFuc2ZlciksXHJcbiAgfSk7XHJcbiAgY29uc3QgVHJhbnNhY3Rpb25SYW5nZSA9IElETC5SZWNvcmQoe1xyXG4gICAgdHJhbnNhY3Rpb25zOiBJREwuVmVjKFRyYW5zYWN0aW9uKSxcclxuICB9KTtcclxuICBjb25zdCBBcmNoaXZlZFJhbmdlXzEgPSBJREwuUmVjb3JkKHtcclxuICAgIGNhbGxiYWNrOiBJREwuRnVuYyhbR2V0QmxvY2tzUmVxdWVzdF0sIFtUcmFuc2FjdGlvblJhbmdlXSwgW1wicXVlcnlcIl0pLFxyXG4gICAgc3RhcnQ6IElETC5OYXQsXHJcbiAgICBsZW5ndGg6IElETC5OYXQsXHJcbiAgfSk7XHJcbiAgY29uc3QgR2V0VHJhbnNhY3Rpb25zUmVzcG9uc2UgPSBJREwuUmVjb3JkKHtcclxuICAgIGZpcnN0X2luZGV4OiBJREwuTmF0LFxyXG4gICAgbG9nX2xlbmd0aDogSURMLk5hdCxcclxuICAgIHRyYW5zYWN0aW9uczogSURMLlZlYyhUcmFuc2FjdGlvbiksXHJcbiAgICBhcmNoaXZlZF90cmFuc2FjdGlvbnM6IElETC5WZWMoQXJjaGl2ZWRSYW5nZV8xKSxcclxuICB9KTtcclxuICBjb25zdCBTdGFuZGFyZFJlY29yZCA9IElETC5SZWNvcmQoeyB1cmw6IElETC5UZXh0LCBuYW1lOiBJREwuVGV4dCB9KTtcclxuICBjb25zdCBUcmFuc2ZlckFyZyA9IElETC5SZWNvcmQoe1xyXG4gICAgdG86IEFjY291bnQsXHJcbiAgICBmZWU6IElETC5PcHQoSURMLk5hdCksXHJcbiAgICBtZW1vOiBJREwuT3B0KElETC5WZWMoSURMLk5hdDgpKSxcclxuICAgIGZyb21fc3ViYWNjb3VudDogSURMLk9wdChJREwuVmVjKElETC5OYXQ4KSksXHJcbiAgICBjcmVhdGVkX2F0X3RpbWU6IElETC5PcHQoSURMLk5hdDY0KSxcclxuICAgIGFtb3VudDogSURMLk5hdCxcclxuICB9KTtcclxuICBjb25zdCBUcmFuc2ZlckVycm9yID0gSURMLlZhcmlhbnQoe1xyXG4gICAgR2VuZXJpY0Vycm9yOiBJREwuUmVjb3JkKHtcclxuICAgICAgbWVzc2FnZTogSURMLlRleHQsXHJcbiAgICAgIGVycm9yX2NvZGU6IElETC5OYXQsXHJcbiAgICB9KSxcclxuICAgIFRlbXBvcmFyaWx5VW5hdmFpbGFibGU6IElETC5OdWxsLFxyXG4gICAgQmFkQnVybjogSURMLlJlY29yZCh7IG1pbl9idXJuX2Ftb3VudDogSURMLk5hdCB9KSxcclxuICAgIER1cGxpY2F0ZTogSURMLlJlY29yZCh7IGR1cGxpY2F0ZV9vZjogSURMLk5hdCB9KSxcclxuICAgIEJhZEZlZTogSURMLlJlY29yZCh7IGV4cGVjdGVkX2ZlZTogSURMLk5hdCB9KSxcclxuICAgIENyZWF0ZWRJbkZ1dHVyZTogSURMLlJlY29yZCh7IGxlZGdlcl90aW1lOiBJREwuTmF0NjQgfSksXHJcbiAgICBUb29PbGQ6IElETC5OdWxsLFxyXG4gICAgSW5zdWZmaWNpZW50RnVuZHM6IElETC5SZWNvcmQoeyBiYWxhbmNlOiBJREwuTmF0IH0pLFxyXG4gIH0pO1xyXG4gIGNvbnN0IFJlc3VsdCA9IElETC5WYXJpYW50KHsgT2s6IElETC5OYXQsIEVycjogVHJhbnNmZXJFcnJvciB9KTtcclxuICBjb25zdCBDb25zZW50TWVzc2FnZU1ldGFkYXRhID0gSURMLlJlY29yZCh7XHJcbiAgICB1dGNfb2Zmc2V0X21pbnV0ZXM6IElETC5PcHQoSURMLkludDE2KSxcclxuICAgIGxhbmd1YWdlOiBJREwuVGV4dCxcclxuICB9KTtcclxuICBjb25zdCBEaXNwbGF5TWVzc2FnZVR5cGUgPSBJREwuVmFyaWFudCh7XHJcbiAgICBHZW5lcmljRGlzcGxheTogSURMLk51bGwsXHJcbiAgICBMaW5lRGlzcGxheTogSURMLlJlY29yZCh7XHJcbiAgICAgIGNoYXJhY3RlcnNfcGVyX2xpbmU6IElETC5OYXQxNixcclxuICAgICAgbGluZXNfcGVyX3BhZ2U6IElETC5OYXQxNixcclxuICAgIH0pLFxyXG4gIH0pO1xyXG4gIGNvbnN0IENvbnNlbnRNZXNzYWdlU3BlYyA9IElETC5SZWNvcmQoe1xyXG4gICAgbWV0YWRhdGE6IENvbnNlbnRNZXNzYWdlTWV0YWRhdGEsXHJcbiAgICBkZXZpY2Vfc3BlYzogSURMLk9wdChEaXNwbGF5TWVzc2FnZVR5cGUpLFxyXG4gIH0pO1xyXG4gIGNvbnN0IENvbnNlbnRNZXNzYWdlUmVxdWVzdCA9IElETC5SZWNvcmQoe1xyXG4gICAgYXJnOiBJREwuVmVjKElETC5OYXQ4KSxcclxuICAgIG1ldGhvZDogSURMLlRleHQsXHJcbiAgICB1c2VyX3ByZWZlcmVuY2VzOiBDb25zZW50TWVzc2FnZVNwZWMsXHJcbiAgfSk7XHJcbiAgY29uc3QgTGluZURpc3BsYXlQYWdlID0gSURMLlJlY29yZCh7IGxpbmVzOiBJREwuVmVjKElETC5UZXh0KSB9KTtcclxuICBjb25zdCBDb25zZW50TWVzc2FnZSA9IElETC5WYXJpYW50KHtcclxuICAgIExpbmVEaXNwbGF5TWVzc2FnZTogSURMLlJlY29yZCh7IHBhZ2VzOiBJREwuVmVjKExpbmVEaXNwbGF5UGFnZSkgfSksXHJcbiAgICBHZW5lcmljRGlzcGxheU1lc3NhZ2U6IElETC5UZXh0LFxyXG4gIH0pO1xyXG4gIGNvbnN0IENvbnNlbnRJbmZvID0gSURMLlJlY29yZCh7XHJcbiAgICBtZXRhZGF0YTogQ29uc2VudE1lc3NhZ2VNZXRhZGF0YSxcclxuICAgIGNvbnNlbnRfbWVzc2FnZTogQ29uc2VudE1lc3NhZ2UsXHJcbiAgfSk7XHJcbiAgY29uc3QgRXJyb3JJbmZvID0gSURMLlJlY29yZCh7IGRlc2NyaXB0aW9uOiBJREwuVGV4dCB9KTtcclxuICBjb25zdCBJY3JjMjFFcnJvciA9IElETC5WYXJpYW50KHtcclxuICAgIEdlbmVyaWNFcnJvcjogSURMLlJlY29yZCh7XHJcbiAgICAgIGRlc2NyaXB0aW9uOiBJREwuVGV4dCxcclxuICAgICAgZXJyb3JfY29kZTogSURMLk5hdCxcclxuICAgIH0pLFxyXG4gICAgSW5zdWZmaWNpZW50UGF5bWVudDogRXJyb3JJbmZvLFxyXG4gICAgVW5zdXBwb3J0ZWRDYW5pc3RlckNhbGw6IEVycm9ySW5mbyxcclxuICAgIENvbnNlbnRNZXNzYWdlVW5hdmFpbGFibGU6IEVycm9ySW5mbyxcclxuICB9KTtcclxuICBjb25zdCBSZXN1bHRfMSA9IElETC5WYXJpYW50KHsgT2s6IENvbnNlbnRJbmZvLCBFcnI6IEljcmMyMUVycm9yIH0pO1xyXG4gIGNvbnN0IEFsbG93YW5jZUFyZ3MgPSBJREwuUmVjb3JkKHtcclxuICAgIGFjY291bnQ6IEFjY291bnQsXHJcbiAgICBzcGVuZGVyOiBBY2NvdW50LFxyXG4gIH0pO1xyXG4gIGNvbnN0IEFsbG93YW5jZSA9IElETC5SZWNvcmQoe1xyXG4gICAgYWxsb3dhbmNlOiBJREwuTmF0LFxyXG4gICAgZXhwaXJlc19hdDogSURMLk9wdChJREwuTmF0NjQpLFxyXG4gIH0pO1xyXG4gIGNvbnN0IEFwcHJvdmVBcmdzID0gSURMLlJlY29yZCh7XHJcbiAgICBmZWU6IElETC5PcHQoSURMLk5hdCksXHJcbiAgICBtZW1vOiBJREwuT3B0KElETC5WZWMoSURMLk5hdDgpKSxcclxuICAgIGZyb21fc3ViYWNjb3VudDogSURMLk9wdChJREwuVmVjKElETC5OYXQ4KSksXHJcbiAgICBjcmVhdGVkX2F0X3RpbWU6IElETC5PcHQoSURMLk5hdDY0KSxcclxuICAgIGFtb3VudDogSURMLk5hdCxcclxuICAgIGV4cGVjdGVkX2FsbG93YW5jZTogSURMLk9wdChJREwuTmF0KSxcclxuICAgIGV4cGlyZXNfYXQ6IElETC5PcHQoSURMLk5hdDY0KSxcclxuICAgIHNwZW5kZXI6IEFjY291bnQsXHJcbiAgfSk7XHJcbiAgY29uc3QgQXBwcm92ZUVycm9yID0gSURMLlZhcmlhbnQoe1xyXG4gICAgR2VuZXJpY0Vycm9yOiBJREwuUmVjb3JkKHtcclxuICAgICAgbWVzc2FnZTogSURMLlRleHQsXHJcbiAgICAgIGVycm9yX2NvZGU6IElETC5OYXQsXHJcbiAgICB9KSxcclxuICAgIFRlbXBvcmFyaWx5VW5hdmFpbGFibGU6IElETC5OdWxsLFxyXG4gICAgRHVwbGljYXRlOiBJREwuUmVjb3JkKHsgZHVwbGljYXRlX29mOiBJREwuTmF0IH0pLFxyXG4gICAgQmFkRmVlOiBJREwuUmVjb3JkKHsgZXhwZWN0ZWRfZmVlOiBJREwuTmF0IH0pLFxyXG4gICAgQWxsb3dhbmNlQ2hhbmdlZDogSURMLlJlY29yZCh7IGN1cnJlbnRfYWxsb3dhbmNlOiBJREwuTmF0IH0pLFxyXG4gICAgQ3JlYXRlZEluRnV0dXJlOiBJREwuUmVjb3JkKHsgbGVkZ2VyX3RpbWU6IElETC5OYXQ2NCB9KSxcclxuICAgIFRvb09sZDogSURMLk51bGwsXHJcbiAgICBFeHBpcmVkOiBJREwuUmVjb3JkKHsgbGVkZ2VyX3RpbWU6IElETC5OYXQ2NCB9KSxcclxuICAgIEluc3VmZmljaWVudEZ1bmRzOiBJREwuUmVjb3JkKHsgYmFsYW5jZTogSURMLk5hdCB9KSxcclxuICB9KTtcclxuICBjb25zdCBSZXN1bHRfMiA9IElETC5WYXJpYW50KHsgT2s6IElETC5OYXQsIEVycjogQXBwcm92ZUVycm9yIH0pO1xyXG4gIGNvbnN0IFRyYW5zZmVyRnJvbUFyZ3MgPSBJREwuUmVjb3JkKHtcclxuICAgIHRvOiBBY2NvdW50LFxyXG4gICAgZmVlOiBJREwuT3B0KElETC5OYXQpLFxyXG4gICAgc3BlbmRlcl9zdWJhY2NvdW50OiBJREwuT3B0KElETC5WZWMoSURMLk5hdDgpKSxcclxuICAgIGZyb206IEFjY291bnQsXHJcbiAgICBtZW1vOiBJREwuT3B0KElETC5WZWMoSURMLk5hdDgpKSxcclxuICAgIGNyZWF0ZWRfYXRfdGltZTogSURMLk9wdChJREwuTmF0NjQpLFxyXG4gICAgYW1vdW50OiBJREwuTmF0LFxyXG4gIH0pO1xyXG4gIGNvbnN0IFRyYW5zZmVyRnJvbUVycm9yID0gSURMLlZhcmlhbnQoe1xyXG4gICAgR2VuZXJpY0Vycm9yOiBJREwuUmVjb3JkKHtcclxuICAgICAgbWVzc2FnZTogSURMLlRleHQsXHJcbiAgICAgIGVycm9yX2NvZGU6IElETC5OYXQsXHJcbiAgICB9KSxcclxuICAgIFRlbXBvcmFyaWx5VW5hdmFpbGFibGU6IElETC5OdWxsLFxyXG4gICAgSW5zdWZmaWNpZW50QWxsb3dhbmNlOiBJREwuUmVjb3JkKHsgYWxsb3dhbmNlOiBJREwuTmF0IH0pLFxyXG4gICAgQmFkQnVybjogSURMLlJlY29yZCh7IG1pbl9idXJuX2Ftb3VudDogSURMLk5hdCB9KSxcclxuICAgIER1cGxpY2F0ZTogSURMLlJlY29yZCh7IGR1cGxpY2F0ZV9vZjogSURMLk5hdCB9KSxcclxuICAgIEJhZEZlZTogSURMLlJlY29yZCh7IGV4cGVjdGVkX2ZlZTogSURMLk5hdCB9KSxcclxuICAgIENyZWF0ZWRJbkZ1dHVyZTogSURMLlJlY29yZCh7IGxlZGdlcl90aW1lOiBJREwuTmF0NjQgfSksXHJcbiAgICBUb29PbGQ6IElETC5OdWxsLFxyXG4gICAgSW5zdWZmaWNpZW50RnVuZHM6IElETC5SZWNvcmQoeyBiYWxhbmNlOiBJREwuTmF0IH0pLFxyXG4gIH0pO1xyXG4gIGNvbnN0IFJlc3VsdF8zID0gSURMLlZhcmlhbnQoeyBPazogSURMLk5hdCwgRXJyOiBUcmFuc2ZlckZyb21FcnJvciB9KTtcclxuICBjb25zdCBHZXRBcmNoaXZlc0FyZ3MgPSBJREwuUmVjb3JkKHsgZnJvbTogSURMLk9wdChJREwuUHJpbmNpcGFsKSB9KTtcclxuICBjb25zdCBJQ1JDM0FyY2hpdmVJbmZvID0gSURMLlJlY29yZCh7XHJcbiAgICBlbmQ6IElETC5OYXQsXHJcbiAgICBjYW5pc3Rlcl9pZDogSURMLlByaW5jaXBhbCxcclxuICAgIHN0YXJ0OiBJREwuTmF0LFxyXG4gIH0pO1xyXG4gIElDUkMzVmFsdWUuZmlsbChcclxuICAgIElETC5WYXJpYW50KHtcclxuICAgICAgSW50OiBJREwuSW50LFxyXG4gICAgICBNYXA6IElETC5WZWMoSURMLlR1cGxlKElETC5UZXh0LCBJQ1JDM1ZhbHVlKSksXHJcbiAgICAgIE5hdDogSURMLk5hdCxcclxuICAgICAgQmxvYjogSURMLlZlYyhJREwuTmF0OCksXHJcbiAgICAgIFRleHQ6IElETC5UZXh0LFxyXG4gICAgICBBcnJheTogSURMLlZlYyhJQ1JDM1ZhbHVlKSxcclxuICAgIH0pXHJcbiAgKTtcclxuICBjb25zdCBCbG9ja1dpdGhJZCA9IElETC5SZWNvcmQoeyBpZDogSURMLk5hdCwgYmxvY2s6IElDUkMzVmFsdWUgfSk7XHJcbiAgY29uc3QgQXJjaGl2ZWRCbG9ja3MgPSBJREwuUmVjb3JkKHtcclxuICAgIGFyZ3M6IElETC5WZWMoR2V0QmxvY2tzUmVxdWVzdCksXHJcbiAgICBjYWxsYmFjazogSURMLkZ1bmMoXHJcbiAgICAgIFtJREwuVmVjKEdldEJsb2Nrc1JlcXVlc3QpXSxcclxuICAgICAgW0dldEJsb2Nrc1Jlc3VsdF0sXHJcbiAgICAgIFtcInF1ZXJ5XCJdXHJcbiAgICApLFxyXG4gIH0pO1xyXG4gIEdldEJsb2Nrc1Jlc3VsdC5maWxsKFxyXG4gICAgSURMLlJlY29yZCh7XHJcbiAgICAgIGxvZ19sZW5ndGg6IElETC5OYXQsXHJcbiAgICAgIGJsb2NrczogSURMLlZlYyhCbG9ja1dpdGhJZCksXHJcbiAgICAgIGFyY2hpdmVkX2Jsb2NrczogSURMLlZlYyhBcmNoaXZlZEJsb2NrcyksXHJcbiAgICB9KVxyXG4gICk7XHJcbiAgY29uc3QgSUNSQzNEYXRhQ2VydGlmaWNhdGUgPSBJREwuUmVjb3JkKHtcclxuICAgIGNlcnRpZmljYXRlOiBJREwuVmVjKElETC5OYXQ4KSxcclxuICAgIGhhc2hfdHJlZTogSURMLlZlYyhJREwuTmF0OCksXHJcbiAgfSk7XHJcbiAgY29uc3QgU3VwcG9ydGVkQmxvY2tUeXBlID0gSURMLlJlY29yZCh7XHJcbiAgICB1cmw6IElETC5UZXh0LFxyXG4gICAgYmxvY2tfdHlwZTogSURMLlRleHQsXHJcbiAgfSk7XHJcbiAgcmV0dXJuIElETC5TZXJ2aWNlKHtcclxuICAgIGFyY2hpdmVzOiBJREwuRnVuYyhbXSwgW0lETC5WZWMoQXJjaGl2ZUluZm8pXSwgW1wicXVlcnlcIl0pLFxyXG4gICAgZ2V0X2Jsb2NrczogSURMLkZ1bmMoW0dldEJsb2Nrc1JlcXVlc3RdLCBbR2V0QmxvY2tzUmVzcG9uc2VdLCBbXCJxdWVyeVwiXSksXHJcbiAgICBnZXRfZGF0YV9jZXJ0aWZpY2F0ZTogSURMLkZ1bmMoW10sIFtEYXRhQ2VydGlmaWNhdGVdLCBbXCJxdWVyeVwiXSksXHJcbiAgICBnZXRfdHJhbnNhY3Rpb25zOiBJREwuRnVuYyhcclxuICAgICAgW0dldEJsb2Nrc1JlcXVlc3RdLFxyXG4gICAgICBbR2V0VHJhbnNhY3Rpb25zUmVzcG9uc2VdLFxyXG4gICAgICBbXCJxdWVyeVwiXVxyXG4gICAgKSxcclxuICAgIGljcmMxMF9zdXBwb3J0ZWRfc3RhbmRhcmRzOiBJREwuRnVuYyhcclxuICAgICAgW10sXHJcbiAgICAgIFtJREwuVmVjKFN0YW5kYXJkUmVjb3JkKV0sXHJcbiAgICAgIFtcInF1ZXJ5XCJdXHJcbiAgICApLFxyXG4gICAgaWNyYzFfYmFsYW5jZV9vZjogSURMLkZ1bmMoW0FjY291bnRdLCBbSURMLk5hdF0sIFtcInF1ZXJ5XCJdKSxcclxuICAgIGljcmMxX2RlY2ltYWxzOiBJREwuRnVuYyhbXSwgW0lETC5OYXQ4XSwgW1wicXVlcnlcIl0pLFxyXG4gICAgaWNyYzFfZmVlOiBJREwuRnVuYyhbXSwgW0lETC5OYXRdLCBbXCJxdWVyeVwiXSksXHJcbiAgICBpY3JjMV9tZXRhZGF0YTogSURMLkZ1bmMoXHJcbiAgICAgIFtdLFxyXG4gICAgICBbSURMLlZlYyhJREwuVHVwbGUoSURMLlRleHQsIE1ldGFkYXRhVmFsdWUpKV0sXHJcbiAgICAgIFtcInF1ZXJ5XCJdXHJcbiAgICApLFxyXG4gICAgaWNyYzFfbWludGluZ19hY2NvdW50OiBJREwuRnVuYyhbXSwgW0lETC5PcHQoQWNjb3VudCldLCBbXCJxdWVyeVwiXSksXHJcbiAgICBpY3JjMV9uYW1lOiBJREwuRnVuYyhbXSwgW0lETC5UZXh0XSwgW1wicXVlcnlcIl0pLFxyXG4gICAgaWNyYzFfc3VwcG9ydGVkX3N0YW5kYXJkczogSURMLkZ1bmMoXHJcbiAgICAgIFtdLFxyXG4gICAgICBbSURMLlZlYyhTdGFuZGFyZFJlY29yZCldLFxyXG4gICAgICBbXCJxdWVyeVwiXVxyXG4gICAgKSxcclxuICAgIGljcmMxX3N5bWJvbDogSURMLkZ1bmMoW10sIFtJREwuVGV4dF0sIFtcInF1ZXJ5XCJdKSxcclxuICAgIGljcmMxX3RvdGFsX3N1cHBseTogSURMLkZ1bmMoW10sIFtJREwuTmF0XSwgW1wicXVlcnlcIl0pLFxyXG4gICAgaWNyYzFfdHJhbnNmZXI6IElETC5GdW5jKFtUcmFuc2ZlckFyZ10sIFtSZXN1bHRdLCBbXSksXHJcbiAgICBpY3JjMjFfY2FuaXN0ZXJfY2FsbF9jb25zZW50X21lc3NhZ2U6IElETC5GdW5jKFxyXG4gICAgICBbQ29uc2VudE1lc3NhZ2VSZXF1ZXN0XSxcclxuICAgICAgW1Jlc3VsdF8xXSxcclxuICAgICAgW11cclxuICAgICksXHJcbiAgICBpY3JjMl9hbGxvd2FuY2U6IElETC5GdW5jKFtBbGxvd2FuY2VBcmdzXSwgW0FsbG93YW5jZV0sIFtcInF1ZXJ5XCJdKSxcclxuICAgIGljcmMyX2FwcHJvdmU6IElETC5GdW5jKFtBcHByb3ZlQXJnc10sIFtSZXN1bHRfMl0sIFtdKSxcclxuICAgIGljcmMyX3RyYW5zZmVyX2Zyb206IElETC5GdW5jKFtUcmFuc2ZlckZyb21BcmdzXSwgW1Jlc3VsdF8zXSwgW10pLFxyXG4gICAgaWNyYzNfZ2V0X2FyY2hpdmVzOiBJREwuRnVuYyhcclxuICAgICAgW0dldEFyY2hpdmVzQXJnc10sXHJcbiAgICAgIFtJREwuVmVjKElDUkMzQXJjaGl2ZUluZm8pXSxcclxuICAgICAgW1wicXVlcnlcIl1cclxuICAgICksXHJcbiAgICBpY3JjM19nZXRfYmxvY2tzOiBJREwuRnVuYyhcclxuICAgICAgW0lETC5WZWMoR2V0QmxvY2tzUmVxdWVzdCldLFxyXG4gICAgICBbR2V0QmxvY2tzUmVzdWx0XSxcclxuICAgICAgW1wicXVlcnlcIl1cclxuICAgICksXHJcbiAgICBpY3JjM19nZXRfdGlwX2NlcnRpZmljYXRlOiBJREwuRnVuYyhcclxuICAgICAgW10sXHJcbiAgICAgIFtJREwuT3B0KElDUkMzRGF0YUNlcnRpZmljYXRlKV0sXHJcbiAgICAgIFtcInF1ZXJ5XCJdXHJcbiAgICApLFxyXG4gICAgaWNyYzNfc3VwcG9ydGVkX2Jsb2NrX3R5cGVzOiBJREwuRnVuYyhcclxuICAgICAgW10sXHJcbiAgICAgIFtJREwuVmVjKFN1cHBvcnRlZEJsb2NrVHlwZSldLFxyXG4gICAgICBbXCJxdWVyeVwiXVxyXG4gICAgKSxcclxuICB9KTtcclxufTtcclxuZXhwb3J0IGNvbnN0IGluaXQgPSAoeyBJREwgfSkgPT4ge1xyXG4gIGNvbnN0IENoYW5nZUFyY2hpdmVPcHRpb25zID0gSURMLlJlY29yZCh7XHJcbiAgICBudW1fYmxvY2tzX3RvX2FyY2hpdmU6IElETC5PcHQoSURMLk5hdDY0KSxcclxuICAgIG1heF90cmFuc2FjdGlvbnNfcGVyX3Jlc3BvbnNlOiBJREwuT3B0KElETC5OYXQ2NCksXHJcbiAgICB0cmlnZ2VyX3RocmVzaG9sZDogSURMLk9wdChJREwuTmF0NjQpLFxyXG4gICAgbW9yZV9jb250cm9sbGVyX2lkczogSURMLk9wdChJREwuVmVjKElETC5QcmluY2lwYWwpKSxcclxuICAgIG1heF9tZXNzYWdlX3NpemVfYnl0ZXM6IElETC5PcHQoSURMLk5hdDY0KSxcclxuICAgIGN5Y2xlc19mb3JfYXJjaGl2ZV9jcmVhdGlvbjogSURMLk9wdChJREwuTmF0NjQpLFxyXG4gICAgbm9kZV9tYXhfbWVtb3J5X3NpemVfYnl0ZXM6IElETC5PcHQoSURMLk5hdDY0KSxcclxuICAgIGNvbnRyb2xsZXJfaWQ6IElETC5PcHQoSURMLlByaW5jaXBhbCksXHJcbiAgfSk7XHJcbiAgY29uc3QgTWV0YWRhdGFWYWx1ZSA9IElETC5WYXJpYW50KHtcclxuICAgIEludDogSURMLkludCxcclxuICAgIE5hdDogSURMLk5hdCxcclxuICAgIEJsb2I6IElETC5WZWMoSURMLk5hdDgpLFxyXG4gICAgVGV4dDogSURMLlRleHQsXHJcbiAgfSk7XHJcbiAgY29uc3QgQWNjb3VudCA9IElETC5SZWNvcmQoe1xyXG4gICAgb3duZXI6IElETC5QcmluY2lwYWwsXHJcbiAgICBzdWJhY2NvdW50OiBJREwuT3B0KElETC5WZWMoSURMLk5hdDgpKSxcclxuICB9KTtcclxuICBjb25zdCBDaGFuZ2VGZWVDb2xsZWN0b3IgPSBJREwuVmFyaWFudCh7XHJcbiAgICBTZXRUbzogQWNjb3VudCxcclxuICAgIFVuc2V0OiBJREwuTnVsbCxcclxuICB9KTtcclxuICBjb25zdCBGZWF0dXJlRmxhZ3MgPSBJREwuUmVjb3JkKHsgaWNyYzI6IElETC5Cb29sIH0pO1xyXG4gIGNvbnN0IFVwZ3JhZGVBcmdzID0gSURMLlJlY29yZCh7XHJcbiAgICBjaGFuZ2VfYXJjaGl2ZV9vcHRpb25zOiBJREwuT3B0KENoYW5nZUFyY2hpdmVPcHRpb25zKSxcclxuICAgIHRva2VuX3N5bWJvbDogSURMLk9wdChJREwuVGV4dCksXHJcbiAgICB0cmFuc2Zlcl9mZWU6IElETC5PcHQoSURMLk5hdCksXHJcbiAgICBtZXRhZGF0YTogSURMLk9wdChJREwuVmVjKElETC5UdXBsZShJREwuVGV4dCwgTWV0YWRhdGFWYWx1ZSkpKSxcclxuICAgIG1heGltdW1fbnVtYmVyX29mX2FjY291bnRzOiBJREwuT3B0KElETC5OYXQ2NCksXHJcbiAgICBhY2NvdW50c19vdmVyZmxvd190cmltX3F1YW50aXR5OiBJREwuT3B0KElETC5OYXQ2NCksXHJcbiAgICBjaGFuZ2VfZmVlX2NvbGxlY3RvcjogSURMLk9wdChDaGFuZ2VGZWVDb2xsZWN0b3IpLFxyXG4gICAgbWF4X21lbW9fbGVuZ3RoOiBJREwuT3B0KElETC5OYXQxNiksXHJcbiAgICB0b2tlbl9uYW1lOiBJREwuT3B0KElETC5UZXh0KSxcclxuICAgIGZlYXR1cmVfZmxhZ3M6IElETC5PcHQoRmVhdHVyZUZsYWdzKSxcclxuICB9KTtcclxuICBjb25zdCBBcmNoaXZlT3B0aW9ucyA9IElETC5SZWNvcmQoe1xyXG4gICAgbnVtX2Jsb2Nrc190b19hcmNoaXZlOiBJREwuTmF0NjQsXHJcbiAgICBtYXhfdHJhbnNhY3Rpb25zX3Blcl9yZXNwb25zZTogSURMLk9wdChJREwuTmF0NjQpLFxyXG4gICAgdHJpZ2dlcl90aHJlc2hvbGQ6IElETC5OYXQ2NCxcclxuICAgIG1vcmVfY29udHJvbGxlcl9pZHM6IElETC5PcHQoSURMLlZlYyhJREwuUHJpbmNpcGFsKSksXHJcbiAgICBtYXhfbWVzc2FnZV9zaXplX2J5dGVzOiBJREwuT3B0KElETC5OYXQ2NCksXHJcbiAgICBjeWNsZXNfZm9yX2FyY2hpdmVfY3JlYXRpb246IElETC5PcHQoSURMLk5hdDY0KSxcclxuICAgIG5vZGVfbWF4X21lbW9yeV9zaXplX2J5dGVzOiBJREwuT3B0KElETC5OYXQ2NCksXHJcbiAgICBjb250cm9sbGVyX2lkOiBJREwuUHJpbmNpcGFsLFxyXG4gIH0pO1xyXG4gIGNvbnN0IEluaXRBcmdzID0gSURMLlJlY29yZCh7XHJcbiAgICBkZWNpbWFsczogSURMLk9wdChJREwuTmF0OCksXHJcbiAgICB0b2tlbl9zeW1ib2w6IElETC5UZXh0LFxyXG4gICAgdHJhbnNmZXJfZmVlOiBJREwuTmF0LFxyXG4gICAgbWV0YWRhdGE6IElETC5WZWMoSURMLlR1cGxlKElETC5UZXh0LCBNZXRhZGF0YVZhbHVlKSksXHJcbiAgICBtaW50aW5nX2FjY291bnQ6IEFjY291bnQsXHJcbiAgICBpbml0aWFsX2JhbGFuY2VzOiBJREwuVmVjKElETC5UdXBsZShBY2NvdW50LCBJREwuTmF0KSksXHJcbiAgICBtYXhpbXVtX251bWJlcl9vZl9hY2NvdW50czogSURMLk9wdChJREwuTmF0NjQpLFxyXG4gICAgYWNjb3VudHNfb3ZlcmZsb3dfdHJpbV9xdWFudGl0eTogSURMLk9wdChJREwuTmF0NjQpLFxyXG4gICAgZmVlX2NvbGxlY3Rvcl9hY2NvdW50OiBJREwuT3B0KEFjY291bnQpLFxyXG4gICAgYXJjaGl2ZV9vcHRpb25zOiBBcmNoaXZlT3B0aW9ucyxcclxuICAgIG1heF9tZW1vX2xlbmd0aDogSURMLk9wdChJREwuTmF0MTYpLFxyXG4gICAgdG9rZW5fbmFtZTogSURMLlRleHQsXHJcbiAgICBmZWF0dXJlX2ZsYWdzOiBJREwuT3B0KEZlYXR1cmVGbGFncyksXHJcbiAgfSk7XHJcbiAgY29uc3QgTGVkZ2VyQXJndW1lbnQgPSBJREwuVmFyaWFudCh7XHJcbiAgICBVcGdyYWRlOiBJREwuT3B0KFVwZ3JhZGVBcmdzKSxcclxuICAgIEluaXQ6IEluaXRBcmdzLFxyXG4gIH0pO1xyXG4gIHJldHVybiBbTGVkZ2VyQXJndW1lbnRdO1xyXG59O1xyXG4iXSwibmFtZXMiOlsiaWRsRmFjdG9yeSIsIklETCIsIkdldEJsb2Nrc1Jlc3VsdCIsIlJlYyIsIklDUkMzVmFsdWUiLCJWYWx1ZSIsIlZlYyIsIkNoYW5nZUFyY2hpdmVPcHRpb25zIiwiUmVjb3JkIiwibnVtX2Jsb2Nrc190b19hcmNoaXZlIiwiT3B0IiwiTmF0NjQiLCJtYXhfdHJhbnNhY3Rpb25zX3Blcl9yZXNwb25zZSIsInRyaWdnZXJfdGhyZXNob2xkIiwibW9yZV9jb250cm9sbGVyX2lkcyIsIlByaW5jaXBhbCIsIm1heF9tZXNzYWdlX3NpemVfYnl0ZXMiLCJjeWNsZXNfZm9yX2FyY2hpdmVfY3JlYXRpb24iLCJub2RlX21heF9tZW1vcnlfc2l6ZV9ieXRlcyIsImNvbnRyb2xsZXJfaWQiLCJNZXRhZGF0YVZhbHVlIiwiVmFyaWFudCIsIkludCIsIk5hdCIsIkJsb2IiLCJOYXQ4IiwiVGV4dCIsIkFjY291bnQiLCJvd25lciIsInN1YmFjY291bnQiLCJDaGFuZ2VGZWVDb2xsZWN0b3IiLCJTZXRUbyIsIlVuc2V0IiwiTnVsbCIsIkZlYXR1cmVGbGFncyIsImljcmMyIiwiQm9vbCIsIlVwZ3JhZGVBcmdzIiwiY2hhbmdlX2FyY2hpdmVfb3B0aW9ucyIsInRva2VuX3N5bWJvbCIsInRyYW5zZmVyX2ZlZSIsIm1ldGFkYXRhIiwiVHVwbGUiLCJtYXhpbXVtX251bWJlcl9vZl9hY2NvdW50cyIsImFjY291bnRzX292ZXJmbG93X3RyaW1fcXVhbnRpdHkiLCJjaGFuZ2VfZmVlX2NvbGxlY3RvciIsIm1heF9tZW1vX2xlbmd0aCIsIk5hdDE2IiwidG9rZW5fbmFtZSIsImZlYXR1cmVfZmxhZ3MiLCJBcmNoaXZlT3B0aW9ucyIsIkluaXRBcmdzIiwiZGVjaW1hbHMiLCJtaW50aW5nX2FjY291bnQiLCJpbml0aWFsX2JhbGFuY2VzIiwiZmVlX2NvbGxlY3Rvcl9hY2NvdW50IiwiYXJjaGl2ZV9vcHRpb25zIiwiTGVkZ2VyQXJndW1lbnQiLCJVcGdyYWRlIiwiSW5pdCIsIkFyY2hpdmVJbmZvIiwiYmxvY2tfcmFuZ2VfZW5kIiwiY2FuaXN0ZXJfaWQiLCJibG9ja19yYW5nZV9zdGFydCIsIkdldEJsb2Nrc1JlcXVlc3QiLCJzdGFydCIsImxlbmd0aCIsImZpbGwiLCJNYXAiLCJBcnJheSIsIkJsb2NrUmFuZ2UiLCJibG9ja3MiLCJBcmNoaXZlZFJhbmdlIiwiY2FsbGJhY2siLCJGdW5jIiwiR2V0QmxvY2tzUmVzcG9uc2UiLCJjZXJ0aWZpY2F0ZSIsImZpcnN0X2luZGV4IiwiY2hhaW5fbGVuZ3RoIiwiYXJjaGl2ZWRfYmxvY2tzIiwiRGF0YUNlcnRpZmljYXRlIiwiaGFzaF90cmVlIiwiQnVybiIsImZyb20iLCJtZW1vIiwiY3JlYXRlZF9hdF90aW1lIiwiYW1vdW50Iiwic3BlbmRlciIsIk1pbnQiLCJ0byIsIkFwcHJvdmUiLCJmZWUiLCJleHBlY3RlZF9hbGxvd2FuY2UiLCJleHBpcmVzX2F0IiwiVHJhbnNmZXIiLCJUcmFuc2FjdGlvbiIsImJ1cm4iLCJraW5kIiwibWludCIsImFwcHJvdmUiLCJ0aW1lc3RhbXAiLCJ0cmFuc2ZlciIsIlRyYW5zYWN0aW9uUmFuZ2UiLCJ0cmFuc2FjdGlvbnMiLCJBcmNoaXZlZFJhbmdlXzEiLCJHZXRUcmFuc2FjdGlvbnNSZXNwb25zZSIsImxvZ19sZW5ndGgiLCJhcmNoaXZlZF90cmFuc2FjdGlvbnMiLCJTdGFuZGFyZFJlY29yZCIsInVybCIsIm5hbWUiLCJUcmFuc2ZlckFyZyIsImZyb21fc3ViYWNjb3VudCIsIlRyYW5zZmVyRXJyb3IiLCJHZW5lcmljRXJyb3IiLCJtZXNzYWdlIiwiZXJyb3JfY29kZSIsIlRlbXBvcmFyaWx5VW5hdmFpbGFibGUiLCJCYWRCdXJuIiwibWluX2J1cm5fYW1vdW50IiwiRHVwbGljYXRlIiwiZHVwbGljYXRlX29mIiwiQmFkRmVlIiwiZXhwZWN0ZWRfZmVlIiwiQ3JlYXRlZEluRnV0dXJlIiwibGVkZ2VyX3RpbWUiLCJUb29PbGQiLCJJbnN1ZmZpY2llbnRGdW5kcyIsImJhbGFuY2UiLCJSZXN1bHQiLCJPayIsIkVyciIsIkNvbnNlbnRNZXNzYWdlTWV0YWRhdGEiLCJ1dGNfb2Zmc2V0X21pbnV0ZXMiLCJJbnQxNiIsImxhbmd1YWdlIiwiRGlzcGxheU1lc3NhZ2VUeXBlIiwiR2VuZXJpY0Rpc3BsYXkiLCJMaW5lRGlzcGxheSIsImNoYXJhY3RlcnNfcGVyX2xpbmUiLCJsaW5lc19wZXJfcGFnZSIsIkNvbnNlbnRNZXNzYWdlU3BlYyIsImRldmljZV9zcGVjIiwiQ29uc2VudE1lc3NhZ2VSZXF1ZXN0IiwiYXJnIiwibWV0aG9kIiwidXNlcl9wcmVmZXJlbmNlcyIsIkxpbmVEaXNwbGF5UGFnZSIsImxpbmVzIiwiQ29uc2VudE1lc3NhZ2UiLCJMaW5lRGlzcGxheU1lc3NhZ2UiLCJwYWdlcyIsIkdlbmVyaWNEaXNwbGF5TWVzc2FnZSIsIkNvbnNlbnRJbmZvIiwiY29uc2VudF9tZXNzYWdlIiwiRXJyb3JJbmZvIiwiZGVzY3JpcHRpb24iLCJJY3JjMjFFcnJvciIsIkluc3VmZmljaWVudFBheW1lbnQiLCJVbnN1cHBvcnRlZENhbmlzdGVyQ2FsbCIsIkNvbnNlbnRNZXNzYWdlVW5hdmFpbGFibGUiLCJSZXN1bHRfMSIsIkFsbG93YW5jZUFyZ3MiLCJhY2NvdW50IiwiQWxsb3dhbmNlIiwiYWxsb3dhbmNlIiwiQXBwcm92ZUFyZ3MiLCJBcHByb3ZlRXJyb3IiLCJBbGxvd2FuY2VDaGFuZ2VkIiwiY3VycmVudF9hbGxvd2FuY2UiLCJFeHBpcmVkIiwiUmVzdWx0XzIiLCJUcmFuc2ZlckZyb21BcmdzIiwic3BlbmRlcl9zdWJhY2NvdW50IiwiVHJhbnNmZXJGcm9tRXJyb3IiLCJJbnN1ZmZpY2llbnRBbGxvd2FuY2UiLCJSZXN1bHRfMyIsIkdldEFyY2hpdmVzQXJncyIsIklDUkMzQXJjaGl2ZUluZm8iLCJlbmQiLCJCbG9ja1dpdGhJZCIsImlkIiwiYmxvY2siLCJBcmNoaXZlZEJsb2NrcyIsImFyZ3MiLCJJQ1JDM0RhdGFDZXJ0aWZpY2F0ZSIsIlN1cHBvcnRlZEJsb2NrVHlwZSIsImJsb2NrX3R5cGUiLCJTZXJ2aWNlIiwiYXJjaGl2ZXMiLCJnZXRfYmxvY2tzIiwiZ2V0X2RhdGFfY2VydGlmaWNhdGUiLCJnZXRfdHJhbnNhY3Rpb25zIiwiaWNyYzEwX3N1cHBvcnRlZF9zdGFuZGFyZHMiLCJpY3JjMV9iYWxhbmNlX29mIiwiaWNyYzFfZGVjaW1hbHMiLCJpY3JjMV9mZWUiLCJpY3JjMV9tZXRhZGF0YSIsImljcmMxX21pbnRpbmdfYWNjb3VudCIsImljcmMxX25hbWUiLCJpY3JjMV9zdXBwb3J0ZWRfc3RhbmRhcmRzIiwiaWNyYzFfc3ltYm9sIiwiaWNyYzFfdG90YWxfc3VwcGx5IiwiaWNyYzFfdHJhbnNmZXIiLCJpY3JjMjFfY2FuaXN0ZXJfY2FsbF9jb25zZW50X21lc3NhZ2UiLCJpY3JjMl9hbGxvd2FuY2UiLCJpY3JjMl9hcHByb3ZlIiwiaWNyYzJfdHJhbnNmZXJfZnJvbSIsImljcmMzX2dldF9hcmNoaXZlcyIsImljcmMzX2dldF9ibG9ja3MiLCJpY3JjM19nZXRfdGlwX2NlcnRpZmljYXRlIiwiaWNyYzNfc3VwcG9ydGVkX2Jsb2NrX3R5cGVzIiwiaW5pdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/data/canisters/ledger/did.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/hooks/useTokenMetrics.ts":
/*!**************************************!*\
  !*** ./src/hooks/useTokenMetrics.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchTokenMetrics: function() { return /* binding */ fetchTokenMetrics; },\n/* harmony export */   useTokenMetrics: function() { return /* binding */ useTokenMetrics; }\n/* harmony export */ });\n/* harmony import */ var _tanstack_react_query__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tanstack/react-query */ \"(app-pages-browser)/../../node_modules/@tanstack/react-query/build/modern/useQuery.js\");\n/* harmony import */ var _dfinity_agent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/agent */ \"(app-pages-browser)/./node_modules/@dfinity/agent/lib/esm/index.js\");\n/* harmony import */ var _data_canisters_gold_did__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../data/canisters/gold/did */ \"(app-pages-browser)/./src/data/canisters/gold/did.js\");\n/* harmony import */ var _data_canisters_ledger_did__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../data/canisters/ledger/did */ \"(app-pages-browser)/./src/data/canisters/ledger/did.js\");\n/* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @dfinity/principal */ \"(app-pages-browser)/./node_modules/@dfinity/principal/lib/esm/index.js\");\n\n\n\n\n\nconst goldTokenCanisters = {\n    \"1g\": {\n        canisterId: \"obapm-2iaaa-aaaak-qcgca-cai\",\n        weightInGrams: BigInt(1)\n    },\n    \"10g\": {\n        canisterId: \"xyo2o-gyaaa-aaaal-qb55a-cai\",\n        weightInGrams: BigInt(10)\n    },\n    \"100g\": {\n        canisterId: \"zhfjc-liaaa-aaaal-acgja-cai\",\n        weightInGrams: BigInt(100)\n    },\n    \"1kg\": {\n        canisterId: \"7i7jl-6qaaa-aaaam-abjma-cai\",\n        weightInGrams: BigInt(1000)\n    }\n};\nconst swapCanisterId = \"m45be-jaaaa-aaaak-qcgnq-cai\";\nconst gldtLedgerCanisterId = \"6uad6-fqaaa-aaaam-abovq-cai\";\nconst fetchTokenMetrics = async ()=>{\n    try {\n        const agent = new _dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.HttpAgent({\n            host: \"https://ic0.app\"\n        });\n        const swapCanisterPrincipal = _dfinity_principal__WEBPACK_IMPORTED_MODULE_3__.Principal.fromText(swapCanisterId);\n        const response = await fetch(\"https://teiwz-pqaaa-aaaap-ag7hq-cai.raw.icp0.io/gold_nft_metrics\");\n        if (!response.ok) {\n            throw new Error(\"Failed to fetch gold price\");\n        }\n        const data = await response.json();\n        const gold_price = parseFloat(data.gold_price);\n        console.log(\"Gold price:\", gold_price);\n        let total_gold_grams = BigInt(0);\n        for (const { canisterId, weightInGrams } of Object.values(goldTokenCanisters)){\n            const actor = _dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.Actor.createActor(_data_canisters_gold_did__WEBPACK_IMPORTED_MODULE_1__.idlFactory, {\n                agent,\n                canisterId\n            });\n            const account = {\n                account: {\n                    owner: swapCanisterPrincipal,\n                    sub_account: []\n                }\n            };\n            const accounts = [\n                account\n            ];\n            const balances = await actor.icrc7_balance_of(accounts);\n            for (const balance of balances){\n                total_gold_grams += balance * weightInGrams;\n            }\n        }\n        const total_gold_kg = Number(total_gold_grams) / 1000;\n        const ledgerActor = _dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.Actor.createActor(_data_canisters_ledger_did__WEBPACK_IMPORTED_MODULE_2__.idlFactory, {\n            agent,\n            canisterId: gldtLedgerCanisterId\n        });\n        const totalSupply = await ledgerActor.icrc1_total_supply();\n        const totalSupplyTokens = Number(totalSupply) / 1e8;\n        const tvl = totalSupplyTokens * gold_price;\n        return {\n            gold_price,\n            total_gold_grams: total_gold_grams.toString(),\n            total_gold_kg,\n            tvl\n        };\n    } catch (error) {\n        console.error(\"Error fetching token metrics:\", error);\n        throw error;\n    }\n};\nconst useTokenMetrics = ()=>{\n    return (0,_tanstack_react_query__WEBPACK_IMPORTED_MODULE_4__.useQuery)({\n        queryKey: [\n            \"tokenMetrics\"\n        ],\n        queryFn: fetchTokenMetrics,\n        staleTime: 5 * 60 * 1000,\n        refetchOnWindowFocus: false\n    });\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VUb2tlbk1ldHJpY3MudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFpRDtBQUNDO0FBQ3lCO0FBQ0U7QUFDOUI7QUFHL0MsTUFBTU8scUJBQXFCO0lBQ3pCLE1BQU07UUFDSkMsWUFBWUMsNkJBQW1DO1FBQy9DRyxlQUFlQyxPQUFPO0lBQ3hCO0lBQ0EsT0FBTztRQUNMTCxZQUFZQyw2QkFBb0M7UUFDaERHLGVBQWVDLE9BQU87SUFDeEI7SUFDQSxRQUFRO1FBQ05MLFlBQVlDLDZCQUFxQztRQUNqREcsZUFBZUMsT0FBTztJQUN4QjtJQUNBLE9BQU87UUFDTEwsWUFBWUMsNkJBQW9DO1FBQ2hERyxlQUFlQyxPQUFPO0lBQ3hCO0FBQ0Y7QUFFQSxNQUFNSSxpQkFBaUJSLDZCQUF3QztBQUMvRCxNQUFNVSx1QkFBdUJWLDZCQUErQztBQVNyRSxNQUFNWSxvQkFBb0I7SUFDL0IsSUFBSTtRQUNGLE1BQU1DLFFBQVEsSUFBSXBCLHFEQUFTQSxDQUFDO1lBQUVxQixNQUFNO1FBQWtCO1FBQ3RELE1BQU1DLHdCQUF3QmxCLHlEQUFTQSxDQUFDbUIsUUFBUSxDQUFDUjtRQUVqRCxNQUFNUyxXQUFXLE1BQU1DLE1BQ3JCO1FBRUYsSUFBSSxDQUFDRCxTQUFTRSxFQUFFLEVBQUU7WUFDaEIsTUFBTSxJQUFJQyxNQUFNO1FBQ2xCO1FBQ0EsTUFBTUMsT0FBTyxNQUFNSixTQUFTSyxJQUFJO1FBQ2hDLE1BQU1DLGFBQWFDLFdBQVdILEtBQUtFLFVBQVU7UUFFN0NFLFFBQVFDLEdBQUcsQ0FBQyxlQUFlSDtRQUUzQixJQUFJSSxtQkFBbUJ2QixPQUFPO1FBRTlCLEtBQUssTUFBTSxFQUFFTCxVQUFVLEVBQUVJLGFBQWEsRUFBRSxJQUFJeUIsT0FBT0MsTUFBTSxDQUN2RC9CLG9CQUNDO1lBQ0QsTUFBTWdDLFFBQVF0QyxpREFBS0EsQ0FBQ3VDLFdBQVcsQ0FBQ3BDLGdFQUFlQSxFQUFFO2dCQUMvQ2tCO2dCQUNBZDtZQUNGO1lBRUEsTUFBTWlDLFVBQW1CO2dCQUN2QkEsU0FBUztvQkFDUEMsT0FBT2xCO29CQUNQbUIsYUFBYSxFQUFFO2dCQUNqQjtZQUNGO1lBRUEsTUFBTUMsV0FBc0I7Z0JBQUNIO2FBQVE7WUFFckMsTUFBTUksV0FBWSxNQUFNTixNQUFNTyxnQkFBZ0IsQ0FBQ0Y7WUFFL0MsS0FBSyxNQUFNRyxXQUFXRixTQUFVO2dCQUM5QlQsb0JBQW9CVyxVQUFVbkM7WUFDaEM7UUFDRjtRQUVBLE1BQU1vQyxnQkFBZ0JDLE9BQU9iLG9CQUFvQjtRQUVqRCxNQUFNYyxjQUFjakQsaURBQUtBLENBQUN1QyxXQUFXLENBQUNuQyxrRUFBZUEsRUFBRTtZQUNyRGlCO1lBQ0FkLFlBQVlXO1FBQ2Q7UUFFQSxNQUFNZ0MsY0FBZSxNQUFNRCxZQUFZRSxrQkFBa0I7UUFDekQsTUFBTUMsb0JBQW9CSixPQUFPRSxlQUFlO1FBRWhELE1BQU1HLE1BQU1ELG9CQUFvQnJCO1FBRWhDLE9BQU87WUFDTEE7WUFDQUksa0JBQWtCQSxpQkFBaUJtQixRQUFRO1lBQzNDUDtZQUNBTTtRQUNGO0lBQ0YsRUFBRSxPQUFPRSxPQUFPO1FBQ2R0QixRQUFRc0IsS0FBSyxDQUFDLGlDQUFpQ0E7UUFDL0MsTUFBTUE7SUFDUjtBQUNGLEVBQUU7QUFFSyxNQUFNQyxrQkFBa0I7SUFDN0IsT0FBT3pELCtEQUFRQSxDQUFlO1FBQzVCMEQsVUFBVTtZQUFDO1NBQWU7UUFDMUJDLFNBQVN0QztRQUNUdUMsV0FBVyxJQUFJLEtBQUs7UUFDcEJDLHNCQUFzQjtJQUN4QjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2hvb2tzL3VzZVRva2VuTWV0cmljcy50cz8wYWU3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVF1ZXJ5IH0gZnJvbSBcIkB0YW5zdGFjay9yZWFjdC1xdWVyeVwiO1xyXG5pbXBvcnQgeyBBY3RvciwgSHR0cEFnZW50IH0gZnJvbSBcIkBkZmluaXR5L2FnZW50XCI7XHJcbmltcG9ydCB7IGlkbEZhY3RvcnkgYXMgaWNyYzdJZGxGYWN0b3J5IH0gZnJvbSBcIi4uL2RhdGEvY2FuaXN0ZXJzL2dvbGQvZGlkXCI7XHJcbmltcG9ydCB7IGlkbEZhY3RvcnkgYXMgaWNyYzFJZGxGYWN0b3J5IH0gZnJvbSBcIi4uL2RhdGEvY2FuaXN0ZXJzL2xlZGdlci9kaWRcIjtcclxuaW1wb3J0IHsgUHJpbmNpcGFsIH0gZnJvbSBcIkBkZmluaXR5L3ByaW5jaXBhbFwiO1xyXG5pbXBvcnQgeyBBY2NvdW50IH0gZnJvbSBcIi4uL2RhdGEvY2FuaXN0ZXJzL2dvbGQvaW50ZXJmYWNlcy9nbGRfbmZ0XCI7XHJcblxyXG5jb25zdCBnb2xkVG9rZW5DYW5pc3RlcnMgPSB7XHJcbiAgXCIxZ1wiOiB7XHJcbiAgICBjYW5pc3RlcklkOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19DQU5JU1RFUl8xRyEsXHJcbiAgICB3ZWlnaHRJbkdyYW1zOiBCaWdJbnQoMSksXHJcbiAgfSxcclxuICBcIjEwZ1wiOiB7XHJcbiAgICBjYW5pc3RlcklkOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19DQU5JU1RFUl8xMEchLFxyXG4gICAgd2VpZ2h0SW5HcmFtczogQmlnSW50KDEwKSxcclxuICB9LFxyXG4gIFwiMTAwZ1wiOiB7XHJcbiAgICBjYW5pc3RlcklkOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19DQU5JU1RFUl8xMDBHISxcclxuICAgIHdlaWdodEluR3JhbXM6IEJpZ0ludCgxMDApLFxyXG4gIH0sXHJcbiAgXCIxa2dcIjoge1xyXG4gICAgY2FuaXN0ZXJJZDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQ0FOSVNURVJfMUtHISxcclxuICAgIHdlaWdodEluR3JhbXM6IEJpZ0ludCgxMDAwKSxcclxuICB9LFxyXG59O1xyXG5cclxuY29uc3Qgc3dhcENhbmlzdGVySWQgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TV0FQX0NBTklTVEVSX0lEITtcclxuY29uc3QgZ2xkdExlZGdlckNhbmlzdGVySWQgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19HTERUX0xFREdFUl9DQU5JU1RFUl9JRCE7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFRva2VuTWV0cmljcyB7XHJcbiAgZ29sZF9wcmljZTogbnVtYmVyO1xyXG4gIHRvdGFsX2dvbGRfZ3JhbXM6IHN0cmluZztcclxuICB0b3RhbF9nb2xkX2tnOiBudW1iZXI7XHJcbiAgdHZsOiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBmZXRjaFRva2VuTWV0cmljcyA9IGFzeW5jICgpOiBQcm9taXNlPFRva2VuTWV0cmljcz4gPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBhZ2VudCA9IG5ldyBIdHRwQWdlbnQoeyBob3N0OiBcImh0dHBzOi8vaWMwLmFwcFwiIH0pO1xyXG4gICAgY29uc3Qgc3dhcENhbmlzdGVyUHJpbmNpcGFsID0gUHJpbmNpcGFsLmZyb21UZXh0KHN3YXBDYW5pc3RlcklkKTtcclxuXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxyXG4gICAgICBcImh0dHBzOi8vdGVpd3otcHFhYWEtYWFhYXAtYWc3aHEtY2FpLnJhdy5pY3AwLmlvL2dvbGRfbmZ0X21ldHJpY3NcIlxyXG4gICAgKTtcclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGZldGNoIGdvbGQgcHJpY2VcIik7XHJcbiAgICB9XHJcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgY29uc3QgZ29sZF9wcmljZSA9IHBhcnNlRmxvYXQoZGF0YS5nb2xkX3ByaWNlKTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIkdvbGQgcHJpY2U6XCIsIGdvbGRfcHJpY2UpO1xyXG5cclxuICAgIGxldCB0b3RhbF9nb2xkX2dyYW1zID0gQmlnSW50KDApO1xyXG5cclxuICAgIGZvciAoY29uc3QgeyBjYW5pc3RlcklkLCB3ZWlnaHRJbkdyYW1zIH0gb2YgT2JqZWN0LnZhbHVlcyhcclxuICAgICAgZ29sZFRva2VuQ2FuaXN0ZXJzXHJcbiAgICApKSB7XHJcbiAgICAgIGNvbnN0IGFjdG9yID0gQWN0b3IuY3JlYXRlQWN0b3IoaWNyYzdJZGxGYWN0b3J5LCB7XHJcbiAgICAgICAgYWdlbnQsXHJcbiAgICAgICAgY2FuaXN0ZXJJZCxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zdCBhY2NvdW50OiBBY2NvdW50ID0ge1xyXG4gICAgICAgIGFjY291bnQ6IHtcclxuICAgICAgICAgIG93bmVyOiBzd2FwQ2FuaXN0ZXJQcmluY2lwYWwsXHJcbiAgICAgICAgICBzdWJfYWNjb3VudDogW10sXHJcbiAgICAgICAgfSxcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGNvbnN0IGFjY291bnRzOiBBY2NvdW50W10gPSBbYWNjb3VudF07XHJcblxyXG4gICAgICBjb25zdCBiYWxhbmNlcyA9IChhd2FpdCBhY3Rvci5pY3JjN19iYWxhbmNlX29mKGFjY291bnRzKSkgYXMgYmlnaW50W107XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IGJhbGFuY2Ugb2YgYmFsYW5jZXMpIHtcclxuICAgICAgICB0b3RhbF9nb2xkX2dyYW1zICs9IGJhbGFuY2UgKiB3ZWlnaHRJbkdyYW1zO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdG90YWxfZ29sZF9rZyA9IE51bWJlcih0b3RhbF9nb2xkX2dyYW1zKSAvIDEwMDA7XHJcblxyXG4gICAgY29uc3QgbGVkZ2VyQWN0b3IgPSBBY3Rvci5jcmVhdGVBY3RvcihpY3JjMUlkbEZhY3RvcnksIHtcclxuICAgICAgYWdlbnQsXHJcbiAgICAgIGNhbmlzdGVySWQ6IGdsZHRMZWRnZXJDYW5pc3RlcklkLFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgdG90YWxTdXBwbHkgPSAoYXdhaXQgbGVkZ2VyQWN0b3IuaWNyYzFfdG90YWxfc3VwcGx5KCkpIGFzIGJpZ2ludDtcclxuICAgIGNvbnN0IHRvdGFsU3VwcGx5VG9rZW5zID0gTnVtYmVyKHRvdGFsU3VwcGx5KSAvIDFlODtcclxuXHJcbiAgICBjb25zdCB0dmwgPSB0b3RhbFN1cHBseVRva2VucyAqIGdvbGRfcHJpY2U7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZ29sZF9wcmljZSxcclxuICAgICAgdG90YWxfZ29sZF9ncmFtczogdG90YWxfZ29sZF9ncmFtcy50b1N0cmluZygpLFxyXG4gICAgICB0b3RhbF9nb2xkX2tnLFxyXG4gICAgICB0dmwsXHJcbiAgICB9O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgdG9rZW4gbWV0cmljczpcIiwgZXJyb3IpO1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHVzZVRva2VuTWV0cmljcyA9ICgpID0+IHtcclxuICByZXR1cm4gdXNlUXVlcnk8VG9rZW5NZXRyaWNzPih7XHJcbiAgICBxdWVyeUtleTogW1widG9rZW5NZXRyaWNzXCJdLFxyXG4gICAgcXVlcnlGbjogZmV0Y2hUb2tlbk1ldHJpY3MsXHJcbiAgICBzdGFsZVRpbWU6IDUgKiA2MCAqIDEwMDAsXHJcbiAgICByZWZldGNoT25XaW5kb3dGb2N1czogZmFsc2UsXHJcbiAgfSk7XHJcbn07XHJcbiJdLCJuYW1lcyI6WyJ1c2VRdWVyeSIsIkFjdG9yIiwiSHR0cEFnZW50IiwiaWRsRmFjdG9yeSIsImljcmM3SWRsRmFjdG9yeSIsImljcmMxSWRsRmFjdG9yeSIsIlByaW5jaXBhbCIsImdvbGRUb2tlbkNhbmlzdGVycyIsImNhbmlzdGVySWQiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQ0FOSVNURVJfMUciLCJ3ZWlnaHRJbkdyYW1zIiwiQmlnSW50IiwiTkVYVF9QVUJMSUNfQ0FOSVNURVJfMTBHIiwiTkVYVF9QVUJMSUNfQ0FOSVNURVJfMTAwRyIsIk5FWFRfUFVCTElDX0NBTklTVEVSXzFLRyIsInN3YXBDYW5pc3RlcklkIiwiTkVYVF9QVUJMSUNfU1dBUF9DQU5JU1RFUl9JRCIsImdsZHRMZWRnZXJDYW5pc3RlcklkIiwiTkVYVF9QVUJMSUNfR0xEVF9MRURHRVJfQ0FOSVNURVJfSUQiLCJmZXRjaFRva2VuTWV0cmljcyIsImFnZW50IiwiaG9zdCIsInN3YXBDYW5pc3RlclByaW5jaXBhbCIsImZyb21UZXh0IiwicmVzcG9uc2UiLCJmZXRjaCIsIm9rIiwiRXJyb3IiLCJkYXRhIiwianNvbiIsImdvbGRfcHJpY2UiLCJwYXJzZUZsb2F0IiwiY29uc29sZSIsImxvZyIsInRvdGFsX2dvbGRfZ3JhbXMiLCJPYmplY3QiLCJ2YWx1ZXMiLCJhY3RvciIsImNyZWF0ZUFjdG9yIiwiYWNjb3VudCIsIm93bmVyIiwic3ViX2FjY291bnQiLCJhY2NvdW50cyIsImJhbGFuY2VzIiwiaWNyYzdfYmFsYW5jZV9vZiIsImJhbGFuY2UiLCJ0b3RhbF9nb2xkX2tnIiwiTnVtYmVyIiwibGVkZ2VyQWN0b3IiLCJ0b3RhbFN1cHBseSIsImljcmMxX3RvdGFsX3N1cHBseSIsInRvdGFsU3VwcGx5VG9rZW5zIiwidHZsIiwidG9TdHJpbmciLCJlcnJvciIsInVzZVRva2VuTWV0cmljcyIsInF1ZXJ5S2V5IiwicXVlcnlGbiIsInN0YWxlVGltZSIsInJlZmV0Y2hPbldpbmRvd0ZvY3VzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useTokenMetrics.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/bls.js":
/*!************************************************************!*\
  !*** ../../node_modules/@noble/curves/esm/abstract/bls.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bls: function() { return /* binding */ bls; }\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _hash_to_curve_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./hash-to-curve.js */ \"(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _weierstrass_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./weierstrass.js */ \"(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n\n\n// prettier-ignore\n\n\n// prettier-ignore\nconst _2n = BigInt(2), _3n = BigInt(3);\nfunction bls(CURVE) {\n    // Fields are specific for curve, so for now we'll need to pass them with opts\n    const { Fp, Fr, Fp2, Fp6, Fp12 } = CURVE.fields;\n    const BLS_X_LEN = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitLen)(CURVE.params.x);\n    // Pre-compute coefficients for sparse multiplication\n    // Point addition and point double calculations is reused for coefficients\n    function calcPairingPrecomputes(p) {\n        const { x, y } = p;\n        // prettier-ignore\n        const Qx = x, Qy = y, Qz = Fp2.ONE;\n        // prettier-ignore\n        let Rx = Qx, Ry = Qy, Rz = Qz;\n        let ell_coeff = [];\n        for (let i = BLS_X_LEN - 2; i >= 0; i--) {\n            // Double\n            let t0 = Fp2.sqr(Ry); // Ry\n            let t1 = Fp2.sqr(Rz); // Rz\n            let t2 = Fp2.multiplyByB(Fp2.mul(t1, _3n)); // 3 * T1 * B\n            let t3 = Fp2.mul(t2, _3n); // 3 * T2\n            let t4 = Fp2.sub(Fp2.sub(Fp2.sqr(Fp2.add(Ry, Rz)), t1), t0); // (Ry + Rz) - T1 - T0\n            ell_coeff.push([\n                Fp2.sub(t2, t0), // T2 - T0\n                Fp2.mul(Fp2.sqr(Rx), _3n), // 3 * Rx\n                Fp2.neg(t4), // -T4\n            ]);\n            Rx = Fp2.div(Fp2.mul(Fp2.mul(Fp2.sub(t0, t3), Rx), Ry), _2n); // ((T0 - T3) * Rx * Ry) / 2\n            Ry = Fp2.sub(Fp2.sqr(Fp2.div(Fp2.add(t0, t3), _2n)), Fp2.mul(Fp2.sqr(t2), _3n)); // ((T0 + T3) / 2) - 3 * T2\n            Rz = Fp2.mul(t0, t4); // T0 * T4\n            if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitGet)(CURVE.params.x, i)) {\n                // Addition\n                let t0 = Fp2.sub(Ry, Fp2.mul(Qy, Rz)); // Ry - Qy * Rz\n                let t1 = Fp2.sub(Rx, Fp2.mul(Qx, Rz)); // Rx - Qx * Rz\n                ell_coeff.push([\n                    Fp2.sub(Fp2.mul(t0, Qx), Fp2.mul(t1, Qy)), // T0 * Qx - T1 * Qy\n                    Fp2.neg(t0), // -T0\n                    t1, // T1\n                ]);\n                let t2 = Fp2.sqr(t1); // T1\n                let t3 = Fp2.mul(t2, t1); // T2 * T1\n                let t4 = Fp2.mul(t2, Rx); // T2 * Rx\n                let t5 = Fp2.add(Fp2.sub(t3, Fp2.mul(t4, _2n)), Fp2.mul(Fp2.sqr(t0), Rz)); // T3 - 2 * T4 + T0 * Rz\n                Rx = Fp2.mul(t1, t5); // T1 * T5\n                Ry = Fp2.sub(Fp2.mul(Fp2.sub(t4, t5), t0), Fp2.mul(t3, Ry)); // (T4 - T5) * T0 - T3 * Ry\n                Rz = Fp2.mul(Rz, t3); // Rz * T3\n            }\n        }\n        return ell_coeff;\n    }\n    function millerLoop(ell, g1) {\n        const { x } = CURVE.params;\n        const Px = g1[0];\n        const Py = g1[1];\n        let f12 = Fp12.ONE;\n        for (let j = 0, i = BLS_X_LEN - 2; i >= 0; i--, j++) {\n            const E = ell[j];\n            f12 = Fp12.multiplyBy014(f12, E[0], Fp2.mul(E[1], Px), Fp2.mul(E[2], Py));\n            if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitGet)(x, i)) {\n                j += 1;\n                const F = ell[j];\n                f12 = Fp12.multiplyBy014(f12, F[0], Fp2.mul(F[1], Px), Fp2.mul(F[2], Py));\n            }\n            if (i !== 0)\n                f12 = Fp12.sqr(f12);\n        }\n        return Fp12.conjugate(f12);\n    }\n    const utils = {\n        randomPrivateKey: () => {\n            const length = (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.getMinHashLength)(Fr.ORDER);\n            return (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mapHashToField)(CURVE.randomBytes(length), Fr.ORDER);\n        },\n        calcPairingPrecomputes,\n    };\n    // Point on G1 curve: (x, y)\n    const G1_ = (0,_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__.weierstrassPoints)({ n: Fr.ORDER, ...CURVE.G1 });\n    const G1 = Object.assign(G1_, (0,_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_3__.createHasher)(G1_.ProjectivePoint, CURVE.G1.mapToCurve, {\n        ...CURVE.htfDefaults,\n        ...CURVE.G1.htfDefaults,\n    }));\n    function pairingPrecomputes(point) {\n        const p = point;\n        if (p._PPRECOMPUTES)\n            return p._PPRECOMPUTES;\n        p._PPRECOMPUTES = calcPairingPrecomputes(point.toAffine());\n        return p._PPRECOMPUTES;\n    }\n    // TODO: export\n    // function clearPairingPrecomputes(point: G2) {\n    //   const p = point as G2 & withPairingPrecomputes;\n    //   p._PPRECOMPUTES = undefined;\n    // }\n    // Point on G2 curve (complex numbers): (x, x+i), (y, y+i)\n    const G2_ = (0,_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__.weierstrassPoints)({ n: Fr.ORDER, ...CURVE.G2 });\n    const G2 = Object.assign(G2_, (0,_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_3__.createHasher)(G2_.ProjectivePoint, CURVE.G2.mapToCurve, {\n        ...CURVE.htfDefaults,\n        ...CURVE.G2.htfDefaults,\n    }));\n    const { ShortSignature } = CURVE.G1;\n    const { Signature } = CURVE.G2;\n    // Calculates bilinear pairing\n    function pairing(Q, P, withFinalExponent = true) {\n        if (Q.equals(G1.ProjectivePoint.ZERO) || P.equals(G2.ProjectivePoint.ZERO))\n            throw new Error('pairing is not available for ZERO point');\n        Q.assertValidity();\n        P.assertValidity();\n        // Performance: 9ms for millerLoop and ~14ms for exp.\n        const Qa = Q.toAffine();\n        const looped = millerLoop(pairingPrecomputes(P), [Qa.x, Qa.y]);\n        return withFinalExponent ? Fp12.finalExponentiate(looped) : looped;\n    }\n    function normP1(point) {\n        return point instanceof G1.ProjectivePoint ? point : G1.ProjectivePoint.fromHex(point);\n    }\n    function normP1Hash(point, htfOpts) {\n        return point instanceof G1.ProjectivePoint\n            ? point\n            : G1.hashToCurve((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('point', point), htfOpts);\n    }\n    function normP2(point) {\n        return point instanceof G2.ProjectivePoint ? point : Signature.fromHex(point);\n    }\n    function normP2Hash(point, htfOpts) {\n        return point instanceof G2.ProjectivePoint\n            ? point\n            : G2.hashToCurve((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('point', point), htfOpts);\n    }\n    // Multiplies generator (G1) by private key.\n    // P = pk x G\n    function getPublicKey(privateKey) {\n        return G1.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(true);\n    }\n    // Multiplies generator (G2) by private key.\n    // P = pk x G\n    function getPublicKeyForShortSignatures(privateKey) {\n        return G2.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(true);\n    }\n    function sign(message, privateKey, htfOpts) {\n        const msgPoint = normP2Hash(message, htfOpts);\n        msgPoint.assertValidity();\n        const sigPoint = msgPoint.multiply(G1.normPrivateKeyToScalar(privateKey));\n        if (message instanceof G2.ProjectivePoint)\n            return sigPoint;\n        return Signature.toRawBytes(sigPoint);\n    }\n    function signShortSignature(message, privateKey, htfOpts) {\n        const msgPoint = normP1Hash(message, htfOpts);\n        msgPoint.assertValidity();\n        const sigPoint = msgPoint.multiply(G1.normPrivateKeyToScalar(privateKey));\n        if (message instanceof G1.ProjectivePoint)\n            return sigPoint;\n        return ShortSignature.toRawBytes(sigPoint);\n    }\n    // Checks if pairing of public key & hash is equal to pairing of generator & signature.\n    // e(P, H(m)) == e(G, S)\n    function verify(signature, message, publicKey, htfOpts) {\n        const P = normP1(publicKey);\n        const Hm = normP2Hash(message, htfOpts);\n        const G = G1.ProjectivePoint.BASE;\n        const S = normP2(signature);\n        // Instead of doing 2 exponentiations, we use property of billinear maps\n        // and do one exp after multiplying 2 points.\n        const ePHm = pairing(P.negate(), Hm, false);\n        const eGS = pairing(G, S, false);\n        const exp = Fp12.finalExponentiate(Fp12.mul(eGS, ePHm));\n        return Fp12.eql(exp, Fp12.ONE);\n    }\n    // Checks if pairing of public key & hash is equal to pairing of generator & signature.\n    // e(S, G) == e(H(m), P)\n    function verifyShortSignature(signature, message, publicKey, htfOpts) {\n        const P = normP2(publicKey);\n        const Hm = normP1Hash(message, htfOpts);\n        const G = G2.ProjectivePoint.BASE;\n        const S = normP1(signature);\n        // Instead of doing 2 exponentiations, we use property of billinear maps\n        // and do one exp after multiplying 2 points.\n        const eHmP = pairing(Hm, P, false);\n        const eSG = pairing(S, G.negate(), false);\n        const exp = Fp12.finalExponentiate(Fp12.mul(eSG, eHmP));\n        return Fp12.eql(exp, Fp12.ONE);\n    }\n    function aggregatePublicKeys(publicKeys) {\n        if (!publicKeys.length)\n            throw new Error('Expected non-empty array');\n        const agg = publicKeys.map(normP1).reduce((sum, p) => sum.add(p), G1.ProjectivePoint.ZERO);\n        const aggAffine = agg; //.toAffine();\n        if (publicKeys[0] instanceof G1.ProjectivePoint) {\n            aggAffine.assertValidity();\n            return aggAffine;\n        }\n        // toRawBytes ensures point validity\n        return aggAffine.toRawBytes(true);\n    }\n    function aggregateSignatures(signatures) {\n        if (!signatures.length)\n            throw new Error('Expected non-empty array');\n        const agg = signatures.map(normP2).reduce((sum, s) => sum.add(s), G2.ProjectivePoint.ZERO);\n        const aggAffine = agg; //.toAffine();\n        if (signatures[0] instanceof G2.ProjectivePoint) {\n            aggAffine.assertValidity();\n            return aggAffine;\n        }\n        return Signature.toRawBytes(aggAffine);\n    }\n    function aggregateShortSignatures(signatures) {\n        if (!signatures.length)\n            throw new Error('Expected non-empty array');\n        const agg = signatures.map(normP1).reduce((sum, s) => sum.add(s), G1.ProjectivePoint.ZERO);\n        const aggAffine = agg; //.toAffine();\n        if (signatures[0] instanceof G1.ProjectivePoint) {\n            aggAffine.assertValidity();\n            return aggAffine;\n        }\n        return ShortSignature.toRawBytes(aggAffine);\n    }\n    // https://ethresear.ch/t/fast-verification-of-multiple-bls-signatures/5407\n    // e(G, S) = e(G, SUM(n)(Si)) = MUL(n)(e(G, Si))\n    function verifyBatch(signature, messages, publicKeys, htfOpts) {\n        // @ts-ignore\n        // console.log('verifyBatch', bytesToHex(signature as any), messages, publicKeys.map(bytesToHex));\n        if (!messages.length)\n            throw new Error('Expected non-empty messages array');\n        if (publicKeys.length !== messages.length)\n            throw new Error('Pubkey count should equal msg count');\n        const sig = normP2(signature);\n        const nMessages = messages.map((i) => normP2Hash(i, htfOpts));\n        const nPublicKeys = publicKeys.map(normP1);\n        try {\n            const paired = [];\n            for (const message of new Set(nMessages)) {\n                const groupPublicKey = nMessages.reduce((groupPublicKey, subMessage, i) => subMessage === message ? groupPublicKey.add(nPublicKeys[i]) : groupPublicKey, G1.ProjectivePoint.ZERO);\n                // const msg = message instanceof PointG2 ? message : await PointG2.hashToCurve(message);\n                // Possible to batch pairing for same msg with different groupPublicKey here\n                paired.push(pairing(groupPublicKey, message, false));\n            }\n            paired.push(pairing(G1.ProjectivePoint.BASE.negate(), sig, false));\n            const product = paired.reduce((a, b) => Fp12.mul(a, b), Fp12.ONE);\n            const exp = Fp12.finalExponentiate(product);\n            return Fp12.eql(exp, Fp12.ONE);\n        }\n        catch {\n            return false;\n        }\n    }\n    G1.ProjectivePoint.BASE._setWindowSize(4);\n    return {\n        getPublicKey,\n        getPublicKeyForShortSignatures,\n        sign,\n        signShortSignature,\n        verify,\n        verifyBatch,\n        verifyShortSignature,\n        aggregatePublicKeys,\n        aggregateSignatures,\n        aggregateShortSignatures,\n        millerLoop,\n        pairing,\n        G1,\n        G2,\n        Signature,\n        ShortSignature,\n        fields: {\n            Fr,\n            Fp,\n            Fp2,\n            Fp6,\n            Fp12,\n        },\n        params: {\n            x: CURVE.params.x,\n            r: CURVE.params.r,\n            G1b: CURVE.G1.b,\n            G2b: CURVE.G2.b,\n        },\n        utils,\n    };\n}\n//# sourceMappingURL=bls.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvYmxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWdFO0FBQ1A7QUFDekQ7QUFDa0Q7QUFDSTtBQUN0RDtBQUNBO0FBQ087QUFDUDtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDLHNCQUFzQixpREFBTTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQSxrQ0FBa0M7QUFDbEMsa0NBQWtDO0FBQ2xDLHdEQUF3RDtBQUN4RCx1Q0FBdUM7QUFDdkMseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUUsNkZBQTZGO0FBQzdGLGtDQUFrQztBQUNsQyxnQkFBZ0IsaURBQU07QUFDdEI7QUFDQSx1REFBdUQ7QUFDdkQsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsMENBQTBDO0FBQzFDLDBDQUEwQztBQUMxQywyRkFBMkY7QUFDM0Ysc0NBQXNDO0FBQ3RDLDZFQUE2RTtBQUM3RSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixJQUFJO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQSxnQkFBZ0IsaURBQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw2REFBZ0I7QUFDM0MsbUJBQW1CLDJEQUFjO0FBQ2pDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0VBQWlCLEdBQUcsMEJBQTBCO0FBQzlELGtDQUFrQywrREFBWTtBQUM5QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtFQUFpQixHQUFHLDBCQUEwQjtBQUM5RCxrQ0FBa0MsK0RBQVk7QUFDOUM7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLGlCQUFpQjtBQUM3QixZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixzREFBVztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixzREFBVztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvYmxzLmpzPzgxNzUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0TWluSGFzaExlbmd0aCwgbWFwSGFzaFRvRmllbGQgfSBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0IHsgYml0TGVuLCBiaXRHZXQsIGVuc3VyZUJ5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBwcmV0dGllci1pZ25vcmVcbmltcG9ydCB7IGNyZWF0ZUhhc2hlciB9IGZyb20gJy4vaGFzaC10by1jdXJ2ZS5qcyc7XG5pbXBvcnQgeyB3ZWllcnN0cmFzc1BvaW50cywgfSBmcm9tICcuL3dlaWVyc3RyYXNzLmpzJztcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzJuID0gQmlnSW50KDIpLCBfM24gPSBCaWdJbnQoMyk7XG5leHBvcnQgZnVuY3Rpb24gYmxzKENVUlZFKSB7XG4gICAgLy8gRmllbGRzIGFyZSBzcGVjaWZpYyBmb3IgY3VydmUsIHNvIGZvciBub3cgd2UnbGwgbmVlZCB0byBwYXNzIHRoZW0gd2l0aCBvcHRzXG4gICAgY29uc3QgeyBGcCwgRnIsIEZwMiwgRnA2LCBGcDEyIH0gPSBDVVJWRS5maWVsZHM7XG4gICAgY29uc3QgQkxTX1hfTEVOID0gYml0TGVuKENVUlZFLnBhcmFtcy54KTtcbiAgICAvLyBQcmUtY29tcHV0ZSBjb2VmZmljaWVudHMgZm9yIHNwYXJzZSBtdWx0aXBsaWNhdGlvblxuICAgIC8vIFBvaW50IGFkZGl0aW9uIGFuZCBwb2ludCBkb3VibGUgY2FsY3VsYXRpb25zIGlzIHJldXNlZCBmb3IgY29lZmZpY2llbnRzXG4gICAgZnVuY3Rpb24gY2FsY1BhaXJpbmdQcmVjb21wdXRlcyhwKSB7XG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcDtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGNvbnN0IFF4ID0geCwgUXkgPSB5LCBReiA9IEZwMi5PTkU7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBsZXQgUnggPSBReCwgUnkgPSBReSwgUnogPSBRejtcbiAgICAgICAgbGV0IGVsbF9jb2VmZiA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gQkxTX1hfTEVOIC0gMjsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIC8vIERvdWJsZVxuICAgICAgICAgICAgbGV0IHQwID0gRnAyLnNxcihSeSk7IC8vIFJ5wrJcbiAgICAgICAgICAgIGxldCB0MSA9IEZwMi5zcXIoUnopOyAvLyBSesKyXG4gICAgICAgICAgICBsZXQgdDIgPSBGcDIubXVsdGlwbHlCeUIoRnAyLm11bCh0MSwgXzNuKSk7IC8vIDMgKiBUMSAqIEJcbiAgICAgICAgICAgIGxldCB0MyA9IEZwMi5tdWwodDIsIF8zbik7IC8vIDMgKiBUMlxuICAgICAgICAgICAgbGV0IHQ0ID0gRnAyLnN1YihGcDIuc3ViKEZwMi5zcXIoRnAyLmFkZChSeSwgUnopKSwgdDEpLCB0MCk7IC8vIChSeSArIFJ6KcKyIC0gVDEgLSBUMFxuICAgICAgICAgICAgZWxsX2NvZWZmLnB1c2goW1xuICAgICAgICAgICAgICAgIEZwMi5zdWIodDIsIHQwKSwgLy8gVDIgLSBUMFxuICAgICAgICAgICAgICAgIEZwMi5tdWwoRnAyLnNxcihSeCksIF8zbiksIC8vIDMgKiBSeMKyXG4gICAgICAgICAgICAgICAgRnAyLm5lZyh0NCksIC8vIC1UNFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBSeCA9IEZwMi5kaXYoRnAyLm11bChGcDIubXVsKEZwMi5zdWIodDAsIHQzKSwgUngpLCBSeSksIF8ybik7IC8vICgoVDAgLSBUMykgKiBSeCAqIFJ5KSAvIDJcbiAgICAgICAgICAgIFJ5ID0gRnAyLnN1YihGcDIuc3FyKEZwMi5kaXYoRnAyLmFkZCh0MCwgdDMpLCBfMm4pKSwgRnAyLm11bChGcDIuc3FyKHQyKSwgXzNuKSk7IC8vICgoVDAgKyBUMykgLyAyKcKyIC0gMyAqIFQywrJcbiAgICAgICAgICAgIFJ6ID0gRnAyLm11bCh0MCwgdDQpOyAvLyBUMCAqIFQ0XG4gICAgICAgICAgICBpZiAoYml0R2V0KENVUlZFLnBhcmFtcy54LCBpKSkge1xuICAgICAgICAgICAgICAgIC8vIEFkZGl0aW9uXG4gICAgICAgICAgICAgICAgbGV0IHQwID0gRnAyLnN1YihSeSwgRnAyLm11bChReSwgUnopKTsgLy8gUnkgLSBReSAqIFJ6XG4gICAgICAgICAgICAgICAgbGV0IHQxID0gRnAyLnN1YihSeCwgRnAyLm11bChReCwgUnopKTsgLy8gUnggLSBReCAqIFJ6XG4gICAgICAgICAgICAgICAgZWxsX2NvZWZmLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICBGcDIuc3ViKEZwMi5tdWwodDAsIFF4KSwgRnAyLm11bCh0MSwgUXkpKSwgLy8gVDAgKiBReCAtIFQxICogUXlcbiAgICAgICAgICAgICAgICAgICAgRnAyLm5lZyh0MCksIC8vIC1UMFxuICAgICAgICAgICAgICAgICAgICB0MSwgLy8gVDFcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICBsZXQgdDIgPSBGcDIuc3FyKHQxKTsgLy8gVDHCslxuICAgICAgICAgICAgICAgIGxldCB0MyA9IEZwMi5tdWwodDIsIHQxKTsgLy8gVDIgKiBUMVxuICAgICAgICAgICAgICAgIGxldCB0NCA9IEZwMi5tdWwodDIsIFJ4KTsgLy8gVDIgKiBSeFxuICAgICAgICAgICAgICAgIGxldCB0NSA9IEZwMi5hZGQoRnAyLnN1Yih0MywgRnAyLm11bCh0NCwgXzJuKSksIEZwMi5tdWwoRnAyLnNxcih0MCksIFJ6KSk7IC8vIFQzIC0gMiAqIFQ0ICsgVDDCsiAqIFJ6XG4gICAgICAgICAgICAgICAgUnggPSBGcDIubXVsKHQxLCB0NSk7IC8vIFQxICogVDVcbiAgICAgICAgICAgICAgICBSeSA9IEZwMi5zdWIoRnAyLm11bChGcDIuc3ViKHQ0LCB0NSksIHQwKSwgRnAyLm11bCh0MywgUnkpKTsgLy8gKFQ0IC0gVDUpICogVDAgLSBUMyAqIFJ5XG4gICAgICAgICAgICAgICAgUnogPSBGcDIubXVsKFJ6LCB0Myk7IC8vIFJ6ICogVDNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxsX2NvZWZmO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtaWxsZXJMb29wKGVsbCwgZzEpIHtcbiAgICAgICAgY29uc3QgeyB4IH0gPSBDVVJWRS5wYXJhbXM7XG4gICAgICAgIGNvbnN0IFB4ID0gZzFbMF07XG4gICAgICAgIGNvbnN0IFB5ID0gZzFbMV07XG4gICAgICAgIGxldCBmMTIgPSBGcDEyLk9ORTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDAsIGkgPSBCTFNfWF9MRU4gLSAyOyBpID49IDA7IGktLSwgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBFID0gZWxsW2pdO1xuICAgICAgICAgICAgZjEyID0gRnAxMi5tdWx0aXBseUJ5MDE0KGYxMiwgRVswXSwgRnAyLm11bChFWzFdLCBQeCksIEZwMi5tdWwoRVsyXSwgUHkpKTtcbiAgICAgICAgICAgIGlmIChiaXRHZXQoeCwgaSkpIHtcbiAgICAgICAgICAgICAgICBqICs9IDE7XG4gICAgICAgICAgICAgICAgY29uc3QgRiA9IGVsbFtqXTtcbiAgICAgICAgICAgICAgICBmMTIgPSBGcDEyLm11bHRpcGx5QnkwMTQoZjEyLCBGWzBdLCBGcDIubXVsKEZbMV0sIFB4KSwgRnAyLm11bChGWzJdLCBQeSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgIT09IDApXG4gICAgICAgICAgICAgICAgZjEyID0gRnAxMi5zcXIoZjEyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRnAxMi5jb25qdWdhdGUoZjEyKTtcbiAgICB9XG4gICAgY29uc3QgdXRpbHMgPSB7XG4gICAgICAgIHJhbmRvbVByaXZhdGVLZXk6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGdldE1pbkhhc2hMZW5ndGgoRnIuT1JERVIpO1xuICAgICAgICAgICAgcmV0dXJuIG1hcEhhc2hUb0ZpZWxkKENVUlZFLnJhbmRvbUJ5dGVzKGxlbmd0aCksIEZyLk9SREVSKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2FsY1BhaXJpbmdQcmVjb21wdXRlcyxcbiAgICB9O1xuICAgIC8vIFBvaW50IG9uIEcxIGN1cnZlOiAoeCwgeSlcbiAgICBjb25zdCBHMV8gPSB3ZWllcnN0cmFzc1BvaW50cyh7IG46IEZyLk9SREVSLCAuLi5DVVJWRS5HMSB9KTtcbiAgICBjb25zdCBHMSA9IE9iamVjdC5hc3NpZ24oRzFfLCBjcmVhdGVIYXNoZXIoRzFfLlByb2plY3RpdmVQb2ludCwgQ1VSVkUuRzEubWFwVG9DdXJ2ZSwge1xuICAgICAgICAuLi5DVVJWRS5odGZEZWZhdWx0cyxcbiAgICAgICAgLi4uQ1VSVkUuRzEuaHRmRGVmYXVsdHMsXG4gICAgfSkpO1xuICAgIGZ1bmN0aW9uIHBhaXJpbmdQcmVjb21wdXRlcyhwb2ludCkge1xuICAgICAgICBjb25zdCBwID0gcG9pbnQ7XG4gICAgICAgIGlmIChwLl9QUFJFQ09NUFVURVMpXG4gICAgICAgICAgICByZXR1cm4gcC5fUFBSRUNPTVBVVEVTO1xuICAgICAgICBwLl9QUFJFQ09NUFVURVMgPSBjYWxjUGFpcmluZ1ByZWNvbXB1dGVzKHBvaW50LnRvQWZmaW5lKCkpO1xuICAgICAgICByZXR1cm4gcC5fUFBSRUNPTVBVVEVTO1xuICAgIH1cbiAgICAvLyBUT0RPOiBleHBvcnRcbiAgICAvLyBmdW5jdGlvbiBjbGVhclBhaXJpbmdQcmVjb21wdXRlcyhwb2ludDogRzIpIHtcbiAgICAvLyAgIGNvbnN0IHAgPSBwb2ludCBhcyBHMiAmIHdpdGhQYWlyaW5nUHJlY29tcHV0ZXM7XG4gICAgLy8gICBwLl9QUFJFQ09NUFVURVMgPSB1bmRlZmluZWQ7XG4gICAgLy8gfVxuICAgIC8vIFBvaW50IG9uIEcyIGN1cnZlIChjb21wbGV4IG51bWJlcnMpOiAoeOKCgSwgeOKCgitpKSwgKHnigoEsIHnigoIraSlcbiAgICBjb25zdCBHMl8gPSB3ZWllcnN0cmFzc1BvaW50cyh7IG46IEZyLk9SREVSLCAuLi5DVVJWRS5HMiB9KTtcbiAgICBjb25zdCBHMiA9IE9iamVjdC5hc3NpZ24oRzJfLCBjcmVhdGVIYXNoZXIoRzJfLlByb2plY3RpdmVQb2ludCwgQ1VSVkUuRzIubWFwVG9DdXJ2ZSwge1xuICAgICAgICAuLi5DVVJWRS5odGZEZWZhdWx0cyxcbiAgICAgICAgLi4uQ1VSVkUuRzIuaHRmRGVmYXVsdHMsXG4gICAgfSkpO1xuICAgIGNvbnN0IHsgU2hvcnRTaWduYXR1cmUgfSA9IENVUlZFLkcxO1xuICAgIGNvbnN0IHsgU2lnbmF0dXJlIH0gPSBDVVJWRS5HMjtcbiAgICAvLyBDYWxjdWxhdGVzIGJpbGluZWFyIHBhaXJpbmdcbiAgICBmdW5jdGlvbiBwYWlyaW5nKFEsIFAsIHdpdGhGaW5hbEV4cG9uZW50ID0gdHJ1ZSkge1xuICAgICAgICBpZiAoUS5lcXVhbHMoRzEuUHJvamVjdGl2ZVBvaW50LlpFUk8pIHx8IFAuZXF1YWxzKEcyLlByb2plY3RpdmVQb2ludC5aRVJPKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFpcmluZyBpcyBub3QgYXZhaWxhYmxlIGZvciBaRVJPIHBvaW50Jyk7XG4gICAgICAgIFEuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAvLyBQZXJmb3JtYW5jZTogOW1zIGZvciBtaWxsZXJMb29wIGFuZCB+MTRtcyBmb3IgZXhwLlxuICAgICAgICBjb25zdCBRYSA9IFEudG9BZmZpbmUoKTtcbiAgICAgICAgY29uc3QgbG9vcGVkID0gbWlsbGVyTG9vcChwYWlyaW5nUHJlY29tcHV0ZXMoUCksIFtRYS54LCBRYS55XSk7XG4gICAgICAgIHJldHVybiB3aXRoRmluYWxFeHBvbmVudCA/IEZwMTIuZmluYWxFeHBvbmVudGlhdGUobG9vcGVkKSA6IGxvb3BlZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9ybVAxKHBvaW50KSB7XG4gICAgICAgIHJldHVybiBwb2ludCBpbnN0YW5jZW9mIEcxLlByb2plY3RpdmVQb2ludCA/IHBvaW50IDogRzEuUHJvamVjdGl2ZVBvaW50LmZyb21IZXgocG9pbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub3JtUDFIYXNoKHBvaW50LCBodGZPcHRzKSB7XG4gICAgICAgIHJldHVybiBwb2ludCBpbnN0YW5jZW9mIEcxLlByb2plY3RpdmVQb2ludFxuICAgICAgICAgICAgPyBwb2ludFxuICAgICAgICAgICAgOiBHMS5oYXNoVG9DdXJ2ZShlbnN1cmVCeXRlcygncG9pbnQnLCBwb2ludCksIGh0Zk9wdHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub3JtUDIocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHBvaW50IGluc3RhbmNlb2YgRzIuUHJvamVjdGl2ZVBvaW50ID8gcG9pbnQgOiBTaWduYXR1cmUuZnJvbUhleChwb2ludCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vcm1QMkhhc2gocG9pbnQsIGh0Zk9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHBvaW50IGluc3RhbmNlb2YgRzIuUHJvamVjdGl2ZVBvaW50XG4gICAgICAgICAgICA/IHBvaW50XG4gICAgICAgICAgICA6IEcyLmhhc2hUb0N1cnZlKGVuc3VyZUJ5dGVzKCdwb2ludCcsIHBvaW50KSwgaHRmT3B0cyk7XG4gICAgfVxuICAgIC8vIE11bHRpcGxpZXMgZ2VuZXJhdG9yIChHMSkgYnkgcHJpdmF0ZSBrZXkuXG4gICAgLy8gUCA9IHBrIHggR1xuICAgIGZ1bmN0aW9uIGdldFB1YmxpY0tleShwcml2YXRlS2V5KSB7XG4gICAgICAgIHJldHVybiBHMS5Qcm9qZWN0aXZlUG9pbnQuZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkudG9SYXdCeXRlcyh0cnVlKTtcbiAgICB9XG4gICAgLy8gTXVsdGlwbGllcyBnZW5lcmF0b3IgKEcyKSBieSBwcml2YXRlIGtleS5cbiAgICAvLyBQID0gcGsgeCBHXG4gICAgZnVuY3Rpb24gZ2V0UHVibGljS2V5Rm9yU2hvcnRTaWduYXR1cmVzKHByaXZhdGVLZXkpIHtcbiAgICAgICAgcmV0dXJuIEcyLlByb2plY3RpdmVQb2ludC5mcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KS50b1Jhd0J5dGVzKHRydWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaWduKG1lc3NhZ2UsIHByaXZhdGVLZXksIGh0Zk9wdHMpIHtcbiAgICAgICAgY29uc3QgbXNnUG9pbnQgPSBub3JtUDJIYXNoKG1lc3NhZ2UsIGh0Zk9wdHMpO1xuICAgICAgICBtc2dQb2ludC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICBjb25zdCBzaWdQb2ludCA9IG1zZ1BvaW50Lm11bHRpcGx5KEcxLm5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSkpO1xuICAgICAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEcyLlByb2plY3RpdmVQb2ludClcbiAgICAgICAgICAgIHJldHVybiBzaWdQb2ludDtcbiAgICAgICAgcmV0dXJuIFNpZ25hdHVyZS50b1Jhd0J5dGVzKHNpZ1BvaW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2lnblNob3J0U2lnbmF0dXJlKG1lc3NhZ2UsIHByaXZhdGVLZXksIGh0Zk9wdHMpIHtcbiAgICAgICAgY29uc3QgbXNnUG9pbnQgPSBub3JtUDFIYXNoKG1lc3NhZ2UsIGh0Zk9wdHMpO1xuICAgICAgICBtc2dQb2ludC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICBjb25zdCBzaWdQb2ludCA9IG1zZ1BvaW50Lm11bHRpcGx5KEcxLm5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSkpO1xuICAgICAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEcxLlByb2plY3RpdmVQb2ludClcbiAgICAgICAgICAgIHJldHVybiBzaWdQb2ludDtcbiAgICAgICAgcmV0dXJuIFNob3J0U2lnbmF0dXJlLnRvUmF3Qnl0ZXMoc2lnUG9pbnQpO1xuICAgIH1cbiAgICAvLyBDaGVja3MgaWYgcGFpcmluZyBvZiBwdWJsaWMga2V5ICYgaGFzaCBpcyBlcXVhbCB0byBwYWlyaW5nIG9mIGdlbmVyYXRvciAmIHNpZ25hdHVyZS5cbiAgICAvLyBlKFAsIEgobSkpID09IGUoRywgUylcbiAgICBmdW5jdGlvbiB2ZXJpZnkoc2lnbmF0dXJlLCBtZXNzYWdlLCBwdWJsaWNLZXksIGh0Zk9wdHMpIHtcbiAgICAgICAgY29uc3QgUCA9IG5vcm1QMShwdWJsaWNLZXkpO1xuICAgICAgICBjb25zdCBIbSA9IG5vcm1QMkhhc2gobWVzc2FnZSwgaHRmT3B0cyk7XG4gICAgICAgIGNvbnN0IEcgPSBHMS5Qcm9qZWN0aXZlUG9pbnQuQkFTRTtcbiAgICAgICAgY29uc3QgUyA9IG5vcm1QMihzaWduYXR1cmUpO1xuICAgICAgICAvLyBJbnN0ZWFkIG9mIGRvaW5nIDIgZXhwb25lbnRpYXRpb25zLCB3ZSB1c2UgcHJvcGVydHkgb2YgYmlsbGluZWFyIG1hcHNcbiAgICAgICAgLy8gYW5kIGRvIG9uZSBleHAgYWZ0ZXIgbXVsdGlwbHlpbmcgMiBwb2ludHMuXG4gICAgICAgIGNvbnN0IGVQSG0gPSBwYWlyaW5nKFAubmVnYXRlKCksIEhtLCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IGVHUyA9IHBhaXJpbmcoRywgUywgZmFsc2UpO1xuICAgICAgICBjb25zdCBleHAgPSBGcDEyLmZpbmFsRXhwb25lbnRpYXRlKEZwMTIubXVsKGVHUywgZVBIbSkpO1xuICAgICAgICByZXR1cm4gRnAxMi5lcWwoZXhwLCBGcDEyLk9ORSk7XG4gICAgfVxuICAgIC8vIENoZWNrcyBpZiBwYWlyaW5nIG9mIHB1YmxpYyBrZXkgJiBoYXNoIGlzIGVxdWFsIHRvIHBhaXJpbmcgb2YgZ2VuZXJhdG9yICYgc2lnbmF0dXJlLlxuICAgIC8vIGUoUywgRykgPT0gZShIKG0pLCBQKVxuICAgIGZ1bmN0aW9uIHZlcmlmeVNob3J0U2lnbmF0dXJlKHNpZ25hdHVyZSwgbWVzc2FnZSwgcHVibGljS2V5LCBodGZPcHRzKSB7XG4gICAgICAgIGNvbnN0IFAgPSBub3JtUDIocHVibGljS2V5KTtcbiAgICAgICAgY29uc3QgSG0gPSBub3JtUDFIYXNoKG1lc3NhZ2UsIGh0Zk9wdHMpO1xuICAgICAgICBjb25zdCBHID0gRzIuUHJvamVjdGl2ZVBvaW50LkJBU0U7XG4gICAgICAgIGNvbnN0IFMgPSBub3JtUDEoc2lnbmF0dXJlKTtcbiAgICAgICAgLy8gSW5zdGVhZCBvZiBkb2luZyAyIGV4cG9uZW50aWF0aW9ucywgd2UgdXNlIHByb3BlcnR5IG9mIGJpbGxpbmVhciBtYXBzXG4gICAgICAgIC8vIGFuZCBkbyBvbmUgZXhwIGFmdGVyIG11bHRpcGx5aW5nIDIgcG9pbnRzLlxuICAgICAgICBjb25zdCBlSG1QID0gcGFpcmluZyhIbSwgUCwgZmFsc2UpO1xuICAgICAgICBjb25zdCBlU0cgPSBwYWlyaW5nKFMsIEcubmVnYXRlKCksIGZhbHNlKTtcbiAgICAgICAgY29uc3QgZXhwID0gRnAxMi5maW5hbEV4cG9uZW50aWF0ZShGcDEyLm11bChlU0csIGVIbVApKTtcbiAgICAgICAgcmV0dXJuIEZwMTIuZXFsKGV4cCwgRnAxMi5PTkUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZ2dyZWdhdGVQdWJsaWNLZXlzKHB1YmxpY0tleXMpIHtcbiAgICAgICAgaWYgKCFwdWJsaWNLZXlzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgbm9uLWVtcHR5IGFycmF5Jyk7XG4gICAgICAgIGNvbnN0IGFnZyA9IHB1YmxpY0tleXMubWFwKG5vcm1QMSkucmVkdWNlKChzdW0sIHApID0+IHN1bS5hZGQocCksIEcxLlByb2plY3RpdmVQb2ludC5aRVJPKTtcbiAgICAgICAgY29uc3QgYWdnQWZmaW5lID0gYWdnOyAvLy50b0FmZmluZSgpO1xuICAgICAgICBpZiAocHVibGljS2V5c1swXSBpbnN0YW5jZW9mIEcxLlByb2plY3RpdmVQb2ludCkge1xuICAgICAgICAgICAgYWdnQWZmaW5lLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gYWdnQWZmaW5lO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRvUmF3Qnl0ZXMgZW5zdXJlcyBwb2ludCB2YWxpZGl0eVxuICAgICAgICByZXR1cm4gYWdnQWZmaW5lLnRvUmF3Qnl0ZXModHJ1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFnZ3JlZ2F0ZVNpZ25hdHVyZXMoc2lnbmF0dXJlcykge1xuICAgICAgICBpZiAoIXNpZ25hdHVyZXMubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBub24tZW1wdHkgYXJyYXknKTtcbiAgICAgICAgY29uc3QgYWdnID0gc2lnbmF0dXJlcy5tYXAobm9ybVAyKS5yZWR1Y2UoKHN1bSwgcykgPT4gc3VtLmFkZChzKSwgRzIuUHJvamVjdGl2ZVBvaW50LlpFUk8pO1xuICAgICAgICBjb25zdCBhZ2dBZmZpbmUgPSBhZ2c7IC8vLnRvQWZmaW5lKCk7XG4gICAgICAgIGlmIChzaWduYXR1cmVzWzBdIGluc3RhbmNlb2YgRzIuUHJvamVjdGl2ZVBvaW50KSB7XG4gICAgICAgICAgICBhZ2dBZmZpbmUuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBhZ2dBZmZpbmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNpZ25hdHVyZS50b1Jhd0J5dGVzKGFnZ0FmZmluZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFnZ3JlZ2F0ZVNob3J0U2lnbmF0dXJlcyhzaWduYXR1cmVzKSB7XG4gICAgICAgIGlmICghc2lnbmF0dXJlcy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIG5vbi1lbXB0eSBhcnJheScpO1xuICAgICAgICBjb25zdCBhZ2cgPSBzaWduYXR1cmVzLm1hcChub3JtUDEpLnJlZHVjZSgoc3VtLCBzKSA9PiBzdW0uYWRkKHMpLCBHMS5Qcm9qZWN0aXZlUG9pbnQuWkVSTyk7XG4gICAgICAgIGNvbnN0IGFnZ0FmZmluZSA9IGFnZzsgLy8udG9BZmZpbmUoKTtcbiAgICAgICAgaWYgKHNpZ25hdHVyZXNbMF0gaW5zdGFuY2VvZiBHMS5Qcm9qZWN0aXZlUG9pbnQpIHtcbiAgICAgICAgICAgIGFnZ0FmZmluZS5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIGFnZ0FmZmluZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU2hvcnRTaWduYXR1cmUudG9SYXdCeXRlcyhhZ2dBZmZpbmUpO1xuICAgIH1cbiAgICAvLyBodHRwczovL2V0aHJlc2Vhci5jaC90L2Zhc3QtdmVyaWZpY2F0aW9uLW9mLW11bHRpcGxlLWJscy1zaWduYXR1cmVzLzU0MDdcbiAgICAvLyBlKEcsIFMpID0gZShHLCBTVU0obikoU2kpKSA9IE1VTChuKShlKEcsIFNpKSlcbiAgICBmdW5jdGlvbiB2ZXJpZnlCYXRjaChzaWduYXR1cmUsIG1lc3NhZ2VzLCBwdWJsaWNLZXlzLCBodGZPcHRzKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3ZlcmlmeUJhdGNoJywgYnl0ZXNUb0hleChzaWduYXR1cmUgYXMgYW55KSwgbWVzc2FnZXMsIHB1YmxpY0tleXMubWFwKGJ5dGVzVG9IZXgpKTtcbiAgICAgICAgaWYgKCFtZXNzYWdlcy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIG5vbi1lbXB0eSBtZXNzYWdlcyBhcnJheScpO1xuICAgICAgICBpZiAocHVibGljS2V5cy5sZW5ndGggIT09IG1lc3NhZ2VzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHVia2V5IGNvdW50IHNob3VsZCBlcXVhbCBtc2cgY291bnQnKTtcbiAgICAgICAgY29uc3Qgc2lnID0gbm9ybVAyKHNpZ25hdHVyZSk7XG4gICAgICAgIGNvbnN0IG5NZXNzYWdlcyA9IG1lc3NhZ2VzLm1hcCgoaSkgPT4gbm9ybVAySGFzaChpLCBodGZPcHRzKSk7XG4gICAgICAgIGNvbnN0IG5QdWJsaWNLZXlzID0gcHVibGljS2V5cy5tYXAobm9ybVAxKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhaXJlZCA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIG5ldyBTZXQobk1lc3NhZ2VzKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGdyb3VwUHVibGljS2V5ID0gbk1lc3NhZ2VzLnJlZHVjZSgoZ3JvdXBQdWJsaWNLZXksIHN1Yk1lc3NhZ2UsIGkpID0+IHN1Yk1lc3NhZ2UgPT09IG1lc3NhZ2UgPyBncm91cFB1YmxpY0tleS5hZGQoblB1YmxpY0tleXNbaV0pIDogZ3JvdXBQdWJsaWNLZXksIEcxLlByb2plY3RpdmVQb2ludC5aRVJPKTtcbiAgICAgICAgICAgICAgICAvLyBjb25zdCBtc2cgPSBtZXNzYWdlIGluc3RhbmNlb2YgUG9pbnRHMiA/IG1lc3NhZ2UgOiBhd2FpdCBQb2ludEcyLmhhc2hUb0N1cnZlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIC8vIFBvc3NpYmxlIHRvIGJhdGNoIHBhaXJpbmcgZm9yIHNhbWUgbXNnIHdpdGggZGlmZmVyZW50IGdyb3VwUHVibGljS2V5IGhlcmVcbiAgICAgICAgICAgICAgICBwYWlyZWQucHVzaChwYWlyaW5nKGdyb3VwUHVibGljS2V5LCBtZXNzYWdlLCBmYWxzZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFpcmVkLnB1c2gocGFpcmluZyhHMS5Qcm9qZWN0aXZlUG9pbnQuQkFTRS5uZWdhdGUoKSwgc2lnLCBmYWxzZSkpO1xuICAgICAgICAgICAgY29uc3QgcHJvZHVjdCA9IHBhaXJlZC5yZWR1Y2UoKGEsIGIpID0+IEZwMTIubXVsKGEsIGIpLCBGcDEyLk9ORSk7XG4gICAgICAgICAgICBjb25zdCBleHAgPSBGcDEyLmZpbmFsRXhwb25lbnRpYXRlKHByb2R1Y3QpO1xuICAgICAgICAgICAgcmV0dXJuIEZwMTIuZXFsKGV4cCwgRnAxMi5PTkUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBHMS5Qcm9qZWN0aXZlUG9pbnQuQkFTRS5fc2V0V2luZG93U2l6ZSg0KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXRQdWJsaWNLZXksXG4gICAgICAgIGdldFB1YmxpY0tleUZvclNob3J0U2lnbmF0dXJlcyxcbiAgICAgICAgc2lnbixcbiAgICAgICAgc2lnblNob3J0U2lnbmF0dXJlLFxuICAgICAgICB2ZXJpZnksXG4gICAgICAgIHZlcmlmeUJhdGNoLFxuICAgICAgICB2ZXJpZnlTaG9ydFNpZ25hdHVyZSxcbiAgICAgICAgYWdncmVnYXRlUHVibGljS2V5cyxcbiAgICAgICAgYWdncmVnYXRlU2lnbmF0dXJlcyxcbiAgICAgICAgYWdncmVnYXRlU2hvcnRTaWduYXR1cmVzLFxuICAgICAgICBtaWxsZXJMb29wLFxuICAgICAgICBwYWlyaW5nLFxuICAgICAgICBHMSxcbiAgICAgICAgRzIsXG4gICAgICAgIFNpZ25hdHVyZSxcbiAgICAgICAgU2hvcnRTaWduYXR1cmUsXG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgRnIsXG4gICAgICAgICAgICBGcCxcbiAgICAgICAgICAgIEZwMixcbiAgICAgICAgICAgIEZwNixcbiAgICAgICAgICAgIEZwMTIsXG4gICAgICAgIH0sXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgeDogQ1VSVkUucGFyYW1zLngsXG4gICAgICAgICAgICByOiBDVVJWRS5wYXJhbXMucixcbiAgICAgICAgICAgIEcxYjogQ1VSVkUuRzEuYixcbiAgICAgICAgICAgIEcyYjogQ1VSVkUuRzIuYixcbiAgICAgICAgfSxcbiAgICAgICAgdXRpbHMsXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/bls.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/curve.js":
/*!**************************************************************!*\
  !*** ../../node_modules/@noble/curves/esm/abstract/curve.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   validateBasic: function() { return /* binding */ validateBasic; },\n/* harmony export */   wNAF: function() { return /* binding */ wNAF; }\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\n\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n    const constTimeNegate = (condition, item) => {\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W) => {\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return { windows, windowSize };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(1) * (Math.ceil( / ) + 1), where:\n         * -  is the window size\n         * -  is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                }\n                else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        wNAFCached(P, precomputesMap, n, transform) {\n            // @ts-ignore\n            const W = P._WINDOW_SIZE || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    precomputesMap.set(P, transform(comp));\n                }\n            }\n            return this.wNAF(W, comp, n);\n        },\n    };\n}\nfunction validateBasic(curve) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(curve.Fp);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject)(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\n//# sourceMappingURL=curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvY3VydmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDc0Q7QUFDVjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCx5Q0FBeUM7QUFDekMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ087QUFDUCxJQUFJLDBEQUFhO0FBQ2pCLElBQUkseURBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsV0FBVyxvREFBTztBQUNsQjtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvY3VydmUuanM/ODkzMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBBYmVsaWFuIGdyb3VwIHV0aWxpdGllc1xuaW1wb3J0IHsgdmFsaWRhdGVGaWVsZCwgbkxlbmd0aCB9IGZyb20gJy4vbW9kdWxhci5qcyc7XG5pbXBvcnQgeyB2YWxpZGF0ZU9iamVjdCB9IGZyb20gJy4vdXRpbHMuanMnO1xuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuLy8gRWxsaXB0aWMgY3VydmUgbXVsdGlwbGljYXRpb24gb2YgUG9pbnQgYnkgc2NhbGFyLiBGcmFnaWxlLlxuLy8gU2NhbGFycyBzaG91bGQgYWx3YXlzIGJlIGxlc3MgdGhhbiBjdXJ2ZSBvcmRlcjogdGhpcyBzaG91bGQgYmUgY2hlY2tlZCBpbnNpZGUgb2YgYSBjdXJ2ZSBpdHNlbGYuXG4vLyBDcmVhdGVzIHByZWNvbXB1dGF0aW9uIHRhYmxlcyBmb3IgZmFzdCBtdWx0aXBsaWNhdGlvbjpcbi8vIC0gcHJpdmF0ZSBzY2FsYXIgaXMgc3BsaXQgYnkgZml4ZWQgc2l6ZSB3aW5kb3dzIG9mIFcgYml0c1xuLy8gLSBldmVyeSB3aW5kb3cgcG9pbnQgaXMgY29sbGVjdGVkIGZyb20gd2luZG93J3MgdGFibGUgJiBhZGRlZCB0byBhY2N1bXVsYXRvclxuLy8gLSBzaW5jZSB3aW5kb3dzIGFyZSBkaWZmZXJlbnQsIHNhbWUgcG9pbnQgaW5zaWRlIHRhYmxlcyB3b24ndCBiZSBhY2Nlc3NlZCBtb3JlIHRoYW4gb25jZSBwZXIgY2FsY1xuLy8gLSBlYWNoIG11bHRpcGxpY2F0aW9uIGlzICdNYXRoLmNlaWwoQ1VSVkVfT1JERVIgLyDwnZGKKSArIDEnIHBvaW50IGFkZGl0aW9ucyAoZml4ZWQgZm9yIGFueSBzY2FsYXIpXG4vLyAtICsxIHdpbmRvdyBpcyBuZWNjZXNzYXJ5IGZvciB3TkFGXG4vLyAtIHdOQUYgcmVkdWNlcyB0YWJsZSBzaXplOiAyeCBsZXNzIG1lbW9yeSArIDJ4IGZhc3RlciBnZW5lcmF0aW9uLCBidXQgMTAlIHNsb3dlciBtdWx0aXBsaWNhdGlvblxuLy8gVE9ETzogUmVzZWFyY2ggcmV0dXJuaW5nIDJkIEpTIGFycmF5IG9mIHdpbmRvd3MsIGluc3RlYWQgb2YgYSBzaW5nbGUgd2luZG93LiBUaGlzIHdvdWxkIGFsbG93XG4vLyB3aW5kb3dzIHRvIGJlIGluIGRpZmZlcmVudCBtZW1vcnkgbG9jYXRpb25zXG5leHBvcnQgZnVuY3Rpb24gd05BRihjLCBiaXRzKSB7XG4gICAgY29uc3QgY29uc3RUaW1lTmVnYXRlID0gKGNvbmRpdGlvbiwgaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBuZWcgPSBpdGVtLm5lZ2F0ZSgpO1xuICAgICAgICByZXR1cm4gY29uZGl0aW9uID8gbmVnIDogaXRlbTtcbiAgICB9O1xuICAgIGNvbnN0IG9wdHMgPSAoVykgPT4ge1xuICAgICAgICBjb25zdCB3aW5kb3dzID0gTWF0aC5jZWlsKGJpdHMgLyBXKSArIDE7IC8vICsxLCBiZWNhdXNlXG4gICAgICAgIGNvbnN0IHdpbmRvd1NpemUgPSAyICoqIChXIC0gMSk7IC8vIC0xIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgIHJldHVybiB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnN0VGltZU5lZ2F0ZSxcbiAgICAgICAgLy8gbm9uLWNvbnN0IHRpbWUgbXVsdGlwbGljYXRpb24gbGFkZGVyXG4gICAgICAgIHVuc2FmZUxhZGRlcihlbG0sIG4pIHtcbiAgICAgICAgICAgIGxldCBwID0gYy5aRVJPO1xuICAgICAgICAgICAgbGV0IGQgPSBlbG07XG4gICAgICAgICAgICB3aGlsZSAobiA+IF8wbikge1xuICAgICAgICAgICAgICAgIGlmIChuICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBwID0gcC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgZCA9IGQuZG91YmxlKCk7XG4gICAgICAgICAgICAgICAgbiA+Pj0gXzFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgd05BRiBwcmVjb21wdXRhdGlvbiB3aW5kb3cuIFVzZWQgZm9yIGNhY2hpbmcuXG4gICAgICAgICAqIERlZmF1bHQgd2luZG93IHNpemUgaXMgc2V0IGJ5IGB1dGlscy5wcmVjb21wdXRlKClgIGFuZCBpcyBlcXVhbCB0byA4LlxuICAgICAgICAgKiBOdW1iZXIgb2YgcHJlY29tcHV0ZWQgcG9pbnRzIGRlcGVuZHMgb24gdGhlIGN1cnZlIHNpemU6XG4gICAgICAgICAqIDJeKPCdkYriiJIxKSAqIChNYXRoLmNlaWwo8J2RmyAvIPCdkYopICsgMSksIHdoZXJlOlxuICAgICAgICAgKiAtIPCdkYogaXMgdGhlIHdpbmRvdyBzaXplXG4gICAgICAgICAqIC0g8J2RmyBpcyB0aGUgYml0bGVuZ3RoIG9mIHRoZSBjdXJ2ZSBvcmRlci5cbiAgICAgICAgICogRm9yIGEgMjU2LWJpdCBjdXJ2ZSBhbmQgd2luZG93IHNpemUgOCwgdGhlIG51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgaXMgMTI4ICogMzMgPSA0MjI0LlxuICAgICAgICAgKiBAcmV0dXJucyBwcmVjb21wdXRlZCBwb2ludCB0YWJsZXMgZmxhdHRlbmVkIHRvIGEgc2luZ2xlIGFycmF5XG4gICAgICAgICAqL1xuICAgICAgICBwcmVjb21wdXRlV2luZG93KGVsbSwgVykge1xuICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBvcHRzKFcpO1xuICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgICAgICAgICBsZXQgcCA9IGVsbTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gcDtcbiAgICAgICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAgICAgYmFzZSA9IHA7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICAgICAgLy8gPTEsIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB3aW5kb3dTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZSA9IGJhc2UuYWRkKHApO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcCA9IGJhc2UuZG91YmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogSW1wbGVtZW50cyBlYyBtdWx0aXBsaWNhdGlvbiB1c2luZyBwcmVjb21wdXRlZCB0YWJsZXMgYW5kIHctYXJ5IG5vbi1hZGphY2VudCBmb3JtLlxuICAgICAgICAgKiBAcGFyYW0gVyB3aW5kb3cgc2l6ZVxuICAgICAgICAgKiBAcGFyYW0gcHJlY29tcHV0ZXMgcHJlY29tcHV0ZWQgdGFibGVzXG4gICAgICAgICAqIEBwYXJhbSBuIHNjYWxhciAod2UgZG9uJ3QgY2hlY2sgaGVyZSwgYnV0IHNob3VsZCBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXIpXG4gICAgICAgICAqIEByZXR1cm5zIHJlYWwgYW5kIGZha2UgKGZvciBjb25zdC10aW1lKSBwb2ludHNcbiAgICAgICAgICovXG4gICAgICAgIHdOQUYoVywgcHJlY29tcHV0ZXMsIG4pIHtcbiAgICAgICAgICAgIC8vIFRPRE86IG1heWJlIGNoZWNrIHRoYXQgc2NhbGFyIGlzIGxlc3MgdGhhbiBncm91cCBvcmRlcj8gd05BRiBiZWhhdmlvdXMgaXMgdW5kZWZpbmVkIG90aGVyd2lzZVxuICAgICAgICAgICAgLy8gQnV0IG5lZWQgdG8gY2FyZWZ1bGx5IHJlbW92ZSBvdGhlciBjaGVja3MgYmVmb3JlIHdOQUYuIE9SREVSID09IGJpdHMgaGVyZVxuICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBvcHRzKFcpO1xuICAgICAgICAgICAgbGV0IHAgPSBjLlpFUk87XG4gICAgICAgICAgICBsZXQgZiA9IGMuQkFTRTtcbiAgICAgICAgICAgIGNvbnN0IG1hc2sgPSBCaWdJbnQoMiAqKiBXIC0gMSk7IC8vIENyZWF0ZSBtYXNrIHdpdGggVyBvbmVzOiAwYjExMTEgZm9yIFc9NCBldGMuXG4gICAgICAgICAgICBjb25zdCBtYXhOdW1iZXIgPSAyICoqIFc7XG4gICAgICAgICAgICBjb25zdCBzaGlmdEJ5ID0gQmlnSW50KFcpO1xuICAgICAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB3aW5kb3cgKiB3aW5kb3dTaXplO1xuICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgVyBiaXRzLlxuICAgICAgICAgICAgICAgIGxldCB3Yml0cyA9IE51bWJlcihuICYgbWFzayk7XG4gICAgICAgICAgICAgICAgLy8gU2hpZnQgbnVtYmVyIGJ5IFcgYml0cy5cbiAgICAgICAgICAgICAgICBuID4+PSBzaGlmdEJ5O1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBiaXRzIGFyZSBiaWdnZXIgdGhhbiBtYXggc2l6ZSwgd2UnbGwgc3BsaXQgdGhvc2UuXG4gICAgICAgICAgICAgICAgLy8gKzIyNCA9PiAyNTYgLSAzMlxuICAgICAgICAgICAgICAgIGlmICh3Yml0cyA+IHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgd2JpdHMgLT0gbWF4TnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICBuICs9IF8xbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjb2RlIHdhcyBmaXJzdCB3cml0dGVuIHdpdGggYXNzdW1wdGlvbiB0aGF0ICdmJyBhbmQgJ3AnIHdpbGwgbmV2ZXIgYmUgaW5maW5pdHkgcG9pbnQ6XG4gICAgICAgICAgICAgICAgLy8gc2luY2UgZWFjaCBhZGRpdGlvbiBpcyBtdWx0aXBsaWVkIGJ5IDIgKiogVywgaXQgY2Fubm90IGNhbmNlbCBlYWNoIG90aGVyLiBIb3dldmVyLFxuICAgICAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5lZ2F0ZSBub3c6IGl0IGlzIHBvc3NpYmxlIHRoYXQgbmVnYXRlZCBlbGVtZW50IGZyb20gbG93IHZhbHVlXG4gICAgICAgICAgICAgICAgLy8gd291bGQgYmUgdGhlIHNhbWUgYXMgaGlnaCBlbGVtZW50LCB3aGljaCB3aWxsIGNyZWF0ZSBjYXJyeSBpbnRvIG5leHQgd2luZG93LlxuICAgICAgICAgICAgICAgIC8vIEl0J3Mgbm90IG9idmlvdXMgaG93IHRoaXMgY2FuIGZhaWwsIGJ1dCBzdGlsbCB3b3J0aCBpbnZlc3RpZ2F0aW5nIGxhdGVyLlxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIG9udG8gWmVybyBwb2ludC5cbiAgICAgICAgICAgICAgICAvLyBBZGQgcmFuZG9tIHBvaW50IGluc2lkZSBjdXJyZW50IHdpbmRvdyB0byBmLlxuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldDEgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0MiA9IG9mZnNldCArIE1hdGguYWJzKHdiaXRzKSAtIDE7IC8vIC0xIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgICAgICAgICAgY29uc3QgY29uZDEgPSB3aW5kb3cgJSAyICE9PSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmQyID0gd2JpdHMgPCAwO1xuICAgICAgICAgICAgICAgIGlmICh3Yml0cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbW9zdCBpbXBvcnRhbnQgcGFydCBmb3IgY29uc3QtdGltZSBnZXRQdWJsaWNLZXlcbiAgICAgICAgICAgICAgICAgICAgZiA9IGYuYWRkKGNvbnN0VGltZU5lZ2F0ZShjb25kMSwgcHJlY29tcHV0ZXNbb2Zmc2V0MV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLmFkZChjb25zdFRpbWVOZWdhdGUoY29uZDIsIHByZWNvbXB1dGVzW29mZnNldDJdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSklULWNvbXBpbGVyIHNob3VsZCBub3QgZWxpbWluYXRlIGYgaGVyZSwgc2luY2UgaXQgd2lsbCBsYXRlciBiZSB1c2VkIGluIG5vcm1hbGl6ZVooKVxuICAgICAgICAgICAgLy8gRXZlbiBpZiB0aGUgdmFyaWFibGUgaXMgc3RpbGwgdW51c2VkLCB0aGVyZSBhcmUgc29tZSBjaGVja3Mgd2hpY2ggd2lsbFxuICAgICAgICAgICAgLy8gdGhyb3cgYW4gZXhjZXB0aW9uLCBzbyBjb21waWxlciBuZWVkcyB0byBwcm92ZSB0aGV5IHdvbid0IGhhcHBlbiwgd2hpY2ggaXMgaGFyZC5cbiAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlcmUgaXMgYSB3YXkgdG8gRiBiZSBpbmZpbml0eS1wb2ludCBldmVuIGlmIHAgaXMgbm90LFxuICAgICAgICAgICAgLy8gd2hpY2ggbWFrZXMgaXQgbGVzcyBjb25zdC10aW1lOiBhcm91bmQgMSBiaWdpbnQgbXVsdGlwbHkuXG4gICAgICAgICAgICByZXR1cm4geyBwLCBmIH07XG4gICAgICAgIH0sXG4gICAgICAgIHdOQUZDYWNoZWQoUCwgcHJlY29tcHV0ZXNNYXAsIG4sIHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgVyA9IFAuX1dJTkRPV19TSVpFIHx8IDE7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgcHJlY29tcHV0ZXMgb24gYSBmaXJzdCBydW4sIHJldXNlIHRoZW0gYWZ0ZXJcbiAgICAgICAgICAgIGxldCBjb21wID0gcHJlY29tcHV0ZXNNYXAuZ2V0KFApO1xuICAgICAgICAgICAgaWYgKCFjb21wKSB7XG4gICAgICAgICAgICAgICAgY29tcCA9IHRoaXMucHJlY29tcHV0ZVdpbmRvdyhQLCBXKTtcbiAgICAgICAgICAgICAgICBpZiAoVyAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVjb21wdXRlc01hcC5zZXQoUCwgdHJhbnNmb3JtKGNvbXApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53TkFGKFcsIGNvbXAsIG4pO1xuICAgICAgICB9LFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVCYXNpYyhjdXJ2ZSkge1xuICAgIHZhbGlkYXRlRmllbGQoY3VydmUuRnApO1xuICAgIHZhbGlkYXRlT2JqZWN0KGN1cnZlLCB7XG4gICAgICAgIG46ICdiaWdpbnQnLFxuICAgICAgICBoOiAnYmlnaW50JyxcbiAgICAgICAgR3g6ICdmaWVsZCcsXG4gICAgICAgIEd5OiAnZmllbGQnLFxuICAgIH0sIHtcbiAgICAgICAgbkJpdExlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBuQnl0ZUxlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgIH0pO1xuICAgIC8vIFNldCBkZWZhdWx0c1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgLi4ubkxlbmd0aChjdXJ2ZS5uLCBjdXJ2ZS5uQml0TGVuZ3RoKSxcbiAgICAgICAgLi4uY3VydmUsXG4gICAgICAgIC4uLnsgcDogY3VydmUuRnAuT1JERVIgfSxcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWN1cnZlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/curve.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/edwards.js":
/*!****************************************************************!*\
  !*** ../../node_modules/@noble/curves/esm/abstract/edwards.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   twistedEdwards: function() { return /* binding */ twistedEdwards; }\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve.js */ \"(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/curve.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Twisted Edwards curve. The formula is: ax + y = 1 + dxy\n\n\n\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\n// verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\nconst VERIFY_DEFAULT = { zip215: true };\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(curve, {\n        hash: 'function',\n        a: 'bigint',\n        d: 'bigint',\n        randomBytes: 'function',\n    }, {\n        adjustScalarBytes: 'function',\n        domain: 'function',\n        uvRatio: 'function',\n        mapToCurve: 'function',\n    });\n    // Set defaults\n    return Object.freeze({ ...opts });\n}\n// It is not generic twisted curve for now, but ed25519/ed448 generic implementation\nfunction twistedEdwards(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER, prehash: prehash, hash: cHash, randomBytes, nByteLength, h: cofactor, } = CURVE;\n    const MASK = _2n << (BigInt(nByteLength * 8) - _1n);\n    const modP = Fp.create; // Function overrides\n    // sqrt(u/v)\n    const uvRatio = CURVE.uvRatio ||\n        ((u, v) => {\n            try {\n                return { isValid: true, value: Fp.sqrt(u * Fp.inv(v)) };\n            }\n            catch (e) {\n                return { isValid: false, value: _0n };\n            }\n        });\n    const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes); // NOOP\n    const domain = CURVE.domain ||\n        ((data, ctx, phflag) => {\n            if (ctx.length || phflag)\n                throw new Error('Contexts/pre-hash are not supported');\n            return data;\n        }); // NOOP\n    const inBig = (n) => typeof n === 'bigint' && _0n < n; // n in [1..]\n    const inRange = (n, max) => inBig(n) && inBig(max) && n < max; // n in [1..max-1]\n    const in0MaskRange = (n) => n === _0n || inRange(n, MASK); // n in [0..MASK-1]\n    function assertInRange(n, max) {\n        // n in [1..max-1]\n        if (inRange(n, max))\n            return n;\n        throw new Error(`Expected valid scalar < ${max}, got ${typeof n} ${n}`);\n    }\n    function assertGE0(n) {\n        // n in [0..CURVE_ORDER-1]\n        return n === _0n ? n : assertInRange(n, CURVE_ORDER); // GE = prime subgroup, not full group\n    }\n    const pointPrecomputes = new Map();\n    function isPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ExtendedPoint expected');\n    }\n    // Extended Point works in extended coordinates: (x, y, z, t)  (x=x/z, y=y/z, t=xy).\n    // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n    class Point {\n        constructor(ex, ey, ez, et) {\n            this.ex = ex;\n            this.ey = ey;\n            this.ez = ez;\n            this.et = et;\n            if (!in0MaskRange(ex))\n                throw new Error('x required');\n            if (!in0MaskRange(ey))\n                throw new Error('y required');\n            if (!in0MaskRange(ez))\n                throw new Error('z required');\n            if (!in0MaskRange(et))\n                throw new Error('t required');\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        static fromAffine(p) {\n            if (p instanceof Point)\n                throw new Error('extended point not allowed');\n            const { x, y } = p || {};\n            if (!in0MaskRange(x) || !in0MaskRange(y))\n                throw new Error('invalid affine point');\n            return new Point(x, y, _1n, modP(x * y));\n        }\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.ez));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // Not required for fromHex(), which always creates valid points.\n        // Could be useful for fromAffine().\n        assertValidity() {\n            const { a, d } = CURVE;\n            if (this.is0())\n                throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n            // Equation in affine coordinates: ax + y = 1 + dxy\n            // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX + Y)Z = Z + dXY\n            const { ex: X, ey: Y, ez: Z, et: T } = this;\n            const X2 = modP(X * X); // X\n            const Y2 = modP(Y * Y); // Y\n            const Z2 = modP(Z * Z); // Z\n            const Z4 = modP(Z2 * Z2); // Z\n            const aX2 = modP(X2 * a); // aX\n            const left = modP(Z2 * modP(aX2 + Y2)); // (aX + Y)Z\n            const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z + dXY\n            if (left !== right)\n                throw new Error('bad point: equation left != right (1)');\n            // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n            const XY = modP(X * Y);\n            const ZT = modP(Z * T);\n            if (XY !== ZT)\n                throw new Error('bad point: equation left != right (2)');\n        }\n        // Compare one point to another.\n        equals(other) {\n            isPoint(other);\n            const { ex: X1, ey: Y1, ez: Z1 } = this;\n            const { ex: X2, ey: Y2, ez: Z2 } = other;\n            const X1Z2 = modP(X1 * Z2);\n            const X2Z1 = modP(X2 * Z1);\n            const Y1Z2 = modP(Y1 * Z2);\n            const Y2Z1 = modP(Y2 * Z1);\n            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        negate() {\n            // Flips point sign to a negative one (-x, y in affine coords)\n            return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));\n        }\n        // Fast algo for doubling Extended Point.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n        // Cost: 4M + 4S + 1*a + 6add + 1*2.\n        double() {\n            const { a } = CURVE;\n            const { ex: X1, ey: Y1, ez: Z1 } = this;\n            const A = modP(X1 * X1); // A = X12\n            const B = modP(Y1 * Y1); // B = Y12\n            const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n            const D = modP(a * A); // D = a*A\n            const x1y1 = X1 + Y1;\n            const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n            const G = D + B; // G = D+B\n            const F = G - C; // F = G-C\n            const H = D - B; // H = D-B\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        // Fast algo for adding 2 Extended Points.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n        // Cost: 9M + 1*a + 1*d + 7add.\n        add(other) {\n            isPoint(other);\n            const { a, d } = CURVE;\n            const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;\n            const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;\n            // Faster algo for adding 2 Extended Points when curve's a=-1.\n            // http://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-4\n            // Cost: 8M + 8add + 2*2.\n            // Note: It does not check whether the `other` point is valid.\n            if (a === BigInt(-1)) {\n                const A = modP((Y1 - X1) * (Y2 + X2));\n                const B = modP((Y1 + X1) * (Y2 - X2));\n                const F = modP(B - A);\n                if (F === _0n)\n                    return this.double(); // Same point. Tests say it doesn't affect timing\n                const C = modP(Z1 * _2n * T2);\n                const D = modP(T1 * _2n * Z2);\n                const E = D + C;\n                const G = B + A;\n                const H = D - C;\n                const X3 = modP(E * F);\n                const Y3 = modP(G * H);\n                const T3 = modP(E * H);\n                const Z3 = modP(F * G);\n                return new Point(X3, Y3, Z3, T3);\n            }\n            const A = modP(X1 * X2); // A = X1*X2\n            const B = modP(Y1 * Y2); // B = Y1*Y2\n            const C = modP(T1 * d * T2); // C = T1*d*T2\n            const D = modP(Z1 * Z2); // D = Z1*Z2\n            const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n            const F = D - C; // F = D-C\n            const G = D + C; // G = D+C\n            const H = modP(B - a * A); // H = B-a*A\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, Point.normalizeZ);\n        }\n        // Constant-time multiplication.\n        multiply(scalar) {\n            const { p, f } = this.wNAF(assertInRange(scalar, CURVE_ORDER));\n            return Point.normalizeZ([p, f])[0];\n        }\n        // Non-constant-time multiplication. Uses double-and-add algorithm.\n        // It's faster, but should only be used when you don't care about\n        // an exposed private key e.g. sig verification.\n        // Does NOT allow scalars higher than CURVE.n.\n        multiplyUnsafe(scalar) {\n            let n = assertGE0(scalar); // 0 <= scalar < CURVE.n\n            if (n === _0n)\n                return I;\n            if (this.equals(I) || n === _1n)\n                return this;\n            if (this.equals(G))\n                return this.wNAF(n).p;\n            return wnaf.unsafeLadder(this, n);\n        }\n        // Checks if point is of small order.\n        // If you add something to small order point, you will have \"dirty\"\n        // point with torsion component.\n        // Multiplies point by cofactor and checks if the result is 0.\n        isSmallOrder() {\n            return this.multiplyUnsafe(cofactor).is0();\n        }\n        // Multiplies point by curve order and checks if the result is 0.\n        // Returns `false` is the point is dirty.\n        isTorsionFree() {\n            return wnaf.unsafeLadder(this, CURVE_ORDER).is0();\n        }\n        // Converts Extended point to default (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        toAffine(iz) {\n            const { ex: x, ey: y, ez: z } = this;\n            const is0 = this.is0();\n            if (iz == null)\n                iz = is0 ? _8n : Fp.inv(z); // 8 was chosen arbitrarily\n            const ax = modP(x * iz);\n            const ay = modP(y * iz);\n            const zz = modP(z * iz);\n            if (is0)\n                return { x: _0n, y: _1n };\n            if (zz !== _1n)\n                throw new Error('invZ was invalid');\n            return { x: ax, y: ay };\n        }\n        clearCofactor() {\n            const { h: cofactor } = CURVE;\n            if (cofactor === _1n)\n                return this;\n            return this.multiplyUnsafe(cofactor);\n        }\n        // Converts hash string or Uint8Array to Point.\n        // Uses algo from RFC8032 5.1.3.\n        static fromHex(hex, zip215 = false) {\n            const { d, a } = CURVE;\n            const len = Fp.BYTES;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('pointHex', hex, len); // copy hex to a new array\n            const normed = hex.slice(); // copy again, we'll manipulate it\n            const lastByte = hex[len - 1]; // select last byte\n            normed[len - 1] = lastByte & ~0x80; // clear last bit\n            const y = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberLE(normed);\n            if (y === _0n) {\n                // y=0 is allowed\n            }\n            else {\n                // RFC8032 prohibits >= p, but ZIP215 doesn't\n                if (zip215)\n                    assertInRange(y, MASK); // zip215=true [1..P-1] (2^255-19-1 for ed25519)\n                else\n                    assertInRange(y, Fp.ORDER); // zip215=false [1..MASK-1] (2^256-1 for ed25519)\n            }\n            // Ed25519: x = (y-1)/(dy+1) mod p. Ed448: x = (y-1)/(dy-1) mod p. Generic case:\n            // ax+y=1+dxy => y-1=dxy-ax => y-1=x(dy-a) => x=(y-1)/(dy-a)\n            const y2 = modP(y * y); // denominator is always non-0 mod p.\n            const u = modP(y2 - _1n); // u = y - 1\n            const v = modP(d * y2 - a); // v = d y + 1.\n            let { isValid, value: x } = uvRatio(u, v); // (u/v)\n            if (!isValid)\n                throw new Error('Point.fromHex: invalid y coordinate');\n            const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n            const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n            if (!zip215 && x === _0n && isLastByteOdd)\n                // if x=0 and x_0 = 1, fail\n                throw new Error('Point.fromHex: x=0 and x_0=1');\n            if (isLastByteOdd !== isXOdd)\n                x = modP(-x); // if x_0 != x mod 2, set x = p-x\n            return Point.fromAffine({ x, y });\n        }\n        static fromPrivateKey(privKey) {\n            return getExtendedPublicKey(privKey).point;\n        }\n        toRawBytes() {\n            const { x, y } = this.toAffine();\n            const bytes = _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesLE(y, Fp.BYTES); // each y has 2 x values (x, -y)\n            bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y\n            return bytes; // and use the last byte to encode sign of x\n        }\n        toHex() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(this.toRawBytes()); // Same as toRawBytes, but returns string.\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n    Point.ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n    const { BASE: G, ZERO: I } = Point;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.wNAF)(Point, nByteLength * 8);\n    function modN(a) {\n        return (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(a, CURVE_ORDER);\n    }\n    // Little-endian SHA512 with modulo n\n    function modN_LE(hash) {\n        return modN(_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberLE(hash));\n    }\n    /** Convenience method that creates public key and other stuff. RFC8032 5.1.5 */\n    function getExtendedPublicKey(key) {\n        const len = nByteLength;\n        key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('private key', key, len);\n        // Hash private key with curve's hash function to produce uniformingly random input\n        // Check byte lengths: ensure(64, h(ensure(32, key)))\n        const hashed = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('hashed private key', cHash(key), 2 * len);\n        const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n        const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n        const scalar = modN_LE(head); // The actual private scalar\n        const point = G.multiply(scalar); // Point on Edwards curve aka public key\n        const pointBytes = point.toRawBytes(); // Uint8Array representation\n        return { head, prefix, scalar, point, pointBytes };\n    }\n    // Calculates EdDSA pub key. RFC8032 5.1.5. Privkey is hashed. Use first half with 3 bits cleared\n    function getPublicKey(privKey) {\n        return getExtendedPublicKey(privKey).pointBytes;\n    }\n    // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n    function hashDomainToScalar(context = new Uint8Array(), ...msgs) {\n        const msg = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(...msgs);\n        return modN_LE(cHash(domain(msg, (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('context', context), !!prehash)));\n    }\n    /** Signs message with privateKey. RFC8032 5.1.6 */\n    function sign(msg, privKey, options = {}) {\n        msg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('message', msg);\n        if (prehash)\n            msg = prehash(msg); // for ed25519ph etc.\n        const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);\n        const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n        const R = G.multiply(r).toRawBytes(); // R = rG\n        const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n        const s = modN(r + k * scalar); // S = (r + k * s) mod L\n        assertGE0(s); // 0 <= s < l\n        const res = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(R, _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesLE(s, Fp.BYTES));\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('result', res, nByteLength * 2); // 64-byte signature\n    }\n    const verifyOpts = VERIFY_DEFAULT;\n    function verify(sig, msg, publicKey, options = verifyOpts) {\n        const { context, zip215 } = options;\n        const len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n        sig = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('signature', sig, 2 * len); // An extended group equation is checked.\n        msg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('message', msg);\n        if (prehash)\n            msg = prehash(msg); // for ed25519ph, etc\n        const s = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberLE(sig.slice(len, 2 * len));\n        // zip215: true is good for consensus-critical apps and allows points < 2^256\n        // zip215: false follows RFC8032 / NIST186-5 and restricts points to CURVE.p\n        let A, R, SB;\n        try {\n            A = Point.fromHex(publicKey, zip215);\n            R = Point.fromHex(sig.slice(0, len), zip215);\n            SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside\n        }\n        catch (error) {\n            return false;\n        }\n        if (!zip215 && A.isSmallOrder())\n            return false;\n        const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);\n        const RkA = R.add(A.multiplyUnsafe(k));\n        // [8][S]B = [8]R + [8][k]A'\n        return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);\n    }\n    G._setWindowSize(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n    const utils = {\n        getExtendedPublicKey,\n        // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.\n        randomPrivateKey: () => randomBytes(Fp.BYTES),\n        /**\n         * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT\n         * values. This slows down first getPublicKey() by milliseconds (see Speed section),\n         * but allows to speed-up subsequent getPublicKey() calls up to 20x.\n         * @param windowSize 2, 4, 8, 16\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3));\n            return point;\n        },\n    };\n    return {\n        CURVE,\n        getPublicKey,\n        sign,\n        verify,\n        ExtendedPoint: Point,\n        utils,\n    };\n}\n//# sourceMappingURL=edwards.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvZWR3YXJkcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNtQztBQUNGO0FBQ1E7QUFDUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGlCQUFpQix3REFBYTtBQUM5QixJQUFJLHFEQUFpQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDTztBQUNQO0FBQ0EsWUFBWSw0RkFBNEY7QUFDeEc7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLFNBQVM7QUFDVCw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsR0FBRztBQUNaLDJEQUEyRDtBQUMzRCxtRUFBbUU7QUFDbkUsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELElBQUksUUFBUSxVQUFVLEVBQUUsRUFBRTtBQUM3RTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQSxv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ZXNtL2Fic3RyYWN0L2Vkd2FyZHMuanM/MDRmYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBUd2lzdGVkIEVkd2FyZHMgY3VydmUuIFRoZSBmb3JtdWxhIGlzOiBheMKyICsgecKyID0gMSArIGR4wrJ5wrJcbmltcG9ydCB7IG1vZCB9IGZyb20gJy4vbW9kdWxhci5qcyc7XG5pbXBvcnQgKiBhcyB1dCBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IGVuc3VyZUJ5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyB3TkFGLCB2YWxpZGF0ZUJhc2ljIH0gZnJvbSAnLi9jdXJ2ZS5qcyc7XG4vLyBCZSBmcmllbmRseSB0byBiYWQgRUNNQVNjcmlwdCBwYXJzZXJzIGJ5IG5vdCB1c2luZyBiaWdpbnQgbGl0ZXJhbHNcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzhuID0gQmlnSW50KDgpO1xuLy8gdmVyaWZpY2F0aW9uIHJ1bGUgaXMgZWl0aGVyIHppcDIxNSBvciByZmM4MDMyIC8gbmlzdDE4Ni01LiBDb25zdWx0IGZyb21IZXg6XG5jb25zdCBWRVJJRllfREVGQVVMVCA9IHsgemlwMjE1OiB0cnVlIH07XG5mdW5jdGlvbiB2YWxpZGF0ZU9wdHMoY3VydmUpIHtcbiAgICBjb25zdCBvcHRzID0gdmFsaWRhdGVCYXNpYyhjdXJ2ZSk7XG4gICAgdXQudmFsaWRhdGVPYmplY3QoY3VydmUsIHtcbiAgICAgICAgaGFzaDogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYTogJ2JpZ2ludCcsXG4gICAgICAgIGQ6ICdiaWdpbnQnLFxuICAgICAgICByYW5kb21CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICB9LCB7XG4gICAgICAgIGFkanVzdFNjYWxhckJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgICAgICBkb21haW46ICdmdW5jdGlvbicsXG4gICAgICAgIHV2UmF0aW86ICdmdW5jdGlvbicsXG4gICAgICAgIG1hcFRvQ3VydmU6ICdmdW5jdGlvbicsXG4gICAgfSk7XG4gICAgLy8gU2V0IGRlZmF1bHRzXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5vcHRzIH0pO1xufVxuLy8gSXQgaXMgbm90IGdlbmVyaWMgdHdpc3RlZCBjdXJ2ZSBmb3Igbm93LCBidXQgZWQyNTUxOS9lZDQ0OCBnZW5lcmljIGltcGxlbWVudGF0aW9uXG5leHBvcnQgZnVuY3Rpb24gdHdpc3RlZEVkd2FyZHMoY3VydmVEZWYpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlT3B0cyhjdXJ2ZURlZik7XG4gICAgY29uc3QgeyBGcCwgbjogQ1VSVkVfT1JERVIsIHByZWhhc2g6IHByZWhhc2gsIGhhc2g6IGNIYXNoLCByYW5kb21CeXRlcywgbkJ5dGVMZW5ndGgsIGg6IGNvZmFjdG9yLCB9ID0gQ1VSVkU7XG4gICAgY29uc3QgTUFTSyA9IF8ybiA8PCAoQmlnSW50KG5CeXRlTGVuZ3RoICogOCkgLSBfMW4pO1xuICAgIGNvbnN0IG1vZFAgPSBGcC5jcmVhdGU7IC8vIEZ1bmN0aW9uIG92ZXJyaWRlc1xuICAgIC8vIHNxcnQodS92KVxuICAgIGNvbnN0IHV2UmF0aW8gPSBDVVJWRS51dlJhdGlvIHx8XG4gICAgICAgICgodSwgdikgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiB0cnVlLCB2YWx1ZTogRnAuc3FydCh1ICogRnAuaW52KHYpKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiBmYWxzZSwgdmFsdWU6IF8wbiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICBjb25zdCBhZGp1c3RTY2FsYXJCeXRlcyA9IENVUlZFLmFkanVzdFNjYWxhckJ5dGVzIHx8ICgoYnl0ZXMpID0+IGJ5dGVzKTsgLy8gTk9PUFxuICAgIGNvbnN0IGRvbWFpbiA9IENVUlZFLmRvbWFpbiB8fFxuICAgICAgICAoKGRhdGEsIGN0eCwgcGhmbGFnKSA9PiB7XG4gICAgICAgICAgICBpZiAoY3R4Lmxlbmd0aCB8fCBwaGZsYWcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb250ZXh0cy9wcmUtaGFzaCBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0pOyAvLyBOT09QXG4gICAgY29uc3QgaW5CaWcgPSAobikgPT4gdHlwZW9mIG4gPT09ICdiaWdpbnQnICYmIF8wbiA8IG47IC8vIG4gaW4gWzEuLl1cbiAgICBjb25zdCBpblJhbmdlID0gKG4sIG1heCkgPT4gaW5CaWcobikgJiYgaW5CaWcobWF4KSAmJiBuIDwgbWF4OyAvLyBuIGluIFsxLi5tYXgtMV1cbiAgICBjb25zdCBpbjBNYXNrUmFuZ2UgPSAobikgPT4gbiA9PT0gXzBuIHx8IGluUmFuZ2UobiwgTUFTSyk7IC8vIG4gaW4gWzAuLk1BU0stMV1cbiAgICBmdW5jdGlvbiBhc3NlcnRJblJhbmdlKG4sIG1heCkge1xuICAgICAgICAvLyBuIGluIFsxLi5tYXgtMV1cbiAgICAgICAgaWYgKGluUmFuZ2UobiwgbWF4KSlcbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIHZhbGlkIHNjYWxhciA8ICR7bWF4fSwgZ290ICR7dHlwZW9mIG59ICR7bn1gKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXNzZXJ0R0UwKG4pIHtcbiAgICAgICAgLy8gbiBpbiBbMC4uQ1VSVkVfT1JERVItMV1cbiAgICAgICAgcmV0dXJuIG4gPT09IF8wbiA/IG4gOiBhc3NlcnRJblJhbmdlKG4sIENVUlZFX09SREVSKTsgLy8gR0UgPSBwcmltZSBzdWJncm91cCwgbm90IGZ1bGwgZ3JvdXBcbiAgICB9XG4gICAgY29uc3QgcG9pbnRQcmVjb21wdXRlcyA9IG5ldyBNYXAoKTtcbiAgICBmdW5jdGlvbiBpc1BvaW50KG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgUG9pbnQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHRlbmRlZFBvaW50IGV4cGVjdGVkJyk7XG4gICAgfVxuICAgIC8vIEV4dGVuZGVkIFBvaW50IHdvcmtzIGluIGV4dGVuZGVkIGNvb3JkaW5hdGVzOiAoeCwgeSwgeiwgdCkg4oiLICh4PXgveiwgeT15L3osIHQ9eHkpLlxuICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1R3aXN0ZWRfRWR3YXJkc19jdXJ2ZSNFeHRlbmRlZF9jb29yZGluYXRlc1xuICAgIGNsYXNzIFBvaW50IHtcbiAgICAgICAgY29uc3RydWN0b3IoZXgsIGV5LCBleiwgZXQpIHtcbiAgICAgICAgICAgIHRoaXMuZXggPSBleDtcbiAgICAgICAgICAgIHRoaXMuZXkgPSBleTtcbiAgICAgICAgICAgIHRoaXMuZXogPSBlejtcbiAgICAgICAgICAgIHRoaXMuZXQgPSBldDtcbiAgICAgICAgICAgIGlmICghaW4wTWFza1JhbmdlKGV4KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ggcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIGlmICghaW4wTWFza1JhbmdlKGV5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3kgcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIGlmICghaW4wTWFza1JhbmdlKGV6KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ogcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIGlmICghaW4wTWFza1JhbmdlKGV0KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3QgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZnJvbUFmZmluZShwKSB7XG4gICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIFBvaW50KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXh0ZW5kZWQgcG9pbnQgbm90IGFsbG93ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcCB8fCB7fTtcbiAgICAgICAgICAgIGlmICghaW4wTWFza1JhbmdlKHgpIHx8ICFpbjBNYXNrUmFuZ2UoeSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFmZmluZSBwb2ludCcpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5LCBfMW4sIG1vZFAoeCAqIHkpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgbm9ybWFsaXplWihwb2ludHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvSW52ID0gRnAuaW52ZXJ0QmF0Y2gocG9pbnRzLm1hcCgocCkgPT4gcC5leikpO1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50cy5tYXAoKHAsIGkpID0+IHAudG9BZmZpbmUodG9JbnZbaV0pKS5tYXAoUG9pbnQuZnJvbUFmZmluZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gXCJQcml2YXRlIG1ldGhvZFwiLCBkb24ndCB1c2UgaXQgZGlyZWN0bHlcbiAgICAgICAgX3NldFdpbmRvd1NpemUod2luZG93U2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5fV0lORE9XX1NJWkUgPSB3aW5kb3dTaXplO1xuICAgICAgICAgICAgcG9pbnRQcmVjb21wdXRlcy5kZWxldGUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90IHJlcXVpcmVkIGZvciBmcm9tSGV4KCksIHdoaWNoIGFsd2F5cyBjcmVhdGVzIHZhbGlkIHBvaW50cy5cbiAgICAgICAgLy8gQ291bGQgYmUgdXNlZnVsIGZvciBmcm9tQWZmaW5lKCkuXG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICAgICAgY29uc3QgeyBhLCBkIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzMCgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBaRVJPJyk7IC8vIFRPRE86IG9wdGltaXplLCB3aXRoIHZhcnMgYmVsb3c/XG4gICAgICAgICAgICAvLyBFcXVhdGlvbiBpbiBhZmZpbmUgY29vcmRpbmF0ZXM6IGF4wrIgKyB5wrIgPSAxICsgZHjCsnnCslxuICAgICAgICAgICAgLy8gRXF1YXRpb24gaW4gcHJvamVjdGl2ZSBjb29yZGluYXRlcyAoWC9aLCBZL1osIFopOiAgKGFYwrIgKyBZwrIpWsKyID0gWuKBtCArIGRYwrJZwrJcbiAgICAgICAgICAgIGNvbnN0IHsgZXg6IFgsIGV5OiBZLCBlejogWiwgZXQ6IFQgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBYMiA9IG1vZFAoWCAqIFgpOyAvLyBYwrJcbiAgICAgICAgICAgIGNvbnN0IFkyID0gbW9kUChZICogWSk7IC8vIFnCslxuICAgICAgICAgICAgY29uc3QgWjIgPSBtb2RQKFogKiBaKTsgLy8gWsKyXG4gICAgICAgICAgICBjb25zdCBaNCA9IG1vZFAoWjIgKiBaMik7IC8vIFrigbRcbiAgICAgICAgICAgIGNvbnN0IGFYMiA9IG1vZFAoWDIgKiBhKTsgLy8gYVjCslxuICAgICAgICAgICAgY29uc3QgbGVmdCA9IG1vZFAoWjIgKiBtb2RQKGFYMiArIFkyKSk7IC8vIChhWMKyICsgWcKyKVrCslxuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBtb2RQKFo0ICsgbW9kUChkICogbW9kUChYMiAqIFkyKSkpOyAvLyBa4oG0ICsgZFjCslnCslxuICAgICAgICAgICAgaWYgKGxlZnQgIT09IHJpZ2h0KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0ICgxKScpO1xuICAgICAgICAgICAgLy8gSW4gRXh0ZW5kZWQgY29vcmRpbmF0ZXMgd2UgYWxzbyBoYXZlIFQsIHdoaWNoIGlzIHgqeT1UL1o6IGNoZWNrIFgqWSA9PSBaKlRcbiAgICAgICAgICAgIGNvbnN0IFhZID0gbW9kUChYICogWSk7XG4gICAgICAgICAgICBjb25zdCBaVCA9IG1vZFAoWiAqIFQpO1xuICAgICAgICAgICAgaWYgKFhZICE9PSBaVClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCAoMiknKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wYXJlIG9uZSBwb2ludCB0byBhbm90aGVyLlxuICAgICAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgICAgIGlzUG9pbnQob3RoZXIpO1xuICAgICAgICAgICAgY29uc3QgeyBleDogWDEsIGV5OiBZMSwgZXo6IFoxIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyBleDogWDIsIGV5OiBZMiwgZXo6IFoyIH0gPSBvdGhlcjtcbiAgICAgICAgICAgIGNvbnN0IFgxWjIgPSBtb2RQKFgxICogWjIpO1xuICAgICAgICAgICAgY29uc3QgWDJaMSA9IG1vZFAoWDIgKiBaMSk7XG4gICAgICAgICAgICBjb25zdCBZMVoyID0gbW9kUChZMSAqIFoyKTtcbiAgICAgICAgICAgIGNvbnN0IFkyWjEgPSBtb2RQKFkyICogWjEpO1xuICAgICAgICAgICAgcmV0dXJuIFgxWjIgPT09IFgyWjEgJiYgWTFaMiA9PT0gWTJaMTtcbiAgICAgICAgfVxuICAgICAgICBpczAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcXVhbHMoUG9pbnQuWkVSTyk7XG4gICAgICAgIH1cbiAgICAgICAgbmVnYXRlKCkge1xuICAgICAgICAgICAgLy8gRmxpcHMgcG9pbnQgc2lnbiB0byBhIG5lZ2F0aXZlIG9uZSAoLXgsIHkgaW4gYWZmaW5lIGNvb3JkcylcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQobW9kUCgtdGhpcy5leCksIHRoaXMuZXksIHRoaXMuZXosIG1vZFAoLXRoaXMuZXQpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGYXN0IGFsZ28gZm9yIGRvdWJsaW5nIEV4dGVuZGVkIFBvaW50LlxuICAgICAgICAvLyBodHRwczovL2h5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by10d2lzdGVkLWV4dGVuZGVkLmh0bWwjZG91YmxpbmctZGJsLTIwMDgtaHdjZFxuICAgICAgICAvLyBDb3N0OiA0TSArIDRTICsgMSphICsgNmFkZCArIDEqMi5cbiAgICAgICAgZG91YmxlKCkge1xuICAgICAgICAgICAgY29uc3QgeyBhIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGNvbnN0IHsgZXg6IFgxLCBleTogWTEsIGV6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IEEgPSBtb2RQKFgxICogWDEpOyAvLyBBID0gWDEyXG4gICAgICAgICAgICBjb25zdCBCID0gbW9kUChZMSAqIFkxKTsgLy8gQiA9IFkxMlxuICAgICAgICAgICAgY29uc3QgQyA9IG1vZFAoXzJuICogbW9kUChaMSAqIFoxKSk7IC8vIEMgPSAyKloxMlxuICAgICAgICAgICAgY29uc3QgRCA9IG1vZFAoYSAqIEEpOyAvLyBEID0gYSpBXG4gICAgICAgICAgICBjb25zdCB4MXkxID0gWDEgKyBZMTtcbiAgICAgICAgICAgIGNvbnN0IEUgPSBtb2RQKG1vZFAoeDF5MSAqIHgxeTEpIC0gQSAtIEIpOyAvLyBFID0gKFgxK1kxKTItQS1CXG4gICAgICAgICAgICBjb25zdCBHID0gRCArIEI7IC8vIEcgPSBEK0JcbiAgICAgICAgICAgIGNvbnN0IEYgPSBHIC0gQzsgLy8gRiA9IEctQ1xuICAgICAgICAgICAgY29uc3QgSCA9IEQgLSBCOyAvLyBIID0gRC1CXG4gICAgICAgICAgICBjb25zdCBYMyA9IG1vZFAoRSAqIEYpOyAvLyBYMyA9IEUqRlxuICAgICAgICAgICAgY29uc3QgWTMgPSBtb2RQKEcgKiBIKTsgLy8gWTMgPSBHKkhcbiAgICAgICAgICAgIGNvbnN0IFQzID0gbW9kUChFICogSCk7IC8vIFQzID0gRSpIXG4gICAgICAgICAgICBjb25zdCBaMyA9IG1vZFAoRiAqIEcpOyAvLyBaMyA9IEYqR1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozLCBUMyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmFzdCBhbGdvIGZvciBhZGRpbmcgMiBFeHRlbmRlZCBQb2ludHMuXG4gICAgICAgIC8vIGh0dHBzOi8vaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXR3aXN0ZWQtZXh0ZW5kZWQuaHRtbCNhZGRpdGlvbi1hZGQtMjAwOC1od2NkXG4gICAgICAgIC8vIENvc3Q6IDlNICsgMSphICsgMSpkICsgN2FkZC5cbiAgICAgICAgYWRkKG90aGVyKSB7XG4gICAgICAgICAgICBpc1BvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgYSwgZCB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBjb25zdCB7IGV4OiBYMSwgZXk6IFkxLCBlejogWjEsIGV0OiBUMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgZXg6IFgyLCBleTogWTIsIGV6OiBaMiwgZXQ6IFQyIH0gPSBvdGhlcjtcbiAgICAgICAgICAgIC8vIEZhc3RlciBhbGdvIGZvciBhZGRpbmcgMiBFeHRlbmRlZCBQb2ludHMgd2hlbiBjdXJ2ZSdzIGE9LTEuXG4gICAgICAgICAgICAvLyBodHRwOi8vaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXR3aXN0ZWQtZXh0ZW5kZWQtMS5odG1sI2FkZGl0aW9uLWFkZC0yMDA4LWh3Y2QtNFxuICAgICAgICAgICAgLy8gQ29zdDogOE0gKyA4YWRkICsgMioyLlxuICAgICAgICAgICAgLy8gTm90ZTogSXQgZG9lcyBub3QgY2hlY2sgd2hldGhlciB0aGUgYG90aGVyYCBwb2ludCBpcyB2YWxpZC5cbiAgICAgICAgICAgIGlmIChhID09PSBCaWdJbnQoLTEpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgQSA9IG1vZFAoKFkxIC0gWDEpICogKFkyICsgWDIpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBCID0gbW9kUCgoWTEgKyBYMSkgKiAoWTIgLSBYMikpO1xuICAgICAgICAgICAgICAgIGNvbnN0IEYgPSBtb2RQKEIgLSBBKTtcbiAgICAgICAgICAgICAgICBpZiAoRiA9PT0gXzBuKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kb3VibGUoKTsgLy8gU2FtZSBwb2ludC4gVGVzdHMgc2F5IGl0IGRvZXNuJ3QgYWZmZWN0IHRpbWluZ1xuICAgICAgICAgICAgICAgIGNvbnN0IEMgPSBtb2RQKFoxICogXzJuICogVDIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IEQgPSBtb2RQKFQxICogXzJuICogWjIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IEUgPSBEICsgQztcbiAgICAgICAgICAgICAgICBjb25zdCBHID0gQiArIEE7XG4gICAgICAgICAgICAgICAgY29uc3QgSCA9IEQgLSBDO1xuICAgICAgICAgICAgICAgIGNvbnN0IFgzID0gbW9kUChFICogRik7XG4gICAgICAgICAgICAgICAgY29uc3QgWTMgPSBtb2RQKEcgKiBIKTtcbiAgICAgICAgICAgICAgICBjb25zdCBUMyA9IG1vZFAoRSAqIEgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IFozID0gbW9kUChGICogRyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozLCBUMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBBID0gbW9kUChYMSAqIFgyKTsgLy8gQSA9IFgxKlgyXG4gICAgICAgICAgICBjb25zdCBCID0gbW9kUChZMSAqIFkyKTsgLy8gQiA9IFkxKlkyXG4gICAgICAgICAgICBjb25zdCBDID0gbW9kUChUMSAqIGQgKiBUMik7IC8vIEMgPSBUMSpkKlQyXG4gICAgICAgICAgICBjb25zdCBEID0gbW9kUChaMSAqIFoyKTsgLy8gRCA9IFoxKloyXG4gICAgICAgICAgICBjb25zdCBFID0gbW9kUCgoWDEgKyBZMSkgKiAoWDIgKyBZMikgLSBBIC0gQik7IC8vIEUgPSAoWDErWTEpKihYMitZMiktQS1CXG4gICAgICAgICAgICBjb25zdCBGID0gRCAtIEM7IC8vIEYgPSBELUNcbiAgICAgICAgICAgIGNvbnN0IEcgPSBEICsgQzsgLy8gRyA9IEQrQ1xuICAgICAgICAgICAgY29uc3QgSCA9IG1vZFAoQiAtIGEgKiBBKTsgLy8gSCA9IEItYSpBXG4gICAgICAgICAgICBjb25zdCBYMyA9IG1vZFAoRSAqIEYpOyAvLyBYMyA9IEUqRlxuICAgICAgICAgICAgY29uc3QgWTMgPSBtb2RQKEcgKiBIKTsgLy8gWTMgPSBHKkhcbiAgICAgICAgICAgIGNvbnN0IFQzID0gbW9kUChFICogSCk7IC8vIFQzID0gRSpIXG4gICAgICAgICAgICBjb25zdCBaMyA9IG1vZFAoRiAqIEcpOyAvLyBaMyA9IEYqR1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozLCBUMyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgd05BRihuKSB7XG4gICAgICAgICAgICByZXR1cm4gd25hZi53TkFGQ2FjaGVkKHRoaXMsIHBvaW50UHJlY29tcHV0ZXMsIG4sIFBvaW50Lm5vcm1hbGl6ZVopO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnN0YW50LXRpbWUgbXVsdGlwbGljYXRpb24uXG4gICAgICAgIG11bHRpcGx5KHNjYWxhcikge1xuICAgICAgICAgICAgY29uc3QgeyBwLCBmIH0gPSB0aGlzLndOQUYoYXNzZXJ0SW5SYW5nZShzY2FsYXIsIENVUlZFX09SREVSKSk7XG4gICAgICAgICAgICByZXR1cm4gUG9pbnQubm9ybWFsaXplWihbcCwgZl0pWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vbi1jb25zdGFudC10aW1lIG11bHRpcGxpY2F0aW9uLiBVc2VzIGRvdWJsZS1hbmQtYWRkIGFsZ29yaXRobS5cbiAgICAgICAgLy8gSXQncyBmYXN0ZXIsIGJ1dCBzaG91bGQgb25seSBiZSB1c2VkIHdoZW4geW91IGRvbid0IGNhcmUgYWJvdXRcbiAgICAgICAgLy8gYW4gZXhwb3NlZCBwcml2YXRlIGtleSBlLmcuIHNpZyB2ZXJpZmljYXRpb24uXG4gICAgICAgIC8vIERvZXMgTk9UIGFsbG93IHNjYWxhcnMgaGlnaGVyIHRoYW4gQ1VSVkUubi5cbiAgICAgICAgbXVsdGlwbHlVbnNhZmUoc2NhbGFyKSB7XG4gICAgICAgICAgICBsZXQgbiA9IGFzc2VydEdFMChzY2FsYXIpOyAvLyAwIDw9IHNjYWxhciA8IENVUlZFLm5cbiAgICAgICAgICAgIGlmIChuID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIEk7XG4gICAgICAgICAgICBpZiAodGhpcy5lcXVhbHMoSSkgfHwgbiA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgaWYgKHRoaXMuZXF1YWxzKEcpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndOQUYobikucDtcbiAgICAgICAgICAgIHJldHVybiB3bmFmLnVuc2FmZUxhZGRlcih0aGlzLCBuKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVja3MgaWYgcG9pbnQgaXMgb2Ygc21hbGwgb3JkZXIuXG4gICAgICAgIC8vIElmIHlvdSBhZGQgc29tZXRoaW5nIHRvIHNtYWxsIG9yZGVyIHBvaW50LCB5b3Ugd2lsbCBoYXZlIFwiZGlydHlcIlxuICAgICAgICAvLyBwb2ludCB3aXRoIHRvcnNpb24gY29tcG9uZW50LlxuICAgICAgICAvLyBNdWx0aXBsaWVzIHBvaW50IGJ5IGNvZmFjdG9yIGFuZCBjaGVja3MgaWYgdGhlIHJlc3VsdCBpcyAwLlxuICAgICAgICBpc1NtYWxsT3JkZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVVuc2FmZShjb2ZhY3RvcikuaXMwKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVsdGlwbGllcyBwb2ludCBieSBjdXJ2ZSBvcmRlciBhbmQgY2hlY2tzIGlmIHRoZSByZXN1bHQgaXMgMC5cbiAgICAgICAgLy8gUmV0dXJucyBgZmFsc2VgIGlzIHRoZSBwb2ludCBpcyBkaXJ0eS5cbiAgICAgICAgaXNUb3JzaW9uRnJlZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB3bmFmLnVuc2FmZUxhZGRlcih0aGlzLCBDVVJWRV9PUkRFUikuaXMwKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29udmVydHMgRXh0ZW5kZWQgcG9pbnQgdG8gZGVmYXVsdCAoeCwgeSkgY29vcmRpbmF0ZXMuXG4gICAgICAgIC8vIENhbiBhY2NlcHQgcHJlY29tcHV0ZWQgWl4tMSAtIGZvciBleGFtcGxlLCBmcm9tIGludmVydEJhdGNoLlxuICAgICAgICB0b0FmZmluZShpeikge1xuICAgICAgICAgICAgY29uc3QgeyBleDogeCwgZXk6IHksIGV6OiB6IH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgaXMwID0gdGhpcy5pczAoKTtcbiAgICAgICAgICAgIGlmIChpeiA9PSBudWxsKVxuICAgICAgICAgICAgICAgIGl6ID0gaXMwID8gXzhuIDogRnAuaW52KHopOyAvLyA4IHdhcyBjaG9zZW4gYXJiaXRyYXJpbHlcbiAgICAgICAgICAgIGNvbnN0IGF4ID0gbW9kUCh4ICogaXopO1xuICAgICAgICAgICAgY29uc3QgYXkgPSBtb2RQKHkgKiBpeik7XG4gICAgICAgICAgICBjb25zdCB6eiA9IG1vZFAoeiAqIGl6KTtcbiAgICAgICAgICAgIGlmIChpczApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogXzBuLCB5OiBfMW4gfTtcbiAgICAgICAgICAgIGlmICh6eiAhPT0gXzFuKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52WiB3YXMgaW52YWxpZCcpO1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogYXgsIHk6IGF5IH07XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJDb2ZhY3RvcigpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaDogY29mYWN0b3IgfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVVuc2FmZShjb2ZhY3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29udmVydHMgaGFzaCBzdHJpbmcgb3IgVWludDhBcnJheSB0byBQb2ludC5cbiAgICAgICAgLy8gVXNlcyBhbGdvIGZyb20gUkZDODAzMiA1LjEuMy5cbiAgICAgICAgc3RhdGljIGZyb21IZXgoaGV4LCB6aXAyMTUgPSBmYWxzZSkge1xuICAgICAgICAgICAgY29uc3QgeyBkLCBhIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IEZwLkJZVEVTO1xuICAgICAgICAgICAgaGV4ID0gZW5zdXJlQnl0ZXMoJ3BvaW50SGV4JywgaGV4LCBsZW4pOyAvLyBjb3B5IGhleCB0byBhIG5ldyBhcnJheVxuICAgICAgICAgICAgY29uc3Qgbm9ybWVkID0gaGV4LnNsaWNlKCk7IC8vIGNvcHkgYWdhaW4sIHdlJ2xsIG1hbmlwdWxhdGUgaXRcbiAgICAgICAgICAgIGNvbnN0IGxhc3RCeXRlID0gaGV4W2xlbiAtIDFdOyAvLyBzZWxlY3QgbGFzdCBieXRlXG4gICAgICAgICAgICBub3JtZWRbbGVuIC0gMV0gPSBsYXN0Qnl0ZSAmIH4weDgwOyAvLyBjbGVhciBsYXN0IGJpdFxuICAgICAgICAgICAgY29uc3QgeSA9IHV0LmJ5dGVzVG9OdW1iZXJMRShub3JtZWQpO1xuICAgICAgICAgICAgaWYgKHkgPT09IF8wbikge1xuICAgICAgICAgICAgICAgIC8vIHk9MCBpcyBhbGxvd2VkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBSRkM4MDMyIHByb2hpYml0cyA+PSBwLCBidXQgWklQMjE1IGRvZXNuJ3RcbiAgICAgICAgICAgICAgICBpZiAoemlwMjE1KVxuICAgICAgICAgICAgICAgICAgICBhc3NlcnRJblJhbmdlKHksIE1BU0spOyAvLyB6aXAyMTU9dHJ1ZSBbMS4uUC0xXSAoMl4yNTUtMTktMSBmb3IgZWQyNTUxOSlcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydEluUmFuZ2UoeSwgRnAuT1JERVIpOyAvLyB6aXAyMTU9ZmFsc2UgWzEuLk1BU0stMV0gKDJeMjU2LTEgZm9yIGVkMjU1MTkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFZDI1NTE5OiB4wrIgPSAoecKyLTEpLyhkecKyKzEpIG1vZCBwLiBFZDQ0ODogeMKyID0gKHnCsi0xKS8oZHnCsi0xKSBtb2QgcC4gR2VuZXJpYyBjYXNlOlxuICAgICAgICAgICAgLy8gYXjCsit5wrI9MStkeMKyecKyID0+IHnCsi0xPWR4wrJ5wrItYXjCsiA9PiB5wrItMT14wrIoZHnCsi1hKSA9PiB4wrI9KHnCsi0xKS8oZHnCsi1hKVxuICAgICAgICAgICAgY29uc3QgeTIgPSBtb2RQKHkgKiB5KTsgLy8gZGVub21pbmF0b3IgaXMgYWx3YXlzIG5vbi0wIG1vZCBwLlxuICAgICAgICAgICAgY29uc3QgdSA9IG1vZFAoeTIgLSBfMW4pOyAvLyB1ID0gecKyIC0gMVxuICAgICAgICAgICAgY29uc3QgdiA9IG1vZFAoZCAqIHkyIC0gYSk7IC8vIHYgPSBkIHnCsiArIDEuXG4gICAgICAgICAgICBsZXQgeyBpc1ZhbGlkLCB2YWx1ZTogeCB9ID0gdXZSYXRpbyh1LCB2KTsgLy8g4oiaKHUvdilcbiAgICAgICAgICAgIGlmICghaXNWYWxpZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50LmZyb21IZXg6IGludmFsaWQgeSBjb29yZGluYXRlJyk7XG4gICAgICAgICAgICBjb25zdCBpc1hPZGQgPSAoeCAmIF8xbikgPT09IF8xbjsgLy8gVGhlcmUgYXJlIDIgc3F1YXJlIHJvb3RzLiBVc2UgeF8wIGJpdCB0byBzZWxlY3QgcHJvcGVyXG4gICAgICAgICAgICBjb25zdCBpc0xhc3RCeXRlT2RkID0gKGxhc3RCeXRlICYgMHg4MCkgIT09IDA7IC8vIHhfMCwgbGFzdCBiaXRcbiAgICAgICAgICAgIGlmICghemlwMjE1ICYmIHggPT09IF8wbiAmJiBpc0xhc3RCeXRlT2RkKVxuICAgICAgICAgICAgICAgIC8vIGlmIHg9MCBhbmQgeF8wID0gMSwgZmFpbFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9pbnQuZnJvbUhleDogeD0wIGFuZCB4XzA9MScpO1xuICAgICAgICAgICAgaWYgKGlzTGFzdEJ5dGVPZGQgIT09IGlzWE9kZClcbiAgICAgICAgICAgICAgICB4ID0gbW9kUCgteCk7IC8vIGlmIHhfMCAhPSB4IG1vZCAyLCBzZXQgeCA9IHAteFxuICAgICAgICAgICAgcmV0dXJuIFBvaW50LmZyb21BZmZpbmUoeyB4LCB5IH0pO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBmcm9tUHJpdmF0ZUtleShwcml2S2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0RXh0ZW5kZWRQdWJsaWNLZXkocHJpdktleSkucG9pbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdG9SYXdCeXRlcygpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSB1dC5udW1iZXJUb0J5dGVzTEUoeSwgRnAuQllURVMpOyAvLyBlYWNoIHkgaGFzIDIgeCB2YWx1ZXMgKHgsIC15KVxuICAgICAgICAgICAgYnl0ZXNbYnl0ZXMubGVuZ3RoIC0gMV0gfD0geCAmIF8xbiA/IDB4ODAgOiAwOyAvLyB3aGVuIGNvbXByZXNzaW5nLCBpdCdzIGVub3VnaCB0byBzdG9yZSB5XG4gICAgICAgICAgICByZXR1cm4gYnl0ZXM7IC8vIGFuZCB1c2UgdGhlIGxhc3QgYnl0ZSB0byBlbmNvZGUgc2lnbiBvZiB4XG4gICAgICAgIH1cbiAgICAgICAgdG9IZXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdXQuYnl0ZXNUb0hleCh0aGlzLnRvUmF3Qnl0ZXMoKSk7IC8vIFNhbWUgYXMgdG9SYXdCeXRlcywgYnV0IHJldHVybnMgc3RyaW5nLlxuICAgICAgICB9XG4gICAgfVxuICAgIFBvaW50LkJBU0UgPSBuZXcgUG9pbnQoQ1VSVkUuR3gsIENVUlZFLkd5LCBfMW4sIG1vZFAoQ1VSVkUuR3ggKiBDVVJWRS5HeSkpO1xuICAgIFBvaW50LlpFUk8gPSBuZXcgUG9pbnQoXzBuLCBfMW4sIF8xbiwgXzBuKTsgLy8gMCwgMSwgMSwgMFxuICAgIGNvbnN0IHsgQkFTRTogRywgWkVSTzogSSB9ID0gUG9pbnQ7XG4gICAgY29uc3Qgd25hZiA9IHdOQUYoUG9pbnQsIG5CeXRlTGVuZ3RoICogOCk7XG4gICAgZnVuY3Rpb24gbW9kTihhKSB7XG4gICAgICAgIHJldHVybiBtb2QoYSwgQ1VSVkVfT1JERVIpO1xuICAgIH1cbiAgICAvLyBMaXR0bGUtZW5kaWFuIFNIQTUxMiB3aXRoIG1vZHVsbyBuXG4gICAgZnVuY3Rpb24gbW9kTl9MRShoYXNoKSB7XG4gICAgICAgIHJldHVybiBtb2ROKHV0LmJ5dGVzVG9OdW1iZXJMRShoYXNoKSk7XG4gICAgfVxuICAgIC8qKiBDb252ZW5pZW5jZSBtZXRob2QgdGhhdCBjcmVhdGVzIHB1YmxpYyBrZXkgYW5kIG90aGVyIHN0dWZmLiBSRkM4MDMyIDUuMS41ICovXG4gICAgZnVuY3Rpb24gZ2V0RXh0ZW5kZWRQdWJsaWNLZXkoa2V5KSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IG5CeXRlTGVuZ3RoO1xuICAgICAgICBrZXkgPSBlbnN1cmVCeXRlcygncHJpdmF0ZSBrZXknLCBrZXksIGxlbik7XG4gICAgICAgIC8vIEhhc2ggcHJpdmF0ZSBrZXkgd2l0aCBjdXJ2ZSdzIGhhc2ggZnVuY3Rpb24gdG8gcHJvZHVjZSB1bmlmb3JtaW5nbHkgcmFuZG9tIGlucHV0XG4gICAgICAgIC8vIENoZWNrIGJ5dGUgbGVuZ3RoczogZW5zdXJlKDY0LCBoKGVuc3VyZSgzMiwga2V5KSkpXG4gICAgICAgIGNvbnN0IGhhc2hlZCA9IGVuc3VyZUJ5dGVzKCdoYXNoZWQgcHJpdmF0ZSBrZXknLCBjSGFzaChrZXkpLCAyICogbGVuKTtcbiAgICAgICAgY29uc3QgaGVhZCA9IGFkanVzdFNjYWxhckJ5dGVzKGhhc2hlZC5zbGljZSgwLCBsZW4pKTsgLy8gY2xlYXIgZmlyc3QgaGFsZiBiaXRzLCBwcm9kdWNlIEZFXG4gICAgICAgIGNvbnN0IHByZWZpeCA9IGhhc2hlZC5zbGljZShsZW4sIDIgKiBsZW4pOyAvLyBzZWNvbmQgaGFsZiBpcyBjYWxsZWQga2V5IHByZWZpeCAoNS4xLjYpXG4gICAgICAgIGNvbnN0IHNjYWxhciA9IG1vZE5fTEUoaGVhZCk7IC8vIFRoZSBhY3R1YWwgcHJpdmF0ZSBzY2FsYXJcbiAgICAgICAgY29uc3QgcG9pbnQgPSBHLm11bHRpcGx5KHNjYWxhcik7IC8vIFBvaW50IG9uIEVkd2FyZHMgY3VydmUgYWthIHB1YmxpYyBrZXlcbiAgICAgICAgY29uc3QgcG9pbnRCeXRlcyA9IHBvaW50LnRvUmF3Qnl0ZXMoKTsgLy8gVWludDhBcnJheSByZXByZXNlbnRhdGlvblxuICAgICAgICByZXR1cm4geyBoZWFkLCBwcmVmaXgsIHNjYWxhciwgcG9pbnQsIHBvaW50Qnl0ZXMgfTtcbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlcyBFZERTQSBwdWIga2V5LiBSRkM4MDMyIDUuMS41LiBQcml2a2V5IGlzIGhhc2hlZC4gVXNlIGZpcnN0IGhhbGYgd2l0aCAzIGJpdHMgY2xlYXJlZFxuICAgIGZ1bmN0aW9uIGdldFB1YmxpY0tleShwcml2S2V5KSB7XG4gICAgICAgIHJldHVybiBnZXRFeHRlbmRlZFB1YmxpY0tleShwcml2S2V5KS5wb2ludEJ5dGVzO1xuICAgIH1cbiAgICAvLyBpbnQoJ0xFJywgU0hBNTEyKGRvbTIoRiwgQykgfHwgbXNncykpIG1vZCBOXG4gICAgZnVuY3Rpb24gaGFzaERvbWFpblRvU2NhbGFyKGNvbnRleHQgPSBuZXcgVWludDhBcnJheSgpLCAuLi5tc2dzKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IHV0LmNvbmNhdEJ5dGVzKC4uLm1zZ3MpO1xuICAgICAgICByZXR1cm4gbW9kTl9MRShjSGFzaChkb21haW4obXNnLCBlbnN1cmVCeXRlcygnY29udGV4dCcsIGNvbnRleHQpLCAhIXByZWhhc2gpKSk7XG4gICAgfVxuICAgIC8qKiBTaWducyBtZXNzYWdlIHdpdGggcHJpdmF0ZUtleS4gUkZDODAzMiA1LjEuNiAqL1xuICAgIGZ1bmN0aW9uIHNpZ24obXNnLCBwcml2S2V5LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgbXNnID0gZW5zdXJlQnl0ZXMoJ21lc3NhZ2UnLCBtc2cpO1xuICAgICAgICBpZiAocHJlaGFzaClcbiAgICAgICAgICAgIG1zZyA9IHByZWhhc2gobXNnKTsgLy8gZm9yIGVkMjU1MTlwaCBldGMuXG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCBzY2FsYXIsIHBvaW50Qnl0ZXMgfSA9IGdldEV4dGVuZGVkUHVibGljS2V5KHByaXZLZXkpO1xuICAgICAgICBjb25zdCByID0gaGFzaERvbWFpblRvU2NhbGFyKG9wdGlvbnMuY29udGV4dCwgcHJlZml4LCBtc2cpOyAvLyByID0gZG9tMihGLCBDKSB8fCBwcmVmaXggfHwgUEgoTSlcbiAgICAgICAgY29uc3QgUiA9IEcubXVsdGlwbHkocikudG9SYXdCeXRlcygpOyAvLyBSID0gckdcbiAgICAgICAgY29uc3QgayA9IGhhc2hEb21haW5Ub1NjYWxhcihvcHRpb25zLmNvbnRleHQsIFIsIHBvaW50Qnl0ZXMsIG1zZyk7IC8vIFIgfHwgQSB8fCBQSChNKVxuICAgICAgICBjb25zdCBzID0gbW9kTihyICsgayAqIHNjYWxhcik7IC8vIFMgPSAociArIGsgKiBzKSBtb2QgTFxuICAgICAgICBhc3NlcnRHRTAocyk7IC8vIDAgPD0gcyA8IGxcbiAgICAgICAgY29uc3QgcmVzID0gdXQuY29uY2F0Qnl0ZXMoUiwgdXQubnVtYmVyVG9CeXRlc0xFKHMsIEZwLkJZVEVTKSk7XG4gICAgICAgIHJldHVybiBlbnN1cmVCeXRlcygncmVzdWx0JywgcmVzLCBuQnl0ZUxlbmd0aCAqIDIpOyAvLyA2NC1ieXRlIHNpZ25hdHVyZVxuICAgIH1cbiAgICBjb25zdCB2ZXJpZnlPcHRzID0gVkVSSUZZX0RFRkFVTFQ7XG4gICAgZnVuY3Rpb24gdmVyaWZ5KHNpZywgbXNnLCBwdWJsaWNLZXksIG9wdGlvbnMgPSB2ZXJpZnlPcHRzKSB7XG4gICAgICAgIGNvbnN0IHsgY29udGV4dCwgemlwMjE1IH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBsZW4gPSBGcC5CWVRFUzsgLy8gVmVyaWZpZXMgRWREU0Egc2lnbmF0dXJlIGFnYWluc3QgbWVzc2FnZSBhbmQgcHVibGljIGtleS4gUkZDODAzMiA1LjEuNy5cbiAgICAgICAgc2lnID0gZW5zdXJlQnl0ZXMoJ3NpZ25hdHVyZScsIHNpZywgMiAqIGxlbik7IC8vIEFuIGV4dGVuZGVkIGdyb3VwIGVxdWF0aW9uIGlzIGNoZWNrZWQuXG4gICAgICAgIG1zZyA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbXNnKTtcbiAgICAgICAgaWYgKHByZWhhc2gpXG4gICAgICAgICAgICBtc2cgPSBwcmVoYXNoKG1zZyk7IC8vIGZvciBlZDI1NTE5cGgsIGV0Y1xuICAgICAgICBjb25zdCBzID0gdXQuYnl0ZXNUb051bWJlckxFKHNpZy5zbGljZShsZW4sIDIgKiBsZW4pKTtcbiAgICAgICAgLy8gemlwMjE1OiB0cnVlIGlzIGdvb2QgZm9yIGNvbnNlbnN1cy1jcml0aWNhbCBhcHBzIGFuZCBhbGxvd3MgcG9pbnRzIDwgMl4yNTZcbiAgICAgICAgLy8gemlwMjE1OiBmYWxzZSBmb2xsb3dzIFJGQzgwMzIgLyBOSVNUMTg2LTUgYW5kIHJlc3RyaWN0cyBwb2ludHMgdG8gQ1VSVkUucFxuICAgICAgICBsZXQgQSwgUiwgU0I7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBBID0gUG9pbnQuZnJvbUhleChwdWJsaWNLZXksIHppcDIxNSk7XG4gICAgICAgICAgICBSID0gUG9pbnQuZnJvbUhleChzaWcuc2xpY2UoMCwgbGVuKSwgemlwMjE1KTtcbiAgICAgICAgICAgIFNCID0gRy5tdWx0aXBseVVuc2FmZShzKTsgLy8gMCA8PSBzIDwgbCBpcyBkb25lIGluc2lkZVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghemlwMjE1ICYmIEEuaXNTbWFsbE9yZGVyKCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGsgPSBoYXNoRG9tYWluVG9TY2FsYXIoY29udGV4dCwgUi50b1Jhd0J5dGVzKCksIEEudG9SYXdCeXRlcygpLCBtc2cpO1xuICAgICAgICBjb25zdCBSa0EgPSBSLmFkZChBLm11bHRpcGx5VW5zYWZlKGspKTtcbiAgICAgICAgLy8gWzhdW1NdQiA9IFs4XVIgKyBbOF1ba11BJ1xuICAgICAgICByZXR1cm4gUmtBLnN1YnRyYWN0KFNCKS5jbGVhckNvZmFjdG9yKCkuZXF1YWxzKFBvaW50LlpFUk8pO1xuICAgIH1cbiAgICBHLl9zZXRXaW5kb3dTaXplKDgpOyAvLyBFbmFibGUgcHJlY29tcHV0ZXMuIFNsb3dzIGRvd24gZmlyc3QgcHVibGljS2V5IGNvbXB1dGF0aW9uIGJ5IDIwbXMuXG4gICAgY29uc3QgdXRpbHMgPSB7XG4gICAgICAgIGdldEV4dGVuZGVkUHVibGljS2V5LFxuICAgICAgICAvLyBlZDI1NTE5IHByaXZhdGUga2V5cyBhcmUgdW5pZm9ybSAzMmIuIE5vIG5lZWQgdG8gY2hlY2sgZm9yIG1vZHVsbyBiaWFzLCBsaWtlIGluIHNlY3AyNTZrMS5cbiAgICAgICAgcmFuZG9tUHJpdmF0ZUtleTogKCkgPT4gcmFuZG9tQnl0ZXMoRnAuQllURVMpLFxuICAgICAgICAvKipcbiAgICAgICAgICogV2UncmUgZG9pbmcgc2NhbGFyIG11bHRpcGxpY2F0aW9uICh1c2VkIGluIGdldFB1YmxpY0tleSBldGMpIHdpdGggcHJlY29tcHV0ZWQgQkFTRV9QT0lOVFxuICAgICAgICAgKiB2YWx1ZXMuIFRoaXMgc2xvd3MgZG93biBmaXJzdCBnZXRQdWJsaWNLZXkoKSBieSBtaWxsaXNlY29uZHMgKHNlZSBTcGVlZCBzZWN0aW9uKSxcbiAgICAgICAgICogYnV0IGFsbG93cyB0byBzcGVlZC11cCBzdWJzZXF1ZW50IGdldFB1YmxpY0tleSgpIGNhbGxzIHVwIHRvIDIweC5cbiAgICAgICAgICogQHBhcmFtIHdpbmRvd1NpemUgMiwgNCwgOCwgMTZcbiAgICAgICAgICovXG4gICAgICAgIHByZWNvbXB1dGUod2luZG93U2l6ZSA9IDgsIHBvaW50ID0gUG9pbnQuQkFTRSkge1xuICAgICAgICAgICAgcG9pbnQuX3NldFdpbmRvd1NpemUod2luZG93U2l6ZSk7XG4gICAgICAgICAgICBwb2ludC5tdWx0aXBseShCaWdJbnQoMykpO1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIGdldFB1YmxpY0tleSxcbiAgICAgICAgc2lnbixcbiAgICAgICAgdmVyaWZ5LFxuICAgICAgICBFeHRlbmRlZFBvaW50OiBQb2ludCxcbiAgICAgICAgdXRpbHMsXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVkd2FyZHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/edwards.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/hash-to-curve.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/@noble/curves/esm/abstract/hash-to-curve.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHasher: function() { return /* binding */ createHasher; },\n/* harmony export */   expand_message_xmd: function() { return /* binding */ expand_message_xmd; },\n/* harmony export */   expand_message_xof: function() { return /* binding */ expand_message_xof; },\n/* harmony export */   hash_to_field: function() { return /* binding */ hash_to_field; },\n/* harmony export */   isogenyMap: function() { return /* binding */ isogenyMap; }\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/utils.js\");\n\n\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    if (value < 0 || value >= 1 << (8 * length)) {\n        throw new Error(`bad I2OSP call: value=${value} length=${length}`);\n    }\n    const res = Array.from({ length }).fill(0);\n    for (let i = length - 1; i >= 0; i--) {\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for (let i = 0; i < a.length; i++) {\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction anum(item) {\n    if (!Number.isSafeInteger(item))\n        throw new Error('number expected');\n}\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255)\n        DST = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (ell > 255)\n        throw new Error('Invalid xmd length');\n    const DST_prime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for (let i = 1; i <= ell; i++) {\n        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n        b[i] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n// Produces a uniformly random byte string using an extendable-output function (XOF) H.\n// 1. The collision resistance of H MUST be at least k bits.\n// 2. H MUST be an XOF that has been proved indifferentiable from\n//    a random oracle under a reasonable cryptographic assumption.\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil((2 * k) / 8);\n        DST = H.create({ dkLen }).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255)\n        throw new Error('expand_message_xof: invalid lenInBytes');\n    return (H.create({ dkLen: lenInBytes })\n        .update(msg)\n        .update(i2osp(lenInBytes, 2))\n        // 2. DST_prime = DST || I2OSP(len(DST), 1)\n        .update(DST)\n        .update(i2osp(DST.length, 1))\n        .digest());\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://www.rfc-editor.org/rfc/rfc9380#section-5.2\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nfunction hash_to_field(msg, count, options) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(options, {\n        DST: 'stringOrUint8Array',\n        p: 'bigint',\n        m: 'isSafeInteger',\n        k: 'isSafeInteger',\n        hash: 'hash',\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    anum(count);\n    const DST = typeof _DST === 'string' ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(_DST) : _DST;\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === 'xmd') {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    }\n    else if (expand === 'xof') {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    }\n    else if (expand === '_internal_pass') {\n        // for internal tests only\n        prb = msg;\n    }\n    else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const e = new Array(m);\n        for (let j = 0; j < m; j++) {\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i) => Array.from(i).reverse());\n    return (x, y) => {\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return { x, y };\n    };\n}\nfunction createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== 'function')\n        throw new Error('mapToCurve() must be defined');\n    return {\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve(msg, options) {\n            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve(msg, options) {\n            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n    };\n}\n//# sourceMappingURL=hash-to-curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQW1DO0FBQzREO0FBQy9GO0FBQ0EsY0FBYyxzREFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTyxTQUFTLE9BQU87QUFDeEU7QUFDQSw2QkFBNkIsUUFBUTtBQUNyQyw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxJQUFJLGlEQUFNO0FBQ1YsSUFBSSxpREFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzREFBVyxDQUFDLHNEQUFXO0FBQ3ZDLFlBQVksOENBQThDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzREFBVztBQUNqQztBQUNBLDRDQUE0QztBQUM1QztBQUNBLGtCQUFrQixzREFBVztBQUM3QixhQUFhLHNEQUFXO0FBQ3hCLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0EsaUJBQWlCLHNEQUFXO0FBQzVCO0FBQ0EsZ0NBQWdDLHNEQUFXO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxJQUFJLGlEQUFNO0FBQ1YsSUFBSSxpREFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTyxTQUFTLHNEQUFXO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZFQUE2RTtBQUNqRztBQUNBO0FBQ087QUFDUCxJQUFJLHlEQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSxtQ0FBbUM7QUFDL0MsSUFBSSxpREFBTTtBQUNWO0FBQ0EsMkNBQTJDLHNEQUFXO0FBQ3REO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQSxtQkFBbUIsZ0RBQUc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsaURBQWlEO0FBQ2pELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsa0NBQWtDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHdDQUF3QztBQUN0RjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcz83YmYwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG1vZCB9IGZyb20gJy4vbW9kdWxhci5qcyc7XG5pbXBvcnQgeyBieXRlc1RvTnVtYmVyQkUsIGFieXRlcywgY29uY2F0Qnl0ZXMsIHV0ZjhUb0J5dGVzLCB2YWxpZGF0ZU9iamVjdCB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gT2N0ZXQgU3RyZWFtIHRvIEludGVnZXIuIFwic3BlY1wiIGltcGxlbWVudGF0aW9uIG9mIG9zMmlwIGlzIDIuNXggc2xvd2VyIHZzIGJ5dGVzVG9OdW1iZXJCRS5cbmNvbnN0IG9zMmlwID0gYnl0ZXNUb051bWJlckJFO1xuLy8gSW50ZWdlciB0byBPY3RldCBTdHJlYW0gKG51bWJlclRvQnl0ZXNCRSlcbmZ1bmN0aW9uIGkyb3NwKHZhbHVlLCBsZW5ndGgpIHtcbiAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID49IDEgPDwgKDggKiBsZW5ndGgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYmFkIEkyT1NQIGNhbGw6IHZhbHVlPSR7dmFsdWV9IGxlbmd0aD0ke2xlbmd0aH1gKTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aCB9KS5maWxsKDApO1xuICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICByZXNbaV0gPSB2YWx1ZSAmIDB4ZmY7XG4gICAgICAgIHZhbHVlID4+Pj0gODtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlcyk7XG59XG5mdW5jdGlvbiBzdHJ4b3IoYSwgYikge1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGEubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gYVtpXSBeIGJbaV07XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG5mdW5jdGlvbiBhbnVtKGl0ZW0pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGl0ZW0pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ251bWJlciBleHBlY3RlZCcpO1xufVxuLy8gUHJvZHVjZXMgYSB1bmlmb3JtbHkgcmFuZG9tIGJ5dGUgc3RyaW5nIHVzaW5nIGEgY3J5cHRvZ3JhcGhpYyBoYXNoIGZ1bmN0aW9uIEggdGhhdCBvdXRwdXRzIGIgYml0c1xuLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuMVxuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZF9tZXNzYWdlX3htZChtc2csIERTVCwgbGVuSW5CeXRlcywgSCkge1xuICAgIGFieXRlcyhtc2cpO1xuICAgIGFieXRlcyhEU1QpO1xuICAgIGFudW0obGVuSW5CeXRlcyk7XG4gICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuM1xuICAgIGlmIChEU1QubGVuZ3RoID4gMjU1KVxuICAgICAgICBEU1QgPSBIKGNvbmNhdEJ5dGVzKHV0ZjhUb0J5dGVzKCdIMkMtT1ZFUlNJWkUtRFNULScpLCBEU1QpKTtcbiAgICBjb25zdCB7IG91dHB1dExlbjogYl9pbl9ieXRlcywgYmxvY2tMZW46IHJfaW5fYnl0ZXMgfSA9IEg7XG4gICAgY29uc3QgZWxsID0gTWF0aC5jZWlsKGxlbkluQnl0ZXMgLyBiX2luX2J5dGVzKTtcbiAgICBpZiAoZWxsID4gMjU1KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgeG1kIGxlbmd0aCcpO1xuICAgIGNvbnN0IERTVF9wcmltZSA9IGNvbmNhdEJ5dGVzKERTVCwgaTJvc3AoRFNULmxlbmd0aCwgMSkpO1xuICAgIGNvbnN0IFpfcGFkID0gaTJvc3AoMCwgcl9pbl9ieXRlcyk7XG4gICAgY29uc3QgbF9pX2Jfc3RyID0gaTJvc3AobGVuSW5CeXRlcywgMik7IC8vIGxlbl9pbl9ieXRlc19zdHJcbiAgICBjb25zdCBiID0gbmV3IEFycmF5KGVsbCk7XG4gICAgY29uc3QgYl8wID0gSChjb25jYXRCeXRlcyhaX3BhZCwgbXNnLCBsX2lfYl9zdHIsIGkyb3NwKDAsIDEpLCBEU1RfcHJpbWUpKTtcbiAgICBiWzBdID0gSChjb25jYXRCeXRlcyhiXzAsIGkyb3NwKDEsIDEpLCBEU1RfcHJpbWUpKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBlbGw7IGkrKykge1xuICAgICAgICBjb25zdCBhcmdzID0gW3N0cnhvcihiXzAsIGJbaSAtIDFdKSwgaTJvc3AoaSArIDEsIDEpLCBEU1RfcHJpbWVdO1xuICAgICAgICBiW2ldID0gSChjb25jYXRCeXRlcyguLi5hcmdzKSk7XG4gICAgfVxuICAgIGNvbnN0IHBzZXVkb19yYW5kb21fYnl0ZXMgPSBjb25jYXRCeXRlcyguLi5iKTtcbiAgICByZXR1cm4gcHNldWRvX3JhbmRvbV9ieXRlcy5zbGljZSgwLCBsZW5JbkJ5dGVzKTtcbn1cbi8vIFByb2R1Y2VzIGEgdW5pZm9ybWx5IHJhbmRvbSBieXRlIHN0cmluZyB1c2luZyBhbiBleHRlbmRhYmxlLW91dHB1dCBmdW5jdGlvbiAoWE9GKSBILlxuLy8gMS4gVGhlIGNvbGxpc2lvbiByZXNpc3RhbmNlIG9mIEggTVVTVCBiZSBhdCBsZWFzdCBrIGJpdHMuXG4vLyAyLiBIIE1VU1QgYmUgYW4gWE9GIHRoYXQgaGFzIGJlZW4gcHJvdmVkIGluZGlmZmVyZW50aWFibGUgZnJvbVxuLy8gICAgYSByYW5kb20gb3JhY2xlIHVuZGVyIGEgcmVhc29uYWJsZSBjcnlwdG9ncmFwaGljIGFzc3VtcHRpb24uXG4vLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4yXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kX21lc3NhZ2VfeG9mKG1zZywgRFNULCBsZW5JbkJ5dGVzLCBrLCBIKSB7XG4gICAgYWJ5dGVzKG1zZyk7XG4gICAgYWJ5dGVzKERTVCk7XG4gICAgYW51bShsZW5JbkJ5dGVzKTtcbiAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4zXG4gICAgLy8gRFNUID0gSCgnSDJDLU9WRVJTSVpFLURTVC0nIHx8IGFfdmVyeV9sb25nX0RTVCwgTWF0aC5jZWlsKChsZW5JbkJ5dGVzICogaykgLyA4KSk7XG4gICAgaWYgKERTVC5sZW5ndGggPiAyNTUpIHtcbiAgICAgICAgY29uc3QgZGtMZW4gPSBNYXRoLmNlaWwoKDIgKiBrKSAvIDgpO1xuICAgICAgICBEU1QgPSBILmNyZWF0ZSh7IGRrTGVuIH0pLnVwZGF0ZSh1dGY4VG9CeXRlcygnSDJDLU9WRVJTSVpFLURTVC0nKSkudXBkYXRlKERTVCkuZGlnZXN0KCk7XG4gICAgfVxuICAgIGlmIChsZW5JbkJ5dGVzID4gNjU1MzUgfHwgRFNULmxlbmd0aCA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmRfbWVzc2FnZV94b2Y6IGludmFsaWQgbGVuSW5CeXRlcycpO1xuICAgIHJldHVybiAoSC5jcmVhdGUoeyBka0xlbjogbGVuSW5CeXRlcyB9KVxuICAgICAgICAudXBkYXRlKG1zZylcbiAgICAgICAgLnVwZGF0ZShpMm9zcChsZW5JbkJ5dGVzLCAyKSlcbiAgICAgICAgLy8gMi4gRFNUX3ByaW1lID0gRFNUIHx8IEkyT1NQKGxlbihEU1QpLCAxKVxuICAgICAgICAudXBkYXRlKERTVClcbiAgICAgICAgLnVwZGF0ZShpMm9zcChEU1QubGVuZ3RoLCAxKSlcbiAgICAgICAgLmRpZ2VzdCgpKTtcbn1cbi8qKlxuICogSGFzaGVzIGFyYml0cmFyeS1sZW5ndGggYnl0ZSBzdHJpbmdzIHRvIGEgbGlzdCBvZiBvbmUgb3IgbW9yZSBlbGVtZW50cyBvZiBhIGZpbml0ZSBmaWVsZCBGXG4gKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMlxuICogQHBhcmFtIG1zZyBhIGJ5dGUgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIG1lc3NhZ2UgdG8gaGFzaFxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgb2YgRiB0byBvdXRwdXRcbiAqIEBwYXJhbSBvcHRpb25zIGB7RFNUOiBzdHJpbmcsIHA6IGJpZ2ludCwgbTogbnVtYmVyLCBrOiBudW1iZXIsIGV4cGFuZDogJ3htZCcgfCAneG9mJywgaGFzaDogSH1gLCBzZWUgYWJvdmVcbiAqIEByZXR1cm5zIFt1XzAsIC4uLiwgdV8oY291bnQgLSAxKV0sIGEgbGlzdCBvZiBmaWVsZCBlbGVtZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2hfdG9fZmllbGQobXNnLCBjb3VudCwgb3B0aW9ucykge1xuICAgIHZhbGlkYXRlT2JqZWN0KG9wdGlvbnMsIHtcbiAgICAgICAgRFNUOiAnc3RyaW5nT3JVaW50OEFycmF5JyxcbiAgICAgICAgcDogJ2JpZ2ludCcsXG4gICAgICAgIG06ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgazogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBoYXNoOiAnaGFzaCcsXG4gICAgfSk7XG4gICAgY29uc3QgeyBwLCBrLCBtLCBoYXNoLCBleHBhbmQsIERTVDogX0RTVCB9ID0gb3B0aW9ucztcbiAgICBhYnl0ZXMobXNnKTtcbiAgICBhbnVtKGNvdW50KTtcbiAgICBjb25zdCBEU1QgPSB0eXBlb2YgX0RTVCA9PT0gJ3N0cmluZycgPyB1dGY4VG9CeXRlcyhfRFNUKSA6IF9EU1Q7XG4gICAgY29uc3QgbG9nMnAgPSBwLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICBjb25zdCBMID0gTWF0aC5jZWlsKChsb2cycCArIGspIC8gOCk7IC8vIHNlY3Rpb24gNS4xIG9mIGlldGYgZHJhZnQgbGluayBhYm92ZVxuICAgIGNvbnN0IGxlbl9pbl9ieXRlcyA9IGNvdW50ICogbSAqIEw7XG4gICAgbGV0IHByYjsgLy8gcHNldWRvX3JhbmRvbV9ieXRlc1xuICAgIGlmIChleHBhbmQgPT09ICd4bWQnKSB7XG4gICAgICAgIHByYiA9IGV4cGFuZF9tZXNzYWdlX3htZChtc2csIERTVCwgbGVuX2luX2J5dGVzLCBoYXNoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwYW5kID09PSAneG9mJykge1xuICAgICAgICBwcmIgPSBleHBhbmRfbWVzc2FnZV94b2YobXNnLCBEU1QsIGxlbl9pbl9ieXRlcywgaywgaGFzaCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cGFuZCA9PT0gJ19pbnRlcm5hbF9wYXNzJykge1xuICAgICAgICAvLyBmb3IgaW50ZXJuYWwgdGVzdHMgb25seVxuICAgICAgICBwcmIgPSBtc2c7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGFuZCBtdXN0IGJlIFwieG1kXCIgb3IgXCJ4b2ZcIicpO1xuICAgIH1cbiAgICBjb25zdCB1ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3QgZSA9IG5ldyBBcnJheShtKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVsbV9vZmZzZXQgPSBMICogKGogKyBpICogbSk7XG4gICAgICAgICAgICBjb25zdCB0diA9IHByYi5zdWJhcnJheShlbG1fb2Zmc2V0LCBlbG1fb2Zmc2V0ICsgTCk7XG4gICAgICAgICAgICBlW2pdID0gbW9kKG9zMmlwKHR2KSwgcCk7XG4gICAgICAgIH1cbiAgICAgICAgdVtpXSA9IGU7XG4gICAgfVxuICAgIHJldHVybiB1O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzb2dlbnlNYXAoZmllbGQsIG1hcCkge1xuICAgIC8vIE1ha2Ugc2FtZSBvcmRlciBhcyBpbiBzcGVjXG4gICAgY29uc3QgQ09FRkYgPSBtYXAubWFwKChpKSA9PiBBcnJheS5mcm9tKGkpLnJldmVyc2UoKSk7XG4gICAgcmV0dXJuICh4LCB5KSA9PiB7XG4gICAgICAgIGNvbnN0IFt4TnVtLCB4RGVuLCB5TnVtLCB5RGVuXSA9IENPRUZGLm1hcCgodmFsKSA9PiB2YWwucmVkdWNlKChhY2MsIGkpID0+IGZpZWxkLmFkZChmaWVsZC5tdWwoYWNjLCB4KSwgaSkpKTtcbiAgICAgICAgeCA9IGZpZWxkLmRpdih4TnVtLCB4RGVuKTsgLy8geE51bSAvIHhEZW5cbiAgICAgICAgeSA9IGZpZWxkLm11bCh5LCBmaWVsZC5kaXYoeU51bSwgeURlbikpOyAvLyB5ICogKHlOdW0gLyB5RGV2KVxuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIYXNoZXIoUG9pbnQsIG1hcFRvQ3VydmUsIGRlZikge1xuICAgIGlmICh0eXBlb2YgbWFwVG9DdXJ2ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlKCkgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLy8gRW5jb2RlcyBieXRlIHN0cmluZyB0byBlbGxpcHRpYyBjdXJ2ZS5cbiAgICAgICAgLy8gaGFzaF90b19jdXJ2ZSBmcm9tIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tM1xuICAgICAgICBoYXNoVG9DdXJ2ZShtc2csIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHUgPSBoYXNoX3RvX2ZpZWxkKG1zZywgMiwgeyAuLi5kZWYsIERTVDogZGVmLkRTVCwgLi4ub3B0aW9ucyB9KTtcbiAgICAgICAgICAgIGNvbnN0IHUwID0gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKHVbMF0pKTtcbiAgICAgICAgICAgIGNvbnN0IHUxID0gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKHVbMV0pKTtcbiAgICAgICAgICAgIGNvbnN0IFAgPSB1MC5hZGQodTEpLmNsZWFyQ29mYWN0b3IoKTtcbiAgICAgICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBQO1xuICAgICAgICB9LFxuICAgICAgICAvLyBFbmNvZGVzIGJ5dGUgc3RyaW5nIHRvIGVsbGlwdGljIGN1cnZlLlxuICAgICAgICAvLyBlbmNvZGVfdG9fY3VydmUgZnJvbSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTNcbiAgICAgICAgZW5jb2RlVG9DdXJ2ZShtc2csIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHUgPSBoYXNoX3RvX2ZpZWxkKG1zZywgMSwgeyAuLi5kZWYsIERTVDogZGVmLmVuY29kZURTVCwgLi4ub3B0aW9ucyB9KTtcbiAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUodVswXSkpLmNsZWFyQ29mYWN0b3IoKTtcbiAgICAgICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBQO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoLXRvLWN1cnZlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/hash-to-curve.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/modular.js":
/*!****************************************************************!*\
  !*** ../../node_modules/@noble/curves/esm/abstract/modular.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: function() { return /* binding */ Field; },\n/* harmony export */   FpDiv: function() { return /* binding */ FpDiv; },\n/* harmony export */   FpInvertBatch: function() { return /* binding */ FpInvertBatch; },\n/* harmony export */   FpIsSquare: function() { return /* binding */ FpIsSquare; },\n/* harmony export */   FpPow: function() { return /* binding */ FpPow; },\n/* harmony export */   FpSqrt: function() { return /* binding */ FpSqrt; },\n/* harmony export */   FpSqrtEven: function() { return /* binding */ FpSqrtEven; },\n/* harmony export */   FpSqrtOdd: function() { return /* binding */ FpSqrtOdd; },\n/* harmony export */   getFieldBytesLength: function() { return /* binding */ getFieldBytesLength; },\n/* harmony export */   getMinHashLength: function() { return /* binding */ getMinHashLength; },\n/* harmony export */   hashToPrivateScalar: function() { return /* binding */ hashToPrivateScalar; },\n/* harmony export */   invert: function() { return /* binding */ invert; },\n/* harmony export */   isNegativeLE: function() { return /* binding */ isNegativeLE; },\n/* harmony export */   mapHashToField: function() { return /* binding */ mapHashToField; },\n/* harmony export */   mod: function() { return /* binding */ mod; },\n/* harmony export */   nLength: function() { return /* binding */ nLength; },\n/* harmony export */   pow: function() { return /* binding */ pow; },\n/* harmony export */   pow2: function() { return /* binding */ pow2; },\n/* harmony export */   tonelliShanks: function() { return /* binding */ tonelliShanks; },\n/* harmony export */   validateField: function() { return /* binding */ validateField; }\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nfunction pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n)\n        throw new Error('Expected power/modulo > 0');\n    if (modulo === _1n)\n        return _0n;\n    let res = _1n;\n    while (power > _0n) {\n        if (power & _1n)\n            res = (res * num) % modulo;\n        num = (num * num) % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n// Inverses number over modulo\nfunction invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nfunction tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p)  1    if a is a square (mod p)\n    // (a | p)  -1   if a is not a square (mod p)\n    // (a | p)  0    if a  0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\n        ;\n    // Step 2: Select a non-square z such that (z | p)  -1 and set c  zq\n    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)\n        ;\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be  -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\n            throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while (!Fp.eql(b, Fp.ONE)) {\n            if (Fp.eql(b, Fp.ZERO))\n                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for (let t2 = Fp.sqr(b); m < r; m++) {\n                if (Fp.eql(t2, Fp.ONE))\n                    break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nfunction FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P  3 (mod 4)\n    // n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q  5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // P  9 (mod 16)\n    if (P % _16n === _9n) {\n        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n        // Means we cannot use sqrt for constants at all!\n        //\n        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n        // sqrt = (x) => {\n        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n        // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nfunction FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n)\n        throw new Error('Expected power > 0');\n    if (power === _0n)\n        return f.ONE;\n    if (power === _1n)\n        return num;\n    let p = f.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nfunction FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nfunction FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n    return (x) => {\n        const p = f.pow(x, legendreConst);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nfunction Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('Field lengths over 2048 bytes are not supported');\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c) => (c ? b : a),\n        toBytes: (num) => (isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);\n        },\n    });\n    return Object.freeze(f);\n}\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */\nfunction hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nfunction getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nfunction getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nfunction mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(key) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(reduced, fieldLen) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvbW9kdWxhci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ3VJO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxxRUFBcUUsUUFBUSxNQUFNLE9BQU87QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaUJBQWlCO0FBQzlDO0FBQ0E7QUFDQSxrQkFBa0IsMkNBQTJDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLG1DQUFtQztBQUNuQyw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsNERBQTREO0FBQzVELDRCQUE0QjtBQUM1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QSxvQ0FBb0MsT0FBTyw0QkFBNEIsSUFBSTtBQUMzRSx1QkFBdUIsMERBQWUsUUFBUSwwREFBZTtBQUM3RDtBQUNBO0FBQ0Esa0JBQWtCLDBEQUFlLHNCQUFzQiwwREFBZTtBQUN0RTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvbW9kdWxhci5qcz84NTU1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFV0aWxpdGllcyBmb3IgbW9kdWxhciBhcml0aG1ldGljcyBhbmQgZmluaXRlIGZpZWxkc1xuaW1wb3J0IHsgYml0TWFzaywgbnVtYmVyVG9CeXRlc0JFLCBudW1iZXJUb0J5dGVzTEUsIGJ5dGVzVG9OdW1iZXJCRSwgYnl0ZXNUb051bWJlckxFLCBlbnN1cmVCeXRlcywgdmFsaWRhdGVPYmplY3QsIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzRuID0gQmlnSW50KDQpLCBfNW4gPSBCaWdJbnQoNSksIF84biA9IEJpZ0ludCg4KTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzluID0gQmlnSW50KDkpLCBfMTZuID0gQmlnSW50KDE2KTtcbi8vIENhbGN1bGF0ZXMgYSBtb2R1bG8gYlxuZXhwb3J0IGZ1bmN0aW9uIG1vZChhLCBiKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYSAlIGI7XG4gICAgcmV0dXJuIHJlc3VsdCA+PSBfMG4gPyByZXN1bHQgOiBiICsgcmVzdWx0O1xufVxuLyoqXG4gKiBFZmZpY2llbnRseSByYWlzZSBudW0gdG8gcG93ZXIgYW5kIGRvIG1vZHVsYXIgZGl2aXNpb24uXG4gKiBVbnNhZmUgaW4gc29tZSBjb250ZXh0czogdXNlcyBsYWRkZXIsIHNvIGNhbiBleHBvc2UgYmlnaW50IGJpdHMuXG4gKiBAZXhhbXBsZVxuICogcG93KDJuLCA2biwgMTFuKSAvLyA2NG4gJSAxMW4gPT0gOW5cbiAqL1xuLy8gVE9ETzogdXNlIGZpZWxkIHZlcnNpb24gJiYgcmVtb3ZlXG5leHBvcnQgZnVuY3Rpb24gcG93KG51bSwgcG93ZXIsIG1vZHVsbykge1xuICAgIGlmIChtb2R1bG8gPD0gXzBuIHx8IHBvd2VyIDwgXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHBvd2VyL21vZHVsbyA+IDAnKTtcbiAgICBpZiAobW9kdWxvID09PSBfMW4pXG4gICAgICAgIHJldHVybiBfMG47XG4gICAgbGV0IHJlcyA9IF8xbjtcbiAgICB3aGlsZSAocG93ZXIgPiBfMG4pIHtcbiAgICAgICAgaWYgKHBvd2VyICYgXzFuKVxuICAgICAgICAgICAgcmVzID0gKHJlcyAqIG51bSkgJSBtb2R1bG87XG4gICAgICAgIG51bSA9IChudW0gKiBudW0pICUgbW9kdWxvO1xuICAgICAgICBwb3dlciA+Pj0gXzFuO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLy8gRG9lcyB4IF4gKDIgXiBwb3dlcikgbW9kIHAuIHBvdzIoMzAsIDQpID09IDMwIF4gKDIgXiA0KVxuZXhwb3J0IGZ1bmN0aW9uIHBvdzIoeCwgcG93ZXIsIG1vZHVsbykge1xuICAgIGxldCByZXMgPSB4O1xuICAgIHdoaWxlIChwb3dlci0tID4gXzBuKSB7XG4gICAgICAgIHJlcyAqPSByZXM7XG4gICAgICAgIHJlcyAlPSBtb2R1bG87XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBJbnZlcnNlcyBudW1iZXIgb3ZlciBtb2R1bG9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQobnVtYmVyLCBtb2R1bG8pIHtcbiAgICBpZiAobnVtYmVyID09PSBfMG4gfHwgbW9kdWxvIDw9IF8wbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmVydDogZXhwZWN0ZWQgcG9zaXRpdmUgaW50ZWdlcnMsIGdvdCBuPSR7bnVtYmVyfSBtb2Q9JHttb2R1bG99YCk7XG4gICAgfVxuICAgIC8vIEV1Y2xpZGVhbiBHQ0QgaHR0cHM6Ly9icmlsbGlhbnQub3JnL3dpa2kvZXh0ZW5kZWQtZXVjbGlkZWFuLWFsZ29yaXRobS9cbiAgICAvLyBGZXJtYXQncyBsaXR0bGUgdGhlb3JlbSBcIkNULWxpa2VcIiB2ZXJzaW9uIGludihuKSA9IG5eKG0tMikgbW9kIG0gaXMgMzB4IHNsb3dlci5cbiAgICBsZXQgYSA9IG1vZChudW1iZXIsIG1vZHVsbyk7XG4gICAgbGV0IGIgPSBtb2R1bG87XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IHggPSBfMG4sIHkgPSBfMW4sIHUgPSBfMW4sIHYgPSBfMG47XG4gICAgd2hpbGUgKGEgIT09IF8wbikge1xuICAgICAgICAvLyBKSVQgYXBwbGllcyBvcHRpbWl6YXRpb24gaWYgdGhvc2UgdHdvIGxpbmVzIGZvbGxvdyBlYWNoIG90aGVyXG4gICAgICAgIGNvbnN0IHEgPSBiIC8gYTtcbiAgICAgICAgY29uc3QgciA9IGIgJSBhO1xuICAgICAgICBjb25zdCBtID0geCAtIHUgKiBxO1xuICAgICAgICBjb25zdCBuID0geSAtIHYgKiBxO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgYiA9IGEsIGEgPSByLCB4ID0gdSwgeSA9IHYsIHUgPSBtLCB2ID0gbjtcbiAgICB9XG4gICAgY29uc3QgZ2NkID0gYjtcbiAgICBpZiAoZ2NkICE9PSBfMW4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52ZXJ0OiBkb2VzIG5vdCBleGlzdCcpO1xuICAgIHJldHVybiBtb2QoeCwgbW9kdWxvKTtcbn1cbi8qKlxuICogVG9uZWxsaS1TaGFua3Mgc3F1YXJlIHJvb3Qgc2VhcmNoIGFsZ29yaXRobS5cbiAqIDEuIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAocGFnZSAxMilcbiAqIDIuIFNxdWFyZSBSb290cyBmcm9tIDE7IDI0LCA1MSwgMTAgdG8gRGFuIFNoYW5rc1xuICogV2lsbCBzdGFydCBhbiBpbmZpbml0ZSBsb29wIGlmIGZpZWxkIG9yZGVyIFAgaXMgbm90IHByaW1lLlxuICogQHBhcmFtIFAgZmllbGQgb3JkZXJcbiAqIEByZXR1cm5zIGZ1bmN0aW9uIHRoYXQgdGFrZXMgZmllbGQgRnAgKGNyZWF0ZWQgZnJvbSBQKSBhbmQgbnVtYmVyIG5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvbmVsbGlTaGFua3MoUCkge1xuICAgIC8vIExlZ2VuZHJlIGNvbnN0YW50OiB1c2VkIHRvIGNhbGN1bGF0ZSBMZWdlbmRyZSBzeW1ib2wgKGEgfCBwKSxcbiAgICAvLyB3aGljaCBkZW5vdGVzIHRoZSB2YWx1ZSBvZiBhXigocC0xKS8yKSAobW9kIHApLlxuICAgIC8vIChhIHwgcCkg4omhIDEgICAgaWYgYSBpcyBhIHNxdWFyZSAobW9kIHApXG4gICAgLy8gKGEgfCBwKSDiiaEgLTEgICBpZiBhIGlzIG5vdCBhIHNxdWFyZSAobW9kIHApXG4gICAgLy8gKGEgfCBwKSDiiaEgMCAgICBpZiBhIOKJoSAwIChtb2QgcClcbiAgICBjb25zdCBsZWdlbmRyZUMgPSAoUCAtIF8xbikgLyBfMm47XG4gICAgbGV0IFEsIFMsIFo7XG4gICAgLy8gU3RlcCAxOiBCeSBmYWN0b3Jpbmcgb3V0IHBvd2VycyBvZiAyIGZyb20gcCAtIDEsXG4gICAgLy8gZmluZCBxIGFuZCBzIHN1Y2ggdGhhdCBwIC0gMSA9IHEqKDJecykgd2l0aCBxIG9kZFxuICAgIGZvciAoUSA9IFAgLSBfMW4sIFMgPSAwOyBRICUgXzJuID09PSBfMG47IFEgLz0gXzJuLCBTKyspXG4gICAgICAgIDtcbiAgICAvLyBTdGVwIDI6IFNlbGVjdCBhIG5vbi1zcXVhcmUgeiBzdWNoIHRoYXQgKHogfCBwKSDiiaEgLTEgYW5kIHNldCBjIOKJoSB6cVxuICAgIGZvciAoWiA9IF8ybjsgWiA8IFAgJiYgcG93KFosIGxlZ2VuZHJlQywgUCkgIT09IFAgLSBfMW47IForKylcbiAgICAgICAgO1xuICAgIC8vIEZhc3QtcGF0aFxuICAgIGlmIChTID09PSAxKSB7XG4gICAgICAgIGNvbnN0IHAxZGl2NCA9IChQICsgXzFuKSAvIF80bjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHRvbmVsbGlGYXN0KEZwLCBuKSB7XG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAucG93KG4sIHAxZGl2NCk7XG4gICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBTbG93LXBhdGhcbiAgICBjb25zdCBRMWRpdjIgPSAoUSArIF8xbikgLyBfMm47XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHRvbmVsbGlTbG93KEZwLCBuKSB7XG4gICAgICAgIC8vIFN0ZXAgMDogQ2hlY2sgdGhhdCBuIGlzIGluZGVlZCBhIHNxdWFyZTogKG4gfCBwKSBzaG91bGQgbm90IGJlIOKJoSAtMVxuICAgICAgICBpZiAoRnAucG93KG4sIGxlZ2VuZHJlQykgPT09IEZwLm5lZyhGcC5PTkUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICBsZXQgciA9IFM7XG4gICAgICAgIC8vIFRPRE86IHdpbGwgZmFpbCBhdCBGcDIvZXRjXG4gICAgICAgIGxldCBnID0gRnAucG93KEZwLm11bChGcC5PTkUsIFopLCBRKTsgLy8gd2lsbCB1cGRhdGUgYm90aCB4IGFuZCBiXG4gICAgICAgIGxldCB4ID0gRnAucG93KG4sIFExZGl2Mik7IC8vIGZpcnN0IGd1ZXNzIGF0IHRoZSBzcXVhcmUgcm9vdFxuICAgICAgICBsZXQgYiA9IEZwLnBvdyhuLCBRKTsgLy8gZmlyc3QgZ3Vlc3MgYXQgdGhlIGZ1ZGdlIGZhY3RvclxuICAgICAgICB3aGlsZSAoIUZwLmVxbChiLCBGcC5PTkUpKSB7XG4gICAgICAgICAgICBpZiAoRnAuZXFsKGIsIEZwLlpFUk8pKVxuICAgICAgICAgICAgICAgIHJldHVybiBGcC5aRVJPOyAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ub25lbGxpJUUyJTgwJTkzU2hhbmtzX2FsZ29yaXRobSAoNC4gSWYgdCA9IDAsIHJldHVybiByID0gMClcbiAgICAgICAgICAgIC8vIEZpbmQgbSBzdWNoIGJeKDJebSk9PTFcbiAgICAgICAgICAgIGxldCBtID0gMTtcbiAgICAgICAgICAgIGZvciAobGV0IHQyID0gRnAuc3FyKGIpOyBtIDwgcjsgbSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKEZwLmVxbCh0MiwgRnAuT05FKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgdDIgPSBGcC5zcXIodDIpOyAvLyB0MiAqPSB0MlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTk9URTogci1tLTEgY2FuIGJlIGJpZ2dlciB0aGFuIDMyLCBuZWVkIHRvIGNvbnZlcnQgdG8gYmlnaW50IGJlZm9yZSBzaGlmdCwgb3RoZXJ3aXNlIHRoZXJlIHdpbGwgYmUgb3ZlcmZsb3dcbiAgICAgICAgICAgIGNvbnN0IGdlID0gRnAucG93KGcsIF8xbiA8PCBCaWdJbnQociAtIG0gLSAxKSk7IC8vIGdlID0gMl4oci1tLTEpXG4gICAgICAgICAgICBnID0gRnAuc3FyKGdlKTsgLy8gZyA9IGdlICogZ2VcbiAgICAgICAgICAgIHggPSBGcC5tdWwoeCwgZ2UpOyAvLyB4ICo9IGdlXG4gICAgICAgICAgICBiID0gRnAubXVsKGIsIGcpOyAvLyBiICo9IGdcbiAgICAgICAgICAgIHIgPSBtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4O1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0KFApIHtcbiAgICAvLyBOT1RFOiBkaWZmZXJlbnQgYWxnb3JpdGhtcyBjYW4gZ2l2ZSBkaWZmZXJlbnQgcm9vdHMsIGl0IGlzIHVwIHRvIHVzZXIgdG8gZGVjaWRlIHdoaWNoIG9uZSB0aGV5IHdhbnQuXG4gICAgLy8gRm9yIGV4YW1wbGUgdGhlcmUgaXMgRnBTcXJ0T2RkL0ZwU3FydEV2ZW4gdG8gY2hvaWNlIHJvb3QgYmFzZWQgb24gb2RkbmVzcyAodXNlZCBmb3IgaGFzaC10by1jdXJ2ZSkuXG4gICAgLy8gUCDiiaEgMyAobW9kIDQpXG4gICAgLy8g4oiabiA9IG5eKChQKzEpLzQpXG4gICAgaWYgKFAgJSBfNG4gPT09IF8zbikge1xuICAgICAgICAvLyBOb3QgYWxsIHJvb3RzIHBvc3NpYmxlIVxuICAgICAgICAvLyBjb25zdCBPUkRFUiA9XG4gICAgICAgIC8vICAgMHgxYTAxMTFlYTM5N2ZlNjlhNGIxYmE3YjY0MzRiYWNkNzY0Nzc0Yjg0ZjM4NTEyYmY2NzMwZDJhMGY2YjBmNjI0MWVhYmZmZmViMTUzZmZmZmI5ZmVmZmZmZmZmZmFhYWJuO1xuICAgICAgICAvLyBjb25zdCBOVU0gPSA3MjA1NzU5NDAzNzkyNzgxNm47XG4gICAgICAgIGNvbnN0IHAxZGl2NCA9IChQICsgXzFuKSAvIF80bjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNxcnQzbW9kNChGcCwgbikge1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLnBvdyhuLCBwMWRpdjQpO1xuICAgICAgICAgICAgLy8gVGhyb3cgaWYgcm9vdCoqMiAhPSBuXG4gICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBBdGtpbiBhbGdvcml0aG0gZm9yIHEg4omhIDUgKG1vZCA4KSwgaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMi82ODUucGRmIChwYWdlIDEwKVxuICAgIGlmIChQICUgXzhuID09PSBfNW4pIHtcbiAgICAgICAgY29uc3QgYzEgPSAoUCAtIF81bikgLyBfOG47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzcXJ0NW1vZDgoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IG4yID0gRnAubXVsKG4sIF8ybik7XG4gICAgICAgICAgICBjb25zdCB2ID0gRnAucG93KG4yLCBjMSk7XG4gICAgICAgICAgICBjb25zdCBudiA9IEZwLm11bChuLCB2KTtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBGcC5tdWwoRnAubXVsKG52LCBfMm4pLCB2KTtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5tdWwobnYsIEZwLnN1YihpLCBGcC5PTkUpKTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFAg4omhIDkgKG1vZCAxNilcbiAgICBpZiAoUCAlIF8xNm4gPT09IF85bikge1xuICAgICAgICAvLyBOT1RFOiB0b25lbGxpIGlzIHRvbyBzbG93IGZvciBibHMtRnAyIGNhbGN1bGF0aW9ucyBldmVuIG9uIHN0YXJ0XG4gICAgICAgIC8vIE1lYW5zIHdlIGNhbm5vdCB1c2Ugc3FydCBmb3IgY29uc3RhbnRzIGF0IGFsbCFcbiAgICAgICAgLy9cbiAgICAgICAgLy8gY29uc3QgYzEgPSBGcC5zcXJ0KEZwLm5lZ2F0ZShGcC5PTkUpKTsgLy8gIDEuIGMxID0gc3FydCgtMSkgaW4gRiwgaS5lLiwgKGMxXjIpID09IC0xIGluIEZcbiAgICAgICAgLy8gY29uc3QgYzIgPSBGcC5zcXJ0KGMxKTsgICAgICAgICAgICAgICAgLy8gIDIuIGMyID0gc3FydChjMSkgaW4gRiwgaS5lLiwgKGMyXjIpID09IGMxIGluIEZcbiAgICAgICAgLy8gY29uc3QgYzMgPSBGcC5zcXJ0KEZwLm5lZ2F0ZShjMSkpOyAgICAgLy8gIDMuIGMzID0gc3FydCgtYzEpIGluIEYsIGkuZS4sIChjM14yKSA9PSAtYzEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjNCA9IChQICsgXzduKSAvIF8xNm47ICAgICAgICAgICAvLyAgNC4gYzQgPSAocSArIDcpIC8gMTYgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgICAgIC8vIHNxcnQgPSAoeCkgPT4ge1xuICAgICAgICAvLyAgIGxldCB0djEgPSBGcC5wb3coeCwgYzQpOyAgICAgICAgICAgICAvLyAgMS4gdHYxID0geF5jNFxuICAgICAgICAvLyAgIGxldCB0djIgPSBGcC5tdWwoYzEsIHR2MSk7ICAgICAgICAgICAvLyAgMi4gdHYyID0gYzEgKiB0djFcbiAgICAgICAgLy8gICBjb25zdCB0djMgPSBGcC5tdWwoYzIsIHR2MSk7ICAgICAgICAgLy8gIDMuIHR2MyA9IGMyICogdHYxXG4gICAgICAgIC8vICAgbGV0IHR2NCA9IEZwLm11bChjMywgdHYxKTsgICAgICAgICAgIC8vICA0LiB0djQgPSBjMyAqIHR2MVxuICAgICAgICAvLyAgIGNvbnN0IGUxID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djIpLCB4KTsgLy8gIDUuICBlMSA9ICh0djJeMikgPT0geFxuICAgICAgICAvLyAgIGNvbnN0IGUyID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djMpLCB4KTsgLy8gIDYuICBlMiA9ICh0djNeMikgPT0geFxuICAgICAgICAvLyAgIHR2MSA9IEZwLmNtb3YodHYxLCB0djIsIGUxKTsgLy8gIDcuIHR2MSA9IENNT1YodHYxLCB0djIsIGUxKSAgIyBTZWxlY3QgdHYyIGlmICh0djJeMikgPT0geFxuICAgICAgICAvLyAgIHR2MiA9IEZwLmNtb3YodHY0LCB0djMsIGUyKTsgLy8gIDguIHR2MiA9IENNT1YodHY0LCB0djMsIGUyKSAgIyBTZWxlY3QgdHYzIGlmICh0djNeMikgPT0geFxuICAgICAgICAvLyAgIGNvbnN0IGUzID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djIpLCB4KTsgLy8gIDkuICBlMyA9ICh0djJeMikgPT0geFxuICAgICAgICAvLyAgIHJldHVybiBGcC5jbW92KHR2MSwgdHYyLCBlMyk7IC8vICAxMC4gIHogPSBDTU9WKHR2MSwgdHYyLCBlMykgICMgU2VsZWN0IHRoZSBzcXJ0IGZyb20gdHYxIGFuZCB0djJcbiAgICAgICAgLy8gfVxuICAgIH1cbiAgICAvLyBPdGhlciBjYXNlczogVG9uZWxsaS1TaGFua3MgYWxnb3JpdGhtXG4gICAgcmV0dXJuIHRvbmVsbGlTaGFua3MoUCk7XG59XG4vLyBMaXR0bGUtZW5kaWFuIGNoZWNrIGZvciBmaXJzdCBMRSBiaXQgKGxhc3QgQkUgYml0KTtcbmV4cG9ydCBjb25zdCBpc05lZ2F0aXZlTEUgPSAobnVtLCBtb2R1bG8pID0+IChtb2QobnVtLCBtb2R1bG8pICYgXzFuKSA9PT0gXzFuO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBGSUVMRF9GSUVMRFMgPSBbXG4gICAgJ2NyZWF0ZScsICdpc1ZhbGlkJywgJ2lzMCcsICduZWcnLCAnaW52JywgJ3NxcnQnLCAnc3FyJyxcbiAgICAnZXFsJywgJ2FkZCcsICdzdWInLCAnbXVsJywgJ3BvdycsICdkaXYnLFxuICAgICdhZGROJywgJ3N1Yk4nLCAnbXVsTicsICdzcXJOJ1xuXTtcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUZpZWxkKGZpZWxkKSB7XG4gICAgY29uc3QgaW5pdGlhbCA9IHtcbiAgICAgICAgT1JERVI6ICdiaWdpbnQnLFxuICAgICAgICBNQVNLOiAnYmlnaW50JyxcbiAgICAgICAgQllURVM6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgQklUUzogJ2lzU2FmZUludGVnZXInLFxuICAgIH07XG4gICAgY29uc3Qgb3B0cyA9IEZJRUxEX0ZJRUxEUy5yZWR1Y2UoKG1hcCwgdmFsKSA9PiB7XG4gICAgICAgIG1hcFt2YWxdID0gJ2Z1bmN0aW9uJztcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9LCBpbml0aWFsKTtcbiAgICByZXR1cm4gdmFsaWRhdGVPYmplY3QoZmllbGQsIG9wdHMpO1xufVxuLy8gR2VuZXJpYyBmaWVsZCBmdW5jdGlvbnNcbi8qKlxuICogU2FtZSBhcyBgcG93YCBidXQgZm9yIEZwOiBub24tY29uc3RhbnQtdGltZS5cbiAqIFVuc2FmZSBpbiBzb21lIGNvbnRleHRzOiB1c2VzIGxhZGRlciwgc28gY2FuIGV4cG9zZSBiaWdpbnQgYml0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwUG93KGYsIG51bSwgcG93ZXIpIHtcbiAgICAvLyBTaG91bGQgaGF2ZSBzYW1lIHNwZWVkIGFzIHBvdyBmb3IgYmlnaW50c1xuICAgIC8vIFRPRE86IGJlbmNobWFyayFcbiAgICBpZiAocG93ZXIgPCBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcG93ZXIgPiAwJyk7XG4gICAgaWYgKHBvd2VyID09PSBfMG4pXG4gICAgICAgIHJldHVybiBmLk9ORTtcbiAgICBpZiAocG93ZXIgPT09IF8xbilcbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICBsZXQgcCA9IGYuT05FO1xuICAgIGxldCBkID0gbnVtO1xuICAgIHdoaWxlIChwb3dlciA+IF8wbikge1xuICAgICAgICBpZiAocG93ZXIgJiBfMW4pXG4gICAgICAgICAgICBwID0gZi5tdWwocCwgZCk7XG4gICAgICAgIGQgPSBmLnNxcihkKTtcbiAgICAgICAgcG93ZXIgPj49IF8xbjtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG4vKipcbiAqIEVmZmljaWVudGx5IGludmVydCBhbiBhcnJheSBvZiBGaWVsZCBlbGVtZW50cy5cbiAqIGBpbnYoMClgIHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgIGhlcmU6IG1ha2Ugc3VyZSB0byB0aHJvdyBhbiBlcnJvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwSW52ZXJ0QmF0Y2goZiwgbnVtcykge1xuICAgIGNvbnN0IHRtcCA9IG5ldyBBcnJheShudW1zLmxlbmd0aCk7XG4gICAgLy8gV2FsayBmcm9tIGZpcnN0IHRvIGxhc3QsIG11bHRpcGx5IHRoZW0gYnkgZWFjaCBvdGhlciBNT0QgcFxuICAgIGNvbnN0IGxhc3RNdWx0aXBsaWVkID0gbnVtcy5yZWR1Y2UoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChmLmlzMChudW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgdG1wW2ldID0gYWNjO1xuICAgICAgICByZXR1cm4gZi5tdWwoYWNjLCBudW0pO1xuICAgIH0sIGYuT05FKTtcbiAgICAvLyBJbnZlcnQgbGFzdCBlbGVtZW50XG4gICAgY29uc3QgaW52ZXJ0ZWQgPSBmLmludihsYXN0TXVsdGlwbGllZCk7XG4gICAgLy8gV2FsayBmcm9tIGxhc3QgdG8gZmlyc3QsIG11bHRpcGx5IHRoZW0gYnkgaW52ZXJ0ZWQgZWFjaCBvdGhlciBNT0QgcFxuICAgIG51bXMucmVkdWNlUmlnaHQoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChmLmlzMChudW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgdG1wW2ldID0gZi5tdWwoYWNjLCB0bXBbaV0pO1xuICAgICAgICByZXR1cm4gZi5tdWwoYWNjLCBudW0pO1xuICAgIH0sIGludmVydGVkKTtcbiAgICByZXR1cm4gdG1wO1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwRGl2KGYsIGxocywgcmhzKSB7XG4gICAgcmV0dXJuIGYubXVsKGxocywgdHlwZW9mIHJocyA9PT0gJ2JpZ2ludCcgPyBpbnZlcnQocmhzLCBmLk9SREVSKSA6IGYuaW52KHJocykpO1xufVxuLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIFRydWUgd2hlbmV2ZXIgdGhlIHZhbHVlIHggaXMgYSBzcXVhcmUgaW4gdGhlIGZpZWxkIEYuXG5leHBvcnQgZnVuY3Rpb24gRnBJc1NxdWFyZShmKSB7XG4gICAgY29uc3QgbGVnZW5kcmVDb25zdCA9IChmLk9SREVSIC0gXzFuKSAvIF8ybjsgLy8gSW50ZWdlciBhcml0aG1ldGljXG4gICAgcmV0dXJuICh4KSA9PiB7XG4gICAgICAgIGNvbnN0IHAgPSBmLnBvdyh4LCBsZWdlbmRyZUNvbnN0KTtcbiAgICAgICAgcmV0dXJuIGYuZXFsKHAsIGYuWkVSTykgfHwgZi5lcWwocCwgZi5PTkUpO1xuICAgIH07XG59XG4vLyBDVVJWRS5uIGxlbmd0aHNcbmV4cG9ydCBmdW5jdGlvbiBuTGVuZ3RoKG4sIG5CaXRMZW5ndGgpIHtcbiAgICAvLyBCaXQgc2l6ZSwgYnl0ZSBzaXplIG9mIENVUlZFLm5cbiAgICBjb25zdCBfbkJpdExlbmd0aCA9IG5CaXRMZW5ndGggIT09IHVuZGVmaW5lZCA/IG5CaXRMZW5ndGggOiBuLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICBjb25zdCBuQnl0ZUxlbmd0aCA9IE1hdGguY2VpbChfbkJpdExlbmd0aCAvIDgpO1xuICAgIHJldHVybiB7IG5CaXRMZW5ndGg6IF9uQml0TGVuZ3RoLCBuQnl0ZUxlbmd0aCB9O1xufVxuLyoqXG4gKiBJbml0aWFsaXplcyBhIGZpbml0ZSBmaWVsZCBvdmVyIHByaW1lLiAqKk5vbi1wcmltZXMgYXJlIG5vdCBzdXBwb3J0ZWQuKipcbiAqIERvIG5vdCBpbml0IGluIGxvb3A6IHNsb3cuIFZlcnkgZnJhZ2lsZTogYWx3YXlzIHJ1biBhIGJlbmNobWFyayBvbiBhIGNoYW5nZS5cbiAqIE1ham9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbnM6XG4gKiAqIGEpIGRlbm9ybWFsaXplZCBvcGVyYXRpb25zIGxpa2UgbXVsTiBpbnN0ZWFkIG9mIG11bFxuICogKiBiKSBzYW1lIG9iamVjdCBzaGFwZTogbmV2ZXIgYWRkIG9yIHJlbW92ZSBrZXlzXG4gKiAqIGMpIE9iamVjdC5mcmVlemVcbiAqIEBwYXJhbSBPUkRFUiBwcmltZSBwb3NpdGl2ZSBiaWdpbnRcbiAqIEBwYXJhbSBiaXRMZW4gaG93IG1hbnkgYml0cyB0aGUgZmllbGQgY29uc3VtZXNcbiAqIEBwYXJhbSBpc0xFIChkZWY6IGZhbHNlKSBpZiBlbmNvZGluZyAvIGRlY29kaW5nIHNob3VsZCBiZSBpbiBsaXR0bGUtZW5kaWFuXG4gKiBAcGFyYW0gcmVkZWYgb3B0aW9uYWwgZmFzdGVyIHJlZGVmaW5pdGlvbnMgb2Ygc3FydCBhbmQgb3RoZXIgbWV0aG9kc1xuICovXG5leHBvcnQgZnVuY3Rpb24gRmllbGQoT1JERVIsIGJpdExlbiwgaXNMRSA9IGZhbHNlLCByZWRlZiA9IHt9KSB7XG4gICAgaWYgKE9SREVSIDw9IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBGaWVsZCBPUkRFUiA+IDAsIGdvdCAke09SREVSfWApO1xuICAgIGNvbnN0IHsgbkJpdExlbmd0aDogQklUUywgbkJ5dGVMZW5ndGg6IEJZVEVTIH0gPSBuTGVuZ3RoKE9SREVSLCBiaXRMZW4pO1xuICAgIGlmIChCWVRFUyA+IDIwNDgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmllbGQgbGVuZ3RocyBvdmVyIDIwNDggYnl0ZXMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICBjb25zdCBzcXJ0UCA9IEZwU3FydChPUkRFUik7XG4gICAgY29uc3QgZiA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBPUkRFUixcbiAgICAgICAgQklUUyxcbiAgICAgICAgQllURVMsXG4gICAgICAgIE1BU0s6IGJpdE1hc2soQklUUyksXG4gICAgICAgIFpFUk86IF8wbixcbiAgICAgICAgT05FOiBfMW4sXG4gICAgICAgIGNyZWF0ZTogKG51bSkgPT4gbW9kKG51bSwgT1JERVIpLFxuICAgICAgICBpc1ZhbGlkOiAobnVtKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGZpZWxkIGVsZW1lbnQ6IGV4cGVjdGVkIGJpZ2ludCwgZ290ICR7dHlwZW9mIG51bX1gKTtcbiAgICAgICAgICAgIHJldHVybiBfMG4gPD0gbnVtICYmIG51bSA8IE9SREVSOyAvLyAwIGlzIHZhbGlkIGVsZW1lbnQsIGJ1dCBpdCdzIG5vdCBpbnZlcnRpYmxlXG4gICAgICAgIH0sXG4gICAgICAgIGlzMDogKG51bSkgPT4gbnVtID09PSBfMG4sXG4gICAgICAgIGlzT2RkOiAobnVtKSA9PiAobnVtICYgXzFuKSA9PT0gXzFuLFxuICAgICAgICBuZWc6IChudW0pID0+IG1vZCgtbnVtLCBPUkRFUiksXG4gICAgICAgIGVxbDogKGxocywgcmhzKSA9PiBsaHMgPT09IHJocyxcbiAgICAgICAgc3FyOiAobnVtKSA9PiBtb2QobnVtICogbnVtLCBPUkRFUiksXG4gICAgICAgIGFkZDogKGxocywgcmhzKSA9PiBtb2QobGhzICsgcmhzLCBPUkRFUiksXG4gICAgICAgIHN1YjogKGxocywgcmhzKSA9PiBtb2QobGhzIC0gcmhzLCBPUkRFUiksXG4gICAgICAgIG11bDogKGxocywgcmhzKSA9PiBtb2QobGhzICogcmhzLCBPUkRFUiksXG4gICAgICAgIHBvdzogKG51bSwgcG93ZXIpID0+IEZwUG93KGYsIG51bSwgcG93ZXIpLFxuICAgICAgICBkaXY6IChsaHMsIHJocykgPT4gbW9kKGxocyAqIGludmVydChyaHMsIE9SREVSKSwgT1JERVIpLFxuICAgICAgICAvLyBTYW1lIGFzIGFib3ZlLCBidXQgZG9lc24ndCBub3JtYWxpemVcbiAgICAgICAgc3FyTjogKG51bSkgPT4gbnVtICogbnVtLFxuICAgICAgICBhZGROOiAobGhzLCByaHMpID0+IGxocyArIHJocyxcbiAgICAgICAgc3ViTjogKGxocywgcmhzKSA9PiBsaHMgLSByaHMsXG4gICAgICAgIG11bE46IChsaHMsIHJocykgPT4gbGhzICogcmhzLFxuICAgICAgICBpbnY6IChudW0pID0+IGludmVydChudW0sIE9SREVSKSxcbiAgICAgICAgc3FydDogcmVkZWYuc3FydCB8fCAoKG4pID0+IHNxcnRQKGYsIG4pKSxcbiAgICAgICAgaW52ZXJ0QmF0Y2g6IChsc3QpID0+IEZwSW52ZXJ0QmF0Y2goZiwgbHN0KSxcbiAgICAgICAgLy8gVE9ETzogZG8gd2UgcmVhbGx5IG5lZWQgY29uc3RhbnQgY21vdj9cbiAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBjb25zdC10aW1lIGJpZ2ludHMgYW55d2F5LCBzbyBwcm9iYWJseSB3aWxsIGJlIG5vdCB2ZXJ5IHVzZWZ1bFxuICAgICAgICBjbW92OiAoYSwgYiwgYykgPT4gKGMgPyBiIDogYSksXG4gICAgICAgIHRvQnl0ZXM6IChudW0pID0+IChpc0xFID8gbnVtYmVyVG9CeXRlc0xFKG51bSwgQllURVMpIDogbnVtYmVyVG9CeXRlc0JFKG51bSwgQllURVMpKSxcbiAgICAgICAgZnJvbUJ5dGVzOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IEJZVEVTKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRnAuZnJvbUJ5dGVzOiBleHBlY3RlZCAke0JZVEVTfSwgZ290ICR7Ynl0ZXMubGVuZ3RofWApO1xuICAgICAgICAgICAgcmV0dXJuIGlzTEUgPyBieXRlc1RvTnVtYmVyTEUoYnl0ZXMpIDogYnl0ZXNUb051bWJlckJFKGJ5dGVzKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShmKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnRPZGQoRnAsIGVsbSkge1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmllbGQgZG9lc24ndCBoYXZlIGlzT2RkYCk7XG4gICAgY29uc3Qgcm9vdCA9IEZwLnNxcnQoZWxtKTtcbiAgICByZXR1cm4gRnAuaXNPZGQocm9vdCkgPyByb290IDogRnAubmVnKHJvb3QpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydEV2ZW4oRnAsIGVsbSkge1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmllbGQgZG9lc24ndCBoYXZlIGlzT2RkYCk7XG4gICAgY29uc3Qgcm9vdCA9IEZwLnNxcnQoZWxtKTtcbiAgICByZXR1cm4gRnAuaXNPZGQocm9vdCkgPyBGcC5uZWcocm9vdCkgOiByb290O1xufVxuLyoqXG4gKiBcIkNvbnN0YW50LXRpbWVcIiBwcml2YXRlIGtleSBnZW5lcmF0aW9uIHV0aWxpdHkuXG4gKiBTYW1lIGFzIG1hcEtleVRvRmllbGQsIGJ1dCBhY2NlcHRzIGxlc3MgYnl0ZXMgKDQwIGluc3RlYWQgb2YgNDggZm9yIDMyLWJ5dGUgZmllbGQpLlxuICogV2hpY2ggbWFrZXMgaXQgc2xpZ2h0bHkgbW9yZSBiaWFzZWQsIGxlc3Mgc2VjdXJlLlxuICogQGRlcHJlY2F0ZWQgdXNlIG1hcEtleVRvRmllbGQgaW5zdGVhZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaFRvUHJpdmF0ZVNjYWxhcihoYXNoLCBncm91cE9yZGVyLCBpc0xFID0gZmFsc2UpIHtcbiAgICBoYXNoID0gZW5zdXJlQnl0ZXMoJ3ByaXZhdGVIYXNoJywgaGFzaCk7XG4gICAgY29uc3QgaGFzaExlbiA9IGhhc2gubGVuZ3RoO1xuICAgIGNvbnN0IG1pbkxlbiA9IG5MZW5ndGgoZ3JvdXBPcmRlcikubkJ5dGVMZW5ndGggKyA4O1xuICAgIGlmIChtaW5MZW4gPCAyNCB8fCBoYXNoTGVuIDwgbWluTGVuIHx8IGhhc2hMZW4gPiAxMDI0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGhhc2hUb1ByaXZhdGVTY2FsYXI6IGV4cGVjdGVkICR7bWluTGVufS0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJHtoYXNoTGVufWApO1xuICAgIGNvbnN0IG51bSA9IGlzTEUgPyBieXRlc1RvTnVtYmVyTEUoaGFzaCkgOiBieXRlc1RvTnVtYmVyQkUoaGFzaCk7XG4gICAgcmV0dXJuIG1vZChudW0sIGdyb3VwT3JkZXIgLSBfMW4pICsgXzFuO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRvdGFsIG51bWJlciBvZiBieXRlcyBjb25zdW1lZCBieSB0aGUgZmllbGQgZWxlbWVudC5cbiAqIEZvciBleGFtcGxlLCAzMiBieXRlcyBmb3IgdXN1YWwgMjU2LWJpdCB3ZWllcnN0cmFzcyBjdXJ2ZS5cbiAqIEBwYXJhbSBmaWVsZE9yZGVyIG51bWJlciBvZiBmaWVsZCBlbGVtZW50cywgdXN1YWxseSBDVVJWRS5uXG4gKiBAcmV0dXJucyBieXRlIGxlbmd0aCBvZiBmaWVsZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKSB7XG4gICAgaWYgKHR5cGVvZiBmaWVsZE9yZGVyICE9PSAnYmlnaW50JylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWVsZCBvcmRlciBtdXN0IGJlIGJpZ2ludCcpO1xuICAgIGNvbnN0IGJpdExlbmd0aCA9IGZpZWxkT3JkZXIudG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIHJldHVybiBNYXRoLmNlaWwoYml0TGVuZ3RoIC8gOCk7XG59XG4vKipcbiAqIFJldHVybnMgbWluaW1hbCBhbW91bnQgb2YgYnl0ZXMgdGhhdCBjYW4gYmUgc2FmZWx5IHJlZHVjZWRcbiAqIGJ5IGZpZWxkIG9yZGVyLlxuICogU2hvdWxkIGJlIDJeLTEyOCBmb3IgMTI4LWJpdCBjdXJ2ZSBzdWNoIGFzIFAyNTYuXG4gKiBAcGFyYW0gZmllbGRPcmRlciBudW1iZXIgb2YgZmllbGQgZWxlbWVudHMsIHVzdWFsbHkgQ1VSVkUublxuICogQHJldHVybnMgYnl0ZSBsZW5ndGggb2YgdGFyZ2V0IGhhc2hcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1pbkhhc2hMZW5ndGgoZmllbGRPcmRlcikge1xuICAgIGNvbnN0IGxlbmd0aCA9IGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgcmV0dXJuIGxlbmd0aCArIE1hdGguY2VpbChsZW5ndGggLyAyKTtcbn1cbi8qKlxuICogXCJDb25zdGFudC10aW1lXCIgcHJpdmF0ZSBrZXkgZ2VuZXJhdGlvbiB1dGlsaXR5LlxuICogQ2FuIHRha2UgKG4gKyBuLzIpIG9yIG1vcmUgYnl0ZXMgb2YgdW5pZm9ybSBpbnB1dCBlLmcuIGZyb20gQ1NQUk5HIG9yIEtERlxuICogYW5kIGNvbnZlcnQgdGhlbSBpbnRvIHByaXZhdGUgc2NhbGFyLCB3aXRoIHRoZSBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWdpYmxlLlxuICogTmVlZHMgYXQgbGVhc3QgNDggYnl0ZXMgb2YgaW5wdXQgZm9yIDMyLWJ5dGUgcHJpdmF0ZSBrZXkuXG4gKiBodHRwczovL3Jlc2VhcmNoLmt1ZGVsc2tpc2VjdXJpdHkuY29tLzIwMjAvMDcvMjgvdGhlLWRlZmluaXRpdmUtZ3VpZGUtdG8tbW9kdWxvLWJpYXMtYW5kLWhvdy10by1hdm9pZC1pdC9cbiAqIEZJUFMgMTg2LTUsIEEuMiBodHRwczovL2NzcmMubmlzdC5nb3YvcHVibGljYXRpb25zL2RldGFpbC9maXBzLzE4Ni81L2ZpbmFsXG4gKiBSRkMgOTM4MCwgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01XG4gKiBAcGFyYW0gaGFzaCBoYXNoIG91dHB1dCBmcm9tIFNIQTMgb3IgYSBzaW1pbGFyIGZ1bmN0aW9uXG4gKiBAcGFyYW0gZ3JvdXBPcmRlciBzaXplIG9mIHN1Ymdyb3VwIC0gKGUuZy4gc2VjcDI1NmsxLkNVUlZFLm4pXG4gKiBAcGFyYW0gaXNMRSBpbnRlcnByZXQgaGFzaCBieXRlcyBhcyBMRSBudW1cbiAqIEByZXR1cm5zIHZhbGlkIHByaXZhdGUgc2NhbGFyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBIYXNoVG9GaWVsZChrZXksIGZpZWxkT3JkZXIsIGlzTEUgPSBmYWxzZSkge1xuICAgIGNvbnN0IGxlbiA9IGtleS5sZW5ndGg7XG4gICAgY29uc3QgZmllbGRMZW4gPSBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIGNvbnN0IG1pbkxlbiA9IGdldE1pbkhhc2hMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgLy8gTm8gc21hbGwgbnVtYmVyczogbmVlZCB0byB1bmRlcnN0YW5kIGJpYXMgc3RvcnkuIE5vIGh1Z2UgbnVtYmVyczogZWFzaWVyIHRvIGRldGVjdCBKUyB0aW1pbmdzLlxuICAgIGlmIChsZW4gPCAxNiB8fCBsZW4gPCBtaW5MZW4gfHwgbGVuID4gMTAyNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCAke21pbkxlbn0tMTAyNCBieXRlcyBvZiBpbnB1dCwgZ290ICR7bGVufWApO1xuICAgIGNvbnN0IG51bSA9IGlzTEUgPyBieXRlc1RvTnVtYmVyQkUoa2V5KSA6IGJ5dGVzVG9OdW1iZXJMRShrZXkpO1xuICAgIC8vIGBtb2QoeCwgMTEpYCBjYW4gc29tZXRpbWVzIHByb2R1Y2UgMC4gYG1vZCh4LCAxMCkgKyAxYCBpcyB0aGUgc2FtZSwgYnV0IG5vIDBcbiAgICBjb25zdCByZWR1Y2VkID0gbW9kKG51bSwgZmllbGRPcmRlciAtIF8xbikgKyBfMW47XG4gICAgcmV0dXJuIGlzTEUgPyBudW1iZXJUb0J5dGVzTEUocmVkdWNlZCwgZmllbGRMZW4pIDogbnVtYmVyVG9CeXRlc0JFKHJlZHVjZWQsIGZpZWxkTGVuKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsYXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/modular.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/montgomery.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/@noble/curves/esm/abstract/montgomery.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   montgomery: function() { return /* binding */ montgomery; }\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction validateOpts(curve) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(curve, {\n        a: 'bigint',\n    }, {\n        montgomeryBits: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n        adjustScalarBytes: 'function',\n        domain: 'function',\n        powPminus2: 'function',\n        Gu: 'bigint',\n    });\n    // Set defaults\n    return Object.freeze({ ...curve });\n}\n// NOTE: not really montgomery curve, just bunch of very specific methods for X25519/X448 (RFC 7748, https://www.rfc-editor.org/rfc/rfc7748)\n// Uses only one coordinate instead of two\nfunction montgomery(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { P } = CURVE;\n    const modP = (n) => (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mod)(n, P);\n    const montgomeryBits = CURVE.montgomeryBits;\n    const montgomeryBytes = Math.ceil(montgomeryBits / 8);\n    const fieldLen = CURVE.nByteLength;\n    const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes);\n    const powPminus2 = CURVE.powPminus2 || ((x) => (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.pow)(x, P - BigInt(2), P));\n    // cswap from RFC7748. But it is not from RFC7748!\n    /*\n      cswap(swap, x_2, x_3):\n           dummy = mask(swap) AND (x_2 XOR x_3)\n           x_2 = x_2 XOR dummy\n           x_3 = x_3 XOR dummy\n           Return (x_2, x_3)\n    Where mask(swap) is the all-1 or all-0 word of the same length as x_2\n     and x_3, computed, e.g., as mask(swap) = 0 - swap.\n    */\n    function cswap(swap, x_2, x_3) {\n        const dummy = modP(swap * (x_2 - x_3));\n        x_2 = modP(x_2 - dummy);\n        x_3 = modP(x_3 + dummy);\n        return [x_2, x_3];\n    }\n    // Accepts 0 as well\n    function assertFieldElement(n) {\n        if (typeof n === 'bigint' && _0n <= n && n < P)\n            return n;\n        throw new Error('Expected valid scalar 0 < scalar < CURVE.P');\n    }\n    // x25519 from 4\n    // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519\n    const a24 = (CURVE.a - BigInt(2)) / BigInt(4);\n    /**\n     *\n     * @param pointU u coordinate (x) on Montgomery Curve 25519\n     * @param scalar by which the point would be multiplied\n     * @returns new Point on Montgomery curve\n     */\n    function montgomeryLadder(pointU, scalar) {\n        const u = assertFieldElement(pointU);\n        // Section 5: Implementations MUST accept non-canonical values and process them as\n        // if they had been reduced modulo the field prime.\n        const k = assertFieldElement(scalar);\n        const x_1 = u;\n        let x_2 = _1n;\n        let z_2 = _0n;\n        let x_3 = u;\n        let z_3 = _1n;\n        let swap = _0n;\n        let sw;\n        for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {\n            const k_t = (k >> t) & _1n;\n            swap ^= k_t;\n            sw = cswap(swap, x_2, x_3);\n            x_2 = sw[0];\n            x_3 = sw[1];\n            sw = cswap(swap, z_2, z_3);\n            z_2 = sw[0];\n            z_3 = sw[1];\n            swap = k_t;\n            const A = x_2 + z_2;\n            const AA = modP(A * A);\n            const B = x_2 - z_2;\n            const BB = modP(B * B);\n            const E = AA - BB;\n            const C = x_3 + z_3;\n            const D = x_3 - z_3;\n            const DA = modP(D * A);\n            const CB = modP(C * B);\n            const dacb = DA + CB;\n            const da_cb = DA - CB;\n            x_3 = modP(dacb * dacb);\n            z_3 = modP(x_1 * modP(da_cb * da_cb));\n            x_2 = modP(AA * BB);\n            z_2 = modP(E * (AA + modP(a24 * E)));\n        }\n        // (x_2, x_3) = cswap(swap, x_2, x_3)\n        sw = cswap(swap, x_2, x_3);\n        x_2 = sw[0];\n        x_3 = sw[1];\n        // (z_2, z_3) = cswap(swap, z_2, z_3)\n        sw = cswap(swap, z_2, z_3);\n        z_2 = sw[0];\n        z_3 = sw[1];\n        // z_2^(p - 2)\n        const z2 = powPminus2(z_2);\n        // Return x_2 * (z_2^(p - 2))\n        return modP(x_2 * z2);\n    }\n    function encodeUCoordinate(u) {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(modP(u), montgomeryBytes);\n    }\n    function decodeUCoordinate(uEnc) {\n        // Section 5: When receiving such an array, implementations of X25519\n        // MUST mask the most significant bit in the final byte.\n        const u = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('u coordinate', uEnc, montgomeryBytes);\n        if (fieldLen === 32)\n            u[31] &= 127; // 0b0111_1111\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(u);\n    }\n    function decodeScalar(n) {\n        const bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('scalar', n);\n        const len = bytes.length;\n        if (len !== montgomeryBytes && len !== fieldLen)\n            throw new Error(`Expected ${montgomeryBytes} or ${fieldLen} bytes, got ${len}`);\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(adjustScalarBytes(bytes));\n    }\n    function scalarMult(scalar, u) {\n        const pointU = decodeUCoordinate(u);\n        const _scalar = decodeScalar(scalar);\n        const pu = montgomeryLadder(pointU, _scalar);\n        // The result was not contributory\n        // https://cr.yp.to/ecdh.html#validate\n        if (pu === _0n)\n            throw new Error('Invalid private or public key received');\n        return encodeUCoordinate(pu);\n    }\n    // Computes public key from private. By doing scalar multiplication of base point.\n    const GuBytes = encodeUCoordinate(CURVE.Gu);\n    function scalarMultBase(scalar) {\n        return scalarMult(scalar, GuBytes);\n    }\n    return {\n        scalarMult,\n        scalarMultBase,\n        getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),\n        getPublicKey: (privateKey) => scalarMultBase(privateKey),\n        utils: { randomPrivateKey: () => CURVE.randomBytes(CURVE.nByteLength) },\n        GuBytes: GuBytes,\n    };\n}\n//# sourceMappingURL=montgomery.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvbW9udGdvbWVyeS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUN3QztBQUNtRDtBQUMzRjtBQUNBO0FBQ0E7QUFDQSxJQUFJLHlEQUFjO0FBQ2xCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDJCQUEyQixVQUFVO0FBQ3JDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxZQUFZLElBQUk7QUFDaEIsd0JBQXdCLGdEQUFHO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGdEQUFHO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFVBQVU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwREFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzREFBVztBQUM3QjtBQUNBLDBCQUEwQjtBQUMxQixlQUFlLDBEQUFlO0FBQzlCO0FBQ0E7QUFDQSxzQkFBc0Isc0RBQVc7QUFDakM7QUFDQTtBQUNBLHdDQUF3QyxpQkFBaUIsS0FBSyxVQUFVLGFBQWEsSUFBSTtBQUN6RixlQUFlLDBEQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw4REFBOEQ7QUFDL0U7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9tb250Z29tZXJ5LmpzP2ZmMTgiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgbW9kLCBwb3cgfSBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0IHsgYnl0ZXNUb051bWJlckxFLCBlbnN1cmVCeXRlcywgbnVtYmVyVG9CeXRlc0xFLCB2YWxpZGF0ZU9iamVjdCB9IGZyb20gJy4vdXRpbHMuanMnO1xuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuZnVuY3Rpb24gdmFsaWRhdGVPcHRzKGN1cnZlKSB7XG4gICAgdmFsaWRhdGVPYmplY3QoY3VydmUsIHtcbiAgICAgICAgYTogJ2JpZ2ludCcsXG4gICAgfSwge1xuICAgICAgICBtb250Z29tZXJ5Qml0czogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBuQnl0ZUxlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBhZGp1c3RTY2FsYXJCeXRlczogJ2Z1bmN0aW9uJyxcbiAgICAgICAgZG9tYWluOiAnZnVuY3Rpb24nLFxuICAgICAgICBwb3dQbWludXMyOiAnZnVuY3Rpb24nLFxuICAgICAgICBHdTogJ2JpZ2ludCcsXG4gICAgfSk7XG4gICAgLy8gU2V0IGRlZmF1bHRzXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5jdXJ2ZSB9KTtcbn1cbi8vIE5PVEU6IG5vdCByZWFsbHkgbW9udGdvbWVyeSBjdXJ2ZSwganVzdCBidW5jaCBvZiB2ZXJ5IHNwZWNpZmljIG1ldGhvZHMgZm9yIFgyNTUxOS9YNDQ4IChSRkMgNzc0OCwgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzc3NDgpXG4vLyBVc2VzIG9ubHkgb25lIGNvb3JkaW5hdGUgaW5zdGVhZCBvZiB0d29cbmV4cG9ydCBmdW5jdGlvbiBtb250Z29tZXJ5KGN1cnZlRGVmKSB7XG4gICAgY29uc3QgQ1VSVkUgPSB2YWxpZGF0ZU9wdHMoY3VydmVEZWYpO1xuICAgIGNvbnN0IHsgUCB9ID0gQ1VSVkU7XG4gICAgY29uc3QgbW9kUCA9IChuKSA9PiBtb2QobiwgUCk7XG4gICAgY29uc3QgbW9udGdvbWVyeUJpdHMgPSBDVVJWRS5tb250Z29tZXJ5Qml0cztcbiAgICBjb25zdCBtb250Z29tZXJ5Qnl0ZXMgPSBNYXRoLmNlaWwobW9udGdvbWVyeUJpdHMgLyA4KTtcbiAgICBjb25zdCBmaWVsZExlbiA9IENVUlZFLm5CeXRlTGVuZ3RoO1xuICAgIGNvbnN0IGFkanVzdFNjYWxhckJ5dGVzID0gQ1VSVkUuYWRqdXN0U2NhbGFyQnl0ZXMgfHwgKChieXRlcykgPT4gYnl0ZXMpO1xuICAgIGNvbnN0IHBvd1BtaW51czIgPSBDVVJWRS5wb3dQbWludXMyIHx8ICgoeCkgPT4gcG93KHgsIFAgLSBCaWdJbnQoMiksIFApKTtcbiAgICAvLyBjc3dhcCBmcm9tIFJGQzc3NDguIEJ1dCBpdCBpcyBub3QgZnJvbSBSRkM3NzQ4IVxuICAgIC8qXG4gICAgICBjc3dhcChzd2FwLCB4XzIsIHhfMyk6XG4gICAgICAgICAgIGR1bW15ID0gbWFzayhzd2FwKSBBTkQgKHhfMiBYT1IgeF8zKVxuICAgICAgICAgICB4XzIgPSB4XzIgWE9SIGR1bW15XG4gICAgICAgICAgIHhfMyA9IHhfMyBYT1IgZHVtbXlcbiAgICAgICAgICAgUmV0dXJuICh4XzIsIHhfMylcbiAgICBXaGVyZSBtYXNrKHN3YXApIGlzIHRoZSBhbGwtMSBvciBhbGwtMCB3b3JkIG9mIHRoZSBzYW1lIGxlbmd0aCBhcyB4XzJcbiAgICAgYW5kIHhfMywgY29tcHV0ZWQsIGUuZy4sIGFzIG1hc2soc3dhcCkgPSAwIC0gc3dhcC5cbiAgICAqL1xuICAgIGZ1bmN0aW9uIGNzd2FwKHN3YXAsIHhfMiwgeF8zKSB7XG4gICAgICAgIGNvbnN0IGR1bW15ID0gbW9kUChzd2FwICogKHhfMiAtIHhfMykpO1xuICAgICAgICB4XzIgPSBtb2RQKHhfMiAtIGR1bW15KTtcbiAgICAgICAgeF8zID0gbW9kUCh4XzMgKyBkdW1teSk7XG4gICAgICAgIHJldHVybiBbeF8yLCB4XzNdO1xuICAgIH1cbiAgICAvLyBBY2NlcHRzIDAgYXMgd2VsbFxuICAgIGZ1bmN0aW9uIGFzc2VydEZpZWxkRWxlbWVudChuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbiA9PT0gJ2JpZ2ludCcgJiYgXzBuIDw9IG4gJiYgbiA8IFApXG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB2YWxpZCBzY2FsYXIgMCA8IHNjYWxhciA8IENVUlZFLlAnKTtcbiAgICB9XG4gICAgLy8geDI1NTE5IGZyb20gNFxuICAgIC8vIFRoZSBjb25zdGFudCBhMjQgaXMgKDQ4NjY2MiAtIDIpIC8gNCA9IDEyMTY2NSBmb3IgY3VydmUyNTUxOS9YMjU1MTlcbiAgICBjb25zdCBhMjQgPSAoQ1VSVkUuYSAtIEJpZ0ludCgyKSkgLyBCaWdJbnQoNCk7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcG9pbnRVIHUgY29vcmRpbmF0ZSAoeCkgb24gTW9udGdvbWVyeSBDdXJ2ZSAyNTUxOVxuICAgICAqIEBwYXJhbSBzY2FsYXIgYnkgd2hpY2ggdGhlIHBvaW50IHdvdWxkIGJlIG11bHRpcGxpZWRcbiAgICAgKiBAcmV0dXJucyBuZXcgUG9pbnQgb24gTW9udGdvbWVyeSBjdXJ2ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1vbnRnb21lcnlMYWRkZXIocG9pbnRVLCBzY2FsYXIpIHtcbiAgICAgICAgY29uc3QgdSA9IGFzc2VydEZpZWxkRWxlbWVudChwb2ludFUpO1xuICAgICAgICAvLyBTZWN0aW9uIDU6IEltcGxlbWVudGF0aW9ucyBNVVNUIGFjY2VwdCBub24tY2Fub25pY2FsIHZhbHVlcyBhbmQgcHJvY2VzcyB0aGVtIGFzXG4gICAgICAgIC8vIGlmIHRoZXkgaGFkIGJlZW4gcmVkdWNlZCBtb2R1bG8gdGhlIGZpZWxkIHByaW1lLlxuICAgICAgICBjb25zdCBrID0gYXNzZXJ0RmllbGRFbGVtZW50KHNjYWxhcik7XG4gICAgICAgIGNvbnN0IHhfMSA9IHU7XG4gICAgICAgIGxldCB4XzIgPSBfMW47XG4gICAgICAgIGxldCB6XzIgPSBfMG47XG4gICAgICAgIGxldCB4XzMgPSB1O1xuICAgICAgICBsZXQgel8zID0gXzFuO1xuICAgICAgICBsZXQgc3dhcCA9IF8wbjtcbiAgICAgICAgbGV0IHN3O1xuICAgICAgICBmb3IgKGxldCB0ID0gQmlnSW50KG1vbnRnb21lcnlCaXRzIC0gMSk7IHQgPj0gXzBuOyB0LS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGtfdCA9IChrID4+IHQpICYgXzFuO1xuICAgICAgICAgICAgc3dhcCBePSBrX3Q7XG4gICAgICAgICAgICBzdyA9IGNzd2FwKHN3YXAsIHhfMiwgeF8zKTtcbiAgICAgICAgICAgIHhfMiA9IHN3WzBdO1xuICAgICAgICAgICAgeF8zID0gc3dbMV07XG4gICAgICAgICAgICBzdyA9IGNzd2FwKHN3YXAsIHpfMiwgel8zKTtcbiAgICAgICAgICAgIHpfMiA9IHN3WzBdO1xuICAgICAgICAgICAgel8zID0gc3dbMV07XG4gICAgICAgICAgICBzd2FwID0ga190O1xuICAgICAgICAgICAgY29uc3QgQSA9IHhfMiArIHpfMjtcbiAgICAgICAgICAgIGNvbnN0IEFBID0gbW9kUChBICogQSk7XG4gICAgICAgICAgICBjb25zdCBCID0geF8yIC0gel8yO1xuICAgICAgICAgICAgY29uc3QgQkIgPSBtb2RQKEIgKiBCKTtcbiAgICAgICAgICAgIGNvbnN0IEUgPSBBQSAtIEJCO1xuICAgICAgICAgICAgY29uc3QgQyA9IHhfMyArIHpfMztcbiAgICAgICAgICAgIGNvbnN0IEQgPSB4XzMgLSB6XzM7XG4gICAgICAgICAgICBjb25zdCBEQSA9IG1vZFAoRCAqIEEpO1xuICAgICAgICAgICAgY29uc3QgQ0IgPSBtb2RQKEMgKiBCKTtcbiAgICAgICAgICAgIGNvbnN0IGRhY2IgPSBEQSArIENCO1xuICAgICAgICAgICAgY29uc3QgZGFfY2IgPSBEQSAtIENCO1xuICAgICAgICAgICAgeF8zID0gbW9kUChkYWNiICogZGFjYik7XG4gICAgICAgICAgICB6XzMgPSBtb2RQKHhfMSAqIG1vZFAoZGFfY2IgKiBkYV9jYikpO1xuICAgICAgICAgICAgeF8yID0gbW9kUChBQSAqIEJCKTtcbiAgICAgICAgICAgIHpfMiA9IG1vZFAoRSAqIChBQSArIG1vZFAoYTI0ICogRSkpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAoeF8yLCB4XzMpID0gY3N3YXAoc3dhcCwgeF8yLCB4XzMpXG4gICAgICAgIHN3ID0gY3N3YXAoc3dhcCwgeF8yLCB4XzMpO1xuICAgICAgICB4XzIgPSBzd1swXTtcbiAgICAgICAgeF8zID0gc3dbMV07XG4gICAgICAgIC8vICh6XzIsIHpfMykgPSBjc3dhcChzd2FwLCB6XzIsIHpfMylcbiAgICAgICAgc3cgPSBjc3dhcChzd2FwLCB6XzIsIHpfMyk7XG4gICAgICAgIHpfMiA9IHN3WzBdO1xuICAgICAgICB6XzMgPSBzd1sxXTtcbiAgICAgICAgLy8gel8yXihwIC0gMilcbiAgICAgICAgY29uc3QgejIgPSBwb3dQbWludXMyKHpfMik7XG4gICAgICAgIC8vIFJldHVybiB4XzIgKiAoel8yXihwIC0gMikpXG4gICAgICAgIHJldHVybiBtb2RQKHhfMiAqIHoyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5jb2RlVUNvb3JkaW5hdGUodSkge1xuICAgICAgICByZXR1cm4gbnVtYmVyVG9CeXRlc0xFKG1vZFAodSksIG1vbnRnb21lcnlCeXRlcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY29kZVVDb29yZGluYXRlKHVFbmMpIHtcbiAgICAgICAgLy8gU2VjdGlvbiA1OiBXaGVuIHJlY2VpdmluZyBzdWNoIGFuIGFycmF5LCBpbXBsZW1lbnRhdGlvbnMgb2YgWDI1NTE5XG4gICAgICAgIC8vIE1VU1QgbWFzayB0aGUgbW9zdCBzaWduaWZpY2FudCBiaXQgaW4gdGhlIGZpbmFsIGJ5dGUuXG4gICAgICAgIGNvbnN0IHUgPSBlbnN1cmVCeXRlcygndSBjb29yZGluYXRlJywgdUVuYywgbW9udGdvbWVyeUJ5dGVzKTtcbiAgICAgICAgaWYgKGZpZWxkTGVuID09PSAzMilcbiAgICAgICAgICAgIHVbMzFdICY9IDEyNzsgLy8gMGIwMTExXzExMTFcbiAgICAgICAgcmV0dXJuIGJ5dGVzVG9OdW1iZXJMRSh1KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlU2NhbGFyKG4pIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBlbnN1cmVCeXRlcygnc2NhbGFyJywgbik7XG4gICAgICAgIGNvbnN0IGxlbiA9IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiAhPT0gbW9udGdvbWVyeUJ5dGVzICYmIGxlbiAhPT0gZmllbGRMZW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkICR7bW9udGdvbWVyeUJ5dGVzfSBvciAke2ZpZWxkTGVufSBieXRlcywgZ290ICR7bGVufWApO1xuICAgICAgICByZXR1cm4gYnl0ZXNUb051bWJlckxFKGFkanVzdFNjYWxhckJ5dGVzKGJ5dGVzKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYWxhck11bHQoc2NhbGFyLCB1KSB7XG4gICAgICAgIGNvbnN0IHBvaW50VSA9IGRlY29kZVVDb29yZGluYXRlKHUpO1xuICAgICAgICBjb25zdCBfc2NhbGFyID0gZGVjb2RlU2NhbGFyKHNjYWxhcik7XG4gICAgICAgIGNvbnN0IHB1ID0gbW9udGdvbWVyeUxhZGRlcihwb2ludFUsIF9zY2FsYXIpO1xuICAgICAgICAvLyBUaGUgcmVzdWx0IHdhcyBub3QgY29udHJpYnV0b3J5XG4gICAgICAgIC8vIGh0dHBzOi8vY3IueXAudG8vZWNkaC5odG1sI3ZhbGlkYXRlXG4gICAgICAgIGlmIChwdSA9PT0gXzBuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHByaXZhdGUgb3IgcHVibGljIGtleSByZWNlaXZlZCcpO1xuICAgICAgICByZXR1cm4gZW5jb2RlVUNvb3JkaW5hdGUocHUpO1xuICAgIH1cbiAgICAvLyBDb21wdXRlcyBwdWJsaWMga2V5IGZyb20gcHJpdmF0ZS4gQnkgZG9pbmcgc2NhbGFyIG11bHRpcGxpY2F0aW9uIG9mIGJhc2UgcG9pbnQuXG4gICAgY29uc3QgR3VCeXRlcyA9IGVuY29kZVVDb29yZGluYXRlKENVUlZFLkd1KTtcbiAgICBmdW5jdGlvbiBzY2FsYXJNdWx0QmFzZShzY2FsYXIpIHtcbiAgICAgICAgcmV0dXJuIHNjYWxhck11bHQoc2NhbGFyLCBHdUJ5dGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2NhbGFyTXVsdCxcbiAgICAgICAgc2NhbGFyTXVsdEJhc2UsXG4gICAgICAgIGdldFNoYXJlZFNlY3JldDogKHByaXZhdGVLZXksIHB1YmxpY0tleSkgPT4gc2NhbGFyTXVsdChwcml2YXRlS2V5LCBwdWJsaWNLZXkpLFxuICAgICAgICBnZXRQdWJsaWNLZXk6IChwcml2YXRlS2V5KSA9PiBzY2FsYXJNdWx0QmFzZShwcml2YXRlS2V5KSxcbiAgICAgICAgdXRpbHM6IHsgcmFuZG9tUHJpdmF0ZUtleTogKCkgPT4gQ1VSVkUucmFuZG9tQnl0ZXMoQ1VSVkUubkJ5dGVMZW5ndGgpIH0sXG4gICAgICAgIEd1Qnl0ZXM6IEd1Qnl0ZXMsXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vbnRnb21lcnkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/montgomery.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/utils.js":
/*!**************************************************************!*\
  !*** ../../node_modules/@noble/curves/esm/abstract/utils.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   abytes: function() { return /* binding */ abytes; },\n/* harmony export */   bitGet: function() { return /* binding */ bitGet; },\n/* harmony export */   bitLen: function() { return /* binding */ bitLen; },\n/* harmony export */   bitMask: function() { return /* binding */ bitMask; },\n/* harmony export */   bitSet: function() { return /* binding */ bitSet; },\n/* harmony export */   bytesToHex: function() { return /* binding */ bytesToHex; },\n/* harmony export */   bytesToNumberBE: function() { return /* binding */ bytesToNumberBE; },\n/* harmony export */   bytesToNumberLE: function() { return /* binding */ bytesToNumberLE; },\n/* harmony export */   concatBytes: function() { return /* binding */ concatBytes; },\n/* harmony export */   createHmacDrbg: function() { return /* binding */ createHmacDrbg; },\n/* harmony export */   ensureBytes: function() { return /* binding */ ensureBytes; },\n/* harmony export */   equalBytes: function() { return /* binding */ equalBytes; },\n/* harmony export */   hexToBytes: function() { return /* binding */ hexToBytes; },\n/* harmony export */   hexToNumber: function() { return /* binding */ hexToNumber; },\n/* harmony export */   isBytes: function() { return /* binding */ isBytes; },\n/* harmony export */   numberToBytesBE: function() { return /* binding */ numberToBytesBE; },\n/* harmony export */   numberToBytesLE: function() { return /* binding */ numberToBytesLE; },\n/* harmony export */   numberToHexUnpadded: function() { return /* binding */ numberToHexUnpadded; },\n/* harmony export */   numberToVarBytesBE: function() { return /* binding */ numberToVarBytesBE; },\n/* harmony export */   utf8ToBytes: function() { return /* binding */ utf8ToBytes; },\n/* harmony export */   validateObject: function() { return /* binding */ validateObject; }\n/* harmony export */ });\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction abytes(item) {\n    if (!isBytes(item))\n        throw new Error('Uint8Array expected');\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    abytes(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // Big Endian\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    abytes(bytes);\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nfunction ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    }\n    else if (isBytes(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nfunction bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nfunction bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nfunction bitSet(n, pos, value) {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nconst bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n()) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || isBytes(val),\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLElBQUk7QUFDOUM7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFNBQVM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPLGlDQUFpQyxJQUFJLFlBQVksRUFBRTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU8sV0FBVyxnQkFBZ0IsYUFBYSxJQUFJO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG1CQUFtQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDREQUE0RCxXQUFXO0FBQ3ZFLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNEJBQTRCO0FBQ25EO0FBQ087QUFDUDtBQUNBLDRDQUE0QztBQUM1Qyw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQ25ELDhEQUE4RDtBQUNyRTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsS0FBSztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxrQkFBa0IsR0FBRyxLQUFLLEdBQUcsV0FBVyxjQUFjLEtBQUs7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXLFdBQVcsWUFBWSxJQUFJO0FBQ3BELGtDQUFrQyxvQkFBb0IsSUFBSSxhQUFhLEdBQUc7QUFDMUU7QUFDQSxrQ0FBa0MsVUFBVSxJQUFJLFNBQVM7QUFDekQsa0NBQWtDLG9CQUFvQixJQUFJLFNBQVM7QUFDbkUsa0NBQWtDLDJCQUEyQjtBQUM3RCxrQ0FBa0Msd0JBQXdCO0FBQzFEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvdXRpbHMuanM/ZjAwMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyAxMDAgbGluZXMgb2YgY29kZSBpbiB0aGUgZmlsZSBhcmUgZHVwbGljYXRlZCBmcm9tIG5vYmxlLWhhc2hlcyAodXRpbHMpLlxuLy8gVGhpcyBpcyBPSzogYGFic3RyYWN0YCBkaXJlY3RvcnkgZG9lcyBub3QgdXNlIG5vYmxlLWhhc2hlcy5cbi8vIFVzZXIgbWF5IG9wdC1pbiBpbnRvIHVzaW5nIGRpZmZlcmVudCBoYXNoaW5nIGxpYnJhcnkuIFRoaXMgd2F5LCBub2JsZS1oYXNoZXNcbi8vIHdvbid0IGJlIGluY2x1ZGVkIGludG8gdGhlaXIgYnVuZGxlLlxuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gQmlnSW50KDIpO1xuZXhwb3J0IGZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuICAgIHJldHVybiAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHxcbiAgICAgICAgKGEgIT0gbnVsbCAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhYnl0ZXMoaXRlbSkge1xuICAgIGlmICghaXNCeXRlcyhpdGVtKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG59XG4vLyBBcnJheSB3aGVyZSBpbmRleCAweGYwICgyNDApIGlzIG1hcHBlZCB0byBzdHJpbmcgJ2YwJ1xuY29uc3QgaGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfLCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGFieXRlcyhieXRlcyk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0hleFVucGFkZGVkKG51bSkge1xuICAgIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gYDAke2hleH1gIDogaGV4O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhleFRvTnVtYmVyKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIC8vIEJpZyBFbmRpYW5cbiAgICByZXR1cm4gQmlnSW50KGhleCA9PT0gJycgPyAnMCcgOiBgMHgke2hleH1gKTtcbn1cbi8vIFdlIHVzZSBvcHRpbWl6ZWQgdGVjaG5pcXVlIHRvIGNvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5XG5jb25zdCBhc2NpaXMgPSB7IF8wOiA0OCwgXzk6IDU3LCBfQTogNjUsIF9GOiA3MCwgX2E6IDk3LCBfZjogMTAyIH07XG5mdW5jdGlvbiBhc2NpaVRvQmFzZTE2KGNoYXIpIHtcbiAgICBpZiAoY2hhciA+PSBhc2NpaXMuXzAgJiYgY2hhciA8PSBhc2NpaXMuXzkpXG4gICAgICAgIHJldHVybiBjaGFyIC0gYXNjaWlzLl8wO1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fQSAmJiBjaGFyIDw9IGFzY2lpcy5fRilcbiAgICAgICAgcmV0dXJuIGNoYXIgLSAoYXNjaWlzLl9BIC0gMTApO1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fYSAmJiBjaGFyIDw9IGFzY2lpcy5fZilcbiAgICAgICAgcmV0dXJuIGNoYXIgLSAoYXNjaWlzLl9hIC0gMTApO1xuICAgIHJldHVybjtcbn1cbi8qKlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICBjb25zdCBobCA9IGhleC5sZW5ndGg7XG4gICAgY29uc3QgYWwgPSBobCAvIDI7XG4gICAgaWYgKGhsICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkZWQgaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGhsKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFsKTtcbiAgICBmb3IgKGxldCBhaSA9IDAsIGhpID0gMDsgYWkgPCBhbDsgYWkrKywgaGkgKz0gMikge1xuICAgICAgICBjb25zdCBuMSA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkpKTtcbiAgICAgICAgY29uc3QgbjIgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpICsgMSkpO1xuICAgICAgICBpZiAobjEgPT09IHVuZGVmaW5lZCB8fCBuMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gaGV4W2hpXSArIGhleFtoaSArIDFdO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3Qgbm9uLWhleCBjaGFyYWN0ZXIgXCInICsgY2hhciArICdcIiBhdCBpbmRleCAnICsgaGkpO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5W2FpXSA9IG4xICogMTYgKyBuMjtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuLy8gQkU6IEJpZyBFbmRpYW4sIExFOiBMaXR0bGUgRW5kaWFuXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb051bWJlckJFKGJ5dGVzKSB7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoYnl0ZXMpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvTnVtYmVyTEUoYnl0ZXMpIHtcbiAgICBhYnl0ZXMoYnl0ZXMpO1xuICAgIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShieXRlcykucmV2ZXJzZSgpKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0JFKG4sIGxlbikge1xuICAgIHJldHVybiBoZXhUb0J5dGVzKG4udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KGxlbiAqIDIsICcwJykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvQnl0ZXNMRShuLCBsZW4pIHtcbiAgICByZXR1cm4gbnVtYmVyVG9CeXRlc0JFKG4sIGxlbikucmV2ZXJzZSgpO1xufVxuLy8gVW5wYWRkZWQsIHJhcmVseSB1c2VkXG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9WYXJCeXRlc0JFKG4pIHtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhudW1iZXJUb0hleFVucGFkZGVkKG4pKTtcbn1cbi8qKlxuICogVGFrZXMgaGV4IHN0cmluZyBvciBVaW50OEFycmF5LCBjb252ZXJ0cyB0byBVaW50OEFycmF5LlxuICogVmFsaWRhdGVzIG91dHB1dCBsZW5ndGguXG4gKiBXaWxsIHRocm93IGVycm9yIGZvciBvdGhlciB0eXBlcy5cbiAqIEBwYXJhbSB0aXRsZSBkZXNjcmlwdGl2ZSB0aXRsZSBmb3IgYW4gZXJyb3IgZS5nLiAncHJpdmF0ZSBrZXknXG4gKiBAcGFyYW0gaGV4IGhleCBzdHJpbmcgb3IgVWludDhBcnJheVxuICogQHBhcmFtIGV4cGVjdGVkTGVuZ3RoIG9wdGlvbmFsLCB3aWxsIGNvbXBhcmUgdG8gcmVzdWx0IGFycmF5J3MgbGVuZ3RoXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlQnl0ZXModGl0bGUsIGhleCwgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICBsZXQgcmVzO1xuICAgIGlmICh0eXBlb2YgaGV4ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzID0gaGV4VG9CeXRlcyhoZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IG11c3QgYmUgdmFsaWQgaGV4IHN0cmluZywgZ290IFwiJHtoZXh9XCIuIENhdXNlOiAke2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNCeXRlcyhoZXgpKSB7XG4gICAgICAgIC8vIFVpbnQ4QXJyYXkuZnJvbSgpIGluc3RlYWQgb2YgaGFzaC5zbGljZSgpIGJlY2F1c2Ugbm9kZS5qcyBCdWZmZXJcbiAgICAgICAgLy8gaXMgaW5zdGFuY2Ugb2YgVWludDhBcnJheSwgYW5kIGl0cyBzbGljZSgpIGNyZWF0ZXMgKiptdXRhYmxlKiogY29weVxuICAgICAgICByZXMgPSBVaW50OEFycmF5LmZyb20oaGV4KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aXRsZX0gbXVzdCBiZSBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXlgKTtcbiAgICB9XG4gICAgY29uc3QgbGVuID0gcmVzLmxlbmd0aDtcbiAgICBpZiAodHlwZW9mIGV4cGVjdGVkTGVuZ3RoID09PSAnbnVtYmVyJyAmJiBsZW4gIT09IGV4cGVjdGVkTGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IGV4cGVjdGVkICR7ZXhwZWN0ZWRMZW5ndGh9IGJ5dGVzLCBnb3QgJHtsZW59YCk7XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKlxuICogQ29waWVzIHNldmVyYWwgVWludDhBcnJheXMgaW50byBvbmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICBhYnl0ZXMoYSk7XG4gICAgICAgIHN1bSArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoc3VtKTtcbiAgICBmb3IgKGxldCBpID0gMCwgcGFkID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICByZXMuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIENvbXBhcmVzIDIgdThhLXMgaW4ga2luZGEgY29uc3RhbnQgdGltZVxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFsQnl0ZXMoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZGlmZiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICBkaWZmIHw9IGFbaV0gXiBiW2ldO1xuICAgIHJldHVybiBkaWZmID09PSAwO1xufVxuLyoqXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gbmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN0cn1gKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG4vLyBCaXQgb3BlcmF0aW9uc1xuLyoqXG4gKiBDYWxjdWxhdGVzIGFtb3VudCBvZiBiaXRzIGluIGEgYmlnaW50LlxuICogU2FtZSBhcyBgbi50b1N0cmluZygyKS5sZW5ndGhgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaXRMZW4obikge1xuICAgIGxldCBsZW47XG4gICAgZm9yIChsZW4gPSAwOyBuID4gXzBuOyBuID4+PSBfMW4sIGxlbiArPSAxKVxuICAgICAgICA7XG4gICAgcmV0dXJuIGxlbjtcbn1cbi8qKlxuICogR2V0cyBzaW5nbGUgYml0IGF0IHBvc2l0aW9uLlxuICogTk9URTogZmlyc3QgYml0IHBvc2l0aW9uIGlzIDAgKHNhbWUgYXMgYXJyYXlzKVxuICogU2FtZSBhcyBgISErQXJyYXkuZnJvbShuLnRvU3RyaW5nKDIpKS5yZXZlcnNlKClbcG9zXWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpdEdldChuLCBwb3MpIHtcbiAgICByZXR1cm4gKG4gPj4gQmlnSW50KHBvcykpICYgXzFuO1xufVxuLyoqXG4gKiBTZXRzIHNpbmdsZSBiaXQgYXQgcG9zaXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaXRTZXQobiwgcG9zLCB2YWx1ZSkge1xuICAgIHJldHVybiBuIHwgKCh2YWx1ZSA/IF8xbiA6IF8wbikgPDwgQmlnSW50KHBvcykpO1xufVxuLyoqXG4gKiBDYWxjdWxhdGUgbWFzayBmb3IgTiBiaXRzLiBOb3QgdXNpbmcgKiogb3BlcmF0b3Igd2l0aCBiaWdpbnRzIGJlY2F1c2Ugb2Ygb2xkIGVuZ2luZXMuXG4gKiBTYW1lIGFzIEJpZ0ludChgMGIke0FycmF5KGkpLmZpbGwoJzEnKS5qb2luKCcnKX1gKVxuICovXG5leHBvcnQgY29uc3QgYml0TWFzayA9IChuKSA9PiAoXzJuIDw8IEJpZ0ludChuIC0gMSkpIC0gXzFuO1xuLy8gRFJCR1xuY29uc3QgdThuID0gKGRhdGEpID0+IG5ldyBVaW50OEFycmF5KGRhdGEpOyAvLyBjcmVhdGVzIFVpbnQ4QXJyYXlcbmNvbnN0IHU4ZnIgPSAoYXJyKSA9PiBVaW50OEFycmF5LmZyb20oYXJyKTsgLy8gYW5vdGhlciBzaG9ydGN1dFxuLyoqXG4gKiBNaW5pbWFsIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB0aGF0IHdpbGwgY2FsbCBEUkJHIHVudGlsIDJuZCBhcmcgcmV0dXJucyBzb21ldGhpbmcgbWVhbmluZ2Z1bFxuICogQGV4YW1wbGVcbiAqICAgY29uc3QgZHJiZyA9IGNyZWF0ZUhtYWNEUkJHPEtleT4oMzIsIDMyLCBobWFjKTtcbiAqICAgZHJiZyhzZWVkLCBieXRlc1RvS2V5KTsgLy8gYnl0ZXNUb0tleSBtdXN0IHJldHVybiBLZXkgb3IgdW5kZWZpbmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIbWFjRHJiZyhoYXNoTGVuLCBxQnl0ZUxlbiwgaG1hY0ZuKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoTGVuICE9PSAnbnVtYmVyJyB8fCBoYXNoTGVuIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIHFCeXRlTGVuICE9PSAnbnVtYmVyJyB8fCBxQnl0ZUxlbiA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncUJ5dGVMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIGlmICh0eXBlb2YgaG1hY0ZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2htYWNGbiBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAvLyBTdGVwIEIsIFN0ZXAgQzogc2V0IGhhc2hMZW4gdG8gOCpjZWlsKGhsZW4vOClcbiAgICBsZXQgdiA9IHU4bihoYXNoTGVuKTsgLy8gTWluaW1hbCBub24tZnVsbC1zcGVjIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gICAgbGV0IGsgPSB1OG4oaGFzaExlbik7IC8vIFN0ZXBzIEIgYW5kIEMgb2YgUkZDNjk3OSAzLjI6IHNldCBoYXNoTGVuLCBpbiBvdXIgY2FzZSBhbHdheXMgc2FtZVxuICAgIGxldCBpID0gMDsgLy8gSXRlcmF0aW9ucyBjb3VudGVyLCB3aWxsIHRocm93IHdoZW4gb3ZlciAxMDAwXG4gICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICAgIHYuZmlsbCgxKTtcbiAgICAgICAgay5maWxsKDApO1xuICAgICAgICBpID0gMDtcbiAgICB9O1xuICAgIGNvbnN0IGggPSAoLi4uYikgPT4gaG1hY0ZuKGssIHYsIC4uLmIpOyAvLyBobWFjKGspKHYsIC4uLnZhbHVlcylcbiAgICBjb25zdCByZXNlZWQgPSAoc2VlZCA9IHU4bigpKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyByZXNlZWQoKSBmdW5jdGlvbi4gU3RlcHMgRC1HXG4gICAgICAgIGsgPSBoKHU4ZnIoWzB4MDBdKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAwIHx8IHNlZWQpXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICAgICAgaWYgKHNlZWQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBrID0gaCh1OGZyKFsweDAxXSksIHNlZWQpOyAvLyBrID0gaG1hYyhrIHx8IHYgfHwgMHgwMSB8fCBzZWVkKVxuICAgICAgICB2ID0gaCgpOyAvLyB2ID0gaG1hYyhrIHx8IHYpXG4gICAgfTtcbiAgICBjb25zdCBnZW4gPSAoKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyBnZW5lcmF0ZSgpIGZ1bmN0aW9uXG4gICAgICAgIGlmIChpKysgPj0gMTAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZHJiZzogdHJpZWQgMTAwMCB2YWx1ZXMnKTtcbiAgICAgICAgbGV0IGxlbiA9IDA7XG4gICAgICAgIGNvbnN0IG91dCA9IFtdO1xuICAgICAgICB3aGlsZSAobGVuIDwgcUJ5dGVMZW4pIHtcbiAgICAgICAgICAgIHYgPSBoKCk7XG4gICAgICAgICAgICBjb25zdCBzbCA9IHYuc2xpY2UoKTtcbiAgICAgICAgICAgIG91dC5wdXNoKHNsKTtcbiAgICAgICAgICAgIGxlbiArPSB2Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uY2F0Qnl0ZXMoLi4ub3V0KTtcbiAgICB9O1xuICAgIGNvbnN0IGdlblVudGlsID0gKHNlZWQsIHByZWQpID0+IHtcbiAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgcmVzZWVkKHNlZWQpOyAvLyBTdGVwcyBELUdcbiAgICAgICAgbGV0IHJlcyA9IHVuZGVmaW5lZDsgLy8gU3RlcCBIOiBncmluZCB1bnRpbCBrIGlzIGluIFsxLi5uLTFdXG4gICAgICAgIHdoaWxlICghKHJlcyA9IHByZWQoZ2VuKCkpKSlcbiAgICAgICAgICAgIHJlc2VlZCgpO1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgcmV0dXJuIGdlblVudGlsO1xufVxuLy8gVmFsaWRhdGluZyBjdXJ2ZXMgYW5kIGZpZWxkc1xuY29uc3QgdmFsaWRhdG9yRm5zID0ge1xuICAgIGJpZ2ludDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2JpZ2ludCcsXG4gICAgZnVuY3Rpb246ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicsXG4gICAgYm9vbGVhbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nLFxuICAgIHN0cmluZzogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycsXG4gICAgc3RyaW5nT3JVaW50OEFycmF5OiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCBpc0J5dGVzKHZhbCksXG4gICAgaXNTYWZlSW50ZWdlcjogKHZhbCkgPT4gTnVtYmVyLmlzU2FmZUludGVnZXIodmFsKSxcbiAgICBhcnJheTogKHZhbCkgPT4gQXJyYXkuaXNBcnJheSh2YWwpLFxuICAgIGZpZWxkOiAodmFsLCBvYmplY3QpID0+IG9iamVjdC5GcC5pc1ZhbGlkKHZhbCksXG4gICAgaGFzaDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwub3V0cHV0TGVuKSxcbn07XG4vLyB0eXBlIFJlY29yZDxLIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyIHwgc3ltYm9sLCBUPiA9IHsgW1AgaW4gS106IFQ7IH1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZU9iamVjdChvYmplY3QsIHZhbGlkYXRvcnMsIG9wdFZhbGlkYXRvcnMgPSB7fSkge1xuICAgIGNvbnN0IGNoZWNrRmllbGQgPSAoZmllbGROYW1lLCB0eXBlLCBpc09wdGlvbmFsKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoZWNrVmFsID0gdmFsaWRhdG9yRm5zW3R5cGVdO1xuICAgICAgICBpZiAodHlwZW9mIGNoZWNrVmFsICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHZhbGlkYXRvciBcIiR7dHlwZX1cIiwgZXhwZWN0ZWQgZnVuY3Rpb25gKTtcbiAgICAgICAgY29uc3QgdmFsID0gb2JqZWN0W2ZpZWxkTmFtZV07XG4gICAgICAgIGlmIChpc09wdGlvbmFsICYmIHZhbCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIWNoZWNrVmFsKHZhbCwgb2JqZWN0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBhcmFtICR7U3RyaW5nKGZpZWxkTmFtZSl9PSR7dmFsfSAoJHt0eXBlb2YgdmFsfSksIGV4cGVjdGVkICR7dHlwZX1gKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyh2YWxpZGF0b3JzKSlcbiAgICAgICAgY2hlY2tGaWVsZChmaWVsZE5hbWUsIHR5cGUsIGZhbHNlKTtcbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIHR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdFZhbGlkYXRvcnMpKVxuICAgICAgICBjaGVja0ZpZWxkKGZpZWxkTmFtZSwgdHlwZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbi8vIHZhbGlkYXRlIHR5cGUgdGVzdHNcbi8vIGNvbnN0IG86IHsgYTogbnVtYmVyOyBiOiBudW1iZXI7IGM6IG51bWJlciB9ID0geyBhOiAxLCBiOiA1LCBjOiA2IH07XG4vLyBjb25zdCB6MCA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2lzU2FmZUludGVnZXInIH0sIHsgYzogJ2JpZ2ludCcgfSk7IC8vIE9rIVxuLy8gLy8gU2hvdWxkIGZhaWwgdHlwZS1jaGVja1xuLy8gY29uc3QgejEgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICd0bXAnIH0sIHsgYzogJ3p6JyB9KTtcbi8vIGNvbnN0IHoyID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnaXNTYWZlSW50ZWdlcicgfSwgeyBjOiAnenonIH0pO1xuLy8gY29uc3QgejMgPSB2YWxpZGF0ZU9iamVjdChvLCB7IHRlc3Q6ICdib29sZWFuJywgejogJ2J1ZycgfSk7XG4vLyBjb25zdCB6NCA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2Jvb2xlYW4nLCB6OiAnYnVnJyB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/weierstrass.js":
/*!********************************************************************!*\
  !*** ../../node_modules/@noble/curves/esm/abstract/weierstrass.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DER: function() { return /* binding */ DER; },\n/* harmony export */   SWUFpSqrtRatio: function() { return /* binding */ SWUFpSqrtRatio; },\n/* harmony export */   mapToCurveSimpleSWU: function() { return /* binding */ mapToCurveSimpleSWU; },\n/* harmony export */   weierstrass: function() { return /* binding */ weierstrass; },\n/* harmony export */   weierstrassPoints: function() { return /* binding */ weierstrassPoints; }\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve.js */ \"(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/curve.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Short Weierstrass curve. The formula is: y = x + ax + b\n\n\n\n\nfunction validatePointOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        a: 'field',\n        b: 'field',\n    }, {\n        allowedPrivateKeyLengths: 'array',\n        wrapPrivateKey: 'boolean',\n        isTorsionFree: 'function',\n        clearCofactor: 'function',\n        allowInfinityPoint: 'boolean',\n        fromBytes: 'function',\n        toBytes: 'function',\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\n        }\n        if (typeof endo !== 'object' ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\n        }\n    }\n    return Object.freeze({ ...opts });\n}\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = _utils_js__WEBPACK_IMPORTED_MODULE_1__;\nconst DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = '') {\n            super(m);\n        }\n    },\n    _parseInt(data) {\n        const { Err: E } = DER;\n        if (data.length < 2 || data[0] !== 0x02)\n            throw new E('Invalid signature integer tag');\n        const len = data[1];\n        const res = data.subarray(2, len + 2);\n        if (!len || res.length !== len)\n            throw new E('Invalid signature integer: wrong length');\n        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n        // since we always use positive integers here. It must always be empty:\n        // - add zero byte if exists\n        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n        if (res[0] & 0b10000000)\n            throw new E('Invalid signature integer: negative');\n        if (res[0] === 0x00 && !(res[1] & 0b10000000))\n            throw new E('Invalid signature integer: unnecessary leading zero');\n        return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E } = DER;\n        const data = typeof hex === 'string' ? h2b(hex) : hex;\n        _utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes(data);\n        let l = data.length;\n        if (l < 2 || data[0] != 0x30)\n            throw new E('Invalid signature tag');\n        if (data[1] !== l - 2)\n            throw new E('Invalid signature: incorrect length');\n        const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\n        const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\n        if (rBytesLeft.length)\n            throw new E('Invalid signature: left bytes after parsing');\n        return { r, s };\n    },\n    hexFromSig(sig) {\n        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n        const slice = (s) => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);\n        const h = (num) => {\n            const hex = num.toString(16);\n            return hex.length & 1 ? `0${hex}` : hex;\n        };\n        const s = slice(h(sig.s));\n        const r = slice(h(sig.r));\n        const shl = s.length / 2;\n        const rhl = r.length / 2;\n        const sl = h(shl);\n        const rl = h(rhl);\n        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const toBytes = CURVE.toBytes ||\n        ((_c, point, _isCompressed) => {\n            const a = point.toAffine();\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n        });\n    const fromBytes = CURVE.fromBytes ||\n        ((bytes) => {\n            // const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n            return { x, y };\n        });\n    /**\n     * y = x + ax + b: Short weierstrass curve formula\n     * @returns y\n     */\n    function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n        throw new Error('bad generator point: equation left != right');\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return typeof num === 'bigint' && _0n < num && num < CURVE.n;\n    }\n    function assertGE(num) {\n        if (!isWithinCurveOrder(num))\n            throw new Error('Expected valid bigint: 0 < bigint < curve.n');\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if (_utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes(key))\n                key = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length))\n                throw new Error('Invalid key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num =\n                typeof key === 'bigint'\n                    ? key\n                    : _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('private key', key, nByteLength));\n        }\n        catch (error) {\n            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n        }\n        if (wrapPrivateKey)\n            num = _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(num, n); // disabled by default, enabled for BLS\n        assertGE(num); // num in range [1..N-1]\n        return num;\n    }\n    const pointPrecomputes = new Map();\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z)  (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        constructor(px, py, pz) {\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px))\n                throw new Error('x required');\n            if (py == null || !Fp.isValid(py))\n                throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz))\n                throw new Error('z required');\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.pz));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            if (this.is0()) {\n                // (0, 1, 0) aka ZERO is invalid in most contexts.\n                // In BLS, ZERO can be serialized, so we allow it.\n                // (0, 0, 0) is wrong representation of ZERO and is always invalid.\n                if (CURVE.allowInfinityPoint && !Fp.is0(this.py))\n                    return;\n                throw new Error('bad point: ZERO');\n            }\n            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n            const { x, y } = this.toAffine();\n            // Check if x, y are valid field elements\n            if (!Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('bad point: x or y not FE');\n            const left = Fp.sqr(y); // y\n            const right = weierstrassEquation(x); // x + ax + b\n            if (!Fp.eql(left, right))\n                throw new Error('bad point: equation left != right');\n            if (!this.isTorsionFree())\n                throw new Error('bad point: not in prime-order subgroup');\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd)\n                return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */\n        equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {\n                const toInv = Fp.invertBatch(comp.map((p) => p.pz));\n                return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n            });\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(n) {\n            const I = Point.ZERO;\n            if (n === _0n)\n                return I;\n            assertGE(n); // Will throw on 0\n            if (n === _1n)\n                return this;\n            const { endo } = CURVE;\n            if (!endo)\n                return wnaf.unsafeLadder(this, n);\n            // Apply endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while (k1 > _0n || k2 > _0n) {\n                if (k1 & _1n)\n                    k1p = k1p.add(d);\n                if (k2 & _1n)\n                    k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            assertGE(scalar);\n            let n = scalar;\n            let point, fake; // Fake point is used to const-time mult\n            const { endo } = CURVE;\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            }\n            else {\n                const { p, f } = this.wNAF(n);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([point, fake])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */\n        multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z)  (x=x/z, y=y/z)\n        toAffine(iz) {\n            const { px: x, py: y, pz: z } = this;\n            const is0 = this.is0();\n            // If invZ was 0, we return zero point. However we still want to execute\n            // all operations, so we replace invZ with a random number, 1.\n            if (iz == null)\n                iz = is0 ? Fp.ONE : Fp.inv(z);\n            const ax = Fp.mul(x, iz);\n            const ay = Fp.mul(y, iz);\n            const zz = Fp.mul(z, iz);\n            if (is0)\n                return { x: Fp.ZERO, y: Fp.ZERO };\n            if (!Fp.eql(zz, Fp.ONE))\n                throw new Error('invZ was invalid');\n            return { x: ax, y: ay };\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n)\n                return true; // No subgroups, always torsion-free\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    };\n}\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function',\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean',\n    });\n    return Object.freeze({ lowS: true, ...opts });\n}\nfunction weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function isValidFieldElement(num) {\n        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n    }\n    function modN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n        ...CURVE,\n        toBytes(_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes;\n            if (isCompressed) {\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n            }\n            else {\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes(bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(tail);\n                if (!isValidFieldElement(x))\n                    throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // y = x + ax + b\n                let y;\n                try {\n                    y = Fp.sqrt(y2); // y = y ^ (p+1)/4\n                }\n                catch (sqrtError) {\n                    const suffix = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n                    throw new Error('Point is not on curve' + suffix);\n                }\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd)\n                    y = Fp.neg(y);\n                return { x, y };\n            }\n            else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return { x, y };\n            }\n            else {\n                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n            }\n        },\n    });\n    const numToNByteStr = (num) => _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to) => _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('DER', hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            // can use assertGE here\n            if (!isWithinCurveOrder(this.r))\n                throw new Error('r must be 0 < r < CURVE.n');\n            if (!isWithinCurveOrder(this.s))\n                throw new Error('s must be 0 < s < CURVE.n');\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER)\n                throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q)\n                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig({ r: this.r, s: this.s });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */\n        randomPrivateKey: () => {\n            const length = _modular_js__WEBPACK_IMPORTED_MODULE_2__.getMinHashLength(CURVE.n);\n            return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        },\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        const arr = _utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes(item);\n        const str = typeof item === 'string';\n        const len = (arr || str) && item.length;\n        if (arr)\n            return len === compressedLen || len === uncompressedLen;\n        if (str)\n            return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point)\n            return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA))\n            throw new Error('first arg must be private key');\n        if (!isProbPub(publicB))\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int ||\n        function (bytes) {\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = CURVE.bits2int_modN ||\n        function (bytes) {\n            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */\n    function int2octets(num) {\n        if (typeof num !== 'bigint')\n            throw new Error('bigint expected');\n        if (!(_0n <= num && num < ORDER_MASK))\n            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n        // works with order, can have different size than numToField!\n        return _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n    // Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null)\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash);\n        if (prehash)\n            msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null && ent !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('extraEntropy', e)); // check for being bytes\n        }\n        const seed = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k))\n                return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G  k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = _utils_js__WEBPACK_IMPORTED_MODULE_1__.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1G - U2P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash);\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('publicKey', publicKey);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        const { lowS, prehash } = opts;\n        let _sig = undefined;\n        let P;\n        try {\n            if (typeof sg === 'string' || _utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes(sg)) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof DER.Err))\n                        throw derError;\n                    _sig = Signature.fromCompact(sg);\n                }\n            }\n            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\n                const { r, s } = sg;\n                _sig = new Signature(r, s);\n            }\n            else {\n                throw new Error('PARSE');\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            if (error.message === 'PARSE')\n                throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n            return false;\n        }\n        if (lowS && _sig.hasHighS())\n            return false;\n        if (prehash)\n            msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1G + u2P\n        if (!R)\n            return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils,\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nfunction SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nfunction mapToCurveSimpleSWU(Fp, opts) {\n    _modular_js__WEBPACK_IMPORTED_MODULE_2__.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd)\n        throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\n//# sourceMappingURL=weierstrass.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ29DO0FBQ0g7QUFDUTtBQUNRO0FBQ2pEO0FBQ0EsaUJBQWlCLHdEQUFhO0FBQzlCLElBQUkscURBQWlCO0FBQ3JCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBLFFBQVEsd0NBQXdDLEVBQUUsc0NBQUU7QUFDN0M7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwwQ0FBMEM7QUFDM0QsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBLFFBQVEsNkNBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEMsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLElBQUk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCLElBQUksR0FBRyxFQUFFLEVBQUUsSUFBSSxHQUFHLEVBQUUsRUFBRTtBQUMzRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsWUFBWSxLQUFLLFNBQVM7QUFD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QkFBNEI7QUFDNUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzP2M4NWMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gU2hvcnQgV2VpZXJzdHJhc3MgY3VydmUuIFRoZSBmb3JtdWxhIGlzOiB5wrIgPSB4wrMgKyBheCArIGJcbmltcG9ydCAqIGFzIG1vZCBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0ICogYXMgdXQgZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBlbnN1cmVCeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgd05BRiwgdmFsaWRhdGVCYXNpYyB9IGZyb20gJy4vY3VydmUuanMnO1xuZnVuY3Rpb24gdmFsaWRhdGVQb2ludE9wdHMoY3VydmUpIHtcbiAgICBjb25zdCBvcHRzID0gdmFsaWRhdGVCYXNpYyhjdXJ2ZSk7XG4gICAgdXQudmFsaWRhdGVPYmplY3Qob3B0cywge1xuICAgICAgICBhOiAnZmllbGQnLFxuICAgICAgICBiOiAnZmllbGQnLFxuICAgIH0sIHtcbiAgICAgICAgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzOiAnYXJyYXknLFxuICAgICAgICB3cmFwUHJpdmF0ZUtleTogJ2Jvb2xlYW4nLFxuICAgICAgICBpc1RvcnNpb25GcmVlOiAnZnVuY3Rpb24nLFxuICAgICAgICBjbGVhckNvZmFjdG9yOiAnZnVuY3Rpb24nLFxuICAgICAgICBhbGxvd0luZmluaXR5UG9pbnQ6ICdib29sZWFuJyxcbiAgICAgICAgZnJvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgICAgICB0b0J5dGVzOiAnZnVuY3Rpb24nLFxuICAgIH0pO1xuICAgIGNvbnN0IHsgZW5kbywgRnAsIGEgfSA9IG9wdHM7XG4gICAgaWYgKGVuZG8pIHtcbiAgICAgICAgaWYgKCFGcC5lcWwoYSwgRnAuWkVSTykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5kb21vcnBoaXNtIGNhbiBvbmx5IGJlIGRlZmluZWQgZm9yIEtvYmxpdHogY3VydmVzIHRoYXQgaGF2ZSBhPTAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVuZG8gIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICB0eXBlb2YgZW5kby5iZXRhICE9PSAnYmlnaW50JyB8fFxuICAgICAgICAgICAgdHlwZW9mIGVuZG8uc3BsaXRTY2FsYXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgZW5kb21vcnBoaXNtIHdpdGggYmV0YTogYmlnaW50IGFuZCBzcGxpdFNjYWxhcjogZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLm9wdHMgfSk7XG59XG4vLyBBU04uMSBERVIgZW5jb2RpbmcgdXRpbGl0aWVzXG5jb25zdCB7IGJ5dGVzVG9OdW1iZXJCRTogYjJuLCBoZXhUb0J5dGVzOiBoMmIgfSA9IHV0O1xuZXhwb3J0IGNvbnN0IERFUiA9IHtcbiAgICAvLyBhc24uMSBERVIgZW5jb2RpbmcgdXRpbHNcbiAgICBFcnI6IGNsYXNzIERFUkVyciBleHRlbmRzIEVycm9yIHtcbiAgICAgICAgY29uc3RydWN0b3IobSA9ICcnKSB7XG4gICAgICAgICAgICBzdXBlcihtKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgX3BhcnNlSW50KGRhdGEpIHtcbiAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgMiB8fCBkYXRhWzBdICE9PSAweDAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXIgdGFnJyk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGFbMV07XG4gICAgICAgIGNvbnN0IHJlcyA9IGRhdGEuc3ViYXJyYXkoMiwgbGVuICsgMik7XG4gICAgICAgIGlmICghbGVuIHx8IHJlcy5sZW5ndGggIT09IGxlbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB3cm9uZyBsZW5ndGgnKTtcbiAgICAgICAgLy8gaHR0cHM6Ly9jcnlwdG8uc3RhY2tleGNoYW5nZS5jb20vYS81NzczNCBMZWZ0bW9zdCBiaXQgb2YgZmlyc3QgYnl0ZSBpcyAnbmVnYXRpdmUnIGZsYWcsXG4gICAgICAgIC8vIHNpbmNlIHdlIGFsd2F5cyB1c2UgcG9zaXRpdmUgaW50ZWdlcnMgaGVyZS4gSXQgbXVzdCBhbHdheXMgYmUgZW1wdHk6XG4gICAgICAgIC8vIC0gYWRkIHplcm8gYnl0ZSBpZiBleGlzdHNcbiAgICAgICAgLy8gLSBpZiBuZXh0IGJ5dGUgZG9lc24ndCBoYXZlIGEgZmxhZywgbGVhZGluZyB6ZXJvIGlzIG5vdCBhbGxvd2VkIChtaW5pbWFsIGVuY29kaW5nKVxuICAgICAgICBpZiAocmVzWzBdICYgMGIxMDAwMDAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiBuZWdhdGl2ZScpO1xuICAgICAgICBpZiAocmVzWzBdID09PSAweDAwICYmICEocmVzWzFdICYgMGIxMDAwMDAwMCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogdW5uZWNlc3NhcnkgbGVhZGluZyB6ZXJvJyk7XG4gICAgICAgIHJldHVybiB7IGQ6IGIybihyZXMpLCBsOiBkYXRhLnN1YmFycmF5KGxlbiArIDIpIH07IC8vIGQgaXMgZGF0YSwgbCBpcyBsZWZ0XG4gICAgfSxcbiAgICB0b1NpZyhoZXgpIHtcbiAgICAgICAgLy8gcGFyc2UgREVSIHNpZ25hdHVyZVxuICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgICBjb25zdCBkYXRhID0gdHlwZW9mIGhleCA9PT0gJ3N0cmluZycgPyBoMmIoaGV4KSA6IGhleDtcbiAgICAgICAgdXQuYWJ5dGVzKGRhdGEpO1xuICAgICAgICBsZXQgbCA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBpZiAobCA8IDIgfHwgZGF0YVswXSAhPSAweDMwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIHRhZycpO1xuICAgICAgICBpZiAoZGF0YVsxXSAhPT0gbCAtIDIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmU6IGluY29ycmVjdCBsZW5ndGgnKTtcbiAgICAgICAgY29uc3QgeyBkOiByLCBsOiBzQnl0ZXMgfSA9IERFUi5fcGFyc2VJbnQoZGF0YS5zdWJhcnJheSgyKSk7XG4gICAgICAgIGNvbnN0IHsgZDogcywgbDogckJ5dGVzTGVmdCB9ID0gREVSLl9wYXJzZUludChzQnl0ZXMpO1xuICAgICAgICBpZiAockJ5dGVzTGVmdC5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmU6IGxlZnQgYnl0ZXMgYWZ0ZXIgcGFyc2luZycpO1xuICAgICAgICByZXR1cm4geyByLCBzIH07XG4gICAgfSxcbiAgICBoZXhGcm9tU2lnKHNpZykge1xuICAgICAgICAvLyBBZGQgbGVhZGluZyB6ZXJvIGlmIGZpcnN0IGJ5dGUgaGFzIG5lZ2F0aXZlIGJpdCBlbmFibGVkLiBNb3JlIGRldGFpbHMgaW4gJ19wYXJzZUludCdcbiAgICAgICAgY29uc3Qgc2xpY2UgPSAocykgPT4gKE51bWJlci5wYXJzZUludChzWzBdLCAxNikgJiAwYjEwMDAgPyAnMDAnICsgcyA6IHMpO1xuICAgICAgICBjb25zdCBoID0gKG51bSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaGV4ID0gbnVtLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIHJldHVybiBoZXgubGVuZ3RoICYgMSA/IGAwJHtoZXh9YCA6IGhleDtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcyA9IHNsaWNlKGgoc2lnLnMpKTtcbiAgICAgICAgY29uc3QgciA9IHNsaWNlKGgoc2lnLnIpKTtcbiAgICAgICAgY29uc3Qgc2hsID0gcy5sZW5ndGggLyAyO1xuICAgICAgICBjb25zdCByaGwgPSByLmxlbmd0aCAvIDI7XG4gICAgICAgIGNvbnN0IHNsID0gaChzaGwpO1xuICAgICAgICBjb25zdCBybCA9IGgocmhsKTtcbiAgICAgICAgcmV0dXJuIGAzMCR7aChyaGwgKyBzaGwgKyA0KX0wMiR7cmx9JHtyfTAyJHtzbH0ke3N9YDtcbiAgICB9LFxufTtcbi8vIEJlIGZyaWVuZGx5IHRvIGJhZCBFQ01BU2NyaXB0IHBhcnNlcnMgYnkgbm90IHVzaW5nIGJpZ2ludCBsaXRlcmFsc1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gQmlnSW50KDIpLCBfM24gPSBCaWdJbnQoMyksIF80biA9IEJpZ0ludCg0KTtcbmV4cG9ydCBmdW5jdGlvbiB3ZWllcnN0cmFzc1BvaW50cyhvcHRzKSB7XG4gICAgY29uc3QgQ1VSVkUgPSB2YWxpZGF0ZVBvaW50T3B0cyhvcHRzKTtcbiAgICBjb25zdCB7IEZwIH0gPSBDVVJWRTsgLy8gQWxsIGN1cnZlcyBoYXMgc2FtZSBmaWVsZCAvIGdyb3VwIGxlbmd0aCBhcyBmb3Igbm93LCBidXQgdGhleSBjYW4gZGlmZmVyXG4gICAgY29uc3QgdG9CeXRlcyA9IENVUlZFLnRvQnl0ZXMgfHxcbiAgICAgICAgKChfYywgcG9pbnQsIF9pc0NvbXByZXNzZWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBwb2ludC50b0FmZmluZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHV0LmNvbmNhdEJ5dGVzKFVpbnQ4QXJyYXkuZnJvbShbMHgwNF0pLCBGcC50b0J5dGVzKGEueCksIEZwLnRvQnl0ZXMoYS55KSk7XG4gICAgICAgIH0pO1xuICAgIGNvbnN0IGZyb21CeXRlcyA9IENVUlZFLmZyb21CeXRlcyB8fFxuICAgICAgICAoKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICAvLyBjb25zdCBoZWFkID0gYnl0ZXNbMF07XG4gICAgICAgICAgICBjb25zdCB0YWlsID0gYnl0ZXMuc3ViYXJyYXkoMSk7XG4gICAgICAgICAgICAvLyBpZiAoaGVhZCAhPT0gMHgwNCkgdGhyb3cgbmV3IEVycm9yKCdPbmx5IG5vbi1jb21wcmVzc2VkIGVuY29kaW5nIGlzIHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICBjb25zdCB5ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoRnAuQllURVMsIDIgKiBGcC5CWVRFUykpO1xuICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICB9KTtcbiAgICAvKipcbiAgICAgKiB5wrIgPSB4wrMgKyBheCArIGI6IFNob3J0IHdlaWVyc3RyYXNzIGN1cnZlIGZvcm11bGFcbiAgICAgKiBAcmV0dXJucyB5wrJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpIHtcbiAgICAgICAgY29uc3QgeyBhLCBiIH0gPSBDVVJWRTtcbiAgICAgICAgY29uc3QgeDIgPSBGcC5zcXIoeCk7IC8vIHggKiB4XG4gICAgICAgIGNvbnN0IHgzID0gRnAubXVsKHgyLCB4KTsgLy8geDIgKiB4XG4gICAgICAgIHJldHVybiBGcC5hZGQoRnAuYWRkKHgzLCBGcC5tdWwoeCwgYSkpLCBiKTsgLy8geDMgKyBhICogeCArIGJcbiAgICB9XG4gICAgLy8gVmFsaWRhdGUgd2hldGhlciB0aGUgcGFzc2VkIGN1cnZlIHBhcmFtcyBhcmUgdmFsaWQuXG4gICAgLy8gV2UgY2hlY2sgaWYgY3VydmUgZXF1YXRpb24gd29ya3MgZm9yIGdlbmVyYXRvciBwb2ludC5cbiAgICAvLyBgYXNzZXJ0VmFsaWRpdHkoKWAgd29uJ3Qgd29yazogYGlzVG9yc2lvbkZyZWUoKWAgaXMgbm90IGF2YWlsYWJsZSBhdCB0aGlzIHBvaW50IGluIGJsczEyLTM4MS5cbiAgICAvLyBQcm9qZWN0aXZlUG9pbnQgY2xhc3MgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldC5cbiAgICBpZiAoIUZwLmVxbChGcC5zcXIoQ1VSVkUuR3kpLCB3ZWllcnN0cmFzc0VxdWF0aW9uKENVUlZFLkd4KSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIGdlbmVyYXRvciBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCcpO1xuICAgIC8vIFZhbGlkIGdyb3VwIGVsZW1lbnRzIHJlc2lkZSBpbiByYW5nZSAxLi5uLTFcbiAgICBmdW5jdGlvbiBpc1dpdGhpbkN1cnZlT3JkZXIobnVtKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgbnVtID09PSAnYmlnaW50JyAmJiBfMG4gPCBudW0gJiYgbnVtIDwgQ1VSVkUubjtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXNzZXJ0R0UobnVtKSB7XG4gICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHZhbGlkIGJpZ2ludDogMCA8IGJpZ2ludCA8IGN1cnZlLm4nKTtcbiAgICB9XG4gICAgLy8gVmFsaWRhdGVzIGlmIHByaXYga2V5IGlzIHZhbGlkIGFuZCBjb252ZXJ0cyBpdCB0byBiaWdpbnQuXG4gICAgLy8gU3VwcG9ydHMgb3B0aW9ucyBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHMgYW5kIHdyYXBQcml2YXRlS2V5LlxuICAgIGZ1bmN0aW9uIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIoa2V5KSB7XG4gICAgICAgIGNvbnN0IHsgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzOiBsZW5ndGhzLCBuQnl0ZUxlbmd0aCwgd3JhcFByaXZhdGVLZXksIG4gfSA9IENVUlZFO1xuICAgICAgICBpZiAobGVuZ3RocyAmJiB0eXBlb2Yga2V5ICE9PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgaWYgKHV0LmlzQnl0ZXMoa2V5KSlcbiAgICAgICAgICAgICAgICBrZXkgPSB1dC5ieXRlc1RvSGV4KGtleSk7XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgdG8gaGV4IHN0cmluZywgcGFkLiBFLmcuIFA1MjEgd291bGQgbm9ybSAxMzAtMTMyIGNoYXIgaGV4IHRvIDEzMi1jaGFyIGJ5dGVzXG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycgfHwgIWxlbmd0aHMuaW5jbHVkZXMoa2V5Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGtleScpO1xuICAgICAgICAgICAga2V5ID0ga2V5LnBhZFN0YXJ0KG5CeXRlTGVuZ3RoICogMiwgJzAnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbnVtO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbnVtID1cbiAgICAgICAgICAgICAgICB0eXBlb2Yga2V5ID09PSAnYmlnaW50J1xuICAgICAgICAgICAgICAgICAgICA/IGtleVxuICAgICAgICAgICAgICAgICAgICA6IHV0LmJ5dGVzVG9OdW1iZXJCRShlbnN1cmVCeXRlcygncHJpdmF0ZSBrZXknLCBrZXksIG5CeXRlTGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHByaXZhdGUga2V5IG11c3QgYmUgJHtuQnl0ZUxlbmd0aH0gYnl0ZXMsIGhleCBvciBiaWdpbnQsIG5vdCAke3R5cGVvZiBrZXl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdyYXBQcml2YXRlS2V5KVxuICAgICAgICAgICAgbnVtID0gbW9kLm1vZChudW0sIG4pOyAvLyBkaXNhYmxlZCBieSBkZWZhdWx0LCBlbmFibGVkIGZvciBCTFNcbiAgICAgICAgYXNzZXJ0R0UobnVtKTsgLy8gbnVtIGluIHJhbmdlIFsxLi5OLTFdXG4gICAgICAgIHJldHVybiBudW07XG4gICAgfVxuICAgIGNvbnN0IHBvaW50UHJlY29tcHV0ZXMgPSBuZXcgTWFwKCk7XG4gICAgZnVuY3Rpb24gYXNzZXJ0UHJqUG9pbnQob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBQb2ludCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2plY3RpdmVQb2ludCBleHBlY3RlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9qZWN0aXZlIFBvaW50IHdvcmtzIGluIDNkIC8gcHJvamVjdGl2ZSAoaG9tb2dlbmVvdXMpIGNvb3JkaW5hdGVzOiAoeCwgeSwgeikg4oiLICh4PXgveiwgeT15L3opXG4gICAgICogRGVmYXVsdCBQb2ludCB3b3JrcyBpbiAyZCAvIGFmZmluZSBjb29yZGluYXRlczogKHgsIHkpXG4gICAgICogV2UncmUgZG9pbmcgY2FsY3VsYXRpb25zIGluIHByb2plY3RpdmUsIGJlY2F1c2UgaXRzIG9wZXJhdGlvbnMgZG9uJ3QgcmVxdWlyZSBjb3N0bHkgaW52ZXJzaW9uLlxuICAgICAqL1xuICAgIGNsYXNzIFBvaW50IHtcbiAgICAgICAgY29uc3RydWN0b3IocHgsIHB5LCBweikge1xuICAgICAgICAgICAgdGhpcy5weCA9IHB4O1xuICAgICAgICAgICAgdGhpcy5weSA9IHB5O1xuICAgICAgICAgICAgdGhpcy5weiA9IHB6O1xuICAgICAgICAgICAgaWYgKHB4ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneCByZXF1aXJlZCcpO1xuICAgICAgICAgICAgaWYgKHB5ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneSByZXF1aXJlZCcpO1xuICAgICAgICAgICAgaWYgKHB6ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHopKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneiByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvZXMgbm90IHZhbGlkYXRlIGlmIHRoZSBwb2ludCBpcyBvbi1jdXJ2ZS5cbiAgICAgICAgLy8gVXNlIGZyb21IZXggaW5zdGVhZCwgb3IgY2FsbCBhc3NlcnRWYWxpZGl0eSgpIGxhdGVyLlxuICAgICAgICBzdGF0aWMgZnJvbUFmZmluZShwKSB7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHAgfHwge307XG4gICAgICAgICAgICBpZiAoIXAgfHwgIUZwLmlzVmFsaWQoeCkgfHwgIUZwLmlzVmFsaWQoeSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFmZmluZSBwb2ludCcpO1xuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2plY3RpdmUgcG9pbnQgbm90IGFsbG93ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IGlzMCA9IChpKSA9PiBGcC5lcWwoaSwgRnAuWkVSTyk7XG4gICAgICAgICAgICAvLyBmcm9tQWZmaW5lKHg6MCwgeTowKSB3b3VsZCBwcm9kdWNlICh4OjAsIHk6MCwgejoxKSwgYnV0IHdlIG5lZWQgKHg6MCwgeToxLCB6OjApXG4gICAgICAgICAgICBpZiAoaXMwKHgpICYmIGlzMCh5KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gUG9pbnQuWkVSTztcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSwgRnAuT05FKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGFrZXMgYSBidW5jaCBvZiBQcm9qZWN0aXZlIFBvaW50cyBidXQgZXhlY3V0ZXMgb25seSBvbmVcbiAgICAgICAgICogaW52ZXJzaW9uIG9uIGFsbCBvZiB0aGVtLiBJbnZlcnNpb24gaXMgdmVyeSBzbG93IG9wZXJhdGlvbixcbiAgICAgICAgICogc28gdGhpcyBpbXByb3ZlcyBwZXJmb3JtYW5jZSBtYXNzaXZlbHkuXG4gICAgICAgICAqIE9wdGltaXphdGlvbjogY29udmVydHMgYSBsaXN0IG9mIHByb2plY3RpdmUgcG9pbnRzIHRvIGEgbGlzdCBvZiBpZGVudGljYWwgcG9pbnRzIHdpdGggWj0xLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIG5vcm1hbGl6ZVoocG9pbnRzKSB7XG4gICAgICAgICAgICBjb25zdCB0b0ludiA9IEZwLmludmVydEJhdGNoKHBvaW50cy5tYXAoKHApID0+IHAucHopKTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludHMubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50LmZyb21BZmZpbmUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBoYXNoIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFBvaW50LlxuICAgICAgICAgKiBAcGFyYW0gaGV4IHNob3J0L2xvbmcgRUNEU0EgaGV4XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKGZyb21CeXRlcyhlbnN1cmVCeXRlcygncG9pbnRIZXgnLCBoZXgpKSk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aXBsaWVzIGdlbmVyYXRvciBwb2ludCBieSBwcml2YXRlS2V5LlxuICAgICAgICBzdGF0aWMgZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIFBvaW50LkJBU0UubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gXCJQcml2YXRlIG1ldGhvZFwiLCBkb24ndCB1c2UgaXQgZGlyZWN0bHlcbiAgICAgICAgX3NldFdpbmRvd1NpemUod2luZG93U2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5fV0lORE9XX1NJWkUgPSB3aW5kb3dTaXplO1xuICAgICAgICAgICAgcG9pbnRQcmVjb21wdXRlcy5kZWxldGUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQSBwb2ludCBvbiBjdXJ2ZSBpcyB2YWxpZCBpZiBpdCBjb25mb3JtcyB0byBlcXVhdGlvbi5cbiAgICAgICAgYXNzZXJ0VmFsaWRpdHkoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pczAoKSkge1xuICAgICAgICAgICAgICAgIC8vICgwLCAxLCAwKSBha2EgWkVSTyBpcyBpbnZhbGlkIGluIG1vc3QgY29udGV4dHMuXG4gICAgICAgICAgICAgICAgLy8gSW4gQkxTLCBaRVJPIGNhbiBiZSBzZXJpYWxpemVkLCBzbyB3ZSBhbGxvdyBpdC5cbiAgICAgICAgICAgICAgICAvLyAoMCwgMCwgMCkgaXMgd3JvbmcgcmVwcmVzZW50YXRpb24gb2YgWkVSTyBhbmQgaXMgYWx3YXlzIGludmFsaWQuXG4gICAgICAgICAgICAgICAgaWYgKENVUlZFLmFsbG93SW5maW5pdHlQb2ludCAmJiAhRnAuaXMwKHRoaXMucHkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IFpFUk8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNvbWUgM3JkLXBhcnR5IHRlc3QgdmVjdG9ycyByZXF1aXJlIGRpZmZlcmVudCB3b3JkaW5nIGJldHdlZW4gaGVyZSAmIGBmcm9tQ29tcHJlc3NlZEhleGBcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgeCwgeSBhcmUgdmFsaWQgZmllbGQgZWxlbWVudHNcbiAgICAgICAgICAgIGlmICghRnAuaXNWYWxpZCh4KSB8fCAhRnAuaXNWYWxpZCh5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogeCBvciB5IG5vdCBGRScpO1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IEZwLnNxcih5KTsgLy8gecKyXG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHdlaWVyc3RyYXNzRXF1YXRpb24oeCk7IC8vIHjCsyArIGF4ICsgYlxuICAgICAgICAgICAgaWYgKCFGcC5lcWwobGVmdCwgcmlnaHQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0Jyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNUb3JzaW9uRnJlZSgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBub3QgaW4gcHJpbWUtb3JkZXIgc3ViZ3JvdXAnKTtcbiAgICAgICAgfVxuICAgICAgICBoYXNFdmVuWSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgaWYgKEZwLmlzT2RkKVxuICAgICAgICAgICAgICAgIHJldHVybiAhRnAuaXNPZGQoeSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCBkb2Vzbid0IHN1cHBvcnQgaXNPZGRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXBhcmUgb25lIHBvaW50IHRvIGFub3RoZXIuXG4gICAgICAgICAqL1xuICAgICAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgICAgIGFzc2VydFByalBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBjb25zdCBVMSA9IEZwLmVxbChGcC5tdWwoWDEsIFoyKSwgRnAubXVsKFgyLCBaMSkpO1xuICAgICAgICAgICAgY29uc3QgVTIgPSBGcC5lcWwoRnAubXVsKFkxLCBaMiksIEZwLm11bChZMiwgWjEpKTtcbiAgICAgICAgICAgIHJldHVybiBVMSAmJiBVMjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRmxpcHMgcG9pbnQgdG8gb25lIGNvcnJlc3BvbmRpbmcgdG8gKHgsIC15KSBpbiBBZmZpbmUgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBuZWdhdGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMucHgsIEZwLm5lZyh0aGlzLnB5KSwgdGhpcy5weik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGRvdWJsaW5nIGZvcm11bGEuXG4gICAgICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gM1xuICAgICAgICAvLyBDb3N0OiA4TSArIDNTICsgMyphICsgMipiMyArIDE1YWRkLlxuICAgICAgICBkb3VibGUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgICAgICAgICAgY29uc3QgYjMgPSBGcC5tdWwoYiwgXzNuKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCBYMyA9IEZwLlpFUk8sIFkzID0gRnAuWkVSTywgWjMgPSBGcC5aRVJPOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGxldCB0MCA9IEZwLm11bChYMSwgWDEpOyAvLyBzdGVwIDFcbiAgICAgICAgICAgIGxldCB0MSA9IEZwLm11bChZMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMSk7XG4gICAgICAgICAgICBsZXQgdDMgPSBGcC5tdWwoWDEsIFkxKTtcbiAgICAgICAgICAgIHQzID0gRnAuYWRkKHQzLCB0Myk7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgWjMgPSBGcC5tdWwoWDEsIFoxKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChhLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChiMywgdDIpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWDMsIFkzKTsgLy8gc3RlcCAxMFxuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFkzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWTMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKGIzLCBaMyk7IC8vIHN0ZXAgMTVcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQwLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLm11bChhLCB0Myk7XG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgdDAgPSBGcC5hZGQoWjMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKHQwLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MCwgdDMpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKFkxLCBaMSk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQyID0gRnAuYWRkKHQyLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MiwgdDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIoWDMsIHQwKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQyLCB0MSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpOyAvLyBzdGVwIDMwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW5lcy1Db3N0ZWxsby1CYXRpbmEgZXhjZXB0aW9uLWZyZWUgYWRkaXRpb24gZm9ybXVsYS5cbiAgICAgICAgLy8gVGhlcmUgaXMgMzAlIGZhc3RlciBKYWNvYmlhbiBmb3JtdWxhLCBidXQgaXQgaXMgbm90IGNvbXBsZXRlLlxuICAgICAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE1LzEwNjAsIGFsZ29yaXRobSAxXG4gICAgICAgIC8vIENvc3Q6IDEyTSArIDBTICsgMyphICsgMypiMyArIDIzYWRkLlxuICAgICAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgICAgIGFzc2VydFByalBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBhID0gQ1VSVkUuYTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKENVUlZFLmIsIF8zbik7XG4gICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgyKTsgLy8gc3RlcCAxXG4gICAgICAgICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkyKTtcbiAgICAgICAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjIpO1xuICAgICAgICAgICAgbGV0IHQzID0gRnAuYWRkKFgxLCBZMSk7XG4gICAgICAgICAgICBsZXQgdDQgPSBGcC5hZGQoWDIsIFkyKTsgLy8gc3RlcCA1XG4gICAgICAgICAgICB0MyA9IEZwLm11bCh0MywgdDQpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDAsIHQxKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQzLCB0NCk7XG4gICAgICAgICAgICB0NCA9IEZwLmFkZChYMSwgWjEpO1xuICAgICAgICAgICAgbGV0IHQ1ID0gRnAuYWRkKFgyLCBaMik7IC8vIHN0ZXAgMTBcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKHQ0LCB0NSk7XG4gICAgICAgICAgICB0NSA9IEZwLmFkZCh0MCwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5zdWIodDQsIHQ1KTtcbiAgICAgICAgICAgIHQ1ID0gRnAuYWRkKFkxLCBaMSk7XG4gICAgICAgICAgICBYMyA9IEZwLmFkZChZMiwgWjIpOyAvLyBzdGVwIDE1XG4gICAgICAgICAgICB0NSA9IEZwLm11bCh0NSwgWDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgICAgICAgIHQ1ID0gRnAuc3ViKHQ1LCBYMyk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bChhLCB0NCk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChiMywgdDIpOyAvLyBzdGVwIDIwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChYMywgWjMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQxLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWjMpO1xuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyNVxuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKGIzLCB0NCk7XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MSwgdDIpO1xuICAgICAgICAgICAgdDIgPSBGcC5zdWIodDAsIHQyKTsgLy8gc3RlcCAzMFxuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDQsIHQyKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQxLCB0NCk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChZMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDUsIHQ0KTsgLy8gc3RlcCAzNVxuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MywgdDEpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwodDUsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCB0MCk7IC8vIHN0ZXAgNDBcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaXMwKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKFBvaW50LlpFUk8pO1xuICAgICAgICB9XG4gICAgICAgIHdOQUYobikge1xuICAgICAgICAgICAgcmV0dXJuIHduYWYud05BRkNhY2hlZCh0aGlzLCBwb2ludFByZWNvbXB1dGVzLCBuLCAoY29tcCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvSW52ID0gRnAuaW52ZXJ0QmF0Y2goY29tcC5tYXAoKHApID0+IHAucHopKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcC5tYXAoKHAsIGkpID0+IHAudG9BZmZpbmUodG9JbnZbaV0pKS5tYXAoUG9pbnQuZnJvbUFmZmluZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTm9uLWNvbnN0YW50LXRpbWUgbXVsdGlwbGljYXRpb24uIFVzZXMgZG91YmxlLWFuZC1hZGQgYWxnb3JpdGhtLlxuICAgICAgICAgKiBJdCdzIGZhc3RlciwgYnV0IHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiB5b3UgZG9uJ3QgY2FyZSBhYm91dFxuICAgICAgICAgKiBhbiBleHBvc2VkIHByaXZhdGUga2V5IGUuZy4gc2lnIHZlcmlmaWNhdGlvbiwgd2hpY2ggd29ya3Mgb3ZlciAqcHVibGljKiBrZXlzLlxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHlVbnNhZmUobikge1xuICAgICAgICAgICAgY29uc3QgSSA9IFBvaW50LlpFUk87XG4gICAgICAgICAgICBpZiAobiA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybiBJO1xuICAgICAgICAgICAgYXNzZXJ0R0Uobik7IC8vIFdpbGwgdGhyb3cgb24gMFxuICAgICAgICAgICAgaWYgKG4gPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbyB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoIWVuZG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHduYWYudW5zYWZlTGFkZGVyKHRoaXMsIG4pO1xuICAgICAgICAgICAgLy8gQXBwbHkgZW5kb21vcnBoaXNtXG4gICAgICAgICAgICBsZXQgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gZW5kby5zcGxpdFNjYWxhcihuKTtcbiAgICAgICAgICAgIGxldCBrMXAgPSBJO1xuICAgICAgICAgICAgbGV0IGsycCA9IEk7XG4gICAgICAgICAgICBsZXQgZCA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZSAoazEgPiBfMG4gfHwgazIgPiBfMG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoazEgJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIGsxcCA9IGsxcC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgaWYgKGsyICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBrMnAgPSBrMnAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIGsxID4+PSBfMW47XG4gICAgICAgICAgICAgICAgazIgPj49IF8xbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrMW5lZylcbiAgICAgICAgICAgICAgICBrMXAgPSBrMXAubmVnYXRlKCk7XG4gICAgICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICAgICAgazJwID0gazJwLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgazJwID0gbmV3IFBvaW50KEZwLm11bChrMnAucHgsIGVuZG8uYmV0YSksIGsycC5weSwgazJwLnB6KTtcbiAgICAgICAgICAgIHJldHVybiBrMXAuYWRkKGsycCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0YW50IHRpbWUgbXVsdGlwbGljYXRpb24uXG4gICAgICAgICAqIFVzZXMgd05BRiBtZXRob2QuIFdpbmRvd2VkIG1ldGhvZCBtYXkgYmUgMTAlIGZhc3RlcixcbiAgICAgICAgICogYnV0IHRha2VzIDJ4IGxvbmdlciB0byBnZW5lcmF0ZSBhbmQgY29uc3VtZXMgMnggbWVtb3J5LlxuICAgICAgICAgKiBVc2VzIHByZWNvbXB1dGVzIHdoZW4gYXZhaWxhYmxlLlxuICAgICAgICAgKiBVc2VzIGVuZG9tb3JwaGlzbSBmb3IgS29ibGl0eiBjdXJ2ZXMuXG4gICAgICAgICAqIEBwYXJhbSBzY2FsYXIgYnkgd2hpY2ggdGhlIHBvaW50IHdvdWxkIGJlIG11bHRpcGxpZWRcbiAgICAgICAgICogQHJldHVybnMgTmV3IHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseShzY2FsYXIpIHtcbiAgICAgICAgICAgIGFzc2VydEdFKHNjYWxhcik7XG4gICAgICAgICAgICBsZXQgbiA9IHNjYWxhcjtcbiAgICAgICAgICAgIGxldCBwb2ludCwgZmFrZTsgLy8gRmFrZSBwb2ludCBpcyB1c2VkIHRvIGNvbnN0LXRpbWUgbXVsdFxuICAgICAgICAgICAgY29uc3QgeyBlbmRvIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChlbmRvKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gZW5kby5zcGxpdFNjYWxhcihuKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMXAsIGY6IGYxcCB9ID0gdGhpcy53TkFGKGsxKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMnAsIGY6IGYycCB9ID0gdGhpcy53TkFGKGsyKTtcbiAgICAgICAgICAgICAgICBrMXAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMW5lZywgazFwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMm5lZywgazJwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSBuZXcgUG9pbnQoRnAubXVsKGsycC5weCwgZW5kby5iZXRhKSwgazJwLnB5LCBrMnAucHopO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gazFwLmFkZChrMnApO1xuICAgICAgICAgICAgICAgIGZha2UgPSBmMXAuYWRkKGYycCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHAsIGYgfSA9IHRoaXMud05BRihuKTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IHA7XG4gICAgICAgICAgICAgICAgZmFrZSA9IGY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgYHpgIGZvciBib3RoIHBvaW50cywgYnV0IHJldHVybiBvbmx5IHJlYWwgb25lXG4gICAgICAgICAgICByZXR1cm4gUG9pbnQubm9ybWFsaXplWihbcG9pbnQsIGZha2VdKVswXTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRWZmaWNpZW50bHkgY2FsY3VsYXRlIGBhUCArIGJRYC4gVW5zYWZlLCBjYW4gZXhwb3NlIHByaXZhdGUga2V5LCBpZiB1c2VkIGluY29ycmVjdGx5LlxuICAgICAgICAgKiBOb3QgdXNpbmcgU3RyYXVzcy1TaGFtaXIgdHJpY2s6IHByZWNvbXB1dGF0aW9uIHRhYmxlcyBhcmUgZmFzdGVyLlxuICAgICAgICAgKiBUaGUgdHJpY2sgY291bGQgYmUgdXNlZnVsIGlmIGJvdGggUCBhbmQgUSBhcmUgbm90IEcgKG5vdCBpbiBvdXIgY2FzZSkuXG4gICAgICAgICAqIEByZXR1cm5zIG5vbi16ZXJvIGFmZmluZSBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHlBbmRBZGRVbnNhZmUoUSwgYSwgYikge1xuICAgICAgICAgICAgY29uc3QgRyA9IFBvaW50LkJBU0U7IC8vIE5vIFN0cmF1c3MtU2hhbWlyIHRyaWNrOiB3ZSBoYXZlIDEwJSBmYXN0ZXIgRyBwcmVjb21wdXRlc1xuICAgICAgICAgICAgY29uc3QgbXVsID0gKFAsIGEgLy8gU2VsZWN0IGZhc3RlciBtdWx0aXBseSgpIG1ldGhvZFxuICAgICAgICAgICAgKSA9PiAoYSA9PT0gXzBuIHx8IGEgPT09IF8xbiB8fCAhUC5lcXVhbHMoRykgPyBQLm11bHRpcGx5VW5zYWZlKGEpIDogUC5tdWx0aXBseShhKSk7XG4gICAgICAgICAgICBjb25zdCBzdW0gPSBtdWwodGhpcywgYSkuYWRkKG11bChRLCBiKSk7XG4gICAgICAgICAgICByZXR1cm4gc3VtLmlzMCgpID8gdW5kZWZpbmVkIDogc3VtO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnZlcnRzIFByb2plY3RpdmUgcG9pbnQgdG8gYWZmaW5lICh4LCB5KSBjb29yZGluYXRlcy5cbiAgICAgICAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXG4gICAgICAgIC8vICh4LCB5LCB6KSDiiIsgKHg9eC96LCB5PXkveilcbiAgICAgICAgdG9BZmZpbmUoaXopIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IHgsIHB5OiB5LCBwejogeiB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGlzMCA9IHRoaXMuaXMwKCk7XG4gICAgICAgICAgICAvLyBJZiBpbnZaIHdhcyAwLCB3ZSByZXR1cm4gemVybyBwb2ludC4gSG93ZXZlciB3ZSBzdGlsbCB3YW50IHRvIGV4ZWN1dGVcbiAgICAgICAgICAgIC8vIGFsbCBvcGVyYXRpb25zLCBzbyB3ZSByZXBsYWNlIGludlogd2l0aCBhIHJhbmRvbSBudW1iZXIsIDEuXG4gICAgICAgICAgICBpZiAoaXogPT0gbnVsbClcbiAgICAgICAgICAgICAgICBpeiA9IGlzMCA/IEZwLk9ORSA6IEZwLmludih6KTtcbiAgICAgICAgICAgIGNvbnN0IGF4ID0gRnAubXVsKHgsIGl6KTtcbiAgICAgICAgICAgIGNvbnN0IGF5ID0gRnAubXVsKHksIGl6KTtcbiAgICAgICAgICAgIGNvbnN0IHp6ID0gRnAubXVsKHosIGl6KTtcbiAgICAgICAgICAgIGlmIChpczApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogRnAuWkVSTywgeTogRnAuWkVSTyB9O1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoenosIEZwLk9ORSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZaIHdhcyBpbnZhbGlkJyk7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBheCwgeTogYXkgfTtcbiAgICAgICAgfVxuICAgICAgICBpc1RvcnNpb25GcmVlKCkge1xuICAgICAgICAgICAgY29uc3QgeyBoOiBjb2ZhY3RvciwgaXNUb3JzaW9uRnJlZSB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gTm8gc3ViZ3JvdXBzLCBhbHdheXMgdG9yc2lvbi1mcmVlXG4gICAgICAgICAgICBpZiAoaXNUb3JzaW9uRnJlZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNUb3JzaW9uRnJlZShQb2ludCwgdGhpcyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lzVG9yc2lvbkZyZWUoKSBoYXMgbm90IGJlZW4gZGVjbGFyZWQgZm9yIHRoZSBlbGxpcHRpYyBjdXJ2ZScpO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyQ29mYWN0b3IoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGg6IGNvZmFjdG9yLCBjbGVhckNvZmFjdG9yIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChjb2ZhY3RvciA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBGYXN0LXBhdGhcbiAgICAgICAgICAgIGlmIChjbGVhckNvZmFjdG9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBjbGVhckNvZmFjdG9yKFBvaW50LCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5VW5zYWZlKENVUlZFLmgpO1xuICAgICAgICB9XG4gICAgICAgIHRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRvQnl0ZXMoUG9pbnQsIHRoaXMsIGlzQ29tcHJlc3NlZCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9IZXgoaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmJ5dGVzVG9IZXgodGhpcy50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFBvaW50LkJBU0UgPSBuZXcgUG9pbnQoQ1VSVkUuR3gsIENVUlZFLkd5LCBGcC5PTkUpO1xuICAgIFBvaW50LlpFUk8gPSBuZXcgUG9pbnQoRnAuWkVSTywgRnAuT05FLCBGcC5aRVJPKTtcbiAgICBjb25zdCBfYml0cyA9IENVUlZFLm5CaXRMZW5ndGg7XG4gICAgY29uc3Qgd25hZiA9IHdOQUYoUG9pbnQsIENVUlZFLmVuZG8gPyBNYXRoLmNlaWwoX2JpdHMgLyAyKSA6IF9iaXRzKTtcbiAgICAvLyBWYWxpZGF0ZSBpZiBnZW5lcmF0b3IgcG9pbnQgaXMgb24gY3VydmVcbiAgICByZXR1cm4ge1xuICAgICAgICBDVVJWRSxcbiAgICAgICAgUHJvamVjdGl2ZVBvaW50OiBQb2ludCxcbiAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcixcbiAgICAgICAgd2VpZXJzdHJhc3NFcXVhdGlvbixcbiAgICAgICAgaXNXaXRoaW5DdXJ2ZU9yZGVyLFxuICAgIH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU9wdHMoY3VydmUpIHtcbiAgICBjb25zdCBvcHRzID0gdmFsaWRhdGVCYXNpYyhjdXJ2ZSk7XG4gICAgdXQudmFsaWRhdGVPYmplY3Qob3B0cywge1xuICAgICAgICBoYXNoOiAnaGFzaCcsXG4gICAgICAgIGhtYWM6ICdmdW5jdGlvbicsXG4gICAgICAgIHJhbmRvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgIH0sIHtcbiAgICAgICAgYml0czJpbnQ6ICdmdW5jdGlvbicsXG4gICAgICAgIGJpdHMyaW50X21vZE46ICdmdW5jdGlvbicsXG4gICAgICAgIGxvd1M6ICdib29sZWFuJyxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IGxvd1M6IHRydWUsIC4uLm9wdHMgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gd2VpZXJzdHJhc3MoY3VydmVEZWYpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlT3B0cyhjdXJ2ZURlZik7XG4gICAgY29uc3QgeyBGcCwgbjogQ1VSVkVfT1JERVIgfSA9IENVUlZFO1xuICAgIGNvbnN0IGNvbXByZXNzZWRMZW4gPSBGcC5CWVRFUyArIDE7IC8vIGUuZy4gMzMgZm9yIDMyXG4gICAgY29uc3QgdW5jb21wcmVzc2VkTGVuID0gMiAqIEZwLkJZVEVTICsgMTsgLy8gZS5nLiA2NSBmb3IgMzJcbiAgICBmdW5jdGlvbiBpc1ZhbGlkRmllbGRFbGVtZW50KG51bSkge1xuICAgICAgICByZXR1cm4gXzBuIDwgbnVtICYmIG51bSA8IEZwLk9SREVSOyAvLyAwIGlzIGJhbm5lZCBzaW5jZSBpdCdzIG5vdCBpbnZlcnRpYmxlIEZFXG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vZE4oYSkge1xuICAgICAgICByZXR1cm4gbW9kLm1vZChhLCBDVVJWRV9PUkRFUik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludk4oYSkge1xuICAgICAgICByZXR1cm4gbW9kLmludmVydChhLCBDVVJWRV9PUkRFUik7XG4gICAgfVxuICAgIGNvbnN0IHsgUHJvamVjdGl2ZVBvaW50OiBQb2ludCwgbm9ybVByaXZhdGVLZXlUb1NjYWxhciwgd2VpZXJzdHJhc3NFcXVhdGlvbiwgaXNXaXRoaW5DdXJ2ZU9yZGVyLCB9ID0gd2VpZXJzdHJhc3NQb2ludHMoe1xuICAgICAgICAuLi5DVVJWRSxcbiAgICAgICAgdG9CeXRlcyhfYywgcG9pbnQsIGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgY29uc3QgYSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgICAgICAgICBjb25zdCB4ID0gRnAudG9CeXRlcyhhLngpO1xuICAgICAgICAgICAgY29uc3QgY2F0ID0gdXQuY29uY2F0Qnl0ZXM7XG4gICAgICAgICAgICBpZiAoaXNDb21wcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhdChVaW50OEFycmF5LmZyb20oW3BvaW50Lmhhc0V2ZW5ZKCkgPyAweDAyIDogMHgwM10pLCB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXQoVWludDhBcnJheS5mcm9tKFsweDA0XSksIHgsIEZwLnRvQnl0ZXMoYS55KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZyb21CeXRlcyhieXRlcykge1xuICAgICAgICAgICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgaGVhZCA9IGJ5dGVzWzBdO1xuICAgICAgICAgICAgY29uc3QgdGFpbCA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgICAgICAgICAgLy8gdGhpcy5hc3NlcnRWYWxpZGl0eSgpIGlzIGRvbmUgaW5zaWRlIG9mIGZyb21IZXhcbiAgICAgICAgICAgIGlmIChsZW4gPT09IGNvbXByZXNzZWRMZW4gJiYgKGhlYWQgPT09IDB4MDIgfHwgaGVhZCA9PT0gMHgwMykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gdXQuYnl0ZXNUb051bWJlckJFKHRhaWwpO1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEZpZWxkRWxlbWVudCh4KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBpcyBub3Qgb24gY3VydmUnKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5MiA9IHdlaWVyc3RyYXNzRXF1YXRpb24oeCk7IC8vIHnCsiA9IHjCsyArIGF4ICsgYlxuICAgICAgICAgICAgICAgIGxldCB5O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBGcC5zcXJ0KHkyKTsgLy8geSA9IHnCsiBeIChwKzEpLzRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKHNxcnRFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWZmaXggPSBzcXJ0RXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/ICc6ICcgKyBzcXJ0RXJyb3IubWVzc2FnZSA6ICcnO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50IGlzIG5vdCBvbiBjdXJ2ZScgKyBzdWZmaXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpc1lPZGQgPSAoeSAmIF8xbikgPT09IF8xbjtcbiAgICAgICAgICAgICAgICAvLyBFQ0RTQVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzSGVhZE9kZCA9IChoZWFkICYgMSkgPT09IDE7XG4gICAgICAgICAgICAgICAgaWYgKGlzSGVhZE9kZCAhPT0gaXNZT2RkKVxuICAgICAgICAgICAgICAgICAgICB5ID0gRnAubmVnKHkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxlbiA9PT0gdW5jb21wcmVzc2VkTGVuICYmIGhlYWQgPT09IDB4MDQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoMCwgRnAuQllURVMpKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoRnAuQllURVMsIDIgKiBGcC5CWVRFUykpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9pbnQgb2YgbGVuZ3RoICR7bGVufSB3YXMgaW52YWxpZC4gRXhwZWN0ZWQgJHtjb21wcmVzc2VkTGVufSBjb21wcmVzc2VkIGJ5dGVzIG9yICR7dW5jb21wcmVzc2VkTGVufSB1bmNvbXByZXNzZWQgYnl0ZXNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBjb25zdCBudW1Ub05CeXRlU3RyID0gKG51bSkgPT4gdXQuYnl0ZXNUb0hleCh1dC5udW1iZXJUb0J5dGVzQkUobnVtLCBDVVJWRS5uQnl0ZUxlbmd0aCkpO1xuICAgIGZ1bmN0aW9uIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihudW1iZXIpIHtcbiAgICAgICAgY29uc3QgSEFMRiA9IENVUlZFX09SREVSID4+IF8xbjtcbiAgICAgICAgcmV0dXJuIG51bWJlciA+IEhBTEY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVMocykge1xuICAgICAgICByZXR1cm4gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHMpID8gbW9kTigtcykgOiBzO1xuICAgIH1cbiAgICAvLyBzbGljZSBieXRlcyBudW1cbiAgICBjb25zdCBzbGNOdW0gPSAoYiwgZnJvbSwgdG8pID0+IHV0LmJ5dGVzVG9OdW1iZXJCRShiLnNsaWNlKGZyb20sIHRvKSk7XG4gICAgLyoqXG4gICAgICogRUNEU0Egc2lnbmF0dXJlIHdpdGggaXRzIChyLCBzKSBwcm9wZXJ0aWVzLiBTdXBwb3J0cyBERVIgJiBjb21wYWN0IHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKi9cbiAgICBjbGFzcyBTaWduYXR1cmUge1xuICAgICAgICBjb25zdHJ1Y3RvcihyLCBzLCByZWNvdmVyeSkge1xuICAgICAgICAgICAgdGhpcy5yID0gcjtcbiAgICAgICAgICAgIHRoaXMucyA9IHM7XG4gICAgICAgICAgICB0aGlzLnJlY292ZXJ5ID0gcmVjb3Zlcnk7XG4gICAgICAgICAgICB0aGlzLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGFpciAoYnl0ZXMgb2YgciwgYnl0ZXMgb2YgcylcbiAgICAgICAgc3RhdGljIGZyb21Db21wYWN0KGhleCkge1xuICAgICAgICAgICAgY29uc3QgbCA9IENVUlZFLm5CeXRlTGVuZ3RoO1xuICAgICAgICAgICAgaGV4ID0gZW5zdXJlQnl0ZXMoJ2NvbXBhY3RTaWduYXR1cmUnLCBoZXgsIGwgKiAyKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHNsY051bShoZXgsIDAsIGwpLCBzbGNOdW0oaGV4LCBsLCAyICogbCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERFUiBlbmNvZGVkIEVDRFNBIHNpZ25hdHVyZVxuICAgICAgICAvLyBodHRwczovL2JpdGNvaW4uc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzU3NjQ0L3doYXQtYXJlLXRoZS1wYXJ0cy1vZi1hLWJpdGNvaW4tdHJhbnNhY3Rpb24taW5wdXQtc2NyaXB0XG4gICAgICAgIHN0YXRpYyBmcm9tREVSKGhleCkge1xuICAgICAgICAgICAgY29uc3QgeyByLCBzIH0gPSBERVIudG9TaWcoZW5zdXJlQnl0ZXMoJ0RFUicsIGhleCkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgcyk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VmFsaWRpdHkoKSB7XG4gICAgICAgICAgICAvLyBjYW4gdXNlIGFzc2VydEdFIGhlcmVcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKHRoaXMucikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyIG11c3QgYmUgMCA8IHIgPCBDVVJWRS5uJyk7XG4gICAgICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcih0aGlzLnMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncyBtdXN0IGJlIDAgPCBzIDwgQ1VSVkUubicpO1xuICAgICAgICB9XG4gICAgICAgIGFkZFJlY292ZXJ5Qml0KHJlY292ZXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIHRoaXMucywgcmVjb3ZlcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJlY292ZXJQdWJsaWNLZXkobXNnSGFzaCkge1xuICAgICAgICAgICAgY29uc3QgeyByLCBzLCByZWNvdmVyeTogcmVjIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4oZW5zdXJlQnl0ZXMoJ21zZ0hhc2gnLCBtc2dIYXNoKSk7IC8vIFRydW5jYXRlIGhhc2hcbiAgICAgICAgICAgIGlmIChyZWMgPT0gbnVsbCB8fCAhWzAsIDEsIDIsIDNdLmluY2x1ZGVzKHJlYykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNvdmVyeSBpZCBpbnZhbGlkJyk7XG4gICAgICAgICAgICBjb25zdCByYWRqID0gcmVjID09PSAyIHx8IHJlYyA9PT0gMyA/IHIgKyBDVVJWRS5uIDogcjtcbiAgICAgICAgICAgIGlmIChyYWRqID49IEZwLk9SREVSKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjb3ZlcnkgaWQgMiBvciAzIGludmFsaWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHByZWZpeCA9IChyZWMgJiAxKSA9PT0gMCA/ICcwMicgOiAnMDMnO1xuICAgICAgICAgICAgY29uc3QgUiA9IFBvaW50LmZyb21IZXgocHJlZml4ICsgbnVtVG9OQnl0ZVN0cihyYWRqKSk7XG4gICAgICAgICAgICBjb25zdCBpciA9IGludk4ocmFkaik7IC8vIHJeLTFcbiAgICAgICAgICAgIGNvbnN0IHUxID0gbW9kTigtaCAqIGlyKTsgLy8gLWhyXi0xXG4gICAgICAgICAgICBjb25zdCB1MiA9IG1vZE4ocyAqIGlyKTsgLy8gc3JeLTFcbiAgICAgICAgICAgIGNvbnN0IFEgPSBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFIsIHUxLCB1Mik7IC8vIChzcl4tMSlSLShocl4tMSlHID0gLShocl4tMSlHICsgKHNyXi0xKVxuICAgICAgICAgICAgaWYgKCFRKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncG9pbnQgYXQgaW5maW5pZnknKTsgLy8gdW5zYWZlIGlzIGZpbmU6IG5vIHByaXYgZGF0YSBsZWFrZWRcbiAgICAgICAgICAgIFEuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBRO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpZ25hdHVyZXMgc2hvdWxkIGJlIGxvdy1zLCB0byBwcmV2ZW50IG1hbGxlYWJpbGl0eS5cbiAgICAgICAgaGFzSGlnaFMoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHRoaXMucyk7XG4gICAgICAgIH1cbiAgICAgICAgbm9ybWFsaXplUygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhc0hpZ2hTKCkgPyBuZXcgU2lnbmF0dXJlKHRoaXMuciwgbW9kTigtdGhpcy5zKSwgdGhpcy5yZWNvdmVyeSkgOiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIERFUi1lbmNvZGVkXG4gICAgICAgIHRvREVSUmF3Qnl0ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdXQuaGV4VG9CeXRlcyh0aGlzLnRvREVSSGV4KCkpO1xuICAgICAgICB9XG4gICAgICAgIHRvREVSSGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIERFUi5oZXhGcm9tU2lnKHsgcjogdGhpcy5yLCBzOiB0aGlzLnMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGFkZGVkIGJ5dGVzIG9mIHIsIHRoZW4gcGFkZGVkIGJ5dGVzIG9mIHNcbiAgICAgICAgdG9Db21wYWN0UmF3Qnl0ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdXQuaGV4VG9CeXRlcyh0aGlzLnRvQ29tcGFjdEhleCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0b0NvbXBhY3RIZXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtVG9OQnl0ZVN0cih0aGlzLnIpICsgbnVtVG9OQnl0ZVN0cih0aGlzLnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHV0aWxzID0ge1xuICAgICAgICBpc1ZhbGlkUHJpdmF0ZUtleShwcml2YXRlS2V5KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXI6IG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlcyBjcnlwdG9ncmFwaGljYWxseSBzZWN1cmUgcHJpdmF0ZSBrZXkgZnJvbSByYW5kb20gb2Ygc2l6ZVxuICAgICAgICAgKiAoZ3JvdXBMZW4gKyBjZWlsKGdyb3VwTGVuIC8gMikpIHdpdGggbW9kdWxvIGJpYXMgYmVpbmcgbmVnbGlnaWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIHJhbmRvbVByaXZhdGVLZXk6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IG1vZC5nZXRNaW5IYXNoTGVuZ3RoKENVUlZFLm4pO1xuICAgICAgICAgICAgcmV0dXJuIG1vZC5tYXBIYXNoVG9GaWVsZChDVVJWRS5yYW5kb21CeXRlcyhsZW5ndGgpLCBDVVJWRS5uKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgcHJlY29tcHV0ZSB0YWJsZSBmb3IgYW4gYXJiaXRyYXJ5IEVDIHBvaW50LiBNYWtlcyBwb2ludCBcImNhY2hlZFwiLlxuICAgICAgICAgKiBBbGxvd3MgdG8gbWFzc2l2ZWx5IHNwZWVkLXVwIGBwb2ludC5tdWx0aXBseShzY2FsYXIpYC5cbiAgICAgICAgICogQHJldHVybnMgY2FjaGVkIHBvaW50XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGNvbnN0IGZhc3QgPSB1dGlscy5wcmVjb21wdXRlKDgsIFByb2plY3RpdmVQb2ludC5mcm9tSGV4KHNvbWVvbmVzUHViS2V5KSk7XG4gICAgICAgICAqIGZhc3QubXVsdGlwbHkocHJpdktleSk7IC8vIG11Y2ggZmFzdGVyIEVDREggbm93XG4gICAgICAgICAqL1xuICAgICAgICBwcmVjb21wdXRlKHdpbmRvd1NpemUgPSA4LCBwb2ludCA9IFBvaW50LkJBU0UpIHtcbiAgICAgICAgICAgIHBvaW50Ll9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpO1xuICAgICAgICAgICAgcG9pbnQubXVsdGlwbHkoQmlnSW50KDMpKTsgLy8gMyBpcyBhcmJpdHJhcnksIGp1c3QgbmVlZCBhbnkgbnVtYmVyIGhlcmVcbiAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHB1YmxpYyBrZXkgZm9yIGEgcHJpdmF0ZSBrZXkuIENoZWNrcyBmb3IgdmFsaWRpdHkgb2YgdGhlIHByaXZhdGUga2V5LlxuICAgICAqIEBwYXJhbSBwcml2YXRlS2V5IHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIGlzQ29tcHJlc3NlZCB3aGV0aGVyIHRvIHJldHVybiBjb21wYWN0IChkZWZhdWx0KSwgb3IgZnVsbCBrZXlcbiAgICAgKiBAcmV0dXJucyBQdWJsaWMga2V5LCBmdWxsIHdoZW4gaXNDb21wcmVzc2VkPWZhbHNlOyBzaG9ydCB3aGVuIGlzQ29tcHJlc3NlZD10cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0UHVibGljS2V5KHByaXZhdGVLZXksIGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIFBvaW50LmZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVpY2sgYW5kIGRpcnR5IGNoZWNrIGZvciBpdGVtIGJlaW5nIHB1YmxpYyBrZXkuIERvZXMgbm90IHZhbGlkYXRlIGhleCwgb3IgYmVpbmcgb24tY3VydmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQcm9iUHViKGl0ZW0pIHtcbiAgICAgICAgY29uc3QgYXJyID0gdXQuaXNCeXRlcyhpdGVtKTtcbiAgICAgICAgY29uc3Qgc3RyID0gdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnO1xuICAgICAgICBjb25zdCBsZW4gPSAoYXJyIHx8IHN0cikgJiYgaXRlbS5sZW5ndGg7XG4gICAgICAgIGlmIChhcnIpXG4gICAgICAgICAgICByZXR1cm4gbGVuID09PSBjb21wcmVzc2VkTGVuIHx8IGxlbiA9PT0gdW5jb21wcmVzc2VkTGVuO1xuICAgICAgICBpZiAoc3RyKVxuICAgICAgICAgICAgcmV0dXJuIGxlbiA9PT0gMiAqIGNvbXByZXNzZWRMZW4gfHwgbGVuID09PSAyICogdW5jb21wcmVzc2VkTGVuO1xuICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFBvaW50KVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRUNESCAoRWxsaXB0aWMgQ3VydmUgRGlmZmllIEhlbGxtYW4pLlxuICAgICAqIENvbXB1dGVzIHNoYXJlZCBwdWJsaWMga2V5IGZyb20gcHJpdmF0ZSBrZXkgYW5kIHB1YmxpYyBrZXkuXG4gICAgICogQ2hlY2tzOiAxKSBwcml2YXRlIGtleSB2YWxpZGl0eSAyKSBzaGFyZWQga2V5IGlzIG9uLWN1cnZlLlxuICAgICAqIERvZXMgTk9UIGhhc2ggdGhlIHJlc3VsdC5cbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUEgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0gcHVibGljQiBkaWZmZXJlbnQgcHVibGljIGtleVxuICAgICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG4gICAgICogQHJldHVybnMgc2hhcmVkIHB1YmxpYyBrZXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTaGFyZWRTZWNyZXQocHJpdmF0ZUEsIHB1YmxpY0IsIGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgaWYgKGlzUHJvYlB1Yihwcml2YXRlQSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpcnN0IGFyZyBtdXN0IGJlIHByaXZhdGUga2V5Jyk7XG4gICAgICAgIGlmICghaXNQcm9iUHViKHB1YmxpY0IpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZWNvbmQgYXJnIG11c3QgYmUgcHVibGljIGtleScpO1xuICAgICAgICBjb25zdCBiID0gUG9pbnQuZnJvbUhleChwdWJsaWNCKTsgLy8gY2hlY2sgZm9yIGJlaW5nIG9uLWN1cnZlXG4gICAgICAgIHJldHVybiBiLm11bHRpcGx5KG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUEpKS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG4gICAgfVxuICAgIC8vIFJGQzY5Nzk6IGVuc3VyZSBFQ0RTQSBtc2cgaXMgWCBieXRlcyBhbmQgPCBOLiBSRkMgc3VnZ2VzdHMgb3B0aW9uYWwgdHJ1bmNhdGluZyB2aWEgYml0czJvY3RldHMuXG4gICAgLy8gRklQUyAxODYtNCA0LjYgc3VnZ2VzdHMgdGhlIGxlZnRtb3N0IG1pbihuQml0TGVuLCBvdXRMZW4pIGJpdHMsIHdoaWNoIG1hdGNoZXMgYml0czJpbnQuXG4gICAgLy8gYml0czJpbnQgY2FuIHByb2R1Y2UgcmVzPk4sIHdlIGNhbiBkbyBtb2QocmVzLCBOKSBzaW5jZSB0aGUgYml0TGVuIGlzIHRoZSBzYW1lLlxuICAgIC8vIGludDJvY3RldHMgY2FuJ3QgYmUgdXNlZDsgcGFkcyBzbWFsbCBtc2dzIHdpdGggMDogdW5hY2NlcHRhdGJsZSBmb3IgdHJ1bmMgYXMgcGVyIFJGQyB2ZWN0b3JzXG4gICAgY29uc3QgYml0czJpbnQgPSBDVVJWRS5iaXRzMmludCB8fFxuICAgICAgICBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICAgICAgICAgIC8vIEZvciBjdXJ2ZXMgd2l0aCBuQml0TGVuZ3RoICUgOCAhPT0gMDogYml0czJvY3RldHMoYml0czJvY3RldHMobSkpICE9PSBiaXRzMm9jdGV0cyhtKVxuICAgICAgICAgICAgLy8gZm9yIHNvbWUgY2FzZXMsIHNpbmNlIGJ5dGVzLmxlbmd0aCAqIDggaXMgbm90IGFjdHVhbCBiaXRMZW5ndGguXG4gICAgICAgICAgICBjb25zdCBudW0gPSB1dC5ieXRlc1RvTnVtYmVyQkUoYnl0ZXMpOyAvLyBjaGVjayBmb3IgPT0gdTggZG9uZSBoZXJlXG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IGJ5dGVzLmxlbmd0aCAqIDggLSBDVVJWRS5uQml0TGVuZ3RoOyAvLyB0cnVuY2F0ZSB0byBuQml0TGVuZ3RoIGxlZnRtb3N0IGJpdHNcbiAgICAgICAgICAgIHJldHVybiBkZWx0YSA+IDAgPyBudW0gPj4gQmlnSW50KGRlbHRhKSA6IG51bTtcbiAgICAgICAgfTtcbiAgICBjb25zdCBiaXRzMmludF9tb2ROID0gQ1VSVkUuYml0czJpbnRfbW9kTiB8fFxuICAgICAgICBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2ROKGJpdHMyaW50KGJ5dGVzKSk7IC8vIGNhbid0IHVzZSBieXRlc1RvTnVtYmVyQkUgaGVyZVxuICAgICAgICB9O1xuICAgIC8vIE5PVEU6IHBhZHMgb3V0cHV0IHdpdGggemVybyBhcyBwZXIgc3BlY1xuICAgIGNvbnN0IE9SREVSX01BU0sgPSB1dC5iaXRNYXNrKENVUlZFLm5CaXRMZW5ndGgpO1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRvIGJ5dGVzLiBDaGVja3MgaWYgbnVtIGluIGBbMC4uT1JERVJfTUFTSy0xXWAgZS5nLjogYFswLi4yXjI1Ni0xXWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW50Mm9jdGV0cyhudW0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBudW0gIT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiaWdpbnQgZXhwZWN0ZWQnKTtcbiAgICAgICAgaWYgKCEoXzBuIDw9IG51bSAmJiBudW0gPCBPUkRFUl9NQVNLKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYmlnaW50IGV4cGVjdGVkIDwgMl4ke0NVUlZFLm5CaXRMZW5ndGh9YCk7XG4gICAgICAgIC8vIHdvcmtzIHdpdGggb3JkZXIsIGNhbiBoYXZlIGRpZmZlcmVudCBzaXplIHRoYW4gbnVtVG9GaWVsZCFcbiAgICAgICAgcmV0dXJuIHV0Lm51bWJlclRvQnl0ZXNCRShudW0sIENVUlZFLm5CeXRlTGVuZ3RoKTtcbiAgICB9XG4gICAgLy8gU3RlcHMgQSwgRCBvZiBSRkM2OTc5IDMuMlxuICAgIC8vIENyZWF0ZXMgUkZDNjk3OSBzZWVkOyBjb252ZXJ0cyBtc2cvcHJpdktleSB0byBudW1iZXJzLlxuICAgIC8vIFVzZWQgb25seSBpbiBzaWduLCBub3QgaW4gdmVyaWZ5LlxuICAgIC8vIE5PVEU6IHdlIGNhbm5vdCBhc3N1bWUgaGVyZSB0aGF0IG1zZ0hhc2ggaGFzIHNhbWUgYW1vdW50IG9mIGJ5dGVzIGFzIGN1cnZlIG9yZGVyLCB0aGlzIHdpbGwgYmUgd3JvbmcgYXQgbGVhc3QgZm9yIFA1MjEuXG4gICAgLy8gQWxzbyBpdCBjYW4gYmUgYmlnZ2VyIGZvciBQMjI0ICsgU0hBMjU2XG4gICAgZnVuY3Rpb24gcHJlcFNpZyhtc2dIYXNoLCBwcml2YXRlS2V5LCBvcHRzID0gZGVmYXVsdFNpZ09wdHMpIHtcbiAgICAgICAgaWYgKFsncmVjb3ZlcmVkJywgJ2Nhbm9uaWNhbCddLnNvbWUoKGspID0+IGsgaW4gb3B0cykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ24oKSBsZWdhY3kgb3B0aW9ucyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIGNvbnN0IHsgaGFzaCwgcmFuZG9tQnl0ZXMgfSA9IENVUlZFO1xuICAgICAgICBsZXQgeyBsb3dTLCBwcmVoYXNoLCBleHRyYUVudHJvcHk6IGVudCB9ID0gb3B0czsgLy8gZ2VuZXJhdGVzIGxvdy1zIHNpZ3MgYnkgZGVmYXVsdFxuICAgICAgICBpZiAobG93UyA9PSBudWxsKVxuICAgICAgICAgICAgbG93UyA9IHRydWU7IC8vIFJGQzY5NzkgMy4yOiB3ZSBza2lwIHN0ZXAgQSwgYmVjYXVzZSB3ZSBhbHJlYWR5IHByb3ZpZGUgaGFzaFxuICAgICAgICBtc2dIYXNoID0gZW5zdXJlQnl0ZXMoJ21zZ0hhc2gnLCBtc2dIYXNoKTtcbiAgICAgICAgaWYgKHByZWhhc2gpXG4gICAgICAgICAgICBtc2dIYXNoID0gZW5zdXJlQnl0ZXMoJ3ByZWhhc2hlZCBtc2dIYXNoJywgaGFzaChtc2dIYXNoKSk7XG4gICAgICAgIC8vIFdlIGNhbid0IGxhdGVyIGNhbGwgYml0czJvY3RldHMsIHNpbmNlIG5lc3RlZCBiaXRzMmludCBpcyBicm9rZW4gZm9yIGN1cnZlc1xuICAgICAgICAvLyB3aXRoIG5CaXRMZW5ndGggJSA4ICE9PSAwLiBCZWNhdXNlIG9mIHRoYXQsIHdlIHVud3JhcCBpdCBoZXJlIGFzIGludDJvY3RldHMgY2FsbC5cbiAgICAgICAgLy8gY29uc3QgYml0czJvY3RldHMgPSAoYml0cykgPT4gaW50Mm9jdGV0cyhiaXRzMmludF9tb2ROKGJpdHMpKVxuICAgICAgICBjb25zdCBoMWludCA9IGJpdHMyaW50X21vZE4obXNnSGFzaCk7XG4gICAgICAgIGNvbnN0IGQgPSBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpOyAvLyB2YWxpZGF0ZSBwcml2YXRlIGtleSwgY29udmVydCB0byBiaWdpbnRcbiAgICAgICAgY29uc3Qgc2VlZEFyZ3MgPSBbaW50Mm9jdGV0cyhkKSwgaW50Mm9jdGV0cyhoMWludCldO1xuICAgICAgICAvLyBleHRyYUVudHJvcHkuIFJGQzY5NzkgMy42OiBhZGRpdGlvbmFsIGsnIChvcHRpb25hbCkuXG4gICAgICAgIGlmIChlbnQgIT0gbnVsbCAmJiBlbnQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAvLyBLID0gSE1BQ19LKFYgfHwgMHgwMCB8fCBpbnQyb2N0ZXRzKHgpIHx8IGJpdHMyb2N0ZXRzKGgxKSB8fCBrJylcbiAgICAgICAgICAgIGNvbnN0IGUgPSBlbnQgPT09IHRydWUgPyByYW5kb21CeXRlcyhGcC5CWVRFUykgOiBlbnQ7IC8vIGdlbmVyYXRlIHJhbmRvbSBieXRlcyBPUiBwYXNzIGFzLWlzXG4gICAgICAgICAgICBzZWVkQXJncy5wdXNoKGVuc3VyZUJ5dGVzKCdleHRyYUVudHJvcHknLCBlKSk7IC8vIGNoZWNrIGZvciBiZWluZyBieXRlc1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlZWQgPSB1dC5jb25jYXRCeXRlcyguLi5zZWVkQXJncyk7IC8vIFN0ZXAgRCBvZiBSRkM2OTc5IDMuMlxuICAgICAgICBjb25zdCBtID0gaDFpbnQ7IC8vIE5PVEU6IG5vIG5lZWQgdG8gY2FsbCBiaXRzMmludCBzZWNvbmQgdGltZSBoZXJlLCBpdCBpcyBpbnNpZGUgdHJ1bmNhdGVIYXNoIVxuICAgICAgICAvLyBDb252ZXJ0cyBzaWduYXR1cmUgcGFyYW1zIGludG8gcG9pbnQgdyByL3MsIGNoZWNrcyByZXN1bHQgZm9yIHZhbGlkaXR5LlxuICAgICAgICBmdW5jdGlvbiBrMnNpZyhrQnl0ZXMpIHtcbiAgICAgICAgICAgIC8vIFJGQyA2OTc5IFNlY3Rpb24gMy4yLCBzdGVwIDM6IGsgPSBiaXRzMmludChUKVxuICAgICAgICAgICAgY29uc3QgayA9IGJpdHMyaW50KGtCeXRlcyk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKGspKVxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gSW1wb3J0YW50OiBhbGwgbW9kKCkgY2FsbHMgaGVyZSBtdXN0IGJlIGRvbmUgb3ZlciBOXG4gICAgICAgICAgICBjb25zdCBpayA9IGludk4oayk7IC8vIGteLTEgbW9kIG5cbiAgICAgICAgICAgIGNvbnN0IHEgPSBQb2ludC5CQVNFLm11bHRpcGx5KGspLnRvQWZmaW5lKCk7IC8vIHEgPSBHa1xuICAgICAgICAgICAgY29uc3QgciA9IG1vZE4ocS54KTsgLy8gciA9IHEueCBtb2QgblxuICAgICAgICAgICAgaWYgKHIgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBDYW4gdXNlIHNjYWxhciBibGluZGluZyBiXi0xKGJtICsgYmRyKSB3aGVyZSBiIOKIiCBbMSxx4oiSMV0gYWNjb3JkaW5nIHRvXG4gICAgICAgICAgICAvLyBodHRwczovL3RjaGVzLmlhY3Iub3JnL2luZGV4LnBocC9UQ0hFUy9hcnRpY2xlL3ZpZXcvNzMzNy82NTA5LiBXZSd2ZSBkZWNpZGVkIGFnYWluc3QgaXQ6XG4gICAgICAgICAgICAvLyBhKSBkZXBlbmRlbmN5IG9uIENTUFJORyBiKSAxNSUgc2xvd2Rvd24gYykgZG9lc24ndCByZWFsbHkgaGVscCBzaW5jZSBiaWdpbnRzIGFyZSBub3QgQ1RcbiAgICAgICAgICAgIGNvbnN0IHMgPSBtb2ROKGlrICogbW9kTihtICsgciAqIGQpKTsgLy8gTm90IHVzaW5nIGJsaW5kaW5nIGhlcmVcbiAgICAgICAgICAgIGlmIChzID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHJlY292ZXJ5ID0gKHEueCA9PT0gciA/IDAgOiAyKSB8IE51bWJlcihxLnkgJiBfMW4pOyAvLyByZWNvdmVyeSBiaXQgKDIgb3IgMywgd2hlbiBxLnggPiBuKVxuICAgICAgICAgICAgbGV0IG5vcm1TID0gcztcbiAgICAgICAgICAgIGlmIChsb3dTICYmIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSkge1xuICAgICAgICAgICAgICAgIG5vcm1TID0gbm9ybWFsaXplUyhzKTsgLy8gaWYgbG93UyB3YXMgcGFzc2VkLCBlbnN1cmUgcyBpcyBhbHdheXNcbiAgICAgICAgICAgICAgICByZWNvdmVyeSBePSAxOyAvLyAvLyBpbiB0aGUgYm90dG9tIGhhbGYgb2YgTlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgbm9ybVMsIHJlY292ZXJ5KTsgLy8gdXNlIG5vcm1TLCBub3Qgc1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHNlZWQsIGsyc2lnIH07XG4gICAgfVxuICAgIGNvbnN0IGRlZmF1bHRTaWdPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIGNvbnN0IGRlZmF1bHRWZXJPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIC8qKlxuICAgICAqIFNpZ25zIG1lc3NhZ2UgaGFzaCB3aXRoIGEgcHJpdmF0ZSBrZXkuXG4gICAgICogYGBgXG4gICAgICogc2lnbihtLCBkLCBrKSB3aGVyZVxuICAgICAqICAgKHgsIHkpID0gRyDDlyBrXG4gICAgICogICByID0geCBtb2QgblxuICAgICAqICAgcyA9IChtICsgZHIpL2sgbW9kIG5cbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gbXNnSGFzaCBOT1QgbWVzc2FnZS4gbXNnIG5lZWRzIHRvIGJlIGhhc2hlZCB0byBgbXNnSGFzaGAsIG9yIHVzZSBgcHJlaGFzaGAuXG4gICAgICogQHBhcmFtIHByaXZLZXkgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0gb3B0cyBsb3dTIGZvciBub24tbWFsbGVhYmxlIHNpZ3MuIGV4dHJhRW50cm9weSBmb3IgbWl4aW5nIHJhbmRvbW5lc3MgaW50byBrLiBwcmVoYXNoIHdpbGwgaGFzaCBmaXJzdCBhcmcuXG4gICAgICogQHJldHVybnMgc2lnbmF0dXJlIHdpdGggcmVjb3ZlcnkgcGFyYW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaWduKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBjb25zdCB7IHNlZWQsIGsyc2lnIH0gPSBwcmVwU2lnKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMpOyAvLyBTdGVwcyBBLCBEIG9mIFJGQzY5NzkgMy4yLlxuICAgICAgICBjb25zdCBDID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IGRyYmcgPSB1dC5jcmVhdGVIbWFjRHJiZyhDLmhhc2gub3V0cHV0TGVuLCBDLm5CeXRlTGVuZ3RoLCBDLmhtYWMpO1xuICAgICAgICByZXR1cm4gZHJiZyhzZWVkLCBrMnNpZyk7IC8vIFN0ZXBzIEIsIEMsIEQsIEUsIEYsIEdcbiAgICB9XG4gICAgLy8gRW5hYmxlIHByZWNvbXB1dGVzLiBTbG93cyBkb3duIGZpcnN0IHB1YmxpY0tleSBjb21wdXRhdGlvbiBieSAyMG1zLlxuICAgIFBvaW50LkJBU0UuX3NldFdpbmRvd1NpemUoOCk7XG4gICAgLy8gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuQkFTRSlcbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBhIHNpZ25hdHVyZSBhZ2FpbnN0IG1lc3NhZ2UgaGFzaCBhbmQgcHVibGljIGtleS5cbiAgICAgKiBSZWplY3RzIGxvd1Mgc2lnbmF0dXJlcyBieSBkZWZhdWx0OiB0byBvdmVycmlkZSxcbiAgICAgKiBzcGVjaWZ5IG9wdGlvbiBge2xvd1M6IGZhbHNlfWAuIEltcGxlbWVudHMgc2VjdGlvbiA0LjEuNCBmcm9tIGh0dHBzOi8vd3d3LnNlY2cub3JnL3NlYzEtdjIucGRmOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogdmVyaWZ5KHIsIHMsIGgsIFApIHdoZXJlXG4gICAgICogICBVMSA9IGhzXi0xIG1vZCBuXG4gICAgICogICBVMiA9IHJzXi0xIG1vZCBuXG4gICAgICogICBSID0gVTHii4VHIC0gVTLii4VQXG4gICAgICogICBtb2QoUi54LCBuKSA9PSByXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmVyaWZ5KHNpZ25hdHVyZSwgbXNnSGFzaCwgcHVibGljS2V5LCBvcHRzID0gZGVmYXVsdFZlck9wdHMpIHtcbiAgICAgICAgY29uc3Qgc2cgPSBzaWduYXR1cmU7XG4gICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpO1xuICAgICAgICBwdWJsaWNLZXkgPSBlbnN1cmVCeXRlcygncHVibGljS2V5JywgcHVibGljS2V5KTtcbiAgICAgICAgaWYgKCdzdHJpY3QnIGluIG9wdHMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMuc3RyaWN0IHdhcyByZW5hbWVkIHRvIGxvd1MnKTtcbiAgICAgICAgY29uc3QgeyBsb3dTLCBwcmVoYXNoIH0gPSBvcHRzO1xuICAgICAgICBsZXQgX3NpZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IFA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNnID09PSAnc3RyaW5nJyB8fCB1dC5pc0J5dGVzKHNnKSkge1xuICAgICAgICAgICAgICAgIC8vIFNpZ25hdHVyZSBjYW4gYmUgcmVwcmVzZW50ZWQgaW4gMiB3YXlzOiBjb21wYWN0ICgyKm5CeXRlTGVuZ3RoKSAmIERFUiAodmFyaWFibGUtbGVuZ3RoKS5cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBERVIgY2FuIGFsc28gYmUgMipuQnl0ZUxlbmd0aCBieXRlcywgd2UgY2hlY2sgZm9yIGl0IGZpcnN0LlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIF9zaWcgPSBTaWduYXR1cmUuZnJvbURFUihzZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChkZXJFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShkZXJFcnJvciBpbnN0YW5jZW9mIERFUi5FcnIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGVyRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIF9zaWcgPSBTaWduYXR1cmUuZnJvbUNvbXBhY3Qoc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzZyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHNnLnIgPT09ICdiaWdpbnQnICYmIHR5cGVvZiBzZy5zID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgciwgcyB9ID0gc2c7XG4gICAgICAgICAgICAgICAgX3NpZyA9IG5ldyBTaWduYXR1cmUociwgcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BBUlNFJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBQID0gUG9pbnQuZnJvbUhleChwdWJsaWNLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UgPT09ICdQQVJTRScpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzaWduYXR1cmUgbXVzdCBiZSBTaWduYXR1cmUgaW5zdGFuY2UsIFVpbnQ4QXJyYXkgb3IgaGV4IHN0cmluZ2ApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb3dTICYmIF9zaWcuaGFzSGlnaFMoKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHByZWhhc2gpXG4gICAgICAgICAgICBtc2dIYXNoID0gQ1VSVkUuaGFzaChtc2dIYXNoKTtcbiAgICAgICAgY29uc3QgeyByLCBzIH0gPSBfc2lnO1xuICAgICAgICBjb25zdCBoID0gYml0czJpbnRfbW9kTihtc2dIYXNoKTsgLy8gQ2Fubm90IHVzZSBmaWVsZHMgbWV0aG9kcywgc2luY2UgaXQgaXMgZ3JvdXAgZWxlbWVudFxuICAgICAgICBjb25zdCBpcyA9IGludk4ocyk7IC8vIHNeLTFcbiAgICAgICAgY29uc3QgdTEgPSBtb2ROKGggKiBpcyk7IC8vIHUxID0gaHNeLTEgbW9kIG5cbiAgICAgICAgY29uc3QgdTIgPSBtb2ROKHIgKiBpcyk7IC8vIHUyID0gcnNeLTEgbW9kIG5cbiAgICAgICAgY29uc3QgUiA9IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUCwgdTEsIHUyKT8udG9BZmZpbmUoKTsgLy8gUiA9IHUx4ouFRyArIHUy4ouFUFxuICAgICAgICBpZiAoIVIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHYgPSBtb2ROKFIueCk7XG4gICAgICAgIHJldHVybiB2ID09PSByO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBDVVJWRSxcbiAgICAgICAgZ2V0UHVibGljS2V5LFxuICAgICAgICBnZXRTaGFyZWRTZWNyZXQsXG4gICAgICAgIHNpZ24sXG4gICAgICAgIHZlcmlmeSxcbiAgICAgICAgUHJvamVjdGl2ZVBvaW50OiBQb2ludCxcbiAgICAgICAgU2lnbmF0dXJlLFxuICAgICAgICB1dGlscyxcbiAgICB9O1xufVxuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2hhbGx1ZSBhbmQgdmFuIGRlIFdvZXN0aWpuZSBtZXRob2QgZm9yIGFueSB3ZWllcnN0cmFzcyBjdXJ2ZS5cbiAqIFRPRE86IGNoZWNrIGlmIHRoZXJlIGlzIGEgd2F5IHRvIG1lcmdlIHRoaXMgd2l0aCB1dlJhdGlvIGluIEVkd2FyZHM7IG1vdmUgdG8gbW9kdWxhci5cbiAqIGIgPSBUcnVlIGFuZCB5ID0gc3FydCh1IC8gdikgaWYgKHUgLyB2KSBpcyBzcXVhcmUgaW4gRiwgYW5kXG4gKiBiID0gRmFsc2UgYW5kIHkgPSBzcXJ0KFogKiAodSAvIHYpKSBvdGhlcndpc2UuXG4gKiBAcGFyYW0gRnBcbiAqIEBwYXJhbSBaXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gU1dVRnBTcXJ0UmF0aW8oRnAsIFopIHtcbiAgICAvLyBHZW5lcmljIGltcGxlbWVudGF0aW9uXG4gICAgY29uc3QgcSA9IEZwLk9SREVSO1xuICAgIGxldCBsID0gXzBuO1xuICAgIGZvciAobGV0IG8gPSBxIC0gXzFuOyBvICUgXzJuID09PSBfMG47IG8gLz0gXzJuKVxuICAgICAgICBsICs9IF8xbjtcbiAgICBjb25zdCBjMSA9IGw7IC8vIDEuIGMxLCB0aGUgbGFyZ2VzdCBpbnRlZ2VyIHN1Y2ggdGhhdCAyXmMxIGRpdmlkZXMgcSAtIDEuXG4gICAgLy8gV2UgbmVlZCAybiAqKiBjMSBhbmQgMm4gKiogKGMxLTEpLiBXZSBjYW4ndCB1c2UgKio7IGJ1dCB3ZSBjYW4gdXNlIDw8LlxuICAgIC8vIDJuICoqIGMxID09IDJuIDw8IChjMS0xKVxuICAgIGNvbnN0IF8ybl9wb3dfYzFfMSA9IF8ybiA8PCAoYzEgLSBfMW4gLSBfMW4pO1xuICAgIGNvbnN0IF8ybl9wb3dfYzEgPSBfMm5fcG93X2MxXzEgKiBfMm47XG4gICAgY29uc3QgYzIgPSAocSAtIF8xbikgLyBfMm5fcG93X2MxOyAvLyAyLiBjMiA9IChxIC0gMSkgLyAoMl5jMSkgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzMgPSAoYzIgLSBfMW4pIC8gXzJuOyAvLyAzLiBjMyA9IChjMiAtIDEpIC8gMiAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzQgPSBfMm5fcG93X2MxIC0gXzFuOyAvLyA0LiBjNCA9IDJeYzEgLSAxICAgICAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzUgPSBfMm5fcG93X2MxXzE7IC8vIDUuIGM1ID0gMl4oYzEgLSAxKSAgICAgICAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzYgPSBGcC5wb3coWiwgYzIpOyAvLyA2LiBjNiA9IFpeYzJcbiAgICBjb25zdCBjNyA9IEZwLnBvdyhaLCAoYzIgKyBfMW4pIC8gXzJuKTsgLy8gNy4gYzcgPSBaXigoYzIgKyAxKSAvIDIpXG4gICAgbGV0IHNxcnRSYXRpbyA9ICh1LCB2KSA9PiB7XG4gICAgICAgIGxldCB0djEgPSBjNjsgLy8gMS4gdHYxID0gYzZcbiAgICAgICAgbGV0IHR2MiA9IEZwLnBvdyh2LCBjNCk7IC8vIDIuIHR2MiA9IHZeYzRcbiAgICAgICAgbGV0IHR2MyA9IEZwLnNxcih0djIpOyAvLyAzLiB0djMgPSB0djJeMlxuICAgICAgICB0djMgPSBGcC5tdWwodHYzLCB2KTsgLy8gNC4gdHYzID0gdHYzICogdlxuICAgICAgICBsZXQgdHY1ID0gRnAubXVsKHUsIHR2Myk7IC8vIDUuIHR2NSA9IHUgKiB0djNcbiAgICAgICAgdHY1ID0gRnAucG93KHR2NSwgYzMpOyAvLyA2LiB0djUgPSB0djVeYzNcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2NSwgdHYyKTsgLy8gNy4gdHY1ID0gdHY1ICogdHYyXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djUsIHYpOyAvLyA4LiB0djIgPSB0djUgKiB2XG4gICAgICAgIHR2MyA9IEZwLm11bCh0djUsIHUpOyAvLyA5LiB0djMgPSB0djUgKiB1XG4gICAgICAgIGxldCB0djQgPSBGcC5tdWwodHYzLCB0djIpOyAvLyAxMC4gdHY0ID0gdHYzICogdHYyXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djQsIGM1KTsgLy8gMTEuIHR2NSA9IHR2NF5jNVxuICAgICAgICBsZXQgaXNRUiA9IEZwLmVxbCh0djUsIEZwLk9ORSk7IC8vIDEyLiBpc1FSID0gdHY1ID09IDFcbiAgICAgICAgdHYyID0gRnAubXVsKHR2MywgYzcpOyAvLyAxMy4gdHYyID0gdHYzICogYzdcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2NCwgdHYxKTsgLy8gMTQuIHR2NSA9IHR2NCAqIHR2MVxuICAgICAgICB0djMgPSBGcC5jbW92KHR2MiwgdHYzLCBpc1FSKTsgLy8gMTUuIHR2MyA9IENNT1YodHYyLCB0djMsIGlzUVIpXG4gICAgICAgIHR2NCA9IEZwLmNtb3YodHY1LCB0djQsIGlzUVIpOyAvLyAxNi4gdHY0ID0gQ01PVih0djUsIHR2NCwgaXNRUilcbiAgICAgICAgLy8gMTcuIGZvciBpIGluIChjMSwgYzEgLSAxLCAuLi4sIDIpOlxuICAgICAgICBmb3IgKGxldCBpID0gYzE7IGkgPiBfMW47IGktLSkge1xuICAgICAgICAgICAgbGV0IHR2NSA9IGkgLSBfMm47IC8vIDE4LiAgICB0djUgPSBpIC0gMlxuICAgICAgICAgICAgdHY1ID0gXzJuIDw8ICh0djUgLSBfMW4pOyAvLyAxOS4gICAgdHY1ID0gMl50djVcbiAgICAgICAgICAgIGxldCB0dnY1ID0gRnAucG93KHR2NCwgdHY1KTsgLy8gMjAuICAgIHR2NSA9IHR2NF50djVcbiAgICAgICAgICAgIGNvbnN0IGUxID0gRnAuZXFsKHR2djUsIEZwLk9ORSk7IC8vIDIxLiAgICBlMSA9IHR2NSA9PSAxXG4gICAgICAgICAgICB0djIgPSBGcC5tdWwodHYzLCB0djEpOyAvLyAyMi4gICAgdHYyID0gdHYzICogdHYxXG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djEpOyAvLyAyMy4gICAgdHYxID0gdHYxICogdHYxXG4gICAgICAgICAgICB0dnY1ID0gRnAubXVsKHR2NCwgdHYxKTsgLy8gMjQuICAgIHR2NSA9IHR2NCAqIHR2MVxuICAgICAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgZTEpOyAvLyAyNS4gICAgdHYzID0gQ01PVih0djIsIHR2MywgZTEpXG4gICAgICAgICAgICB0djQgPSBGcC5jbW92KHR2djUsIHR2NCwgZTEpOyAvLyAyNi4gICAgdHY0ID0gQ01PVih0djUsIHR2NCwgZTEpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHR2MyB9O1xuICAgIH07XG4gICAgaWYgKEZwLk9SREVSICUgXzRuID09PSBfM24pIHtcbiAgICAgICAgLy8gc3FydF9yYXRpb18zbW9kNCh1LCB2KVxuICAgICAgICBjb25zdCBjMSA9IChGcC5PUkRFUiAtIF8zbikgLyBfNG47IC8vIDEuIGMxID0gKHEgLSAzKSAvIDQgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgICAgIGNvbnN0IGMyID0gRnAuc3FydChGcC5uZWcoWikpOyAvLyAyLiBjMiA9IHNxcnQoLVopXG4gICAgICAgIHNxcnRSYXRpbyA9ICh1LCB2KSA9PiB7XG4gICAgICAgICAgICBsZXQgdHYxID0gRnAuc3FyKHYpOyAvLyAxLiB0djEgPSB2XjJcbiAgICAgICAgICAgIGNvbnN0IHR2MiA9IEZwLm11bCh1LCB2KTsgLy8gMi4gdHYyID0gdSAqIHZcbiAgICAgICAgICAgIHR2MSA9IEZwLm11bCh0djEsIHR2Mik7IC8vIDMuIHR2MSA9IHR2MSAqIHR2MlxuICAgICAgICAgICAgbGV0IHkxID0gRnAucG93KHR2MSwgYzEpOyAvLyA0LiB5MSA9IHR2MV5jMVxuICAgICAgICAgICAgeTEgPSBGcC5tdWwoeTEsIHR2Mik7IC8vIDUuIHkxID0geTEgKiB0djJcbiAgICAgICAgICAgIGNvbnN0IHkyID0gRnAubXVsKHkxLCBjMik7IC8vIDYuIHkyID0geTEgKiBjMlxuICAgICAgICAgICAgY29uc3QgdHYzID0gRnAubXVsKEZwLnNxcih5MSksIHYpOyAvLyA3LiB0djMgPSB5MV4yOyA4LiB0djMgPSB0djMgKiB2XG4gICAgICAgICAgICBjb25zdCBpc1FSID0gRnAuZXFsKHR2MywgdSk7IC8vIDkuIGlzUVIgPSB0djMgPT0gdVxuICAgICAgICAgICAgbGV0IHkgPSBGcC5jbW92KHkyLCB5MSwgaXNRUik7IC8vIDEwLiB5ID0gQ01PVih5MiwgeTEsIGlzUVIpXG4gICAgICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiBpc1FSLCB2YWx1ZTogeSB9OyAvLyAxMS4gcmV0dXJuIChpc1FSLCB5KSBpc1FSID8geSA6IHkqYzJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gTm8gY3VydmVzIHVzZXMgdGhhdFxuICAgIC8vIGlmIChGcC5PUkRFUiAlIF84biA9PT0gXzVuKSAvLyBzcXJ0X3JhdGlvXzVtb2Q4XG4gICAgcmV0dXJuIHNxcnRSYXRpbztcbn1cbi8qKlxuICogU2ltcGxpZmllZCBTaGFsbHVlLXZhbiBkZSBXb2VzdGlqbmUtVWxhcyBNZXRob2RcbiAqIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNi42LjJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcFRvQ3VydmVTaW1wbGVTV1UoRnAsIG9wdHMpIHtcbiAgICBtb2QudmFsaWRhdGVGaWVsZChGcCk7XG4gICAgaWYgKCFGcC5pc1ZhbGlkKG9wdHMuQSkgfHwgIUZwLmlzVmFsaWQob3B0cy5CKSB8fCAhRnAuaXNWYWxpZChvcHRzLlopKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmVTaW1wbGVTV1U6IGludmFsaWQgb3B0cycpO1xuICAgIGNvbnN0IHNxcnRSYXRpbyA9IFNXVUZwU3FydFJhdGlvKEZwLCBvcHRzLlopO1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRnAuaXNPZGQgaXMgbm90IGltcGxlbWVudGVkIScpO1xuICAgIC8vIElucHV0OiB1LCBhbiBlbGVtZW50IG9mIEYuXG4gICAgLy8gT3V0cHV0OiAoeCwgeSksIGEgcG9pbnQgb24gRS5cbiAgICByZXR1cm4gKHUpID0+IHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGxldCB0djEsIHR2MiwgdHYzLCB0djQsIHR2NSwgdHY2LCB4LCB5O1xuICAgICAgICB0djEgPSBGcC5zcXIodSk7IC8vIDEuICB0djEgPSB1XjJcbiAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgb3B0cy5aKTsgLy8gMi4gIHR2MSA9IFogKiB0djFcbiAgICAgICAgdHYyID0gRnAuc3FyKHR2MSk7IC8vIDMuICB0djIgPSB0djFeMlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djEpOyAvLyA0LiAgdHYyID0gdHYyICsgdHYxXG4gICAgICAgIHR2MyA9IEZwLmFkZCh0djIsIEZwLk9ORSk7IC8vIDUuICB0djMgPSB0djIgKyAxXG4gICAgICAgIHR2MyA9IEZwLm11bCh0djMsIG9wdHMuQik7IC8vIDYuICB0djMgPSBCICogdHYzXG4gICAgICAgIHR2NCA9IEZwLmNtb3Yob3B0cy5aLCBGcC5uZWcodHYyKSwgIUZwLmVxbCh0djIsIEZwLlpFUk8pKTsgLy8gNy4gIHR2NCA9IENNT1YoWiwgLXR2MiwgdHYyICE9IDApXG4gICAgICAgIHR2NCA9IEZwLm11bCh0djQsIG9wdHMuQSk7IC8vIDguICB0djQgPSBBICogdHY0XG4gICAgICAgIHR2MiA9IEZwLnNxcih0djMpOyAvLyA5LiAgdHYyID0gdHYzXjJcbiAgICAgICAgdHY2ID0gRnAuc3FyKHR2NCk7IC8vIDEwLiB0djYgPSB0djReMlxuICAgICAgICB0djUgPSBGcC5tdWwodHY2LCBvcHRzLkEpOyAvLyAxMS4gdHY1ID0gQSAqIHR2NlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djUpOyAvLyAxMi4gdHYyID0gdHYyICsgdHY1XG4gICAgICAgIHR2MiA9IEZwLm11bCh0djIsIHR2Myk7IC8vIDEzLiB0djIgPSB0djIgKiB0djNcbiAgICAgICAgdHY2ID0gRnAubXVsKHR2NiwgdHY0KTsgLy8gMTQuIHR2NiA9IHR2NiAqIHR2NFxuICAgICAgICB0djUgPSBGcC5tdWwodHY2LCBvcHRzLkIpOyAvLyAxNS4gdHY1ID0gQiAqIHR2NlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djUpOyAvLyAxNi4gdHYyID0gdHYyICsgdHY1XG4gICAgICAgIHggPSBGcC5tdWwodHYxLCB0djMpOyAvLyAxNy4gICB4ID0gdHYxICogdHYzXG4gICAgICAgIGNvbnN0IHsgaXNWYWxpZCwgdmFsdWUgfSA9IHNxcnRSYXRpbyh0djIsIHR2Nik7IC8vIDE4LiAoaXNfZ3gxX3NxdWFyZSwgeTEpID0gc3FydF9yYXRpbyh0djIsIHR2NilcbiAgICAgICAgeSA9IEZwLm11bCh0djEsIHUpOyAvLyAxOS4gICB5ID0gdHYxICogdSAgLT4gWiAqIHVeMyAqIHkxXG4gICAgICAgIHkgPSBGcC5tdWwoeSwgdmFsdWUpOyAvLyAyMC4gICB5ID0geSAqIHkxXG4gICAgICAgIHggPSBGcC5jbW92KHgsIHR2MywgaXNWYWxpZCk7IC8vIDIxLiAgIHggPSBDTU9WKHgsIHR2MywgaXNfZ3gxX3NxdWFyZSlcbiAgICAgICAgeSA9IEZwLmNtb3YoeSwgdmFsdWUsIGlzVmFsaWQpOyAvLyAyMi4gICB5ID0gQ01PVih5LCB5MSwgaXNfZ3gxX3NxdWFyZSlcbiAgICAgICAgY29uc3QgZTEgPSBGcC5pc09kZCh1KSA9PT0gRnAuaXNPZGQoeSk7IC8vIDIzLiAgZTEgPSBzZ24wKHUpID09IHNnbjAoeSlcbiAgICAgICAgeSA9IEZwLmNtb3YoRnAubmVnKHkpLCB5LCBlMSk7IC8vIDI0LiAgIHkgPSBDTU9WKC15LCB5LCBlMSlcbiAgICAgICAgeCA9IEZwLmRpdih4LCB0djQpOyAvLyAyNS4gICB4ID0geCAvIHR2NFxuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlaWVyc3RyYXNzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/weierstrass.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@noble/curves/esm/bls12-381.js":
/*!*********************************************************!*\
  !*** ../../node_modules/@noble/curves/esm/bls12-381.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bls12_381: function() { return /* binding */ bls12_381; }\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(app-pages-browser)/../../node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/../../node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_bls_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/bls.js */ \"(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/bls.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./abstract/utils.js */ \"(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// bls12-381 is pairing-friendly Barreto-Lynn-Scott elliptic curve construction allowing to:\n// - Construct zk-SNARKs at the 120-bit security\n// - Efficiently verify N aggregate signatures with 1 pairing and N ec additions:\n//   the Boneh-Lynn-Shacham signature scheme is orders of magnitude more efficient than Schnorr\n//\n// ### Summary\n// 1. BLS Relies on Bilinear Pairing (expensive)\n// 2. Private Keys: 32 bytes\n// 3. Public Keys: 48 bytes: 381 bit affine x coordinate, encoded into 48 big-endian bytes.\n// 4. Signatures: 96 bytes: two 381 bit integers (affine x coordinate), encoded into two 48 big-endian byte arrays.\n//     - The signature is a point on the G2 subgroup, which is defined over a finite field\n//     with elements twice as big as the G1 curve (G2 is over Fp2 rather than Fp. Fp2 is analogous to the complex numbers).\n// 5. The 12 stands for the Embedding degree.\n//\n// ### Formulas\n// - `P = pk x G` - public keys\n// - `S = pk x H(m)` - signing\n// - `e(P, H(m)) == e(G, S)` - verification using pairings\n// - `e(G, S) = e(G, SUM(n)(Si)) = MUL(n)(e(G, Si))` - signature aggregation\n//\n// ### Compatibility and notes\n// 1. It is compatible with Algorand, Chia, Dfinity, Ethereum, Filecoin, ZEC\n//    Filecoin uses little endian byte arrays for private keys - make sure to reverse byte order.\n// 2. Some projects use G2 for public keys and G1 for signatures. It's called \"short signature\"\n// 3. Curve security level is about 120 bits as per Barbulescu-Duquesne 2017\n//    https://hal.science/hal-01534101/file/main.pdf\n// 4. Compatible with specs:\n// [cfrg-pairing-friendly-curves-11](https://tools.ietf.org/html/draft-irtf-cfrg-pairing-friendly-curves-11),\n// [cfrg-bls-signature-05](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-05),\n// [RFC 9380](https://www.rfc-editor.org/rfc/rfc9380).\n\n\n\n\n\n// Types\n\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\n// prettier-ignore\nconst _8n = BigInt(8), _16n = BigInt(16);\n// CURVE FIELDS\n// Finite field over p.\nconst Fp_raw = BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab');\nconst Fp = _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field(Fp_raw);\n// Finite field over r.\n// This particular field is not used anywhere in bls12-381, but it is still useful.\nconst Fr = _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field(BigInt('0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001'));\nconst Fp2Add = ({ c0, c1 }, { c0: r0, c1: r1 }) => ({\n    c0: Fp.add(c0, r0),\n    c1: Fp.add(c1, r1),\n});\nconst Fp2Subtract = ({ c0, c1 }, { c0: r0, c1: r1 }) => ({\n    c0: Fp.sub(c0, r0),\n    c1: Fp.sub(c1, r1),\n});\nconst Fp2Multiply = ({ c0, c1 }, rhs) => {\n    if (typeof rhs === 'bigint')\n        return { c0: Fp.mul(c0, rhs), c1: Fp.mul(c1, rhs) };\n    // (a+bi)(c+di) = (acbd) + (ad+bc)i\n    const { c0: r0, c1: r1 } = rhs;\n    let t1 = Fp.mul(c0, r0); // c0 * o0\n    let t2 = Fp.mul(c1, r1); // c1 * o1\n    // (T1 - T2) + ((c0 + c1) * (r0 + r1) - (T1 + T2))*i\n    const o0 = Fp.sub(t1, t2);\n    const o1 = Fp.sub(Fp.mul(Fp.add(c0, c1), Fp.add(r0, r1)), Fp.add(t1, t2));\n    return { c0: o0, c1: o1 };\n};\nconst Fp2Square = ({ c0, c1 }) => {\n    const a = Fp.add(c0, c1);\n    const b = Fp.sub(c0, c1);\n    const c = Fp.add(c0, c0);\n    return { c0: Fp.mul(a, b), c1: Fp.mul(c, c1) };\n};\n// G2 is the order-q subgroup of E2(Fp) : y = x+4(1+1),\n// where Fp2 is Fp[1]/(x2+1). #E2(Fp2 ) = h2q, where\n// G - 1\n// h2q\n// NOTE: ORDER was wrong!\nconst FP2_ORDER = Fp_raw * Fp_raw;\nconst Fp2 = {\n    ORDER: FP2_ORDER,\n    BITS: (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitLen)(FP2_ORDER),\n    BYTES: Math.ceil((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitLen)(FP2_ORDER) / 8),\n    MASK: (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitLen)(FP2_ORDER)),\n    ZERO: { c0: Fp.ZERO, c1: Fp.ZERO },\n    ONE: { c0: Fp.ONE, c1: Fp.ZERO },\n    create: (num) => num,\n    isValid: ({ c0, c1 }) => typeof c0 === 'bigint' && typeof c1 === 'bigint',\n    is0: ({ c0, c1 }) => Fp.is0(c0) && Fp.is0(c1),\n    eql: ({ c0, c1 }, { c0: r0, c1: r1 }) => Fp.eql(c0, r0) && Fp.eql(c1, r1),\n    neg: ({ c0, c1 }) => ({ c0: Fp.neg(c0), c1: Fp.neg(c1) }),\n    pow: (num, power) => _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.FpPow(Fp2, num, power),\n    invertBatch: (nums) => _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.FpInvertBatch(Fp2, nums),\n    // Normalized\n    add: Fp2Add,\n    sub: Fp2Subtract,\n    mul: Fp2Multiply,\n    sqr: Fp2Square,\n    // NonNormalized stuff\n    addN: Fp2Add,\n    subN: Fp2Subtract,\n    mulN: Fp2Multiply,\n    sqrN: Fp2Square,\n    // Why inversion for bigint inside Fp instead of Fp2? it is even used in that context?\n    div: (lhs, rhs) => Fp2.mul(lhs, typeof rhs === 'bigint' ? Fp.inv(Fp.create(rhs)) : Fp2.inv(rhs)),\n    inv: ({ c0: a, c1: b }) => {\n        // We wish to find the multiplicative inverse of a nonzero\n        // element a + bu in Fp2. We leverage an identity\n        //\n        // (a + bu)(a - bu) = a + b\n        //\n        // which holds because u = -1. This can be rewritten as\n        //\n        // (a + bu)(a - bu)/(a + b) = 1\n        //\n        // because a + b = 0 has no nonzero solutions for (a, b).\n        // This gives that (a - bu)/(a + b) is the inverse\n        // of (a + bu). Importantly, this can be computing using\n        // only a single inversion in Fp.\n        const factor = Fp.inv(Fp.create(a * a + b * b));\n        return { c0: Fp.mul(factor, Fp.create(a)), c1: Fp.mul(factor, Fp.create(-b)) };\n    },\n    sqrt: (num) => {\n        if (Fp2.eql(num, Fp2.ZERO))\n            return Fp2.ZERO; // Algo doesn't handles this case\n        // TODO: Optimize this line. It's extremely slow.\n        // Speeding this up would boost aggregateSignatures.\n        // https://eprint.iacr.org/2012/685.pdf applicable?\n        // https://github.com/zkcrypto/bls12_381/blob/080eaa74ec0e394377caa1ba302c8c121df08b07/src/fp2.rs#L250\n        // https://github.com/supranational/blst/blob/aae0c7d70b799ac269ff5edf29d8191dbd357876/src/exp2.c#L1\n        // Inspired by https://github.com/dalek-cryptography/curve25519-dalek/blob/17698df9d4c834204f83a3574143abacb4fc81a5/src/field.rs#L99\n        const candidateSqrt = Fp2.pow(num, (Fp2.ORDER + _8n) / _16n);\n        const check = Fp2.div(Fp2.sqr(candidateSqrt), num); // candidateSqrt.square().div(this);\n        const R = FP2_ROOTS_OF_UNITY;\n        const divisor = [R[0], R[2], R[4], R[6]].find((r) => Fp2.eql(r, check));\n        if (!divisor)\n            throw new Error('No root');\n        const index = R.indexOf(divisor);\n        const root = R[index / 2];\n        if (!root)\n            throw new Error('Invalid root');\n        const x1 = Fp2.div(candidateSqrt, root);\n        const x2 = Fp2.neg(x1);\n        const { re: re1, im: im1 } = Fp2.reim(x1);\n        const { re: re2, im: im2 } = Fp2.reim(x2);\n        if (im1 > im2 || (im1 === im2 && re1 > re2))\n            return x1;\n        return x2;\n    },\n    // Same as sgn0_m_eq_2 in RFC 9380\n    isOdd: (x) => {\n        const { re: x0, im: x1 } = Fp2.reim(x);\n        const sign_0 = x0 % _2n;\n        const zero_0 = x0 === _0n;\n        const sign_1 = x1 % _2n;\n        return BigInt(sign_0 || (zero_0 && sign_1)) == _1n;\n    },\n    // Bytes util\n    fromBytes(b) {\n        if (b.length !== Fp2.BYTES)\n            throw new Error(`fromBytes wrong length=${b.length}`);\n        return { c0: Fp.fromBytes(b.subarray(0, Fp.BYTES)), c1: Fp.fromBytes(b.subarray(Fp.BYTES)) };\n    },\n    toBytes: ({ c0, c1 }) => (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(Fp.toBytes(c0), Fp.toBytes(c1)),\n    cmov: ({ c0, c1 }, { c0: r0, c1: r1 }, c) => ({\n        c0: Fp.cmov(c0, r0, c),\n        c1: Fp.cmov(c1, r1, c),\n    }),\n    // Specific utils\n    // toString() {\n    //   return `Fp2(${this.c0} + ${this.c1}i)`;\n    // }\n    reim: ({ c0, c1 }) => ({ re: c0, im: c1 }),\n    // multiply by u + 1\n    mulByNonresidue: ({ c0, c1 }) => ({ c0: Fp.sub(c0, c1), c1: Fp.add(c0, c1) }),\n    multiplyByB: ({ c0, c1 }) => {\n        let t0 = Fp.mul(c0, _4n); // 4 * c0\n        let t1 = Fp.mul(c1, _4n); // 4 * c1\n        // (T0-T1) + (T0+T1)*i\n        return { c0: Fp.sub(t0, t1), c1: Fp.add(t0, t1) };\n    },\n    fromBigTuple: (tuple) => {\n        if (tuple.length !== 2)\n            throw new Error('Invalid tuple');\n        const fps = tuple.map((n) => Fp.create(n));\n        return { c0: fps[0], c1: fps[1] };\n    },\n    frobeniusMap: ({ c0, c1 }, power) => ({\n        c0,\n        c1: Fp.mul(c1, FP2_FROBENIUS_COEFFICIENTS[power % 2]),\n    }),\n};\n// Finite extension field over irreducible polynominal.\n// Fp(u) / (u - ) where  = -1\nconst FP2_FROBENIUS_COEFFICIENTS = [\n    BigInt('0x1'),\n    BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaaa'),\n].map((item) => Fp.create(item));\n// For Fp2 roots of unity.\nconst rv1 = BigInt('0x6af0e0437ff400b6831e36d6bd17ffe48395dabc2d3435e77f76e17009241c5ee67992f72ec05f4c81084fbede3cc09');\n// const ev1 =\n//   BigInt('0x699be3b8c6870965e5bf892ad5d2cc7b0e85a117402dfd83b7f4a947e02d978498255a2aaec0ac627b5afbdf1bf1c90');\n// const ev2 =\n//   BigInt('0x8157cd83046453f5dd0972b6e3949e4288020b5b8a9cc99ca07e27089a2ce2436d965026adad3ef7baba37f2183e9b5');\n// const ev3 =\n//   BigInt('0xab1c2ffdd6c253ca155231eb3e71ba044fd562f6f72bc5bad5ec46a0b7a3b0247cf08ce6c6317f40edbc653a72dee17');\n// const ev4 =\n//   BigInt('0xaa404866706722864480885d68ad0ccac1967c7544b447873cc37e0181271e006df72162a3d3e0287bf597fbf7f8fc1');\n// Eighth roots of unity, used for computing square roots in Fp2.\n// To verify or re-calculate:\n// Array(8).fill(new Fp2([1n, 1n])).map((fp2, k) => fp2.pow(Fp2.ORDER * BigInt(k) / 8n))\nconst FP2_ROOTS_OF_UNITY = [\n    [_1n, _0n],\n    [rv1, -rv1],\n    [_0n, _1n],\n    [rv1, rv1],\n    [-_1n, _0n],\n    [-rv1, rv1],\n    [_0n, -_1n],\n    [-rv1, -rv1],\n].map((pair) => Fp2.fromBigTuple(pair));\nconst Fp6Add = ({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r2 }) => ({\n    c0: Fp2.add(c0, r0),\n    c1: Fp2.add(c1, r1),\n    c2: Fp2.add(c2, r2),\n});\nconst Fp6Subtract = ({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r2 }) => ({\n    c0: Fp2.sub(c0, r0),\n    c1: Fp2.sub(c1, r1),\n    c2: Fp2.sub(c2, r2),\n});\nconst Fp6Multiply = ({ c0, c1, c2 }, rhs) => {\n    if (typeof rhs === 'bigint') {\n        return {\n            c0: Fp2.mul(c0, rhs),\n            c1: Fp2.mul(c1, rhs),\n            c2: Fp2.mul(c2, rhs),\n        };\n    }\n    const { c0: r0, c1: r1, c2: r2 } = rhs;\n    const t0 = Fp2.mul(c0, r0); // c0 * o0\n    const t1 = Fp2.mul(c1, r1); // c1 * o1\n    const t2 = Fp2.mul(c2, r2); // c2 * o2\n    return {\n        // t0 + (c1 + c2) * (r1 * r2) - (T1 + T2) * (u + 1)\n        c0: Fp2.add(t0, Fp2.mulByNonresidue(Fp2.sub(Fp2.mul(Fp2.add(c1, c2), Fp2.add(r1, r2)), Fp2.add(t1, t2)))),\n        // (c0 + c1) * (r0 + r1) - (T0 + T1) + T2 * (u + 1)\n        c1: Fp2.add(Fp2.sub(Fp2.mul(Fp2.add(c0, c1), Fp2.add(r0, r1)), Fp2.add(t0, t1)), Fp2.mulByNonresidue(t2)),\n        // T1 + (c0 + c2) * (r0 + r2) - T0 + T2\n        c2: Fp2.sub(Fp2.add(t1, Fp2.mul(Fp2.add(c0, c2), Fp2.add(r0, r2))), Fp2.add(t0, t2)),\n    };\n};\nconst Fp6Square = ({ c0, c1, c2 }) => {\n    let t0 = Fp2.sqr(c0); // c0\n    let t1 = Fp2.mul(Fp2.mul(c0, c1), _2n); // 2 * c0 * c1\n    let t3 = Fp2.mul(Fp2.mul(c1, c2), _2n); // 2 * c1 * c2\n    let t4 = Fp2.sqr(c2); // c2\n    return {\n        c0: Fp2.add(Fp2.mulByNonresidue(t3), t0), // T3 * (u + 1) + T0\n        c1: Fp2.add(Fp2.mulByNonresidue(t4), t1), // T4 * (u + 1) + T1\n        // T1 + (c0 - c1 + c2) + T3 - T0 - T4\n        c2: Fp2.sub(Fp2.sub(Fp2.add(Fp2.add(t1, Fp2.sqr(Fp2.add(Fp2.sub(c0, c1), c2))), t3), t0), t4),\n    };\n};\nconst Fp6 = {\n    ORDER: Fp2.ORDER, // TODO: unused, but need to verify\n    BITS: 3 * Fp2.BITS,\n    BYTES: 3 * Fp2.BYTES,\n    MASK: (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask)(3 * Fp2.BITS),\n    ZERO: { c0: Fp2.ZERO, c1: Fp2.ZERO, c2: Fp2.ZERO },\n    ONE: { c0: Fp2.ONE, c1: Fp2.ZERO, c2: Fp2.ZERO },\n    create: (num) => num,\n    isValid: ({ c0, c1, c2 }) => Fp2.isValid(c0) && Fp2.isValid(c1) && Fp2.isValid(c2),\n    is0: ({ c0, c1, c2 }) => Fp2.is0(c0) && Fp2.is0(c1) && Fp2.is0(c2),\n    neg: ({ c0, c1, c2 }) => ({ c0: Fp2.neg(c0), c1: Fp2.neg(c1), c2: Fp2.neg(c2) }),\n    eql: ({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r2 }) => Fp2.eql(c0, r0) && Fp2.eql(c1, r1) && Fp2.eql(c2, r2),\n    sqrt: () => {\n        throw new Error('Not implemented');\n    },\n    // Do we need division by bigint at all? Should be done via order:\n    div: (lhs, rhs) => Fp6.mul(lhs, typeof rhs === 'bigint' ? Fp.inv(Fp.create(rhs)) : Fp6.inv(rhs)),\n    pow: (num, power) => _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.FpPow(Fp6, num, power),\n    invertBatch: (nums) => _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.FpInvertBatch(Fp6, nums),\n    // Normalized\n    add: Fp6Add,\n    sub: Fp6Subtract,\n    mul: Fp6Multiply,\n    sqr: Fp6Square,\n    // NonNormalized stuff\n    addN: Fp6Add,\n    subN: Fp6Subtract,\n    mulN: Fp6Multiply,\n    sqrN: Fp6Square,\n    inv: ({ c0, c1, c2 }) => {\n        let t0 = Fp2.sub(Fp2.sqr(c0), Fp2.mulByNonresidue(Fp2.mul(c2, c1))); // c0 - c2 * c1 * (u + 1)\n        let t1 = Fp2.sub(Fp2.mulByNonresidue(Fp2.sqr(c2)), Fp2.mul(c0, c1)); // c2 * (u + 1) - c0 * c1\n        let t2 = Fp2.sub(Fp2.sqr(c1), Fp2.mul(c0, c2)); // c1 - c0 * c2\n        // 1/(((c2 * T1 + c1 * T2) * v) + c0 * T0)\n        let t4 = Fp2.inv(Fp2.add(Fp2.mulByNonresidue(Fp2.add(Fp2.mul(c2, t1), Fp2.mul(c1, t2))), Fp2.mul(c0, t0)));\n        return { c0: Fp2.mul(t4, t0), c1: Fp2.mul(t4, t1), c2: Fp2.mul(t4, t2) };\n    },\n    // Bytes utils\n    fromBytes: (b) => {\n        if (b.length !== Fp6.BYTES)\n            throw new Error(`fromBytes wrong length=${b.length}`);\n        return {\n            c0: Fp2.fromBytes(b.subarray(0, Fp2.BYTES)),\n            c1: Fp2.fromBytes(b.subarray(Fp2.BYTES, 2 * Fp2.BYTES)),\n            c2: Fp2.fromBytes(b.subarray(2 * Fp2.BYTES)),\n        };\n    },\n    toBytes: ({ c0, c1, c2 }) => (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(Fp2.toBytes(c0), Fp2.toBytes(c1), Fp2.toBytes(c2)),\n    cmov: ({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r2 }, c) => ({\n        c0: Fp2.cmov(c0, r0, c),\n        c1: Fp2.cmov(c1, r1, c),\n        c2: Fp2.cmov(c2, r2, c),\n    }),\n    // Utils\n    //   fromTriple(triple: [Fp2, Fp2, Fp2]) {\n    //     return new Fp6(...triple);\n    //   }\n    //   toString() {\n    //     return `Fp6(${this.c0} + ${this.c1} * v, ${this.c2} * v^2)`;\n    //   }\n    fromBigSix: (t) => {\n        if (!Array.isArray(t) || t.length !== 6)\n            throw new Error('Invalid Fp6 usage');\n        return {\n            c0: Fp2.fromBigTuple(t.slice(0, 2)),\n            c1: Fp2.fromBigTuple(t.slice(2, 4)),\n            c2: Fp2.fromBigTuple(t.slice(4, 6)),\n        };\n    },\n    frobeniusMap: ({ c0, c1, c2 }, power) => ({\n        c0: Fp2.frobeniusMap(c0, power),\n        c1: Fp2.mul(Fp2.frobeniusMap(c1, power), FP6_FROBENIUS_COEFFICIENTS_1[power % 6]),\n        c2: Fp2.mul(Fp2.frobeniusMap(c2, power), FP6_FROBENIUS_COEFFICIENTS_2[power % 6]),\n    }),\n    mulByNonresidue: ({ c0, c1, c2 }) => ({ c0: Fp2.mulByNonresidue(c2), c1: c0, c2: c1 }),\n    // Sparse multiplication\n    multiplyBy1: ({ c0, c1, c2 }, b1) => ({\n        c0: Fp2.mulByNonresidue(Fp2.mul(c2, b1)),\n        c1: Fp2.mul(c0, b1),\n        c2: Fp2.mul(c1, b1),\n    }),\n    // Sparse multiplication\n    multiplyBy01({ c0, c1, c2 }, b0, b1) {\n        let t0 = Fp2.mul(c0, b0); // c0 * b0\n        let t1 = Fp2.mul(c1, b1); // c1 * b1\n        return {\n            // ((c1 + c2) * b1 - T1) * (u + 1) + T0\n            c0: Fp2.add(Fp2.mulByNonresidue(Fp2.sub(Fp2.mul(Fp2.add(c1, c2), b1), t1)), t0),\n            // (b0 + b1) * (c0 + c1) - T0 - T1\n            c1: Fp2.sub(Fp2.sub(Fp2.mul(Fp2.add(b0, b1), Fp2.add(c0, c1)), t0), t1),\n            // (c0 + c2) * b0 - T0 + T1\n            c2: Fp2.add(Fp2.sub(Fp2.mul(Fp2.add(c0, c2), b0), t0), t1),\n        };\n    },\n    multiplyByFp2: ({ c0, c1, c2 }, rhs) => ({\n        c0: Fp2.mul(c0, rhs),\n        c1: Fp2.mul(c1, rhs),\n        c2: Fp2.mul(c2, rhs),\n    }),\n};\nconst FP6_FROBENIUS_COEFFICIENTS_1 = [\n    [BigInt('0x1'), BigInt('0x0')],\n    [\n        BigInt('0x0'),\n        BigInt('0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac'),\n    ],\n    [\n        BigInt('0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe'),\n        BigInt('0x0'),\n    ],\n    [BigInt('0x0'), BigInt('0x1')],\n    [\n        BigInt('0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac'),\n        BigInt('0x0'),\n    ],\n    [\n        BigInt('0x0'),\n        BigInt('0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe'),\n    ],\n].map((pair) => Fp2.fromBigTuple(pair));\nconst FP6_FROBENIUS_COEFFICIENTS_2 = [\n    [BigInt('0x1'), BigInt('0x0')],\n    [\n        BigInt('0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaad'),\n        BigInt('0x0'),\n    ],\n    [\n        BigInt('0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac'),\n        BigInt('0x0'),\n    ],\n    [\n        BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaaa'),\n        BigInt('0x0'),\n    ],\n    [\n        BigInt('0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe'),\n        BigInt('0x0'),\n    ],\n    [\n        BigInt('0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffeffff'),\n        BigInt('0x0'),\n    ],\n].map((pair) => Fp2.fromBigTuple(pair));\n// The BLS parameter x for BLS12-381\nconst BLS_X = BigInt('0xd201000000010000');\nconst BLS_X_LEN = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitLen)(BLS_X);\nconst Fp12Add = ({ c0, c1 }, { c0: r0, c1: r1 }) => ({\n    c0: Fp6.add(c0, r0),\n    c1: Fp6.add(c1, r1),\n});\nconst Fp12Subtract = ({ c0, c1 }, { c0: r0, c1: r1 }) => ({\n    c0: Fp6.sub(c0, r0),\n    c1: Fp6.sub(c1, r1),\n});\nconst Fp12Multiply = ({ c0, c1 }, rhs) => {\n    if (typeof rhs === 'bigint')\n        return { c0: Fp6.mul(c0, rhs), c1: Fp6.mul(c1, rhs) };\n    let { c0: r0, c1: r1 } = rhs;\n    let t1 = Fp6.mul(c0, r0); // c0 * r0\n    let t2 = Fp6.mul(c1, r1); // c1 * r1\n    return {\n        c0: Fp6.add(t1, Fp6.mulByNonresidue(t2)), // T1 + T2 * v\n        // (c0 + c1) * (r0 + r1) - (T1 + T2)\n        c1: Fp6.sub(Fp6.mul(Fp6.add(c0, c1), Fp6.add(r0, r1)), Fp6.add(t1, t2)),\n    };\n};\nconst Fp12Square = ({ c0, c1 }) => {\n    let ab = Fp6.mul(c0, c1); // c0 * c1\n    return {\n        // (c1 * v + c0) * (c0 + c1) - AB - AB * v\n        c0: Fp6.sub(Fp6.sub(Fp6.mul(Fp6.add(Fp6.mulByNonresidue(c1), c0), Fp6.add(c0, c1)), ab), Fp6.mulByNonresidue(ab)),\n        c1: Fp6.add(ab, ab),\n    }; // AB + AB\n};\nfunction Fp4Square(a, b) {\n    const a2 = Fp2.sqr(a);\n    const b2 = Fp2.sqr(b);\n    return {\n        first: Fp2.add(Fp2.mulByNonresidue(b2), a2), // b * Nonresidue + a\n        second: Fp2.sub(Fp2.sub(Fp2.sqr(Fp2.add(a, b)), a2), b2), // (a + b) - a - b\n    };\n}\nconst Fp12 = {\n    ORDER: Fp2.ORDER, // TODO: unused, but need to verify\n    BITS: 2 * Fp2.BITS,\n    BYTES: 2 * Fp2.BYTES,\n    MASK: (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask)(2 * Fp2.BITS),\n    ZERO: { c0: Fp6.ZERO, c1: Fp6.ZERO },\n    ONE: { c0: Fp6.ONE, c1: Fp6.ZERO },\n    create: (num) => num,\n    isValid: ({ c0, c1 }) => Fp6.isValid(c0) && Fp6.isValid(c1),\n    is0: ({ c0, c1 }) => Fp6.is0(c0) && Fp6.is0(c1),\n    neg: ({ c0, c1 }) => ({ c0: Fp6.neg(c0), c1: Fp6.neg(c1) }),\n    eql: ({ c0, c1 }, { c0: r0, c1: r1 }) => Fp6.eql(c0, r0) && Fp6.eql(c1, r1),\n    sqrt: () => {\n        throw new Error('Not implemented');\n    },\n    inv: ({ c0, c1 }) => {\n        let t = Fp6.inv(Fp6.sub(Fp6.sqr(c0), Fp6.mulByNonresidue(Fp6.sqr(c1)))); // 1 / (c0 - c1 * v)\n        return { c0: Fp6.mul(c0, t), c1: Fp6.neg(Fp6.mul(c1, t)) }; // ((C0 * T) * T) + (-C1 * T) * w\n    },\n    div: (lhs, rhs) => Fp12.mul(lhs, typeof rhs === 'bigint' ? Fp.inv(Fp.create(rhs)) : Fp12.inv(rhs)),\n    pow: (num, power) => _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.FpPow(Fp12, num, power),\n    invertBatch: (nums) => _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.FpInvertBatch(Fp12, nums),\n    // Normalized\n    add: Fp12Add,\n    sub: Fp12Subtract,\n    mul: Fp12Multiply,\n    sqr: Fp12Square,\n    // NonNormalized stuff\n    addN: Fp12Add,\n    subN: Fp12Subtract,\n    mulN: Fp12Multiply,\n    sqrN: Fp12Square,\n    // Bytes utils\n    fromBytes: (b) => {\n        if (b.length !== Fp12.BYTES)\n            throw new Error(`fromBytes wrong length=${b.length}`);\n        return {\n            c0: Fp6.fromBytes(b.subarray(0, Fp6.BYTES)),\n            c1: Fp6.fromBytes(b.subarray(Fp6.BYTES)),\n        };\n    },\n    toBytes: ({ c0, c1 }) => (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(Fp6.toBytes(c0), Fp6.toBytes(c1)),\n    cmov: ({ c0, c1 }, { c0: r0, c1: r1 }, c) => ({\n        c0: Fp6.cmov(c0, r0, c),\n        c1: Fp6.cmov(c1, r1, c),\n    }),\n    // Utils\n    // toString() {\n    //   return `Fp12(${this.c0} + ${this.c1} * w)`;\n    // },\n    // fromTuple(c: [Fp6, Fp6]) {\n    //   return new Fp12(...c);\n    // }\n    fromBigTwelve: (t) => ({\n        c0: Fp6.fromBigSix(t.slice(0, 6)),\n        c1: Fp6.fromBigSix(t.slice(6, 12)),\n    }),\n    // Raises to q**i -th power\n    frobeniusMap(lhs, power) {\n        const r0 = Fp6.frobeniusMap(lhs.c0, power);\n        const { c0, c1, c2 } = Fp6.frobeniusMap(lhs.c1, power);\n        const coeff = FP12_FROBENIUS_COEFFICIENTS[power % 12];\n        return {\n            c0: r0,\n            c1: Fp6.create({\n                c0: Fp2.mul(c0, coeff),\n                c1: Fp2.mul(c1, coeff),\n                c2: Fp2.mul(c2, coeff),\n            }),\n        };\n    },\n    // Sparse multiplication\n    multiplyBy014: ({ c0, c1 }, o0, o1, o4) => {\n        let t0 = Fp6.multiplyBy01(c0, o0, o1);\n        let t1 = Fp6.multiplyBy1(c1, o4);\n        return {\n            c0: Fp6.add(Fp6.mulByNonresidue(t1), t0), // T1 * v + T0\n            // (c1 + c0) * [o0, o1+o4] - T0 - T1\n            c1: Fp6.sub(Fp6.sub(Fp6.multiplyBy01(Fp6.add(c1, c0), o0, Fp2.add(o1, o4)), t0), t1),\n        };\n    },\n    multiplyByFp2: ({ c0, c1 }, rhs) => ({\n        c0: Fp6.multiplyByFp2(c0, rhs),\n        c1: Fp6.multiplyByFp2(c1, rhs),\n    }),\n    conjugate: ({ c0, c1 }) => ({ c0, c1: Fp6.neg(c1) }),\n    // A cyclotomic group is a subgroup of Fp^n defined by\n    //   G(p) = {  Fp : ^(p) = 1}\n    // The result of any pairing is in a cyclotomic subgroup\n    // https://eprint.iacr.org/2009/565.pdf\n    _cyclotomicSquare: ({ c0, c1 }) => {\n        const { c0: c0c0, c1: c0c1, c2: c0c2 } = c0;\n        const { c0: c1c0, c1: c1c1, c2: c1c2 } = c1;\n        const { first: t3, second: t4 } = Fp4Square(c0c0, c1c1);\n        const { first: t5, second: t6 } = Fp4Square(c1c0, c0c2);\n        const { first: t7, second: t8 } = Fp4Square(c0c1, c1c2);\n        let t9 = Fp2.mulByNonresidue(t8); // T8 * (u + 1)\n        return {\n            c0: Fp6.create({\n                c0: Fp2.add(Fp2.mul(Fp2.sub(t3, c0c0), _2n), t3), // 2 * (T3 - c0c0)  + T3\n                c1: Fp2.add(Fp2.mul(Fp2.sub(t5, c0c1), _2n), t5), // 2 * (T5 - c0c1)  + T5\n                c2: Fp2.add(Fp2.mul(Fp2.sub(t7, c0c2), _2n), t7),\n            }), // 2 * (T7 - c0c2)  + T7\n            c1: Fp6.create({\n                c0: Fp2.add(Fp2.mul(Fp2.add(t9, c1c0), _2n), t9), // 2 * (T9 + c1c0) + T9\n                c1: Fp2.add(Fp2.mul(Fp2.add(t4, c1c1), _2n), t4), // 2 * (T4 + c1c1) + T4\n                c2: Fp2.add(Fp2.mul(Fp2.add(t6, c1c2), _2n), t6),\n            }),\n        }; // 2 * (T6 + c1c2) + T6\n    },\n    _cyclotomicExp(num, n) {\n        let z = Fp12.ONE;\n        for (let i = BLS_X_LEN - 1; i >= 0; i--) {\n            z = Fp12._cyclotomicSquare(z);\n            if ((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitGet)(n, i))\n                z = Fp12.mul(z, num);\n        }\n        return z;\n    },\n    // https://eprint.iacr.org/2010/354.pdf\n    // https://eprint.iacr.org/2009/565.pdf\n    finalExponentiate: (num) => {\n        const x = BLS_X;\n        // this^(q) / this\n        const t0 = Fp12.div(Fp12.frobeniusMap(num, 6), num);\n        // t0^(q) * t0\n        const t1 = Fp12.mul(Fp12.frobeniusMap(t0, 2), t0);\n        const t2 = Fp12.conjugate(Fp12._cyclotomicExp(t1, x));\n        const t3 = Fp12.mul(Fp12.conjugate(Fp12._cyclotomicSquare(t1)), t2);\n        const t4 = Fp12.conjugate(Fp12._cyclotomicExp(t3, x));\n        const t5 = Fp12.conjugate(Fp12._cyclotomicExp(t4, x));\n        const t6 = Fp12.mul(Fp12.conjugate(Fp12._cyclotomicExp(t5, x)), Fp12._cyclotomicSquare(t2));\n        const t7 = Fp12.conjugate(Fp12._cyclotomicExp(t6, x));\n        const t2_t5_pow_q2 = Fp12.frobeniusMap(Fp12.mul(t2, t5), 2);\n        const t4_t1_pow_q3 = Fp12.frobeniusMap(Fp12.mul(t4, t1), 3);\n        const t6_t1c_pow_q1 = Fp12.frobeniusMap(Fp12.mul(t6, Fp12.conjugate(t1)), 1);\n        const t7_t3c_t1 = Fp12.mul(Fp12.mul(t7, Fp12.conjugate(t3)), t1);\n        // (t2 * t5)^(q) * (t4 * t1)^(q) * (t6 * t1.conj)^(q^1) * t7 * t3.conj * t1\n        return Fp12.mul(Fp12.mul(Fp12.mul(t2_t5_pow_q2, t4_t1_pow_q3), t6_t1c_pow_q1), t7_t3c_t1);\n    },\n};\nconst FP12_FROBENIUS_COEFFICIENTS = [\n    [BigInt('0x1'), BigInt('0x0')],\n    [\n        BigInt('0x1904d3bf02bb0667c231beb4202c0d1f0fd603fd3cbd5f4f7b2443d784bab9c4f67ea53d63e7813d8d0775ed92235fb8'),\n        BigInt('0x00fc3e2b36c4e03288e9e902231f9fb854a14787b6c7b36fec0c8ec971f63c5f282d5ac14d6c7ec22cf78a126ddc4af3'),\n    ],\n    [\n        BigInt('0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffeffff'),\n        BigInt('0x0'),\n    ],\n    [\n        BigInt('0x135203e60180a68ee2e9c448d77a2cd91c3dedd930b1cf60ef396489f61eb45e304466cf3e67fa0af1ee7b04121bdea2'),\n        BigInt('0x06af0e0437ff400b6831e36d6bd17ffe48395dabc2d3435e77f76e17009241c5ee67992f72ec05f4c81084fbede3cc09'),\n    ],\n    [\n        BigInt('0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe'),\n        BigInt('0x0'),\n    ],\n    [\n        BigInt('0x144e4211384586c16bd3ad4afa99cc9170df3560e77982d0db45f3536814f0bd5871c1908bd478cd1ee605167ff82995'),\n        BigInt('0x05b2cfd9013a5fd8df47fa6b48b1e045f39816240c0b8fee8beadf4d8e9c0566c63a3e6e257f87329b18fae980078116'),\n    ],\n    [\n        BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaaa'),\n        BigInt('0x0'),\n    ],\n    [\n        BigInt('0x00fc3e2b36c4e03288e9e902231f9fb854a14787b6c7b36fec0c8ec971f63c5f282d5ac14d6c7ec22cf78a126ddc4af3'),\n        BigInt('0x1904d3bf02bb0667c231beb4202c0d1f0fd603fd3cbd5f4f7b2443d784bab9c4f67ea53d63e7813d8d0775ed92235fb8'),\n    ],\n    [\n        BigInt('0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac'),\n        BigInt('0x0'),\n    ],\n    [\n        BigInt('0x06af0e0437ff400b6831e36d6bd17ffe48395dabc2d3435e77f76e17009241c5ee67992f72ec05f4c81084fbede3cc09'),\n        BigInt('0x135203e60180a68ee2e9c448d77a2cd91c3dedd930b1cf60ef396489f61eb45e304466cf3e67fa0af1ee7b04121bdea2'),\n    ],\n    [\n        BigInt('0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaad'),\n        BigInt('0x0'),\n    ],\n    [\n        BigInt('0x05b2cfd9013a5fd8df47fa6b48b1e045f39816240c0b8fee8beadf4d8e9c0566c63a3e6e257f87329b18fae980078116'),\n        BigInt('0x144e4211384586c16bd3ad4afa99cc9170df3560e77982d0db45f3536814f0bd5871c1908bd478cd1ee605167ff82995'),\n    ],\n].map((n) => Fp2.fromBigTuple(n));\n// END OF CURVE FIELDS\n// HashToCurve\n// 3-isogeny map from E' to E https://www.rfc-editor.org/rfc/rfc9380#appendix-E.3\nconst isogenyMapG2 = (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_2__.isogenyMap)(Fp2, [\n    // xNum\n    [\n        [\n            '0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6',\n            '0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6',\n        ],\n        [\n            '0x0',\n            '0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71a',\n        ],\n        [\n            '0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71e',\n            '0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38d',\n        ],\n        [\n            '0x171d6541fa38ccfaed6dea691f5fb614cb14b4e7f4e810aa22d6108f142b85757098e38d0f671c7188e2aaaaaaaa5ed1',\n            '0x0',\n        ],\n    ],\n    // xDen\n    [\n        [\n            '0x0',\n            '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa63',\n        ],\n        [\n            '0xc',\n            '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa9f',\n        ],\n        ['0x1', '0x0'], // LAST 1\n    ],\n    // yNum\n    [\n        [\n            '0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706',\n            '0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706',\n        ],\n        [\n            '0x0',\n            '0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97be',\n        ],\n        [\n            '0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71c',\n            '0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38f',\n        ],\n        [\n            '0x124c9ad43b6cf79bfbf7043de3811ad0761b0f37a1e26286b0e977c69aa274524e79097a56dc4bd9e1b371c71c718b10',\n            '0x0',\n        ],\n    ],\n    // yDen\n    [\n        [\n            '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb',\n            '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb',\n        ],\n        [\n            '0x0',\n            '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa9d3',\n        ],\n        [\n            '0x12',\n            '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa99',\n        ],\n        ['0x1', '0x0'], // LAST 1\n    ],\n].map((i) => i.map((pair) => Fp2.fromBigTuple(pair.map(BigInt)))));\n// 11-isogeny map from E' to E\nconst isogenyMapG1 = (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_2__.isogenyMap)(Fp, [\n    // xNum\n    [\n        '0x11a05f2b1e833340b809101dd99815856b303e88a2d7005ff2627b56cdb4e2c85610c2d5f2e62d6eaeac1662734649b7',\n        '0x17294ed3e943ab2f0588bab22147a81c7c17e75b2f6a8417f565e33c70d1e86b4838f2a6f318c356e834eef1b3cb83bb',\n        '0xd54005db97678ec1d1048c5d10a9a1bce032473295983e56878e501ec68e25c958c3e3d2a09729fe0179f9dac9edcb0',\n        '0x1778e7166fcc6db74e0609d307e55412d7f5e4656a8dbf25f1b33289f1b330835336e25ce3107193c5b388641d9b6861',\n        '0xe99726a3199f4436642b4b3e4118e5499db995a1257fb3f086eeb65982fac18985a286f301e77c451154ce9ac8895d9',\n        '0x1630c3250d7313ff01d1201bf7a74ab5db3cb17dd952799b9ed3ab9097e68f90a0870d2dcae73d19cd13c1c66f652983',\n        '0xd6ed6553fe44d296a3726c38ae652bfb11586264f0f8ce19008e218f9c86b2a8da25128c1052ecaddd7f225a139ed84',\n        '0x17b81e7701abdbe2e8743884d1117e53356de5ab275b4db1a682c62ef0f2753339b7c8f8c8f475af9ccb5618e3f0c88e',\n        '0x80d3cf1f9a78fc47b90b33563be990dc43b756ce79f5574a2c596c928c5d1de4fa295f296b74e956d71986a8497e317',\n        '0x169b1f8e1bcfa7c42e0c37515d138f22dd2ecb803a0c5c99676314baf4bb1b7fa3190b2edc0327797f241067be390c9e',\n        '0x10321da079ce07e272d8ec09d2565b0dfa7dccdde6787f96d50af36003b14866f69b771f8c285decca67df3f1605fb7b',\n        '0x6e08c248e260e70bd1e962381edee3d31d79d7e22c837bc23c0bf1bc24c6b68c24b1b80b64d391fa9c8ba2e8ba2d229',\n    ],\n    // xDen\n    [\n        '0x8ca8d548cff19ae18b2e62f4bd3fa6f01d5ef4ba35b48ba9c9588617fc8ac62b558d681be343df8993cf9fa40d21b1c',\n        '0x12561a5deb559c4348b4711298e536367041e8ca0cf0800c0126c2588c48bf5713daa8846cb026e9e5c8276ec82b3bff',\n        '0xb2962fe57a3225e8137e629bff2991f6f89416f5a718cd1fca64e00b11aceacd6a3d0967c94fedcfcc239ba5cb83e19',\n        '0x3425581a58ae2fec83aafef7c40eb545b08243f16b1655154cca8abc28d6fd04976d5243eecf5c4130de8938dc62cd8',\n        '0x13a8e162022914a80a6f1d5f43e7a07dffdfc759a12062bb8d6b44e833b306da9bd29ba81f35781d539d395b3532a21e',\n        '0xe7355f8e4e667b955390f7f0506c6e9395735e9ce9cad4d0a43bcef24b8982f7400d24bc4228f11c02df9a29f6304a5',\n        '0x772caacf16936190f3e0c63e0596721570f5799af53a1894e2e073062aede9cea73b3538f0de06cec2574496ee84a3a',\n        '0x14a7ac2a9d64a8b230b3f5b074cf01996e7f63c21bca68a81996e1cdf9822c580fa5b9489d11e2d311f7d99bbdcc5a5e',\n        '0xa10ecf6ada54f825e920b3dafc7a3cce07f8d1d7161366b74100da67f39883503826692abba43704776ec3a79a1d641',\n        '0x95fc13ab9e92ad4476d6e3eb3a56680f682b4ee96f7d03776df533978f31c1593174e4b4b7865002d6384d168ecdd0a',\n        '0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x90d97c81ba24ee0259d1f094980dcfa11ad138e48a869522b52af6c956543d3cd0c7aee9b3ba3c2be9845719707bb33',\n        '0x134996a104ee5811d51036d776fb46831223e96c254f383d0f906343eb67ad34d6c56711962fa8bfe097e75a2e41c696',\n        '0xcc786baa966e66f4a384c86a3b49942552e2d658a31ce2c344be4b91400da7d26d521628b00523b8dfe240c72de1f6',\n        '0x1f86376e8981c217898751ad8746757d42aa7b90eeb791c09e4a3ec03251cf9de405aba9ec61deca6355c77b0e5f4cb',\n        '0x8cc03fdefe0ff135caf4fe2a21529c4195536fbe3ce50b879833fd221351adc2ee7f8dc099040a841b6daecf2e8fedb',\n        '0x16603fca40634b6a2211e11db8f0a6a074a7d0d4afadb7bd76505c3d3ad5544e203f6326c95a807299b23ab13633a5f0',\n        '0x4ab0b9bcfac1bbcb2c977d027796b3ce75bb8ca2be184cb5231413c4d634f3747a87ac2460f415ec961f8855fe9d6f2',\n        '0x987c8d5333ab86fde9926bd2ca6c674170a05bfe3bdd81ffd038da6c26c842642f64550fedfe935a15e4ca31870fb29',\n        '0x9fc4018bd96684be88c9e221e4da1bb8f3abd16679dc26c1e8b6e6a1f20cabe69d65201c78607a360370e577bdba587',\n        '0xe1bba7a1186bdb5223abde7ada14a23c42a0ca7915af6fe06985e7ed1e4d43b9b3f7055dd4eba6f2bafaaebca731c30',\n        '0x19713e47937cd1be0dfd0b8f1d43fb93cd2fcbcb6caf493fd1183e416389e61031bf3a5cce3fbafce813711ad011c132',\n        '0x18b46a908f36f6deb918c143fed2edcc523559b8aaf0c2462e6bfe7f911f643249d9cdf41b44d606ce07c8a4d0074d8e',\n        '0xb182cac101b9399d155096004f53f447aa7b12a3426b08ec02710e807b4633f06c851c1919211f20d4c04f00b971ef8',\n        '0x245a394ad1eca9b72fc00ae7be315dc757b3b080d4c158013e6632d3c40659cc6cf90ad1c232a6442d9d3f5db980133',\n        '0x5c129645e44cf1102a159f748c4a3fc5e673d81d7e86568d9ab0f5d396a7ce46ba1049b6579afb7866b1e715475224b',\n        '0x15e6be4e990f03ce4ea50b3b42df2eb5cb181d8f84965a3957add4fa95af01b2b665027efec01c7704b456be69c8b604',\n    ],\n    // yDen\n    [\n        '0x16112c4c3a9c98b252181140fad0eae9601a6de578980be6eec3232b5be72e7a07f3688ef60c206d01479253b03663c1',\n        '0x1962d75c2381201e1a0cbd6c43c348b885c84ff731c4d59ca4a10356f453e01f78a4260763529e3532f6102c2e49a03d',\n        '0x58df3306640da276faaae7d6e8eb15778c4855551ae7f310c35a5dd279cd2eca6757cd636f96f891e2538b53dbf67f2',\n        '0x16b7d288798e5395f20d23bf89edb4d1d115c5dbddbcd30e123da489e726af41727364f2c28297ada8d26d98445f5416',\n        '0xbe0e079545f43e4b00cc912f8228ddcc6d19c9f0f69bbb0542eda0fc9dec916a20b15dc0fd2ededda39142311a5001d',\n        '0x8d9e5297186db2d9fb266eaac783182b70152c65550d881c5ecd87b6f0f5a6449f38db9dfa9cce202c6477faaf9b7ac',\n        '0x166007c08a99db2fc3ba8734ace9824b5eecfdfa8d0cf8ef5dd365bc400a0051d5fa9c01a58b1fb93d1a1399126a775c',\n        '0x16a3ef08be3ea7ea03bcddfabba6ff6ee5a4375efa1f4fd7feb34fd206357132b920f5b00801dee460ee415a15812ed9',\n        '0x1866c8ed336c61231a1be54fd1d74cc4f9fb0ce4c6af5920abc5750c4bf39b4852cfe2f7bb9248836b233d9d55535d4a',\n        '0x167a55cda70a6e1cea820597d94a84903216f763e13d87bb5308592e7ea7d4fbc7385ea3d529b35e346ef48bb8913f55',\n        '0x4d2f259eea405bd48f010a01ad2911d9c6dd039bb61a6290e591b36e636a5c871a5c29f4f83060400f8b49cba8f6aa8',\n        '0xaccbb67481d033ff5852c1e48c50c477f94ff8aefce42d28c0f9a88cea7913516f968986f7ebbea9684b529e2561092',\n        '0xad6b9514c767fe3c3613144b45f1496543346d98adf02267d5ceef9a00d9b8693000763e3b90ac11e99b138573345cc',\n        '0x2660400eb2e4f3b628bdd0d53cd76f2bf565b94e72927c1cb748df27942480e420517bd8714cc80d1fadc1326ed06f7',\n        '0xe0fa1d816ddc03e6b24255e0d7819c171c40f65e273b853324efcd6356caa205ca2f570f13497804415473a1d634b8f',\n        '0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j))));\n// SWU Map - Fp2 to G2': y = x + 240i * x + 1012 + 1012i\nconst G2_SWU = (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_3__.mapToCurveSimpleSWU)(Fp2, {\n    A: Fp2.create({ c0: Fp.create(_0n), c1: Fp.create(BigInt(240)) }), // A' = 240 * I\n    B: Fp2.create({ c0: Fp.create(BigInt(1012)), c1: Fp.create(BigInt(1012)) }), // B' = 1012 * (1 + I)\n    Z: Fp2.create({ c0: Fp.create(BigInt(-2)), c1: Fp.create(BigInt(-1)) }), // Z: -(2 + I)\n});\n// Optimized SWU Map - Fp to G1\nconst G1_SWU = (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_3__.mapToCurveSimpleSWU)(Fp, {\n    A: Fp.create(BigInt('0x144698a3b8e9433d693a02c96d4982b0ea985383ee66a8d8e8981aefd881ac98936f8da0e0f97f5cf428082d584c1d')),\n    B: Fp.create(BigInt('0x12e2908d11688030018b12e8753eee3b2016c1f0f24f4070a0b9c14fcef35ef55a23215a316ceaa5d1cc48e98e172be0')),\n    Z: Fp.create(BigInt(11)),\n});\n// Endomorphisms (for fast cofactor clearing)\n// (P) endomorphism\nconst ut_root = Fp6.create({ c0: Fp2.ZERO, c1: Fp2.ONE, c2: Fp2.ZERO });\nconst wsq = Fp12.create({ c0: ut_root, c1: Fp6.ZERO });\nconst wcu = Fp12.create({ c0: Fp6.ZERO, c1: ut_root });\nconst [wsq_inv, wcu_inv] = Fp12.invertBatch([wsq, wcu]);\nfunction psi(x, y) {\n    // Untwist Fp2->Fp12 && frobenius(1) && twist back\n    const x2 = Fp12.mul(Fp12.frobeniusMap(Fp12.multiplyByFp2(wsq_inv, x), 1), wsq).c0.c0;\n    const y2 = Fp12.mul(Fp12.frobeniusMap(Fp12.multiplyByFp2(wcu_inv, y), 1), wcu).c0.c0;\n    return [x2, y2];\n}\n//  endomorphism\nfunction G2psi(c, P) {\n    const affine = P.toAffine();\n    const p = psi(affine.x, affine.y);\n    return new c(p[0], p[1], Fp2.ONE);\n}\n// (P) endomorphism\n// 1 / F2(2)^((p-1)/3) in GF(p)\nconst PSI2_C1 = BigInt('0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac');\nfunction psi2(x, y) {\n    return [Fp2.mul(x, PSI2_C1), Fp2.neg(y)];\n}\nfunction G2psi2(c, P) {\n    const affine = P.toAffine();\n    const p = psi2(affine.x, affine.y);\n    return new c(p[0], p[1], Fp2.ONE);\n}\n// Default hash_to_field options are for hash to G2.\n//\n// Parameter definitions are in section 5.3 of the spec unless otherwise noted.\n// Parameter values come from section 8.8.2 of the spec.\n// https://www.rfc-editor.org/rfc/rfc9380#section-8.8.2\n//\n// Base field F is GF(p^m)\n// p = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\n// m = 2 (or 1 for G1 see section 8.8.1)\n// k = 128\nconst htfDefaults = Object.freeze({\n    // DST: a domain separation tag\n    // defined in section 2.2.5\n    // Use utils.getDSTLabel(), utils.setDSTLabel(value)\n    DST: 'BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_',\n    encodeDST: 'BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_',\n    // p: the characteristic of F\n    //    where F is a finite field of characteristic p and order q = p^m\n    p: Fp.ORDER,\n    // m: the extension degree of F, m >= 1\n    //     where F is a finite field of characteristic p and order q = p^m\n    m: 2,\n    // k: the target security level for the suite in bits\n    // defined in section 5.1\n    k: 128,\n    // option to use a message that has already been processed by\n    // expand_message_xmd\n    expand: 'xmd',\n    // Hash functions for: expand_message_xmd is appropriate for use with a\n    // wide range of hash functions, including SHA-2, SHA-3, BLAKE2, and others.\n    // BBS+ uses blake2: https://github.com/hyperledger/aries-framework-go/issues/2247\n    hash: _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256,\n});\n// Encoding utils\n// Point on G1 curve: (x, y)\n// Compressed point of infinity\nconst COMPRESSED_ZERO = setMask(Fp.toBytes(_0n), { infinity: true, compressed: true }); // set compressed & point-at-infinity bits\nfunction parseMask(bytes) {\n    // Copy, so we can remove mask data. It will be removed also later, when Fp.create will call modulo.\n    bytes = bytes.slice();\n    const mask = bytes[0] & 224;\n    const compressed = !!((mask >> 7) & 1); // compression bit (0b1000_0000)\n    const infinity = !!((mask >> 6) & 1); // point at infinity bit (0b0100_0000)\n    const sort = !!((mask >> 5) & 1); // sort bit (0b0010_0000)\n    bytes[0] &= 31; // clear mask (zero first 3 bits)\n    return { compressed, infinity, sort, value: bytes };\n}\nfunction setMask(bytes, mask) {\n    if (bytes[0] & 224)\n        throw new Error('setMask: non-empty mask');\n    if (mask.compressed)\n        bytes[0] |= 128;\n    if (mask.infinity)\n        bytes[0] |= 64;\n    if (mask.sort)\n        bytes[0] |= 32;\n    return bytes;\n}\nfunction signatureG1ToRawBytes(point) {\n    point.assertValidity();\n    const isZero = point.equals(bls12_381.G1.ProjectivePoint.ZERO);\n    const { x, y } = point.toAffine();\n    if (isZero)\n        return COMPRESSED_ZERO.slice();\n    const P = Fp.ORDER;\n    const sort = Boolean((y * _2n) / P);\n    return setMask((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE)(x, Fp.BYTES), { compressed: true, sort });\n}\nfunction signatureG2ToRawBytes(point) {\n    // NOTE: by some reasons it was missed in bls12-381, looks like bug\n    point.assertValidity();\n    const len = Fp.BYTES;\n    if (point.equals(bls12_381.G2.ProjectivePoint.ZERO))\n        return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(COMPRESSED_ZERO, (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE)(_0n, len));\n    const { x, y } = point.toAffine();\n    const { re: x0, im: x1 } = Fp2.reim(x);\n    const { re: y0, im: y1 } = Fp2.reim(y);\n    const tmp = y1 > _0n ? y1 * _2n : y0 * _2n;\n    const sort = Boolean((tmp / Fp.ORDER) & _1n);\n    const z2 = x0;\n    return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(setMask((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE)(x1, len), { sort, compressed: true }), (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE)(z2, len));\n}\n// To verify curve parameters, see pairing-friendly-curves spec:\n// https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-11\n// Basic math is done over finite fields over p.\n// More complicated math is done over polynominal extension fields.\n// To simplify calculations in Fp12, we construct extension tower:\n// Fp = Fp => Fp\n// Fp(u) / (u - ) where  = -1\n// Fp(v) / (v - ) where  = u + 1\n// Fp(w) / (w - ) where  = v\n// Here goes constants && point encoding format\nconst bls12_381 = (0,_abstract_bls_js__WEBPACK_IMPORTED_MODULE_5__.bls)({\n    // Fields\n    fields: {\n        Fp,\n        Fp2,\n        Fp6,\n        Fp12,\n        Fr,\n    },\n    // G1 is the order-q subgroup of E1(Fp) : y = x + 4, #E1(Fp) = h1q, where\n    // characteristic; z + (z - z + 1)(z - 1)/3\n    G1: {\n        Fp,\n        // cofactor; (z - 1)/3\n        h: BigInt('0x396c8c005555e1568c00aaab0000aaab'),\n        // generator's coordinates\n        // x = 3685416753713387016781088315183077757961620795782546409894578378688607592378376318836054947676345821548104185464507\n        // y = 1339506544944476473020471379941921221584933875938349620426543736416511423956333506472724655353366534992391756441569\n        Gx: BigInt('0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb'),\n        Gy: BigInt('0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1'),\n        a: Fp.ZERO,\n        b: _4n,\n        htfDefaults: { ...htfDefaults, m: 1, DST: 'BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_NUL_' },\n        wrapPrivateKey: true,\n        allowInfinityPoint: true,\n        // Checks is the point resides in prime-order subgroup.\n        // point.isTorsionFree() should return true for valid points\n        // It returns false for shitty points.\n        // https://eprint.iacr.org/2021/1130.pdf\n        isTorsionFree: (c, point) => {\n            //  endomorphism\n            const cubicRootOfUnityModP = BigInt('0x5f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe');\n            const phi = new c(Fp.mul(point.px, cubicRootOfUnityModP), point.py, point.pz);\n            // todo: unroll\n            const xP = point.multiplyUnsafe(bls12_381.params.x).negate(); // [x]P\n            const u2P = xP.multiplyUnsafe(bls12_381.params.x); // [u2]P\n            return u2P.equals(phi);\n            // https://eprint.iacr.org/2019/814.pdf\n            // (z  1)/3\n            // const c1 = BigInt('0x396c8c005555e1560000000055555555');\n            // const P = this;\n            // const S = P.sigma();\n            // const Q = S.double();\n            // const S2 = S.sigma();\n            // // [(z  1)/3](2(P)  P  (P))  (P) = O\n            // const left = Q.subtract(P).subtract(S2).multiplyUnsafe(c1);\n            // const C = left.subtract(S2);\n            // return C.isZero();\n        },\n        // Clear cofactor of G1\n        // https://eprint.iacr.org/2019/403\n        clearCofactor: (_c, point) => {\n            // return this.multiplyUnsafe(CURVE.h);\n            return point.multiplyUnsafe(bls12_381.params.x).add(point); // x*P + P\n        },\n        mapToCurve: (scalars) => {\n            const { x, y } = G1_SWU(Fp.create(scalars[0]));\n            return isogenyMapG1(x, y);\n        },\n        fromBytes: (bytes) => {\n            const { compressed, infinity, sort, value } = parseMask(bytes);\n            if (value.length === 48 && compressed) {\n                // TODO: Fp.bytes\n                const P = Fp.ORDER;\n                const compressedValue = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE)(value);\n                // Zero\n                const x = Fp.create(compressedValue & Fp.MASK);\n                if (infinity) {\n                    if (x !== _0n)\n                        throw new Error('G1: non-empty compressed point at infinity');\n                    return { x: _0n, y: _0n };\n                }\n                const right = Fp.add(Fp.pow(x, _3n), Fp.create(bls12_381.params.G1b)); // y = x + b\n                let y = Fp.sqrt(right);\n                if (!y)\n                    throw new Error('Invalid compressed G1 point');\n                if ((y * _2n) / P !== BigInt(sort))\n                    y = Fp.neg(y);\n                return { x: Fp.create(x), y: Fp.create(y) };\n            }\n            else if (value.length === 96 && !compressed) {\n                // Check if the infinity flag is set\n                const x = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE)(value.subarray(0, Fp.BYTES));\n                const y = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE)(value.subarray(Fp.BYTES));\n                if (infinity) {\n                    if (x !== _0n || y !== _0n)\n                        throw new Error('G1: non-empty point at infinity');\n                    return bls12_381.G1.ProjectivePoint.ZERO.toAffine();\n                }\n                return { x: Fp.create(x), y: Fp.create(y) };\n            }\n            else {\n                throw new Error('Invalid point G1, expected 48/96 bytes');\n            }\n        },\n        toBytes: (c, point, isCompressed) => {\n            const isZero = point.equals(c.ZERO);\n            const { x, y } = point.toAffine();\n            if (isCompressed) {\n                if (isZero)\n                    return COMPRESSED_ZERO.slice();\n                const P = Fp.ORDER;\n                const sort = Boolean((y * _2n) / P);\n                return setMask((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE)(x, Fp.BYTES), { compressed: true, sort });\n            }\n            else {\n                if (isZero) {\n                    // 2x PUBLIC_KEY_LENGTH\n                    const x = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(new Uint8Array([0x40]), new Uint8Array(2 * Fp.BYTES - 1));\n                    return x;\n                }\n                else {\n                    return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE)(x, Fp.BYTES), (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE)(y, Fp.BYTES));\n                }\n            }\n        },\n        ShortSignature: {\n            fromHex(hex) {\n                const { infinity, sort, value } = parseMask((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('signatureHex', hex, 48));\n                const P = Fp.ORDER;\n                const compressedValue = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE)(value);\n                // Zero\n                if (infinity)\n                    return bls12_381.G1.ProjectivePoint.ZERO;\n                const x = Fp.create(compressedValue & Fp.MASK);\n                const right = Fp.add(Fp.pow(x, _3n), Fp.create(bls12_381.params.G1b)); // y = x + b\n                let y = Fp.sqrt(right);\n                if (!y)\n                    throw new Error('Invalid compressed G1 point');\n                const aflag = BigInt(sort);\n                if ((y * _2n) / P !== aflag)\n                    y = Fp.neg(y);\n                const point = bls12_381.G1.ProjectivePoint.fromAffine({ x, y });\n                point.assertValidity();\n                return point;\n            },\n            toRawBytes(point) {\n                return signatureG1ToRawBytes(point);\n            },\n            toHex(point) {\n                return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex)(signatureG1ToRawBytes(point));\n            },\n        },\n    },\n    // G2 is the order-q subgroup of E2(Fp) : y = x+4(1+1),\n    // where Fp2 is Fp[1]/(x2+1). #E2(Fp2 ) = h2q, where\n    // G - 1\n    // h2q\n    G2: {\n        Fp: Fp2,\n        // cofactor\n        h: BigInt('0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5'),\n        Gx: Fp2.fromBigTuple([\n            BigInt('0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8'),\n            BigInt('0x13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e'),\n        ]),\n        // y =\n        // 927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582,\n        // 1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905\n        Gy: Fp2.fromBigTuple([\n            BigInt('0x0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801'),\n            BigInt('0x0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be'),\n        ]),\n        a: Fp2.ZERO,\n        b: Fp2.fromBigTuple([_4n, _4n]),\n        hEff: BigInt('0xbc69f08f2ee75b3584c6a0ea91b352888e2a8e9145ad7689986ff031508ffe1329c2f178731db956d82bf015d1212b02ec0ec69d7477c1ae954cbc06689f6a359894c0adebbf6b4e8020005aaa95551'),\n        htfDefaults: { ...htfDefaults },\n        wrapPrivateKey: true,\n        allowInfinityPoint: true,\n        mapToCurve: (scalars) => {\n            const { x, y } = G2_SWU(Fp2.fromBigTuple(scalars));\n            return isogenyMapG2(x, y);\n        },\n        // Checks is the point resides in prime-order subgroup.\n        // point.isTorsionFree() should return true for valid points\n        // It returns false for shitty points.\n        // https://eprint.iacr.org/2021/1130.pdf\n        isTorsionFree: (c, P) => {\n            return P.multiplyUnsafe(bls12_381.params.x).negate().equals(G2psi(c, P)); // (P) == [u](P)\n            // Older version: https://eprint.iacr.org/2019/814.pdf\n            // (P) => (P) => [z](P) where z = -x => [z](P) - (P) + P == O\n            // return P.psi2().psi().mulNegX().subtract(psi2).add(P).isZero();\n        },\n        // Maps the point into the prime-order subgroup G2.\n        // clear_cofactor_bls12381_g2 from cfrg-hash-to-curve-11\n        // https://eprint.iacr.org/2017/419.pdf\n        // prettier-ignore\n        clearCofactor: (c, P) => {\n            const x = bls12_381.params.x;\n            let t1 = P.multiplyUnsafe(x).negate(); // [-x]P\n            let t2 = G2psi(c, P); // (P)\n            let t3 = P.double(); // 2P\n            t3 = G2psi2(c, t3); // (2P)\n            t3 = t3.subtract(t2); // (2P) - (P)\n            t2 = t1.add(t2); // [-x]P + (P)\n            t2 = t2.multiplyUnsafe(x).negate(); // [x]P - [x](P)\n            t3 = t3.add(t2); // (2P) - (P) + [x]P - [x](P)\n            t3 = t3.subtract(t1); // (2P) - (P) + [x]P - [x](P) + [x]P\n            const Q = t3.subtract(P); // (2P) - (P) + [x]P - [x](P) + [x]P - 1P\n            return Q; // [x-x-1]P + [x-1](P) + (2P)\n        },\n        fromBytes: (bytes) => {\n            const { compressed, infinity, sort, value } = parseMask(bytes);\n            if ((!compressed && !infinity && sort) || // 00100000\n                (!compressed && infinity && sort) || // 01100000\n                (sort && infinity && compressed) // 11100000\n            ) {\n                throw new Error('Invalid encoding flag: ' + (bytes[0] & 224));\n            }\n            const L = Fp.BYTES;\n            const slc = (b, from, to) => (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE)(b.slice(from, to));\n            if (value.length === 96 && compressed) {\n                const b = bls12_381.params.G2b;\n                const P = Fp.ORDER;\n                if (infinity) {\n                    // check that all bytes are 0\n                    if (value.reduce((p, c) => (p !== 0 ? c + 1 : c), 0) > 0) {\n                        throw new Error('Invalid compressed G2 point');\n                    }\n                    return { x: Fp2.ZERO, y: Fp2.ZERO };\n                }\n                const x_1 = slc(value, 0, L);\n                const x_0 = slc(value, L, 2 * L);\n                const x = Fp2.create({ c0: Fp.create(x_0), c1: Fp.create(x_1) });\n                const right = Fp2.add(Fp2.pow(x, _3n), b); // y = x + 4 * (u+1) = x + b\n                let y = Fp2.sqrt(right);\n                const Y_bit = y.c1 === _0n ? (y.c0 * _2n) / P : (y.c1 * _2n) / P ? _1n : _0n;\n                y = sort && Y_bit > 0 ? y : Fp2.neg(y);\n                return { x, y };\n            }\n            else if (value.length === 192 && !compressed) {\n                if (infinity) {\n                    if (value.reduce((p, c) => (p !== 0 ? c + 1 : c), 0) > 0) {\n                        throw new Error('Invalid uncompressed G2 point');\n                    }\n                    return { x: Fp2.ZERO, y: Fp2.ZERO };\n                }\n                const x1 = slc(value, 0, L);\n                const x0 = slc(value, L, 2 * L);\n                const y1 = slc(value, 2 * L, 3 * L);\n                const y0 = slc(value, 3 * L, 4 * L);\n                return { x: Fp2.fromBigTuple([x0, x1]), y: Fp2.fromBigTuple([y0, y1]) };\n            }\n            else {\n                throw new Error('Invalid point G2, expected 96/192 bytes');\n            }\n        },\n        toBytes: (c, point, isCompressed) => {\n            const { BYTES: len, ORDER: P } = Fp;\n            const isZero = point.equals(c.ZERO);\n            const { x, y } = point.toAffine();\n            if (isCompressed) {\n                if (isZero)\n                    return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(COMPRESSED_ZERO, (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE)(_0n, len));\n                const flag = Boolean(y.c1 === _0n ? (y.c0 * _2n) / P : (y.c1 * _2n) / P);\n                return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(setMask((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE)(x.c1, len), { compressed: true, sort: flag }), (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE)(x.c0, len));\n            }\n            else {\n                if (isZero)\n                    return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(new Uint8Array([0x40]), new Uint8Array(4 * len - 1)); // bytes[0] |= 1 << 6;\n                const { re: x0, im: x1 } = Fp2.reim(x);\n                const { re: y0, im: y1 } = Fp2.reim(y);\n                return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE)(x1, len), (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE)(x0, len), (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE)(y1, len), (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE)(y0, len));\n            }\n        },\n        Signature: {\n            // TODO: Optimize, it's very slow because of sqrt.\n            fromHex(hex) {\n                const { infinity, sort, value } = parseMask((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('signatureHex', hex));\n                const P = Fp.ORDER;\n                const half = value.length / 2;\n                if (half !== 48 && half !== 96)\n                    throw new Error('Invalid compressed signature length, must be 96 or 192');\n                const z1 = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE)(value.slice(0, half));\n                const z2 = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE)(value.slice(half));\n                // Indicates the infinity point\n                if (infinity)\n                    return bls12_381.G2.ProjectivePoint.ZERO;\n                const x1 = Fp.create(z1 & Fp.MASK);\n                const x2 = Fp.create(z2);\n                const x = Fp2.create({ c0: x2, c1: x1 });\n                const y2 = Fp2.add(Fp2.pow(x, _3n), bls12_381.params.G2b); // y = x + 4\n                // The slow part\n                let y = Fp2.sqrt(y2);\n                if (!y)\n                    throw new Error('Failed to find a square root');\n                // Choose the y whose leftmost bit of the imaginary part is equal to the a_flag1\n                // If y1 happens to be zero, then use the bit of y0\n                const { re: y0, im: y1 } = Fp2.reim(y);\n                const aflag1 = BigInt(sort);\n                const isGreater = y1 > _0n && (y1 * _2n) / P !== aflag1;\n                const isZero = y1 === _0n && (y0 * _2n) / P !== aflag1;\n                if (isGreater || isZero)\n                    y = Fp2.neg(y);\n                const point = bls12_381.G2.ProjectivePoint.fromAffine({ x, y });\n                point.assertValidity();\n                return point;\n            },\n            toRawBytes(point) {\n                return signatureG2ToRawBytes(point);\n            },\n            toHex(point) {\n                return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex)(signatureG2ToRawBytes(point));\n            },\n        },\n    },\n    params: {\n        x: BLS_X, // The BLS parameter x for BLS12-381\n        r: Fr.ORDER, // order; z  z + 1; CURVE.n from other curves\n    },\n    htfDefaults,\n    hash: _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256,\n    randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__.randomBytes,\n});\n//# sourceMappingURL=bls12-381.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYmxzMTItMzgxLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDOEM7QUFDSTtBQUNWO0FBQ0s7QUFDcUc7QUFDbEo7QUFDaUU7QUFDUjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1REFBUztBQUNwQjtBQUNBO0FBQ0EsV0FBVyx1REFBUztBQUNwQixrQkFBa0IsUUFBUSxJQUFJLGdCQUFnQjtBQUM5QztBQUNBO0FBQ0EsQ0FBQztBQUNELHVCQUF1QixRQUFRLElBQUksZ0JBQWdCO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxZQUFZLGlCQUFpQjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDBEQUFNO0FBQ2hCLHFCQUFxQiwwREFBTTtBQUMzQixVQUFVLDJEQUFPLENBQUMsMERBQU07QUFDeEIsWUFBWSwwQkFBMEI7QUFDdEMsV0FBVyx5QkFBeUI7QUFDcEM7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRLElBQUksZ0JBQWdCO0FBQ3hDLFlBQVksUUFBUSxRQUFRLGdDQUFnQztBQUM1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QXdCLGlCQUFpQjtBQUN6Qyx3QkFBd0IsaUJBQWlCO0FBQ3pDLHVCQUF1QiwrREFBTyxDQUFDLG1FQUFlLFdBQVcsbUVBQWUsV0FBVyxtRUFBZSxXQUFXLG1FQUFlO0FBQzVIO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0IsWUFBWSwrREFBVztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtRUFBZTtBQUMxQywyQkFBMkIsbUVBQWU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxnQkFBZ0I7QUFDdkQsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxNQUFNO0FBQzlFO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHVCQUF1Qiw4REFBVTtBQUNqQyxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EsK0JBQStCLGFBQWE7QUFDNUMsS0FBSztBQUNMO0FBQ0EsVUFBVSx3REFBTTtBQUNoQixlQUFlO0FBQ2YsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYmxzMTItMzgxLmpzPzZjYTgiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gYmxzMTItMzgxIGlzIHBhaXJpbmctZnJpZW5kbHkgQmFycmV0by1MeW5uLVNjb3R0IGVsbGlwdGljIGN1cnZlIGNvbnN0cnVjdGlvbiBhbGxvd2luZyB0bzpcbi8vIC0gQ29uc3RydWN0IHprLVNOQVJLcyBhdCB0aGUgMTIwLWJpdCBzZWN1cml0eVxuLy8gLSBFZmZpY2llbnRseSB2ZXJpZnkgTiBhZ2dyZWdhdGUgc2lnbmF0dXJlcyB3aXRoIDEgcGFpcmluZyBhbmQgTiBlYyBhZGRpdGlvbnM6XG4vLyAgIHRoZSBCb25laC1MeW5uLVNoYWNoYW0gc2lnbmF0dXJlIHNjaGVtZSBpcyBvcmRlcnMgb2YgbWFnbml0dWRlIG1vcmUgZWZmaWNpZW50IHRoYW4gU2Nobm9yclxuLy9cbi8vICMjIyBTdW1tYXJ5XG4vLyAxLiBCTFMgUmVsaWVzIG9uIEJpbGluZWFyIFBhaXJpbmcgKGV4cGVuc2l2ZSlcbi8vIDIuIFByaXZhdGUgS2V5czogMzIgYnl0ZXNcbi8vIDMuIFB1YmxpYyBLZXlzOiA0OCBieXRlczogMzgxIGJpdCBhZmZpbmUgeCBjb29yZGluYXRlLCBlbmNvZGVkIGludG8gNDggYmlnLWVuZGlhbiBieXRlcy5cbi8vIDQuIFNpZ25hdHVyZXM6IDk2IGJ5dGVzOiB0d28gMzgxIGJpdCBpbnRlZ2VycyAoYWZmaW5lIHggY29vcmRpbmF0ZSksIGVuY29kZWQgaW50byB0d28gNDggYmlnLWVuZGlhbiBieXRlIGFycmF5cy5cbi8vICAgICAtIFRoZSBzaWduYXR1cmUgaXMgYSBwb2ludCBvbiB0aGUgRzIgc3ViZ3JvdXAsIHdoaWNoIGlzIGRlZmluZWQgb3ZlciBhIGZpbml0ZSBmaWVsZFxuLy8gICAgIHdpdGggZWxlbWVudHMgdHdpY2UgYXMgYmlnIGFzIHRoZSBHMSBjdXJ2ZSAoRzIgaXMgb3ZlciBGcDIgcmF0aGVyIHRoYW4gRnAuIEZwMiBpcyBhbmFsb2dvdXMgdG8gdGhlIGNvbXBsZXggbnVtYmVycykuXG4vLyA1LiBUaGUgMTIgc3RhbmRzIGZvciB0aGUgRW1iZWRkaW5nIGRlZ3JlZS5cbi8vXG4vLyAjIyMgRm9ybXVsYXNcbi8vIC0gYFAgPSBwayB4IEdgIC0gcHVibGljIGtleXNcbi8vIC0gYFMgPSBwayB4IEgobSlgIC0gc2lnbmluZ1xuLy8gLSBgZShQLCBIKG0pKSA9PSBlKEcsIFMpYCAtIHZlcmlmaWNhdGlvbiB1c2luZyBwYWlyaW5nc1xuLy8gLSBgZShHLCBTKSA9IGUoRywgU1VNKG4pKFNpKSkgPSBNVUwobikoZShHLCBTaSkpYCAtIHNpZ25hdHVyZSBhZ2dyZWdhdGlvblxuLy9cbi8vICMjIyBDb21wYXRpYmlsaXR5IGFuZCBub3Rlc1xuLy8gMS4gSXQgaXMgY29tcGF0aWJsZSB3aXRoIEFsZ29yYW5kLCBDaGlhLCBEZmluaXR5LCBFdGhlcmV1bSwgRmlsZWNvaW4sIFpFQ1xuLy8gICAgRmlsZWNvaW4gdXNlcyBsaXR0bGUgZW5kaWFuIGJ5dGUgYXJyYXlzIGZvciBwcml2YXRlIGtleXMgLSBtYWtlIHN1cmUgdG8gcmV2ZXJzZSBieXRlIG9yZGVyLlxuLy8gMi4gU29tZSBwcm9qZWN0cyB1c2UgRzIgZm9yIHB1YmxpYyBrZXlzIGFuZCBHMSBmb3Igc2lnbmF0dXJlcy4gSXQncyBjYWxsZWQgXCJzaG9ydCBzaWduYXR1cmVcIlxuLy8gMy4gQ3VydmUgc2VjdXJpdHkgbGV2ZWwgaXMgYWJvdXQgMTIwIGJpdHMgYXMgcGVyIEJhcmJ1bGVzY3UtRHVxdWVzbmUgMjAxN1xuLy8gICAgaHR0cHM6Ly9oYWwuc2NpZW5jZS9oYWwtMDE1MzQxMDEvZmlsZS9tYWluLnBkZlxuLy8gNC4gQ29tcGF0aWJsZSB3aXRoIHNwZWNzOlxuLy8gW2NmcmctcGFpcmluZy1mcmllbmRseS1jdXJ2ZXMtMTFdKGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1pcnRmLWNmcmctcGFpcmluZy1mcmllbmRseS1jdXJ2ZXMtMTEpLFxuLy8gW2NmcmctYmxzLXNpZ25hdHVyZS0wNV0oaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pcnRmLWNmcmctYmxzLXNpZ25hdHVyZS0wNSksXG4vLyBbUkZDIDkzODBdKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwKS5cbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMjU2JztcbmltcG9ydCB7IHJhbmRvbUJ5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5pbXBvcnQgeyBibHMgfSBmcm9tICcuL2Fic3RyYWN0L2Jscy5qcyc7XG5pbXBvcnQgKiBhcyBtb2QgZnJvbSAnLi9hYnN0cmFjdC9tb2R1bGFyLmpzJztcbmltcG9ydCB7IGNvbmNhdEJ5dGVzIGFzIGNvbmNhdEIsIGVuc3VyZUJ5dGVzLCBudW1iZXJUb0J5dGVzQkUsIGJ5dGVzVG9OdW1iZXJCRSwgYml0TGVuLCBiaXRHZXQsIGJpdE1hc2ssIGJ5dGVzVG9IZXgsIH0gZnJvbSAnLi9hYnN0cmFjdC91dGlscy5qcyc7XG4vLyBUeXBlc1xuaW1wb3J0IHsgbWFwVG9DdXJ2ZVNpbXBsZVNXVSwgfSBmcm9tICcuL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzJztcbmltcG9ydCB7IGlzb2dlbnlNYXAgfSBmcm9tICcuL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUuanMnO1xuLy8gQmUgZnJpZW5kbHkgdG8gYmFkIEVDTUFTY3JpcHQgcGFyc2VycyBieSBub3QgdXNpbmcgYmlnaW50IGxpdGVyYWxzXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKSwgXzRuID0gQmlnSW50KDQpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfOG4gPSBCaWdJbnQoOCksIF8xNm4gPSBCaWdJbnQoMTYpO1xuLy8gQ1VSVkUgRklFTERTXG4vLyBGaW5pdGUgZmllbGQgb3ZlciBwLlxuY29uc3QgRnBfcmF3ID0gQmlnSW50KCcweDFhMDExMWVhMzk3ZmU2OWE0YjFiYTdiNjQzNGJhY2Q3NjQ3NzRiODRmMzg1MTJiZjY3MzBkMmEwZjZiMGY2MjQxZWFiZmZmZWIxNTNmZmZmYjlmZWZmZmZmZmZmYWFhYicpO1xuY29uc3QgRnAgPSBtb2QuRmllbGQoRnBfcmF3KTtcbi8vIEZpbml0ZSBmaWVsZCBvdmVyIHIuXG4vLyBUaGlzIHBhcnRpY3VsYXIgZmllbGQgaXMgbm90IHVzZWQgYW55d2hlcmUgaW4gYmxzMTItMzgxLCBidXQgaXQgaXMgc3RpbGwgdXNlZnVsLlxuY29uc3QgRnIgPSBtb2QuRmllbGQoQmlnSW50KCcweDczZWRhNzUzMjk5ZDdkNDgzMzM5ZDgwODA5YTFkODA1NTNiZGE0MDJmZmZlNWJmZWZmZmZmZmZmMDAwMDAwMDEnKSk7XG5jb25zdCBGcDJBZGQgPSAoeyBjMCwgYzEgfSwgeyBjMDogcjAsIGMxOiByMSB9KSA9PiAoe1xuICAgIGMwOiBGcC5hZGQoYzAsIHIwKSxcbiAgICBjMTogRnAuYWRkKGMxLCByMSksXG59KTtcbmNvbnN0IEZwMlN1YnRyYWN0ID0gKHsgYzAsIGMxIH0sIHsgYzA6IHIwLCBjMTogcjEgfSkgPT4gKHtcbiAgICBjMDogRnAuc3ViKGMwLCByMCksXG4gICAgYzE6IEZwLnN1YihjMSwgcjEpLFxufSk7XG5jb25zdCBGcDJNdWx0aXBseSA9ICh7IGMwLCBjMSB9LCByaHMpID0+IHtcbiAgICBpZiAodHlwZW9mIHJocyA9PT0gJ2JpZ2ludCcpXG4gICAgICAgIHJldHVybiB7IGMwOiBGcC5tdWwoYzAsIHJocyksIGMxOiBGcC5tdWwoYzEsIHJocykgfTtcbiAgICAvLyAoYStiaSkoYytkaSkgPSAoYWPiiJJiZCkgKyAoYWQrYmMpaVxuICAgIGNvbnN0IHsgYzA6IHIwLCBjMTogcjEgfSA9IHJocztcbiAgICBsZXQgdDEgPSBGcC5tdWwoYzAsIHIwKTsgLy8gYzAgKiBvMFxuICAgIGxldCB0MiA9IEZwLm11bChjMSwgcjEpOyAvLyBjMSAqIG8xXG4gICAgLy8gKFQxIC0gVDIpICsgKChjMCArIGMxKSAqIChyMCArIHIxKSAtIChUMSArIFQyKSkqaVxuICAgIGNvbnN0IG8wID0gRnAuc3ViKHQxLCB0Mik7XG4gICAgY29uc3QgbzEgPSBGcC5zdWIoRnAubXVsKEZwLmFkZChjMCwgYzEpLCBGcC5hZGQocjAsIHIxKSksIEZwLmFkZCh0MSwgdDIpKTtcbiAgICByZXR1cm4geyBjMDogbzAsIGMxOiBvMSB9O1xufTtcbmNvbnN0IEZwMlNxdWFyZSA9ICh7IGMwLCBjMSB9KSA9PiB7XG4gICAgY29uc3QgYSA9IEZwLmFkZChjMCwgYzEpO1xuICAgIGNvbnN0IGIgPSBGcC5zdWIoYzAsIGMxKTtcbiAgICBjb25zdCBjID0gRnAuYWRkKGMwLCBjMCk7XG4gICAgcmV0dXJuIHsgYzA6IEZwLm11bChhLCBiKSwgYzE6IEZwLm11bChjLCBjMSkgfTtcbn07XG4vLyBHMiBpcyB0aGUgb3JkZXItcSBzdWJncm91cCBvZiBFMihGcMKyKSA6IHnCsiA9IHjCsys0KDEr4oia4oiSMSksXG4vLyB3aGVyZSBGcDIgaXMgRnBb4oia4oiSMV0vKHgyKzEpLiAjRTIoRnAyICkgPSBoMnEsIHdoZXJlXG4vLyBHwrIgLSAxXG4vLyBoMnFcbi8vIE5PVEU6IE9SREVSIHdhcyB3cm9uZyFcbmNvbnN0IEZQMl9PUkRFUiA9IEZwX3JhdyAqIEZwX3JhdztcbmNvbnN0IEZwMiA9IHtcbiAgICBPUkRFUjogRlAyX09SREVSLFxuICAgIEJJVFM6IGJpdExlbihGUDJfT1JERVIpLFxuICAgIEJZVEVTOiBNYXRoLmNlaWwoYml0TGVuKEZQMl9PUkRFUikgLyA4KSxcbiAgICBNQVNLOiBiaXRNYXNrKGJpdExlbihGUDJfT1JERVIpKSxcbiAgICBaRVJPOiB7IGMwOiBGcC5aRVJPLCBjMTogRnAuWkVSTyB9LFxuICAgIE9ORTogeyBjMDogRnAuT05FLCBjMTogRnAuWkVSTyB9LFxuICAgIGNyZWF0ZTogKG51bSkgPT4gbnVtLFxuICAgIGlzVmFsaWQ6ICh7IGMwLCBjMSB9KSA9PiB0eXBlb2YgYzAgPT09ICdiaWdpbnQnICYmIHR5cGVvZiBjMSA9PT0gJ2JpZ2ludCcsXG4gICAgaXMwOiAoeyBjMCwgYzEgfSkgPT4gRnAuaXMwKGMwKSAmJiBGcC5pczAoYzEpLFxuICAgIGVxbDogKHsgYzAsIGMxIH0sIHsgYzA6IHIwLCBjMTogcjEgfSkgPT4gRnAuZXFsKGMwLCByMCkgJiYgRnAuZXFsKGMxLCByMSksXG4gICAgbmVnOiAoeyBjMCwgYzEgfSkgPT4gKHsgYzA6IEZwLm5lZyhjMCksIGMxOiBGcC5uZWcoYzEpIH0pLFxuICAgIHBvdzogKG51bSwgcG93ZXIpID0+IG1vZC5GcFBvdyhGcDIsIG51bSwgcG93ZXIpLFxuICAgIGludmVydEJhdGNoOiAobnVtcykgPT4gbW9kLkZwSW52ZXJ0QmF0Y2goRnAyLCBudW1zKSxcbiAgICAvLyBOb3JtYWxpemVkXG4gICAgYWRkOiBGcDJBZGQsXG4gICAgc3ViOiBGcDJTdWJ0cmFjdCxcbiAgICBtdWw6IEZwMk11bHRpcGx5LFxuICAgIHNxcjogRnAyU3F1YXJlLFxuICAgIC8vIE5vbk5vcm1hbGl6ZWQgc3R1ZmZcbiAgICBhZGROOiBGcDJBZGQsXG4gICAgc3ViTjogRnAyU3VidHJhY3QsXG4gICAgbXVsTjogRnAyTXVsdGlwbHksXG4gICAgc3FyTjogRnAyU3F1YXJlLFxuICAgIC8vIFdoeSBpbnZlcnNpb24gZm9yIGJpZ2ludCBpbnNpZGUgRnAgaW5zdGVhZCBvZiBGcDI/IGl0IGlzIGV2ZW4gdXNlZCBpbiB0aGF0IGNvbnRleHQ/XG4gICAgZGl2OiAobGhzLCByaHMpID0+IEZwMi5tdWwobGhzLCB0eXBlb2YgcmhzID09PSAnYmlnaW50JyA/IEZwLmludihGcC5jcmVhdGUocmhzKSkgOiBGcDIuaW52KHJocykpLFxuICAgIGludjogKHsgYzA6IGEsIGMxOiBiIH0pID0+IHtcbiAgICAgICAgLy8gV2Ugd2lzaCB0byBmaW5kIHRoZSBtdWx0aXBsaWNhdGl2ZSBpbnZlcnNlIG9mIGEgbm9uemVyb1xuICAgICAgICAvLyBlbGVtZW50IGEgKyBidSBpbiBGcDIuIFdlIGxldmVyYWdlIGFuIGlkZW50aXR5XG4gICAgICAgIC8vXG4gICAgICAgIC8vIChhICsgYnUpKGEgLSBidSkgPSBhwrIgKyBiwrJcbiAgICAgICAgLy9cbiAgICAgICAgLy8gd2hpY2ggaG9sZHMgYmVjYXVzZSB1wrIgPSAtMS4gVGhpcyBjYW4gYmUgcmV3cml0dGVuIGFzXG4gICAgICAgIC8vXG4gICAgICAgIC8vIChhICsgYnUpKGEgLSBidSkvKGHCsiArIGLCsikgPSAxXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGJlY2F1c2UgYcKyICsgYsKyID0gMCBoYXMgbm8gbm9uemVybyBzb2x1dGlvbnMgZm9yIChhLCBiKS5cbiAgICAgICAgLy8gVGhpcyBnaXZlcyB0aGF0IChhIC0gYnUpLyhhwrIgKyBiwrIpIGlzIHRoZSBpbnZlcnNlXG4gICAgICAgIC8vIG9mIChhICsgYnUpLiBJbXBvcnRhbnRseSwgdGhpcyBjYW4gYmUgY29tcHV0aW5nIHVzaW5nXG4gICAgICAgIC8vIG9ubHkgYSBzaW5nbGUgaW52ZXJzaW9uIGluIEZwLlxuICAgICAgICBjb25zdCBmYWN0b3IgPSBGcC5pbnYoRnAuY3JlYXRlKGEgKiBhICsgYiAqIGIpKTtcbiAgICAgICAgcmV0dXJuIHsgYzA6IEZwLm11bChmYWN0b3IsIEZwLmNyZWF0ZShhKSksIGMxOiBGcC5tdWwoZmFjdG9yLCBGcC5jcmVhdGUoLWIpKSB9O1xuICAgIH0sXG4gICAgc3FydDogKG51bSkgPT4ge1xuICAgICAgICBpZiAoRnAyLmVxbChudW0sIEZwMi5aRVJPKSlcbiAgICAgICAgICAgIHJldHVybiBGcDIuWkVSTzsgLy8gQWxnbyBkb2Vzbid0IGhhbmRsZXMgdGhpcyBjYXNlXG4gICAgICAgIC8vIFRPRE86IE9wdGltaXplIHRoaXMgbGluZS4gSXQncyBleHRyZW1lbHkgc2xvdy5cbiAgICAgICAgLy8gU3BlZWRpbmcgdGhpcyB1cCB3b3VsZCBib29zdCBhZ2dyZWdhdGVTaWduYXR1cmVzLlxuICAgICAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGYgYXBwbGljYWJsZT9cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3prY3J5cHRvL2JsczEyXzM4MS9ibG9iLzA4MGVhYTc0ZWMwZTM5NDM3N2NhYTFiYTMwMmM4YzEyMWRmMDhiMDcvc3JjL2ZwMi5ycyNMMjUwXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zdXByYW5hdGlvbmFsL2Jsc3QvYmxvYi9hYWUwYzdkNzBiNzk5YWMyNjlmZjVlZGYyOWQ4MTkxZGJkMzU3ODc2L3NyYy9leHAyLmMjTDFcbiAgICAgICAgLy8gSW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL2RhbGVrLWNyeXB0b2dyYXBoeS9jdXJ2ZTI1NTE5LWRhbGVrL2Jsb2IvMTc2OThkZjlkNGM4MzQyMDRmODNhMzU3NDE0M2FiYWNiNGZjODFhNS9zcmMvZmllbGQucnMjTDk5XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZVNxcnQgPSBGcDIucG93KG51bSwgKEZwMi5PUkRFUiArIF84bikgLyBfMTZuKTtcbiAgICAgICAgY29uc3QgY2hlY2sgPSBGcDIuZGl2KEZwMi5zcXIoY2FuZGlkYXRlU3FydCksIG51bSk7IC8vIGNhbmRpZGF0ZVNxcnQuc3F1YXJlKCkuZGl2KHRoaXMpO1xuICAgICAgICBjb25zdCBSID0gRlAyX1JPT1RTX09GX1VOSVRZO1xuICAgICAgICBjb25zdCBkaXZpc29yID0gW1JbMF0sIFJbMl0sIFJbNF0sIFJbNl1dLmZpbmQoKHIpID0+IEZwMi5lcWwociwgY2hlY2spKTtcbiAgICAgICAgaWYgKCFkaXZpc29yKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyByb290Jyk7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gUi5pbmRleE9mKGRpdmlzb3IpO1xuICAgICAgICBjb25zdCByb290ID0gUltpbmRleCAvIDJdO1xuICAgICAgICBpZiAoIXJvb3QpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcm9vdCcpO1xuICAgICAgICBjb25zdCB4MSA9IEZwMi5kaXYoY2FuZGlkYXRlU3FydCwgcm9vdCk7XG4gICAgICAgIGNvbnN0IHgyID0gRnAyLm5lZyh4MSk7XG4gICAgICAgIGNvbnN0IHsgcmU6IHJlMSwgaW06IGltMSB9ID0gRnAyLnJlaW0oeDEpO1xuICAgICAgICBjb25zdCB7IHJlOiByZTIsIGltOiBpbTIgfSA9IEZwMi5yZWltKHgyKTtcbiAgICAgICAgaWYgKGltMSA+IGltMiB8fCAoaW0xID09PSBpbTIgJiYgcmUxID4gcmUyKSlcbiAgICAgICAgICAgIHJldHVybiB4MTtcbiAgICAgICAgcmV0dXJuIHgyO1xuICAgIH0sXG4gICAgLy8gU2FtZSBhcyBzZ24wX21fZXFfMiBpbiBSRkMgOTM4MFxuICAgIGlzT2RkOiAoeCkgPT4ge1xuICAgICAgICBjb25zdCB7IHJlOiB4MCwgaW06IHgxIH0gPSBGcDIucmVpbSh4KTtcbiAgICAgICAgY29uc3Qgc2lnbl8wID0geDAgJSBfMm47XG4gICAgICAgIGNvbnN0IHplcm9fMCA9IHgwID09PSBfMG47XG4gICAgICAgIGNvbnN0IHNpZ25fMSA9IHgxICUgXzJuO1xuICAgICAgICByZXR1cm4gQmlnSW50KHNpZ25fMCB8fCAoemVyb18wICYmIHNpZ25fMSkpID09IF8xbjtcbiAgICB9LFxuICAgIC8vIEJ5dGVzIHV0aWxcbiAgICBmcm9tQnl0ZXMoYikge1xuICAgICAgICBpZiAoYi5sZW5ndGggIT09IEZwMi5CWVRFUylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZnJvbUJ5dGVzIHdyb25nIGxlbmd0aD0ke2IubGVuZ3RofWApO1xuICAgICAgICByZXR1cm4geyBjMDogRnAuZnJvbUJ5dGVzKGIuc3ViYXJyYXkoMCwgRnAuQllURVMpKSwgYzE6IEZwLmZyb21CeXRlcyhiLnN1YmFycmF5KEZwLkJZVEVTKSkgfTtcbiAgICB9LFxuICAgIHRvQnl0ZXM6ICh7IGMwLCBjMSB9KSA9PiBjb25jYXRCKEZwLnRvQnl0ZXMoYzApLCBGcC50b0J5dGVzKGMxKSksXG4gICAgY21vdjogKHsgYzAsIGMxIH0sIHsgYzA6IHIwLCBjMTogcjEgfSwgYykgPT4gKHtcbiAgICAgICAgYzA6IEZwLmNtb3YoYzAsIHIwLCBjKSxcbiAgICAgICAgYzE6IEZwLmNtb3YoYzEsIHIxLCBjKSxcbiAgICB9KSxcbiAgICAvLyBTcGVjaWZpYyB1dGlsc1xuICAgIC8vIHRvU3RyaW5nKCkge1xuICAgIC8vICAgcmV0dXJuIGBGcDIoJHt0aGlzLmMwfSArICR7dGhpcy5jMX3Dl2kpYDtcbiAgICAvLyB9XG4gICAgcmVpbTogKHsgYzAsIGMxIH0pID0+ICh7IHJlOiBjMCwgaW06IGMxIH0pLFxuICAgIC8vIG11bHRpcGx5IGJ5IHUgKyAxXG4gICAgbXVsQnlOb25yZXNpZHVlOiAoeyBjMCwgYzEgfSkgPT4gKHsgYzA6IEZwLnN1YihjMCwgYzEpLCBjMTogRnAuYWRkKGMwLCBjMSkgfSksXG4gICAgbXVsdGlwbHlCeUI6ICh7IGMwLCBjMSB9KSA9PiB7XG4gICAgICAgIGxldCB0MCA9IEZwLm11bChjMCwgXzRuKTsgLy8gNCAqIGMwXG4gICAgICAgIGxldCB0MSA9IEZwLm11bChjMSwgXzRuKTsgLy8gNCAqIGMxXG4gICAgICAgIC8vIChUMC1UMSkgKyAoVDArVDEpKmlcbiAgICAgICAgcmV0dXJuIHsgYzA6IEZwLnN1Yih0MCwgdDEpLCBjMTogRnAuYWRkKHQwLCB0MSkgfTtcbiAgICB9LFxuICAgIGZyb21CaWdUdXBsZTogKHR1cGxlKSA9PiB7XG4gICAgICAgIGlmICh0dXBsZS5sZW5ndGggIT09IDIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHVwbGUnKTtcbiAgICAgICAgY29uc3QgZnBzID0gdHVwbGUubWFwKChuKSA9PiBGcC5jcmVhdGUobikpO1xuICAgICAgICByZXR1cm4geyBjMDogZnBzWzBdLCBjMTogZnBzWzFdIH07XG4gICAgfSxcbiAgICBmcm9iZW5pdXNNYXA6ICh7IGMwLCBjMSB9LCBwb3dlcikgPT4gKHtcbiAgICAgICAgYzAsXG4gICAgICAgIGMxOiBGcC5tdWwoYzEsIEZQMl9GUk9CRU5JVVNfQ09FRkZJQ0lFTlRTW3Bvd2VyICUgMl0pLFxuICAgIH0pLFxufTtcbi8vIEZpbml0ZSBleHRlbnNpb24gZmllbGQgb3ZlciBpcnJlZHVjaWJsZSBwb2x5bm9taW5hbC5cbi8vIEZwKHUpIC8gKHXCsiAtIM6yKSB3aGVyZSDOsiA9IC0xXG5jb25zdCBGUDJfRlJPQkVOSVVTX0NPRUZGSUNJRU5UUyA9IFtcbiAgICBCaWdJbnQoJzB4MScpLFxuICAgIEJpZ0ludCgnMHgxYTAxMTFlYTM5N2ZlNjlhNGIxYmE3YjY0MzRiYWNkNzY0Nzc0Yjg0ZjM4NTEyYmY2NzMwZDJhMGY2YjBmNjI0MWVhYmZmZmViMTUzZmZmZmI5ZmVmZmZmZmZmZmFhYWEnKSxcbl0ubWFwKChpdGVtKSA9PiBGcC5jcmVhdGUoaXRlbSkpO1xuLy8gRm9yIEZwMiByb290cyBvZiB1bml0eS5cbmNvbnN0IHJ2MSA9IEJpZ0ludCgnMHg2YWYwZTA0MzdmZjQwMGI2ODMxZTM2ZDZiZDE3ZmZlNDgzOTVkYWJjMmQzNDM1ZTc3Zjc2ZTE3MDA5MjQxYzVlZTY3OTkyZjcyZWMwNWY0YzgxMDg0ZmJlZGUzY2MwOScpO1xuLy8gY29uc3QgZXYxID1cbi8vICAgQmlnSW50KCcweDY5OWJlM2I4YzY4NzA5NjVlNWJmODkyYWQ1ZDJjYzdiMGU4NWExMTc0MDJkZmQ4M2I3ZjRhOTQ3ZTAyZDk3ODQ5ODI1NWEyYWFlYzBhYzYyN2I1YWZiZGYxYmYxYzkwJyk7XG4vLyBjb25zdCBldjIgPVxuLy8gICBCaWdJbnQoJzB4ODE1N2NkODMwNDY0NTNmNWRkMDk3MmI2ZTM5NDllNDI4ODAyMGI1YjhhOWNjOTljYTA3ZTI3MDg5YTJjZTI0MzZkOTY1MDI2YWRhZDNlZjdiYWJhMzdmMjE4M2U5YjUnKTtcbi8vIGNvbnN0IGV2MyA9XG4vLyAgIEJpZ0ludCgnMHhhYjFjMmZmZGQ2YzI1M2NhMTU1MjMxZWIzZTcxYmEwNDRmZDU2MmY2ZjcyYmM1YmFkNWVjNDZhMGI3YTNiMDI0N2NmMDhjZTZjNjMxN2Y0MGVkYmM2NTNhNzJkZWUxNycpO1xuLy8gY29uc3QgZXY0ID1cbi8vICAgQmlnSW50KCcweGFhNDA0ODY2NzA2NzIyODY0NDgwODg1ZDY4YWQwY2NhYzE5NjdjNzU0NGI0NDc4NzNjYzM3ZTAxODEyNzFlMDA2ZGY3MjE2MmEzZDNlMDI4N2JmNTk3ZmJmN2Y4ZmMxJyk7XG4vLyBFaWdodGggcm9vdHMgb2YgdW5pdHksIHVzZWQgZm9yIGNvbXB1dGluZyBzcXVhcmUgcm9vdHMgaW4gRnAyLlxuLy8gVG8gdmVyaWZ5IG9yIHJlLWNhbGN1bGF0ZTpcbi8vIEFycmF5KDgpLmZpbGwobmV3IEZwMihbMW4sIDFuXSkpLm1hcCgoZnAyLCBrKSA9PiBmcDIucG93KEZwMi5PUkRFUiAqIEJpZ0ludChrKSAvIDhuKSlcbmNvbnN0IEZQMl9ST09UU19PRl9VTklUWSA9IFtcbiAgICBbXzFuLCBfMG5dLFxuICAgIFtydjEsIC1ydjFdLFxuICAgIFtfMG4sIF8xbl0sXG4gICAgW3J2MSwgcnYxXSxcbiAgICBbLV8xbiwgXzBuXSxcbiAgICBbLXJ2MSwgcnYxXSxcbiAgICBbXzBuLCAtXzFuXSxcbiAgICBbLXJ2MSwgLXJ2MV0sXG5dLm1hcCgocGFpcikgPT4gRnAyLmZyb21CaWdUdXBsZShwYWlyKSk7XG5jb25zdCBGcDZBZGQgPSAoeyBjMCwgYzEsIGMyIH0sIHsgYzA6IHIwLCBjMTogcjEsIGMyOiByMiB9KSA9PiAoe1xuICAgIGMwOiBGcDIuYWRkKGMwLCByMCksXG4gICAgYzE6IEZwMi5hZGQoYzEsIHIxKSxcbiAgICBjMjogRnAyLmFkZChjMiwgcjIpLFxufSk7XG5jb25zdCBGcDZTdWJ0cmFjdCA9ICh7IGMwLCBjMSwgYzIgfSwgeyBjMDogcjAsIGMxOiByMSwgYzI6IHIyIH0pID0+ICh7XG4gICAgYzA6IEZwMi5zdWIoYzAsIHIwKSxcbiAgICBjMTogRnAyLnN1YihjMSwgcjEpLFxuICAgIGMyOiBGcDIuc3ViKGMyLCByMiksXG59KTtcbmNvbnN0IEZwNk11bHRpcGx5ID0gKHsgYzAsIGMxLCBjMiB9LCByaHMpID0+IHtcbiAgICBpZiAodHlwZW9mIHJocyA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGMwOiBGcDIubXVsKGMwLCByaHMpLFxuICAgICAgICAgICAgYzE6IEZwMi5tdWwoYzEsIHJocyksXG4gICAgICAgICAgICBjMjogRnAyLm11bChjMiwgcmhzKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgeyBjMDogcjAsIGMxOiByMSwgYzI6IHIyIH0gPSByaHM7XG4gICAgY29uc3QgdDAgPSBGcDIubXVsKGMwLCByMCk7IC8vIGMwICogbzBcbiAgICBjb25zdCB0MSA9IEZwMi5tdWwoYzEsIHIxKTsgLy8gYzEgKiBvMVxuICAgIGNvbnN0IHQyID0gRnAyLm11bChjMiwgcjIpOyAvLyBjMiAqIG8yXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLy8gdDAgKyAoYzEgKyBjMikgKiAocjEgKiByMikgLSAoVDEgKyBUMikgKiAodSArIDEpXG4gICAgICAgIGMwOiBGcDIuYWRkKHQwLCBGcDIubXVsQnlOb25yZXNpZHVlKEZwMi5zdWIoRnAyLm11bChGcDIuYWRkKGMxLCBjMiksIEZwMi5hZGQocjEsIHIyKSksIEZwMi5hZGQodDEsIHQyKSkpKSxcbiAgICAgICAgLy8gKGMwICsgYzEpICogKHIwICsgcjEpIC0gKFQwICsgVDEpICsgVDIgKiAodSArIDEpXG4gICAgICAgIGMxOiBGcDIuYWRkKEZwMi5zdWIoRnAyLm11bChGcDIuYWRkKGMwLCBjMSksIEZwMi5hZGQocjAsIHIxKSksIEZwMi5hZGQodDAsIHQxKSksIEZwMi5tdWxCeU5vbnJlc2lkdWUodDIpKSxcbiAgICAgICAgLy8gVDEgKyAoYzAgKyBjMikgKiAocjAgKyByMikgLSBUMCArIFQyXG4gICAgICAgIGMyOiBGcDIuc3ViKEZwMi5hZGQodDEsIEZwMi5tdWwoRnAyLmFkZChjMCwgYzIpLCBGcDIuYWRkKHIwLCByMikpKSwgRnAyLmFkZCh0MCwgdDIpKSxcbiAgICB9O1xufTtcbmNvbnN0IEZwNlNxdWFyZSA9ICh7IGMwLCBjMSwgYzIgfSkgPT4ge1xuICAgIGxldCB0MCA9IEZwMi5zcXIoYzApOyAvLyBjMMKyXG4gICAgbGV0IHQxID0gRnAyLm11bChGcDIubXVsKGMwLCBjMSksIF8ybik7IC8vIDIgKiBjMCAqIGMxXG4gICAgbGV0IHQzID0gRnAyLm11bChGcDIubXVsKGMxLCBjMiksIF8ybik7IC8vIDIgKiBjMSAqIGMyXG4gICAgbGV0IHQ0ID0gRnAyLnNxcihjMik7IC8vIGMywrJcbiAgICByZXR1cm4ge1xuICAgICAgICBjMDogRnAyLmFkZChGcDIubXVsQnlOb25yZXNpZHVlKHQzKSwgdDApLCAvLyBUMyAqICh1ICsgMSkgKyBUMFxuICAgICAgICBjMTogRnAyLmFkZChGcDIubXVsQnlOb25yZXNpZHVlKHQ0KSwgdDEpLCAvLyBUNCAqICh1ICsgMSkgKyBUMVxuICAgICAgICAvLyBUMSArIChjMCAtIGMxICsgYzIpwrIgKyBUMyAtIFQwIC0gVDRcbiAgICAgICAgYzI6IEZwMi5zdWIoRnAyLnN1YihGcDIuYWRkKEZwMi5hZGQodDEsIEZwMi5zcXIoRnAyLmFkZChGcDIuc3ViKGMwLCBjMSksIGMyKSkpLCB0MyksIHQwKSwgdDQpLFxuICAgIH07XG59O1xuY29uc3QgRnA2ID0ge1xuICAgIE9SREVSOiBGcDIuT1JERVIsIC8vIFRPRE86IHVudXNlZCwgYnV0IG5lZWQgdG8gdmVyaWZ5XG4gICAgQklUUzogMyAqIEZwMi5CSVRTLFxuICAgIEJZVEVTOiAzICogRnAyLkJZVEVTLFxuICAgIE1BU0s6IGJpdE1hc2soMyAqIEZwMi5CSVRTKSxcbiAgICBaRVJPOiB7IGMwOiBGcDIuWkVSTywgYzE6IEZwMi5aRVJPLCBjMjogRnAyLlpFUk8gfSxcbiAgICBPTkU6IHsgYzA6IEZwMi5PTkUsIGMxOiBGcDIuWkVSTywgYzI6IEZwMi5aRVJPIH0sXG4gICAgY3JlYXRlOiAobnVtKSA9PiBudW0sXG4gICAgaXNWYWxpZDogKHsgYzAsIGMxLCBjMiB9KSA9PiBGcDIuaXNWYWxpZChjMCkgJiYgRnAyLmlzVmFsaWQoYzEpICYmIEZwMi5pc1ZhbGlkKGMyKSxcbiAgICBpczA6ICh7IGMwLCBjMSwgYzIgfSkgPT4gRnAyLmlzMChjMCkgJiYgRnAyLmlzMChjMSkgJiYgRnAyLmlzMChjMiksXG4gICAgbmVnOiAoeyBjMCwgYzEsIGMyIH0pID0+ICh7IGMwOiBGcDIubmVnKGMwKSwgYzE6IEZwMi5uZWcoYzEpLCBjMjogRnAyLm5lZyhjMikgfSksXG4gICAgZXFsOiAoeyBjMCwgYzEsIGMyIH0sIHsgYzA6IHIwLCBjMTogcjEsIGMyOiByMiB9KSA9PiBGcDIuZXFsKGMwLCByMCkgJiYgRnAyLmVxbChjMSwgcjEpICYmIEZwMi5lcWwoYzIsIHIyKSxcbiAgICBzcXJ0OiAoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gICAgfSxcbiAgICAvLyBEbyB3ZSBuZWVkIGRpdmlzaW9uIGJ5IGJpZ2ludCBhdCBhbGw/IFNob3VsZCBiZSBkb25lIHZpYSBvcmRlcjpcbiAgICBkaXY6IChsaHMsIHJocykgPT4gRnA2Lm11bChsaHMsIHR5cGVvZiByaHMgPT09ICdiaWdpbnQnID8gRnAuaW52KEZwLmNyZWF0ZShyaHMpKSA6IEZwNi5pbnYocmhzKSksXG4gICAgcG93OiAobnVtLCBwb3dlcikgPT4gbW9kLkZwUG93KEZwNiwgbnVtLCBwb3dlciksXG4gICAgaW52ZXJ0QmF0Y2g6IChudW1zKSA9PiBtb2QuRnBJbnZlcnRCYXRjaChGcDYsIG51bXMpLFxuICAgIC8vIE5vcm1hbGl6ZWRcbiAgICBhZGQ6IEZwNkFkZCxcbiAgICBzdWI6IEZwNlN1YnRyYWN0LFxuICAgIG11bDogRnA2TXVsdGlwbHksXG4gICAgc3FyOiBGcDZTcXVhcmUsXG4gICAgLy8gTm9uTm9ybWFsaXplZCBzdHVmZlxuICAgIGFkZE46IEZwNkFkZCxcbiAgICBzdWJOOiBGcDZTdWJ0cmFjdCxcbiAgICBtdWxOOiBGcDZNdWx0aXBseSxcbiAgICBzcXJOOiBGcDZTcXVhcmUsXG4gICAgaW52OiAoeyBjMCwgYzEsIGMyIH0pID0+IHtcbiAgICAgICAgbGV0IHQwID0gRnAyLnN1YihGcDIuc3FyKGMwKSwgRnAyLm11bEJ5Tm9ucmVzaWR1ZShGcDIubXVsKGMyLCBjMSkpKTsgLy8gYzDCsiAtIGMyICogYzEgKiAodSArIDEpXG4gICAgICAgIGxldCB0MSA9IEZwMi5zdWIoRnAyLm11bEJ5Tm9ucmVzaWR1ZShGcDIuc3FyKGMyKSksIEZwMi5tdWwoYzAsIGMxKSk7IC8vIGMywrIgKiAodSArIDEpIC0gYzAgKiBjMVxuICAgICAgICBsZXQgdDIgPSBGcDIuc3ViKEZwMi5zcXIoYzEpLCBGcDIubXVsKGMwLCBjMikpOyAvLyBjMcKyIC0gYzAgKiBjMlxuICAgICAgICAvLyAxLygoKGMyICogVDEgKyBjMSAqIFQyKSAqIHYpICsgYzAgKiBUMClcbiAgICAgICAgbGV0IHQ0ID0gRnAyLmludihGcDIuYWRkKEZwMi5tdWxCeU5vbnJlc2lkdWUoRnAyLmFkZChGcDIubXVsKGMyLCB0MSksIEZwMi5tdWwoYzEsIHQyKSkpLCBGcDIubXVsKGMwLCB0MCkpKTtcbiAgICAgICAgcmV0dXJuIHsgYzA6IEZwMi5tdWwodDQsIHQwKSwgYzE6IEZwMi5tdWwodDQsIHQxKSwgYzI6IEZwMi5tdWwodDQsIHQyKSB9O1xuICAgIH0sXG4gICAgLy8gQnl0ZXMgdXRpbHNcbiAgICBmcm9tQnl0ZXM6IChiKSA9PiB7XG4gICAgICAgIGlmIChiLmxlbmd0aCAhPT0gRnA2LkJZVEVTKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBmcm9tQnl0ZXMgd3JvbmcgbGVuZ3RoPSR7Yi5sZW5ndGh9YCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjMDogRnAyLmZyb21CeXRlcyhiLnN1YmFycmF5KDAsIEZwMi5CWVRFUykpLFxuICAgICAgICAgICAgYzE6IEZwMi5mcm9tQnl0ZXMoYi5zdWJhcnJheShGcDIuQllURVMsIDIgKiBGcDIuQllURVMpKSxcbiAgICAgICAgICAgIGMyOiBGcDIuZnJvbUJ5dGVzKGIuc3ViYXJyYXkoMiAqIEZwMi5CWVRFUykpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9CeXRlczogKHsgYzAsIGMxLCBjMiB9KSA9PiBjb25jYXRCKEZwMi50b0J5dGVzKGMwKSwgRnAyLnRvQnl0ZXMoYzEpLCBGcDIudG9CeXRlcyhjMikpLFxuICAgIGNtb3Y6ICh7IGMwLCBjMSwgYzIgfSwgeyBjMDogcjAsIGMxOiByMSwgYzI6IHIyIH0sIGMpID0+ICh7XG4gICAgICAgIGMwOiBGcDIuY21vdihjMCwgcjAsIGMpLFxuICAgICAgICBjMTogRnAyLmNtb3YoYzEsIHIxLCBjKSxcbiAgICAgICAgYzI6IEZwMi5jbW92KGMyLCByMiwgYyksXG4gICAgfSksXG4gICAgLy8gVXRpbHNcbiAgICAvLyAgIGZyb21UcmlwbGUodHJpcGxlOiBbRnAyLCBGcDIsIEZwMl0pIHtcbiAgICAvLyAgICAgcmV0dXJuIG5ldyBGcDYoLi4udHJpcGxlKTtcbiAgICAvLyAgIH1cbiAgICAvLyAgIHRvU3RyaW5nKCkge1xuICAgIC8vICAgICByZXR1cm4gYEZwNigke3RoaXMuYzB9ICsgJHt0aGlzLmMxfSAqIHYsICR7dGhpcy5jMn0gKiB2XjIpYDtcbiAgICAvLyAgIH1cbiAgICBmcm9tQmlnU2l4OiAodCkgPT4ge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodCkgfHwgdC5sZW5ndGggIT09IDYpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgRnA2IHVzYWdlJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjMDogRnAyLmZyb21CaWdUdXBsZSh0LnNsaWNlKDAsIDIpKSxcbiAgICAgICAgICAgIGMxOiBGcDIuZnJvbUJpZ1R1cGxlKHQuc2xpY2UoMiwgNCkpLFxuICAgICAgICAgICAgYzI6IEZwMi5mcm9tQmlnVHVwbGUodC5zbGljZSg0LCA2KSksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBmcm9iZW5pdXNNYXA6ICh7IGMwLCBjMSwgYzIgfSwgcG93ZXIpID0+ICh7XG4gICAgICAgIGMwOiBGcDIuZnJvYmVuaXVzTWFwKGMwLCBwb3dlciksXG4gICAgICAgIGMxOiBGcDIubXVsKEZwMi5mcm9iZW5pdXNNYXAoYzEsIHBvd2VyKSwgRlA2X0ZST0JFTklVU19DT0VGRklDSUVOVFNfMVtwb3dlciAlIDZdKSxcbiAgICAgICAgYzI6IEZwMi5tdWwoRnAyLmZyb2Jlbml1c01hcChjMiwgcG93ZXIpLCBGUDZfRlJPQkVOSVVTX0NPRUZGSUNJRU5UU18yW3Bvd2VyICUgNl0pLFxuICAgIH0pLFxuICAgIG11bEJ5Tm9ucmVzaWR1ZTogKHsgYzAsIGMxLCBjMiB9KSA9PiAoeyBjMDogRnAyLm11bEJ5Tm9ucmVzaWR1ZShjMiksIGMxOiBjMCwgYzI6IGMxIH0pLFxuICAgIC8vIFNwYXJzZSBtdWx0aXBsaWNhdGlvblxuICAgIG11bHRpcGx5QnkxOiAoeyBjMCwgYzEsIGMyIH0sIGIxKSA9PiAoe1xuICAgICAgICBjMDogRnAyLm11bEJ5Tm9ucmVzaWR1ZShGcDIubXVsKGMyLCBiMSkpLFxuICAgICAgICBjMTogRnAyLm11bChjMCwgYjEpLFxuICAgICAgICBjMjogRnAyLm11bChjMSwgYjEpLFxuICAgIH0pLFxuICAgIC8vIFNwYXJzZSBtdWx0aXBsaWNhdGlvblxuICAgIG11bHRpcGx5QnkwMSh7IGMwLCBjMSwgYzIgfSwgYjAsIGIxKSB7XG4gICAgICAgIGxldCB0MCA9IEZwMi5tdWwoYzAsIGIwKTsgLy8gYzAgKiBiMFxuICAgICAgICBsZXQgdDEgPSBGcDIubXVsKGMxLCBiMSk7IC8vIGMxICogYjFcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vICgoYzEgKyBjMikgKiBiMSAtIFQxKSAqICh1ICsgMSkgKyBUMFxuICAgICAgICAgICAgYzA6IEZwMi5hZGQoRnAyLm11bEJ5Tm9ucmVzaWR1ZShGcDIuc3ViKEZwMi5tdWwoRnAyLmFkZChjMSwgYzIpLCBiMSksIHQxKSksIHQwKSxcbiAgICAgICAgICAgIC8vIChiMCArIGIxKSAqIChjMCArIGMxKSAtIFQwIC0gVDFcbiAgICAgICAgICAgIGMxOiBGcDIuc3ViKEZwMi5zdWIoRnAyLm11bChGcDIuYWRkKGIwLCBiMSksIEZwMi5hZGQoYzAsIGMxKSksIHQwKSwgdDEpLFxuICAgICAgICAgICAgLy8gKGMwICsgYzIpICogYjAgLSBUMCArIFQxXG4gICAgICAgICAgICBjMjogRnAyLmFkZChGcDIuc3ViKEZwMi5tdWwoRnAyLmFkZChjMCwgYzIpLCBiMCksIHQwKSwgdDEpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgbXVsdGlwbHlCeUZwMjogKHsgYzAsIGMxLCBjMiB9LCByaHMpID0+ICh7XG4gICAgICAgIGMwOiBGcDIubXVsKGMwLCByaHMpLFxuICAgICAgICBjMTogRnAyLm11bChjMSwgcmhzKSxcbiAgICAgICAgYzI6IEZwMi5tdWwoYzIsIHJocyksXG4gICAgfSksXG59O1xuY29uc3QgRlA2X0ZST0JFTklVU19DT0VGRklDSUVOVFNfMSA9IFtcbiAgICBbQmlnSW50KCcweDEnKSwgQmlnSW50KCcweDAnKV0sXG4gICAgW1xuICAgICAgICBCaWdJbnQoJzB4MCcpLFxuICAgICAgICBCaWdJbnQoJzB4MWEwMTExZWEzOTdmZTY5OWVjMDI0MDg2NjNkNGRlODVhYTBkODU3ZDg5NzU5YWQ0ODk3ZDI5NjUwZmI4NWY5YjQwOTQyN2ViNGY0OWZmZmQ4YmZkMDAwMDAwMDBhYWFjJyksXG4gICAgXSxcbiAgICBbXG4gICAgICAgIEJpZ0ludCgnMHgwMDAwMDAwMDAwMDAwMDAwNWYxOTY3MmZkZjc2Y2U1MWJhNjljNjA3NmEwZjc3ZWFkZGIzYTkzYmU2Zjg5Njg4ZGUxN2Q4MTM2MjBhMDAwMjJlMDFmZmZmZmZmZWZmZmUnKSxcbiAgICAgICAgQmlnSW50KCcweDAnKSxcbiAgICBdLFxuICAgIFtCaWdJbnQoJzB4MCcpLCBCaWdJbnQoJzB4MScpXSxcbiAgICBbXG4gICAgICAgIEJpZ0ludCgnMHgxYTAxMTFlYTM5N2ZlNjk5ZWMwMjQwODY2M2Q0ZGU4NWFhMGQ4NTdkODk3NTlhZDQ4OTdkMjk2NTBmYjg1ZjliNDA5NDI3ZWI0ZjQ5ZmZmZDhiZmQwMDAwMDAwMGFhYWMnKSxcbiAgICAgICAgQmlnSW50KCcweDAnKSxcbiAgICBdLFxuICAgIFtcbiAgICAgICAgQmlnSW50KCcweDAnKSxcbiAgICAgICAgQmlnSW50KCcweDAwMDAwMDAwMDAwMDAwMDA1ZjE5NjcyZmRmNzZjZTUxYmE2OWM2MDc2YTBmNzdlYWRkYjNhOTNiZTZmODk2ODhkZTE3ZDgxMzYyMGEwMDAyMmUwMWZmZmZmZmZlZmZmZScpLFxuICAgIF0sXG5dLm1hcCgocGFpcikgPT4gRnAyLmZyb21CaWdUdXBsZShwYWlyKSk7XG5jb25zdCBGUDZfRlJPQkVOSVVTX0NPRUZGSUNJRU5UU18yID0gW1xuICAgIFtCaWdJbnQoJzB4MScpLCBCaWdJbnQoJzB4MCcpXSxcbiAgICBbXG4gICAgICAgIEJpZ0ludCgnMHgxYTAxMTFlYTM5N2ZlNjk5ZWMwMjQwODY2M2Q0ZGU4NWFhMGQ4NTdkODk3NTlhZDQ4OTdkMjk2NTBmYjg1ZjliNDA5NDI3ZWI0ZjQ5ZmZmZDhiZmQwMDAwMDAwMGFhYWQnKSxcbiAgICAgICAgQmlnSW50KCcweDAnKSxcbiAgICBdLFxuICAgIFtcbiAgICAgICAgQmlnSW50KCcweDFhMDExMWVhMzk3ZmU2OTllYzAyNDA4NjYzZDRkZTg1YWEwZDg1N2Q4OTc1OWFkNDg5N2QyOTY1MGZiODVmOWI0MDk0MjdlYjRmNDlmZmZkOGJmZDAwMDAwMDAwYWFhYycpLFxuICAgICAgICBCaWdJbnQoJzB4MCcpLFxuICAgIF0sXG4gICAgW1xuICAgICAgICBCaWdJbnQoJzB4MWEwMTExZWEzOTdmZTY5YTRiMWJhN2I2NDM0YmFjZDc2NDc3NGI4NGYzODUxMmJmNjczMGQyYTBmNmIwZjYyNDFlYWJmZmZlYjE1M2ZmZmZiOWZlZmZmZmZmZmZhYWFhJyksXG4gICAgICAgIEJpZ0ludCgnMHgwJyksXG4gICAgXSxcbiAgICBbXG4gICAgICAgIEJpZ0ludCgnMHgwMDAwMDAwMDAwMDAwMDAwNWYxOTY3MmZkZjc2Y2U1MWJhNjljNjA3NmEwZjc3ZWFkZGIzYTkzYmU2Zjg5Njg4ZGUxN2Q4MTM2MjBhMDAwMjJlMDFmZmZmZmZmZWZmZmUnKSxcbiAgICAgICAgQmlnSW50KCcweDAnKSxcbiAgICBdLFxuICAgIFtcbiAgICAgICAgQmlnSW50KCcweDAwMDAwMDAwMDAwMDAwMDA1ZjE5NjcyZmRmNzZjZTUxYmE2OWM2MDc2YTBmNzdlYWRkYjNhOTNiZTZmODk2ODhkZTE3ZDgxMzYyMGEwMDAyMmUwMWZmZmZmZmZlZmZmZicpLFxuICAgICAgICBCaWdJbnQoJzB4MCcpLFxuICAgIF0sXG5dLm1hcCgocGFpcikgPT4gRnAyLmZyb21CaWdUdXBsZShwYWlyKSk7XG4vLyBUaGUgQkxTIHBhcmFtZXRlciB4IGZvciBCTFMxMi0zODFcbmNvbnN0IEJMU19YID0gQmlnSW50KCcweGQyMDEwMDAwMDAwMTAwMDAnKTtcbmNvbnN0IEJMU19YX0xFTiA9IGJpdExlbihCTFNfWCk7XG5jb25zdCBGcDEyQWRkID0gKHsgYzAsIGMxIH0sIHsgYzA6IHIwLCBjMTogcjEgfSkgPT4gKHtcbiAgICBjMDogRnA2LmFkZChjMCwgcjApLFxuICAgIGMxOiBGcDYuYWRkKGMxLCByMSksXG59KTtcbmNvbnN0IEZwMTJTdWJ0cmFjdCA9ICh7IGMwLCBjMSB9LCB7IGMwOiByMCwgYzE6IHIxIH0pID0+ICh7XG4gICAgYzA6IEZwNi5zdWIoYzAsIHIwKSxcbiAgICBjMTogRnA2LnN1YihjMSwgcjEpLFxufSk7XG5jb25zdCBGcDEyTXVsdGlwbHkgPSAoeyBjMCwgYzEgfSwgcmhzKSA9PiB7XG4gICAgaWYgKHR5cGVvZiByaHMgPT09ICdiaWdpbnQnKVxuICAgICAgICByZXR1cm4geyBjMDogRnA2Lm11bChjMCwgcmhzKSwgYzE6IEZwNi5tdWwoYzEsIHJocykgfTtcbiAgICBsZXQgeyBjMDogcjAsIGMxOiByMSB9ID0gcmhzO1xuICAgIGxldCB0MSA9IEZwNi5tdWwoYzAsIHIwKTsgLy8gYzAgKiByMFxuICAgIGxldCB0MiA9IEZwNi5tdWwoYzEsIHIxKTsgLy8gYzEgKiByMVxuICAgIHJldHVybiB7XG4gICAgICAgIGMwOiBGcDYuYWRkKHQxLCBGcDYubXVsQnlOb25yZXNpZHVlKHQyKSksIC8vIFQxICsgVDIgKiB2XG4gICAgICAgIC8vIChjMCArIGMxKSAqIChyMCArIHIxKSAtIChUMSArIFQyKVxuICAgICAgICBjMTogRnA2LnN1YihGcDYubXVsKEZwNi5hZGQoYzAsIGMxKSwgRnA2LmFkZChyMCwgcjEpKSwgRnA2LmFkZCh0MSwgdDIpKSxcbiAgICB9O1xufTtcbmNvbnN0IEZwMTJTcXVhcmUgPSAoeyBjMCwgYzEgfSkgPT4ge1xuICAgIGxldCBhYiA9IEZwNi5tdWwoYzAsIGMxKTsgLy8gYzAgKiBjMVxuICAgIHJldHVybiB7XG4gICAgICAgIC8vIChjMSAqIHYgKyBjMCkgKiAoYzAgKyBjMSkgLSBBQiAtIEFCICogdlxuICAgICAgICBjMDogRnA2LnN1YihGcDYuc3ViKEZwNi5tdWwoRnA2LmFkZChGcDYubXVsQnlOb25yZXNpZHVlKGMxKSwgYzApLCBGcDYuYWRkKGMwLCBjMSkpLCBhYiksIEZwNi5tdWxCeU5vbnJlc2lkdWUoYWIpKSxcbiAgICAgICAgYzE6IEZwNi5hZGQoYWIsIGFiKSxcbiAgICB9OyAvLyBBQiArIEFCXG59O1xuZnVuY3Rpb24gRnA0U3F1YXJlKGEsIGIpIHtcbiAgICBjb25zdCBhMiA9IEZwMi5zcXIoYSk7XG4gICAgY29uc3QgYjIgPSBGcDIuc3FyKGIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGZpcnN0OiBGcDIuYWRkKEZwMi5tdWxCeU5vbnJlc2lkdWUoYjIpLCBhMiksIC8vIGLCsiAqIE5vbnJlc2lkdWUgKyBhwrJcbiAgICAgICAgc2Vjb25kOiBGcDIuc3ViKEZwMi5zdWIoRnAyLnNxcihGcDIuYWRkKGEsIGIpKSwgYTIpLCBiMiksIC8vIChhICsgYinCsiAtIGHCsiAtIGLCslxuICAgIH07XG59XG5jb25zdCBGcDEyID0ge1xuICAgIE9SREVSOiBGcDIuT1JERVIsIC8vIFRPRE86IHVudXNlZCwgYnV0IG5lZWQgdG8gdmVyaWZ5XG4gICAgQklUUzogMiAqIEZwMi5CSVRTLFxuICAgIEJZVEVTOiAyICogRnAyLkJZVEVTLFxuICAgIE1BU0s6IGJpdE1hc2soMiAqIEZwMi5CSVRTKSxcbiAgICBaRVJPOiB7IGMwOiBGcDYuWkVSTywgYzE6IEZwNi5aRVJPIH0sXG4gICAgT05FOiB7IGMwOiBGcDYuT05FLCBjMTogRnA2LlpFUk8gfSxcbiAgICBjcmVhdGU6IChudW0pID0+IG51bSxcbiAgICBpc1ZhbGlkOiAoeyBjMCwgYzEgfSkgPT4gRnA2LmlzVmFsaWQoYzApICYmIEZwNi5pc1ZhbGlkKGMxKSxcbiAgICBpczA6ICh7IGMwLCBjMSB9KSA9PiBGcDYuaXMwKGMwKSAmJiBGcDYuaXMwKGMxKSxcbiAgICBuZWc6ICh7IGMwLCBjMSB9KSA9PiAoeyBjMDogRnA2Lm5lZyhjMCksIGMxOiBGcDYubmVnKGMxKSB9KSxcbiAgICBlcWw6ICh7IGMwLCBjMSB9LCB7IGMwOiByMCwgYzE6IHIxIH0pID0+IEZwNi5lcWwoYzAsIHIwKSAmJiBGcDYuZXFsKGMxLCByMSksXG4gICAgc3FydDogKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH0sXG4gICAgaW52OiAoeyBjMCwgYzEgfSkgPT4ge1xuICAgICAgICBsZXQgdCA9IEZwNi5pbnYoRnA2LnN1YihGcDYuc3FyKGMwKSwgRnA2Lm11bEJ5Tm9ucmVzaWR1ZShGcDYuc3FyKGMxKSkpKTsgLy8gMSAvIChjMMKyIC0gYzHCsiAqIHYpXG4gICAgICAgIHJldHVybiB7IGMwOiBGcDYubXVsKGMwLCB0KSwgYzE6IEZwNi5uZWcoRnA2Lm11bChjMSwgdCkpIH07IC8vICgoQzAgKiBUKSAqIFQpICsgKC1DMSAqIFQpICogd1xuICAgIH0sXG4gICAgZGl2OiAobGhzLCByaHMpID0+IEZwMTIubXVsKGxocywgdHlwZW9mIHJocyA9PT0gJ2JpZ2ludCcgPyBGcC5pbnYoRnAuY3JlYXRlKHJocykpIDogRnAxMi5pbnYocmhzKSksXG4gICAgcG93OiAobnVtLCBwb3dlcikgPT4gbW9kLkZwUG93KEZwMTIsIG51bSwgcG93ZXIpLFxuICAgIGludmVydEJhdGNoOiAobnVtcykgPT4gbW9kLkZwSW52ZXJ0QmF0Y2goRnAxMiwgbnVtcyksXG4gICAgLy8gTm9ybWFsaXplZFxuICAgIGFkZDogRnAxMkFkZCxcbiAgICBzdWI6IEZwMTJTdWJ0cmFjdCxcbiAgICBtdWw6IEZwMTJNdWx0aXBseSxcbiAgICBzcXI6IEZwMTJTcXVhcmUsXG4gICAgLy8gTm9uTm9ybWFsaXplZCBzdHVmZlxuICAgIGFkZE46IEZwMTJBZGQsXG4gICAgc3ViTjogRnAxMlN1YnRyYWN0LFxuICAgIG11bE46IEZwMTJNdWx0aXBseSxcbiAgICBzcXJOOiBGcDEyU3F1YXJlLFxuICAgIC8vIEJ5dGVzIHV0aWxzXG4gICAgZnJvbUJ5dGVzOiAoYikgPT4ge1xuICAgICAgICBpZiAoYi5sZW5ndGggIT09IEZwMTIuQllURVMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGZyb21CeXRlcyB3cm9uZyBsZW5ndGg9JHtiLmxlbmd0aH1gKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGMwOiBGcDYuZnJvbUJ5dGVzKGIuc3ViYXJyYXkoMCwgRnA2LkJZVEVTKSksXG4gICAgICAgICAgICBjMTogRnA2LmZyb21CeXRlcyhiLnN1YmFycmF5KEZwNi5CWVRFUykpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9CeXRlczogKHsgYzAsIGMxIH0pID0+IGNvbmNhdEIoRnA2LnRvQnl0ZXMoYzApLCBGcDYudG9CeXRlcyhjMSkpLFxuICAgIGNtb3Y6ICh7IGMwLCBjMSB9LCB7IGMwOiByMCwgYzE6IHIxIH0sIGMpID0+ICh7XG4gICAgICAgIGMwOiBGcDYuY21vdihjMCwgcjAsIGMpLFxuICAgICAgICBjMTogRnA2LmNtb3YoYzEsIHIxLCBjKSxcbiAgICB9KSxcbiAgICAvLyBVdGlsc1xuICAgIC8vIHRvU3RyaW5nKCkge1xuICAgIC8vICAgcmV0dXJuIGBGcDEyKCR7dGhpcy5jMH0gKyAke3RoaXMuYzF9ICogdylgO1xuICAgIC8vIH0sXG4gICAgLy8gZnJvbVR1cGxlKGM6IFtGcDYsIEZwNl0pIHtcbiAgICAvLyAgIHJldHVybiBuZXcgRnAxMiguLi5jKTtcbiAgICAvLyB9XG4gICAgZnJvbUJpZ1R3ZWx2ZTogKHQpID0+ICh7XG4gICAgICAgIGMwOiBGcDYuZnJvbUJpZ1NpeCh0LnNsaWNlKDAsIDYpKSxcbiAgICAgICAgYzE6IEZwNi5mcm9tQmlnU2l4KHQuc2xpY2UoNiwgMTIpKSxcbiAgICB9KSxcbiAgICAvLyBSYWlzZXMgdG8gcSoqaSAtdGggcG93ZXJcbiAgICBmcm9iZW5pdXNNYXAobGhzLCBwb3dlcikge1xuICAgICAgICBjb25zdCByMCA9IEZwNi5mcm9iZW5pdXNNYXAobGhzLmMwLCBwb3dlcik7XG4gICAgICAgIGNvbnN0IHsgYzAsIGMxLCBjMiB9ID0gRnA2LmZyb2Jlbml1c01hcChsaHMuYzEsIHBvd2VyKTtcbiAgICAgICAgY29uc3QgY29lZmYgPSBGUDEyX0ZST0JFTklVU19DT0VGRklDSUVOVFNbcG93ZXIgJSAxMl07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjMDogcjAsXG4gICAgICAgICAgICBjMTogRnA2LmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgYzA6IEZwMi5tdWwoYzAsIGNvZWZmKSxcbiAgICAgICAgICAgICAgICBjMTogRnAyLm11bChjMSwgY29lZmYpLFxuICAgICAgICAgICAgICAgIGMyOiBGcDIubXVsKGMyLCBjb2VmZiksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIC8vIFNwYXJzZSBtdWx0aXBsaWNhdGlvblxuICAgIG11bHRpcGx5QnkwMTQ6ICh7IGMwLCBjMSB9LCBvMCwgbzEsIG80KSA9PiB7XG4gICAgICAgIGxldCB0MCA9IEZwNi5tdWx0aXBseUJ5MDEoYzAsIG8wLCBvMSk7XG4gICAgICAgIGxldCB0MSA9IEZwNi5tdWx0aXBseUJ5MShjMSwgbzQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYzA6IEZwNi5hZGQoRnA2Lm11bEJ5Tm9ucmVzaWR1ZSh0MSksIHQwKSwgLy8gVDEgKiB2ICsgVDBcbiAgICAgICAgICAgIC8vIChjMSArIGMwKSAqIFtvMCwgbzErbzRdIC0gVDAgLSBUMVxuICAgICAgICAgICAgYzE6IEZwNi5zdWIoRnA2LnN1YihGcDYubXVsdGlwbHlCeTAxKEZwNi5hZGQoYzEsIGMwKSwgbzAsIEZwMi5hZGQobzEsIG80KSksIHQwKSwgdDEpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgbXVsdGlwbHlCeUZwMjogKHsgYzAsIGMxIH0sIHJocykgPT4gKHtcbiAgICAgICAgYzA6IEZwNi5tdWx0aXBseUJ5RnAyKGMwLCByaHMpLFxuICAgICAgICBjMTogRnA2Lm11bHRpcGx5QnlGcDIoYzEsIHJocyksXG4gICAgfSksXG4gICAgY29uanVnYXRlOiAoeyBjMCwgYzEgfSkgPT4gKHsgYzAsIGMxOiBGcDYubmVnKGMxKSB9KSxcbiAgICAvLyBBIGN5Y2xvdG9taWMgZ3JvdXAgaXMgYSBzdWJncm91cCBvZiBGcF5uIGRlZmluZWQgYnlcbiAgICAvLyAgIEfOpuKCmShwKSA9IHvOsSDiiIggRnDigb8gOiDOsV7OpuKCmShwKSA9IDF9XG4gICAgLy8gVGhlIHJlc3VsdCBvZiBhbnkgcGFpcmluZyBpcyBpbiBhIGN5Y2xvdG9taWMgc3ViZ3JvdXBcbiAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDA5LzU2NS5wZGZcbiAgICBfY3ljbG90b21pY1NxdWFyZTogKHsgYzAsIGMxIH0pID0+IHtcbiAgICAgICAgY29uc3QgeyBjMDogYzBjMCwgYzE6IGMwYzEsIGMyOiBjMGMyIH0gPSBjMDtcbiAgICAgICAgY29uc3QgeyBjMDogYzFjMCwgYzE6IGMxYzEsIGMyOiBjMWMyIH0gPSBjMTtcbiAgICAgICAgY29uc3QgeyBmaXJzdDogdDMsIHNlY29uZDogdDQgfSA9IEZwNFNxdWFyZShjMGMwLCBjMWMxKTtcbiAgICAgICAgY29uc3QgeyBmaXJzdDogdDUsIHNlY29uZDogdDYgfSA9IEZwNFNxdWFyZShjMWMwLCBjMGMyKTtcbiAgICAgICAgY29uc3QgeyBmaXJzdDogdDcsIHNlY29uZDogdDggfSA9IEZwNFNxdWFyZShjMGMxLCBjMWMyKTtcbiAgICAgICAgbGV0IHQ5ID0gRnAyLm11bEJ5Tm9ucmVzaWR1ZSh0OCk7IC8vIFQ4ICogKHUgKyAxKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYzA6IEZwNi5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIGMwOiBGcDIuYWRkKEZwMi5tdWwoRnAyLnN1Yih0MywgYzBjMCksIF8ybiksIHQzKSwgLy8gMiAqIChUMyAtIGMwYzApICArIFQzXG4gICAgICAgICAgICAgICAgYzE6IEZwMi5hZGQoRnAyLm11bChGcDIuc3ViKHQ1LCBjMGMxKSwgXzJuKSwgdDUpLCAvLyAyICogKFQ1IC0gYzBjMSkgICsgVDVcbiAgICAgICAgICAgICAgICBjMjogRnAyLmFkZChGcDIubXVsKEZwMi5zdWIodDcsIGMwYzIpLCBfMm4pLCB0NyksXG4gICAgICAgICAgICB9KSwgLy8gMiAqIChUNyAtIGMwYzIpICArIFQ3XG4gICAgICAgICAgICBjMTogRnA2LmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgYzA6IEZwMi5hZGQoRnAyLm11bChGcDIuYWRkKHQ5LCBjMWMwKSwgXzJuKSwgdDkpLCAvLyAyICogKFQ5ICsgYzFjMCkgKyBUOVxuICAgICAgICAgICAgICAgIGMxOiBGcDIuYWRkKEZwMi5tdWwoRnAyLmFkZCh0NCwgYzFjMSksIF8ybiksIHQ0KSwgLy8gMiAqIChUNCArIGMxYzEpICsgVDRcbiAgICAgICAgICAgICAgICBjMjogRnAyLmFkZChGcDIubXVsKEZwMi5hZGQodDYsIGMxYzIpLCBfMm4pLCB0NiksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfTsgLy8gMiAqIChUNiArIGMxYzIpICsgVDZcbiAgICB9LFxuICAgIF9jeWNsb3RvbWljRXhwKG51bSwgbikge1xuICAgICAgICBsZXQgeiA9IEZwMTIuT05FO1xuICAgICAgICBmb3IgKGxldCBpID0gQkxTX1hfTEVOIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHogPSBGcDEyLl9jeWNsb3RvbWljU3F1YXJlKHopO1xuICAgICAgICAgICAgaWYgKGJpdEdldChuLCBpKSlcbiAgICAgICAgICAgICAgICB6ID0gRnAxMi5tdWwoeiwgbnVtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gejtcbiAgICB9LFxuICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTAvMzU0LnBkZlxuICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMDkvNTY1LnBkZlxuICAgIGZpbmFsRXhwb25lbnRpYXRlOiAobnVtKSA9PiB7XG4gICAgICAgIGNvbnN0IHggPSBCTFNfWDtcbiAgICAgICAgLy8gdGhpc14oceKBtikgLyB0aGlzXG4gICAgICAgIGNvbnN0IHQwID0gRnAxMi5kaXYoRnAxMi5mcm9iZW5pdXNNYXAobnVtLCA2KSwgbnVtKTtcbiAgICAgICAgLy8gdDBeKHHCsikgKiB0MFxuICAgICAgICBjb25zdCB0MSA9IEZwMTIubXVsKEZwMTIuZnJvYmVuaXVzTWFwKHQwLCAyKSwgdDApO1xuICAgICAgICBjb25zdCB0MiA9IEZwMTIuY29uanVnYXRlKEZwMTIuX2N5Y2xvdG9taWNFeHAodDEsIHgpKTtcbiAgICAgICAgY29uc3QgdDMgPSBGcDEyLm11bChGcDEyLmNvbmp1Z2F0ZShGcDEyLl9jeWNsb3RvbWljU3F1YXJlKHQxKSksIHQyKTtcbiAgICAgICAgY29uc3QgdDQgPSBGcDEyLmNvbmp1Z2F0ZShGcDEyLl9jeWNsb3RvbWljRXhwKHQzLCB4KSk7XG4gICAgICAgIGNvbnN0IHQ1ID0gRnAxMi5jb25qdWdhdGUoRnAxMi5fY3ljbG90b21pY0V4cCh0NCwgeCkpO1xuICAgICAgICBjb25zdCB0NiA9IEZwMTIubXVsKEZwMTIuY29uanVnYXRlKEZwMTIuX2N5Y2xvdG9taWNFeHAodDUsIHgpKSwgRnAxMi5fY3ljbG90b21pY1NxdWFyZSh0MikpO1xuICAgICAgICBjb25zdCB0NyA9IEZwMTIuY29uanVnYXRlKEZwMTIuX2N5Y2xvdG9taWNFeHAodDYsIHgpKTtcbiAgICAgICAgY29uc3QgdDJfdDVfcG93X3EyID0gRnAxMi5mcm9iZW5pdXNNYXAoRnAxMi5tdWwodDIsIHQ1KSwgMik7XG4gICAgICAgIGNvbnN0IHQ0X3QxX3Bvd19xMyA9IEZwMTIuZnJvYmVuaXVzTWFwKEZwMTIubXVsKHQ0LCB0MSksIDMpO1xuICAgICAgICBjb25zdCB0Nl90MWNfcG93X3ExID0gRnAxMi5mcm9iZW5pdXNNYXAoRnAxMi5tdWwodDYsIEZwMTIuY29uanVnYXRlKHQxKSksIDEpO1xuICAgICAgICBjb25zdCB0N190M2NfdDEgPSBGcDEyLm11bChGcDEyLm11bCh0NywgRnAxMi5jb25qdWdhdGUodDMpKSwgdDEpO1xuICAgICAgICAvLyAodDIgKiB0NSleKHHCsikgKiAodDQgKiB0MSleKHHCsykgKiAodDYgKiB0MS5jb25qKV4ocV4xKSAqIHQ3ICogdDMuY29uaiAqIHQxXG4gICAgICAgIHJldHVybiBGcDEyLm11bChGcDEyLm11bChGcDEyLm11bCh0Ml90NV9wb3dfcTIsIHQ0X3QxX3Bvd19xMyksIHQ2X3QxY19wb3dfcTEpLCB0N190M2NfdDEpO1xuICAgIH0sXG59O1xuY29uc3QgRlAxMl9GUk9CRU5JVVNfQ09FRkZJQ0lFTlRTID0gW1xuICAgIFtCaWdJbnQoJzB4MScpLCBCaWdJbnQoJzB4MCcpXSxcbiAgICBbXG4gICAgICAgIEJpZ0ludCgnMHgxOTA0ZDNiZjAyYmIwNjY3YzIzMWJlYjQyMDJjMGQxZjBmZDYwM2ZkM2NiZDVmNGY3YjI0NDNkNzg0YmFiOWM0ZjY3ZWE1M2Q2M2U3ODEzZDhkMDc3NWVkOTIyMzVmYjgnKSxcbiAgICAgICAgQmlnSW50KCcweDAwZmMzZTJiMzZjNGUwMzI4OGU5ZTkwMjIzMWY5ZmI4NTRhMTQ3ODdiNmM3YjM2ZmVjMGM4ZWM5NzFmNjNjNWYyODJkNWFjMTRkNmM3ZWMyMmNmNzhhMTI2ZGRjNGFmMycpLFxuICAgIF0sXG4gICAgW1xuICAgICAgICBCaWdJbnQoJzB4MDAwMDAwMDAwMDAwMDAwMDVmMTk2NzJmZGY3NmNlNTFiYTY5YzYwNzZhMGY3N2VhZGRiM2E5M2JlNmY4OTY4OGRlMTdkODEzNjIwYTAwMDIyZTAxZmZmZmZmZmVmZmZmJyksXG4gICAgICAgIEJpZ0ludCgnMHgwJyksXG4gICAgXSxcbiAgICBbXG4gICAgICAgIEJpZ0ludCgnMHgxMzUyMDNlNjAxODBhNjhlZTJlOWM0NDhkNzdhMmNkOTFjM2RlZGQ5MzBiMWNmNjBlZjM5NjQ4OWY2MWViNDVlMzA0NDY2Y2YzZTY3ZmEwYWYxZWU3YjA0MTIxYmRlYTInKSxcbiAgICAgICAgQmlnSW50KCcweDA2YWYwZTA0MzdmZjQwMGI2ODMxZTM2ZDZiZDE3ZmZlNDgzOTVkYWJjMmQzNDM1ZTc3Zjc2ZTE3MDA5MjQxYzVlZTY3OTkyZjcyZWMwNWY0YzgxMDg0ZmJlZGUzY2MwOScpLFxuICAgIF0sXG4gICAgW1xuICAgICAgICBCaWdJbnQoJzB4MDAwMDAwMDAwMDAwMDAwMDVmMTk2NzJmZGY3NmNlNTFiYTY5YzYwNzZhMGY3N2VhZGRiM2E5M2JlNmY4OTY4OGRlMTdkODEzNjIwYTAwMDIyZTAxZmZmZmZmZmVmZmZlJyksXG4gICAgICAgIEJpZ0ludCgnMHgwJyksXG4gICAgXSxcbiAgICBbXG4gICAgICAgIEJpZ0ludCgnMHgxNDRlNDIxMTM4NDU4NmMxNmJkM2FkNGFmYTk5Y2M5MTcwZGYzNTYwZTc3OTgyZDBkYjQ1ZjM1MzY4MTRmMGJkNTg3MWMxOTA4YmQ0NzhjZDFlZTYwNTE2N2ZmODI5OTUnKSxcbiAgICAgICAgQmlnSW50KCcweDA1YjJjZmQ5MDEzYTVmZDhkZjQ3ZmE2YjQ4YjFlMDQ1ZjM5ODE2MjQwYzBiOGZlZThiZWFkZjRkOGU5YzA1NjZjNjNhM2U2ZTI1N2Y4NzMyOWIxOGZhZTk4MDA3ODExNicpLFxuICAgIF0sXG4gICAgW1xuICAgICAgICBCaWdJbnQoJzB4MWEwMTExZWEzOTdmZTY5YTRiMWJhN2I2NDM0YmFjZDc2NDc3NGI4NGYzODUxMmJmNjczMGQyYTBmNmIwZjYyNDFlYWJmZmZlYjE1M2ZmZmZiOWZlZmZmZmZmZmZhYWFhJyksXG4gICAgICAgIEJpZ0ludCgnMHgwJyksXG4gICAgXSxcbiAgICBbXG4gICAgICAgIEJpZ0ludCgnMHgwMGZjM2UyYjM2YzRlMDMyODhlOWU5MDIyMzFmOWZiODU0YTE0Nzg3YjZjN2IzNmZlYzBjOGVjOTcxZjYzYzVmMjgyZDVhYzE0ZDZjN2VjMjJjZjc4YTEyNmRkYzRhZjMnKSxcbiAgICAgICAgQmlnSW50KCcweDE5MDRkM2JmMDJiYjA2NjdjMjMxYmViNDIwMmMwZDFmMGZkNjAzZmQzY2JkNWY0ZjdiMjQ0M2Q3ODRiYWI5YzRmNjdlYTUzZDYzZTc4MTNkOGQwNzc1ZWQ5MjIzNWZiOCcpLFxuICAgIF0sXG4gICAgW1xuICAgICAgICBCaWdJbnQoJzB4MWEwMTExZWEzOTdmZTY5OWVjMDI0MDg2NjNkNGRlODVhYTBkODU3ZDg5NzU5YWQ0ODk3ZDI5NjUwZmI4NWY5YjQwOTQyN2ViNGY0OWZmZmQ4YmZkMDAwMDAwMDBhYWFjJyksXG4gICAgICAgIEJpZ0ludCgnMHgwJyksXG4gICAgXSxcbiAgICBbXG4gICAgICAgIEJpZ0ludCgnMHgwNmFmMGUwNDM3ZmY0MDBiNjgzMWUzNmQ2YmQxN2ZmZTQ4Mzk1ZGFiYzJkMzQzNWU3N2Y3NmUxNzAwOTI0MWM1ZWU2Nzk5MmY3MmVjMDVmNGM4MTA4NGZiZWRlM2NjMDknKSxcbiAgICAgICAgQmlnSW50KCcweDEzNTIwM2U2MDE4MGE2OGVlMmU5YzQ0OGQ3N2EyY2Q5MWMzZGVkZDkzMGIxY2Y2MGVmMzk2NDg5ZjYxZWI0NWUzMDQ0NjZjZjNlNjdmYTBhZjFlZTdiMDQxMjFiZGVhMicpLFxuICAgIF0sXG4gICAgW1xuICAgICAgICBCaWdJbnQoJzB4MWEwMTExZWEzOTdmZTY5OWVjMDI0MDg2NjNkNGRlODVhYTBkODU3ZDg5NzU5YWQ0ODk3ZDI5NjUwZmI4NWY5YjQwOTQyN2ViNGY0OWZmZmQ4YmZkMDAwMDAwMDBhYWFkJyksXG4gICAgICAgIEJpZ0ludCgnMHgwJyksXG4gICAgXSxcbiAgICBbXG4gICAgICAgIEJpZ0ludCgnMHgwNWIyY2ZkOTAxM2E1ZmQ4ZGY0N2ZhNmI0OGIxZTA0NWYzOTgxNjI0MGMwYjhmZWU4YmVhZGY0ZDhlOWMwNTY2YzYzYTNlNmUyNTdmODczMjliMThmYWU5ODAwNzgxMTYnKSxcbiAgICAgICAgQmlnSW50KCcweDE0NGU0MjExMzg0NTg2YzE2YmQzYWQ0YWZhOTljYzkxNzBkZjM1NjBlNzc5ODJkMGRiNDVmMzUzNjgxNGYwYmQ1ODcxYzE5MDhiZDQ3OGNkMWVlNjA1MTY3ZmY4Mjk5NScpLFxuICAgIF0sXG5dLm1hcCgobikgPT4gRnAyLmZyb21CaWdUdXBsZShuKSk7XG4vLyBFTkQgT0YgQ1VSVkUgRklFTERTXG4vLyBIYXNoVG9DdXJ2ZVxuLy8gMy1pc29nZW55IG1hcCBmcm9tIEUnIHRvIEUgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjYXBwZW5kaXgtRS4zXG5jb25zdCBpc29nZW55TWFwRzIgPSBpc29nZW55TWFwKEZwMiwgW1xuICAgIC8vIHhOdW1cbiAgICBbXG4gICAgICAgIFtcbiAgICAgICAgICAgICcweDVjNzU5NTA3ZThlMzMzZWJiNWI3YTlhNDdkN2VkODUzMmM1MmQzOWZkM2EwNDJhODhiNTg0MjNjNTBhZTE1ZDVjMjYzOGUzNDNkOWM3MWM2MjM4YWFhYWFhYWE5N2Q2JyxcbiAgICAgICAgICAgICcweDVjNzU5NTA3ZThlMzMzZWJiNWI3YTlhNDdkN2VkODUzMmM1MmQzOWZkM2EwNDJhODhiNTg0MjNjNTBhZTE1ZDVjMjYzOGUzNDNkOWM3MWM2MjM4YWFhYWFhYWE5N2Q2JyxcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgICAgJzB4MCcsXG4gICAgICAgICAgICAnMHgxMTU2MGJmMTdiYWE5OWJjMzIxMjZmY2VkNzg3Yzg4Zjk4NGY4N2FkZjdhZTBjN2Y5YTIwOGM2YjRmMjBhNDE4MTQ3MmFhYTljYjhkNTU1NTI2YTlmZmZmZmZmZmM3MWEnLFxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgICAnMHgxMTU2MGJmMTdiYWE5OWJjMzIxMjZmY2VkNzg3Yzg4Zjk4NGY4N2FkZjdhZTBjN2Y5YTIwOGM2YjRmMjBhNDE4MTQ3MmFhYTljYjhkNTU1NTI2YTlmZmZmZmZmZmM3MWUnLFxuICAgICAgICAgICAgJzB4OGFiMDVmOGJkZDU0Y2RlMTkwOTM3ZTc2YmMzZTQ0N2NjMjdjM2Q2ZmJkNzA2M2ZjZDEwNDYzNWE3OTA1MjBjMGEzOTU1NTRlNWM2YWFhYTkzNTRmZmZmZmZmZmUzOGQnLFxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgICAnMHgxNzFkNjU0MWZhMzhjY2ZhZWQ2ZGVhNjkxZjVmYjYxNGNiMTRiNGU3ZjRlODEwYWEyMmQ2MTA4ZjE0MmI4NTc1NzA5OGUzOGQwZjY3MWM3MTg4ZTJhYWFhYWFhYTVlZDEnLFxuICAgICAgICAgICAgJzB4MCcsXG4gICAgICAgIF0sXG4gICAgXSxcbiAgICAvLyB4RGVuXG4gICAgW1xuICAgICAgICBbXG4gICAgICAgICAgICAnMHgwJyxcbiAgICAgICAgICAgICcweDFhMDExMWVhMzk3ZmU2OWE0YjFiYTdiNjQzNGJhY2Q3NjQ3NzRiODRmMzg1MTJiZjY3MzBkMmEwZjZiMGY2MjQxZWFiZmZmZWIxNTNmZmZmYjlmZWZmZmZmZmZmYWE2MycsXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICAgICcweGMnLFxuICAgICAgICAgICAgJzB4MWEwMTExZWEzOTdmZTY5YTRiMWJhN2I2NDM0YmFjZDc2NDc3NGI4NGYzODUxMmJmNjczMGQyYTBmNmIwZjYyNDFlYWJmZmZlYjE1M2ZmZmZiOWZlZmZmZmZmZmZhYTlmJyxcbiAgICAgICAgXSxcbiAgICAgICAgWycweDEnLCAnMHgwJ10sIC8vIExBU1QgMVxuICAgIF0sXG4gICAgLy8geU51bVxuICAgIFtcbiAgICAgICAgW1xuICAgICAgICAgICAgJzB4MTUzMDQ3N2M3YWI0MTEzYjU5YTRjMThiMDc2ZDExOTMwZjdkYTVkNGEwN2Y2NDliZjU0NDM5ZDg3ZDI3ZTUwMGZjOGMyNWViZjhjOTJmNjgxMmNmYzcxYzcxYzZkNzA2JyxcbiAgICAgICAgICAgICcweDE1MzA0NzdjN2FiNDExM2I1OWE0YzE4YjA3NmQxMTkzMGY3ZGE1ZDRhMDdmNjQ5YmY1NDQzOWQ4N2QyN2U1MDBmYzhjMjVlYmY4YzkyZjY4MTJjZmM3MWM3MWM2ZDcwNicsXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICAgICcweDAnLFxuICAgICAgICAgICAgJzB4NWM3NTk1MDdlOGUzMzNlYmI1YjdhOWE0N2Q3ZWQ4NTMyYzUyZDM5ZmQzYTA0MmE4OGI1ODQyM2M1MGFlMTVkNWMyNjM4ZTM0M2Q5YzcxYzYyMzhhYWFhYWFhYTk3YmUnLFxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgICAnMHgxMTU2MGJmMTdiYWE5OWJjMzIxMjZmY2VkNzg3Yzg4Zjk4NGY4N2FkZjdhZTBjN2Y5YTIwOGM2YjRmMjBhNDE4MTQ3MmFhYTljYjhkNTU1NTI2YTlmZmZmZmZmZmM3MWMnLFxuICAgICAgICAgICAgJzB4OGFiMDVmOGJkZDU0Y2RlMTkwOTM3ZTc2YmMzZTQ0N2NjMjdjM2Q2ZmJkNzA2M2ZjZDEwNDYzNWE3OTA1MjBjMGEzOTU1NTRlNWM2YWFhYTkzNTRmZmZmZmZmZmUzOGYnLFxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgICAnMHgxMjRjOWFkNDNiNmNmNzliZmJmNzA0M2RlMzgxMWFkMDc2MWIwZjM3YTFlMjYyODZiMGU5NzdjNjlhYTI3NDUyNGU3OTA5N2E1NmRjNGJkOWUxYjM3MWM3MWM3MThiMTAnLFxuICAgICAgICAgICAgJzB4MCcsXG4gICAgICAgIF0sXG4gICAgXSxcbiAgICAvLyB5RGVuXG4gICAgW1xuICAgICAgICBbXG4gICAgICAgICAgICAnMHgxYTAxMTFlYTM5N2ZlNjlhNGIxYmE3YjY0MzRiYWNkNzY0Nzc0Yjg0ZjM4NTEyYmY2NzMwZDJhMGY2YjBmNjI0MWVhYmZmZmViMTUzZmZmZmI5ZmVmZmZmZmZmZmE4ZmInLFxuICAgICAgICAgICAgJzB4MWEwMTExZWEzOTdmZTY5YTRiMWJhN2I2NDM0YmFjZDc2NDc3NGI4NGYzODUxMmJmNjczMGQyYTBmNmIwZjYyNDFlYWJmZmZlYjE1M2ZmZmZiOWZlZmZmZmZmZmZhOGZiJyxcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgICAgJzB4MCcsXG4gICAgICAgICAgICAnMHgxYTAxMTFlYTM5N2ZlNjlhNGIxYmE3YjY0MzRiYWNkNzY0Nzc0Yjg0ZjM4NTEyYmY2NzMwZDJhMGY2YjBmNjI0MWVhYmZmZmViMTUzZmZmZmI5ZmVmZmZmZmZmZmE5ZDMnLFxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgICAnMHgxMicsXG4gICAgICAgICAgICAnMHgxYTAxMTFlYTM5N2ZlNjlhNGIxYmE3YjY0MzRiYWNkNzY0Nzc0Yjg0ZjM4NTEyYmY2NzMwZDJhMGY2YjBmNjI0MWVhYmZmZmViMTUzZmZmZmI5ZmVmZmZmZmZmZmFhOTknLFxuICAgICAgICBdLFxuICAgICAgICBbJzB4MScsICcweDAnXSwgLy8gTEFTVCAxXG4gICAgXSxcbl0ubWFwKChpKSA9PiBpLm1hcCgocGFpcikgPT4gRnAyLmZyb21CaWdUdXBsZShwYWlyLm1hcChCaWdJbnQpKSkpKTtcbi8vIDExLWlzb2dlbnkgbWFwIGZyb20gRScgdG8gRVxuY29uc3QgaXNvZ2VueU1hcEcxID0gaXNvZ2VueU1hcChGcCwgW1xuICAgIC8vIHhOdW1cbiAgICBbXG4gICAgICAgICcweDExYTA1ZjJiMWU4MzMzNDBiODA5MTAxZGQ5OTgxNTg1NmIzMDNlODhhMmQ3MDA1ZmYyNjI3YjU2Y2RiNGUyYzg1NjEwYzJkNWYyZTYyZDZlYWVhYzE2NjI3MzQ2NDliNycsXG4gICAgICAgICcweDE3Mjk0ZWQzZTk0M2FiMmYwNTg4YmFiMjIxNDdhODFjN2MxN2U3NWIyZjZhODQxN2Y1NjVlMzNjNzBkMWU4NmI0ODM4ZjJhNmYzMThjMzU2ZTgzNGVlZjFiM2NiODNiYicsXG4gICAgICAgICcweGQ1NDAwNWRiOTc2NzhlYzFkMTA0OGM1ZDEwYTlhMWJjZTAzMjQ3MzI5NTk4M2U1Njg3OGU1MDFlYzY4ZTI1Yzk1OGMzZTNkMmEwOTcyOWZlMDE3OWY5ZGFjOWVkY2IwJyxcbiAgICAgICAgJzB4MTc3OGU3MTY2ZmNjNmRiNzRlMDYwOWQzMDdlNTU0MTJkN2Y1ZTQ2NTZhOGRiZjI1ZjFiMzMyODlmMWIzMzA4MzUzMzZlMjVjZTMxMDcxOTNjNWIzODg2NDFkOWI2ODYxJyxcbiAgICAgICAgJzB4ZTk5NzI2YTMxOTlmNDQzNjY0MmI0YjNlNDExOGU1NDk5ZGI5OTVhMTI1N2ZiM2YwODZlZWI2NTk4MmZhYzE4OTg1YTI4NmYzMDFlNzdjNDUxMTU0Y2U5YWM4ODk1ZDknLFxuICAgICAgICAnMHgxNjMwYzMyNTBkNzMxM2ZmMDFkMTIwMWJmN2E3NGFiNWRiM2NiMTdkZDk1Mjc5OWI5ZWQzYWI5MDk3ZTY4ZjkwYTA4NzBkMmRjYWU3M2QxOWNkMTNjMWM2NmY2NTI5ODMnLFxuICAgICAgICAnMHhkNmVkNjU1M2ZlNDRkMjk2YTM3MjZjMzhhZTY1MmJmYjExNTg2MjY0ZjBmOGNlMTkwMDhlMjE4ZjljODZiMmE4ZGEyNTEyOGMxMDUyZWNhZGRkN2YyMjVhMTM5ZWQ4NCcsXG4gICAgICAgICcweDE3YjgxZTc3MDFhYmRiZTJlODc0Mzg4NGQxMTE3ZTUzMzU2ZGU1YWIyNzViNGRiMWE2ODJjNjJlZjBmMjc1MzMzOWI3YzhmOGM4ZjQ3NWFmOWNjYjU2MThlM2YwYzg4ZScsXG4gICAgICAgICcweDgwZDNjZjFmOWE3OGZjNDdiOTBiMzM1NjNiZTk5MGRjNDNiNzU2Y2U3OWY1NTc0YTJjNTk2YzkyOGM1ZDFkZTRmYTI5NWYyOTZiNzRlOTU2ZDcxOTg2YTg0OTdlMzE3JyxcbiAgICAgICAgJzB4MTY5YjFmOGUxYmNmYTdjNDJlMGMzNzUxNWQxMzhmMjJkZDJlY2I4MDNhMGM1Yzk5Njc2MzE0YmFmNGJiMWI3ZmEzMTkwYjJlZGMwMzI3Nzk3ZjI0MTA2N2JlMzkwYzllJyxcbiAgICAgICAgJzB4MTAzMjFkYTA3OWNlMDdlMjcyZDhlYzA5ZDI1NjViMGRmYTdkY2NkZGU2Nzg3Zjk2ZDUwYWYzNjAwM2IxNDg2NmY2OWI3NzFmOGMyODVkZWNjYTY3ZGYzZjE2MDVmYjdiJyxcbiAgICAgICAgJzB4NmUwOGMyNDhlMjYwZTcwYmQxZTk2MjM4MWVkZWUzZDMxZDc5ZDdlMjJjODM3YmMyM2MwYmYxYmMyNGM2YjY4YzI0YjFiODBiNjRkMzkxZmE5YzhiYTJlOGJhMmQyMjknLFxuICAgIF0sXG4gICAgLy8geERlblxuICAgIFtcbiAgICAgICAgJzB4OGNhOGQ1NDhjZmYxOWFlMThiMmU2MmY0YmQzZmE2ZjAxZDVlZjRiYTM1YjQ4YmE5Yzk1ODg2MTdmYzhhYzYyYjU1OGQ2ODFiZTM0M2RmODk5M2NmOWZhNDBkMjFiMWMnLFxuICAgICAgICAnMHgxMjU2MWE1ZGViNTU5YzQzNDhiNDcxMTI5OGU1MzYzNjcwNDFlOGNhMGNmMDgwMGMwMTI2YzI1ODhjNDhiZjU3MTNkYWE4ODQ2Y2IwMjZlOWU1YzgyNzZlYzgyYjNiZmYnLFxuICAgICAgICAnMHhiMjk2MmZlNTdhMzIyNWU4MTM3ZTYyOWJmZjI5OTFmNmY4OTQxNmY1YTcxOGNkMWZjYTY0ZTAwYjExYWNlYWNkNmEzZDA5NjdjOTRmZWRjZmNjMjM5YmE1Y2I4M2UxOScsXG4gICAgICAgICcweDM0MjU1ODFhNThhZTJmZWM4M2FhZmVmN2M0MGViNTQ1YjA4MjQzZjE2YjE2NTUxNTRjY2E4YWJjMjhkNmZkMDQ5NzZkNTI0M2VlY2Y1YzQxMzBkZTg5MzhkYzYyY2Q4JyxcbiAgICAgICAgJzB4MTNhOGUxNjIwMjI5MTRhODBhNmYxZDVmNDNlN2EwN2RmZmRmYzc1OWExMjA2MmJiOGQ2YjQ0ZTgzM2IzMDZkYTliZDI5YmE4MWYzNTc4MWQ1MzlkMzk1YjM1MzJhMjFlJyxcbiAgICAgICAgJzB4ZTczNTVmOGU0ZTY2N2I5NTUzOTBmN2YwNTA2YzZlOTM5NTczNWU5Y2U5Y2FkNGQwYTQzYmNlZjI0Yjg5ODJmNzQwMGQyNGJjNDIyOGYxMWMwMmRmOWEyOWY2MzA0YTUnLFxuICAgICAgICAnMHg3NzJjYWFjZjE2OTM2MTkwZjNlMGM2M2UwNTk2NzIxNTcwZjU3OTlhZjUzYTE4OTRlMmUwNzMwNjJhZWRlOWNlYTczYjM1MzhmMGRlMDZjZWMyNTc0NDk2ZWU4NGEzYScsXG4gICAgICAgICcweDE0YTdhYzJhOWQ2NGE4YjIzMGIzZjViMDc0Y2YwMTk5NmU3ZjYzYzIxYmNhNjhhODE5OTZlMWNkZjk4MjJjNTgwZmE1Yjk0ODlkMTFlMmQzMTFmN2Q5OWJiZGNjNWE1ZScsXG4gICAgICAgICcweGExMGVjZjZhZGE1NGY4MjVlOTIwYjNkYWZjN2EzY2NlMDdmOGQxZDcxNjEzNjZiNzQxMDBkYTY3ZjM5ODgzNTAzODI2NjkyYWJiYTQzNzA0Nzc2ZWMzYTc5YTFkNjQxJyxcbiAgICAgICAgJzB4OTVmYzEzYWI5ZTkyYWQ0NDc2ZDZlM2ViM2E1NjY4MGY2ODJiNGVlOTZmN2QwMzc3NmRmNTMzOTc4ZjMxYzE1OTMxNzRlNGI0Yjc4NjUwMDJkNjM4NGQxNjhlY2RkMGEnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLCAvLyBMQVNUIDFcbiAgICBdLFxuICAgIC8vIHlOdW1cbiAgICBbXG4gICAgICAgICcweDkwZDk3YzgxYmEyNGVlMDI1OWQxZjA5NDk4MGRjZmExMWFkMTM4ZTQ4YTg2OTUyMmI1MmFmNmM5NTY1NDNkM2NkMGM3YWVlOWIzYmEzYzJiZTk4NDU3MTk3MDdiYjMzJyxcbiAgICAgICAgJzB4MTM0OTk2YTEwNGVlNTgxMWQ1MTAzNmQ3NzZmYjQ2ODMxMjIzZTk2YzI1NGYzODNkMGY5MDYzNDNlYjY3YWQzNGQ2YzU2NzExOTYyZmE4YmZlMDk3ZTc1YTJlNDFjNjk2JyxcbiAgICAgICAgJzB4Y2M3ODZiYWE5NjZlNjZmNGEzODRjODZhM2I0OTk0MjU1MmUyZDY1OGEzMWNlMmMzNDRiZTRiOTE0MDBkYTdkMjZkNTIxNjI4YjAwNTIzYjhkZmUyNDBjNzJkZTFmNicsXG4gICAgICAgICcweDFmODYzNzZlODk4MWMyMTc4OTg3NTFhZDg3NDY3NTdkNDJhYTdiOTBlZWI3OTFjMDllNGEzZWMwMzI1MWNmOWRlNDA1YWJhOWVjNjFkZWNhNjM1NWM3N2IwZTVmNGNiJyxcbiAgICAgICAgJzB4OGNjMDNmZGVmZTBmZjEzNWNhZjRmZTJhMjE1MjljNDE5NTUzNmZiZTNjZTUwYjg3OTgzM2ZkMjIxMzUxYWRjMmVlN2Y4ZGMwOTkwNDBhODQxYjZkYWVjZjJlOGZlZGInLFxuICAgICAgICAnMHgxNjYwM2ZjYTQwNjM0YjZhMjIxMWUxMWRiOGYwYTZhMDc0YTdkMGQ0YWZhZGI3YmQ3NjUwNWMzZDNhZDU1NDRlMjAzZjYzMjZjOTVhODA3Mjk5YjIzYWIxMzYzM2E1ZjAnLFxuICAgICAgICAnMHg0YWIwYjliY2ZhYzFiYmNiMmM5NzdkMDI3Nzk2YjNjZTc1YmI4Y2EyYmUxODRjYjUyMzE0MTNjNGQ2MzRmMzc0N2E4N2FjMjQ2MGY0MTVlYzk2MWY4ODU1ZmU5ZDZmMicsXG4gICAgICAgICcweDk4N2M4ZDUzMzNhYjg2ZmRlOTkyNmJkMmNhNmM2NzQxNzBhMDViZmUzYmRkODFmZmQwMzhkYTZjMjZjODQyNjQyZjY0NTUwZmVkZmU5MzVhMTVlNGNhMzE4NzBmYjI5JyxcbiAgICAgICAgJzB4OWZjNDAxOGJkOTY2ODRiZTg4YzllMjIxZTRkYTFiYjhmM2FiZDE2Njc5ZGMyNmMxZThiNmU2YTFmMjBjYWJlNjlkNjUyMDFjNzg2MDdhMzYwMzcwZTU3N2JkYmE1ODcnLFxuICAgICAgICAnMHhlMWJiYTdhMTE4NmJkYjUyMjNhYmRlN2FkYTE0YTIzYzQyYTBjYTc5MTVhZjZmZTA2OTg1ZTdlZDFlNGQ0M2I5YjNmNzA1NWRkNGViYTZmMmJhZmFhZWJjYTczMWMzMCcsXG4gICAgICAgICcweDE5NzEzZTQ3OTM3Y2QxYmUwZGZkMGI4ZjFkNDNmYjkzY2QyZmNiY2I2Y2FmNDkzZmQxMTgzZTQxNjM4OWU2MTAzMWJmM2E1Y2NlM2ZiYWZjZTgxMzcxMWFkMDExYzEzMicsXG4gICAgICAgICcweDE4YjQ2YTkwOGYzNmY2ZGViOTE4YzE0M2ZlZDJlZGNjNTIzNTU5YjhhYWYwYzI0NjJlNmJmZTdmOTExZjY0MzI0OWQ5Y2RmNDFiNDRkNjA2Y2UwN2M4YTRkMDA3NGQ4ZScsXG4gICAgICAgICcweGIxODJjYWMxMDFiOTM5OWQxNTUwOTYwMDRmNTNmNDQ3YWE3YjEyYTM0MjZiMDhlYzAyNzEwZTgwN2I0NjMzZjA2Yzg1MWMxOTE5MjExZjIwZDRjMDRmMDBiOTcxZWY4JyxcbiAgICAgICAgJzB4MjQ1YTM5NGFkMWVjYTliNzJmYzAwYWU3YmUzMTVkYzc1N2IzYjA4MGQ0YzE1ODAxM2U2NjMyZDNjNDA2NTljYzZjZjkwYWQxYzIzMmE2NDQyZDlkM2Y1ZGI5ODAxMzMnLFxuICAgICAgICAnMHg1YzEyOTY0NWU0NGNmMTEwMmExNTlmNzQ4YzRhM2ZjNWU2NzNkODFkN2U4NjU2OGQ5YWIwZjVkMzk2YTdjZTQ2YmExMDQ5YjY1NzlhZmI3ODY2YjFlNzE1NDc1MjI0YicsXG4gICAgICAgICcweDE1ZTZiZTRlOTkwZjAzY2U0ZWE1MGIzYjQyZGYyZWI1Y2IxODFkOGY4NDk2NWEzOTU3YWRkNGZhOTVhZjAxYjJiNjY1MDI3ZWZlYzAxYzc3MDRiNDU2YmU2OWM4YjYwNCcsXG4gICAgXSxcbiAgICAvLyB5RGVuXG4gICAgW1xuICAgICAgICAnMHgxNjExMmM0YzNhOWM5OGIyNTIxODExNDBmYWQwZWFlOTYwMWE2ZGU1Nzg5ODBiZTZlZWMzMjMyYjViZTcyZTdhMDdmMzY4OGVmNjBjMjA2ZDAxNDc5MjUzYjAzNjYzYzEnLFxuICAgICAgICAnMHgxOTYyZDc1YzIzODEyMDFlMWEwY2JkNmM0M2MzNDhiODg1Yzg0ZmY3MzFjNGQ1OWNhNGExMDM1NmY0NTNlMDFmNzhhNDI2MDc2MzUyOWUzNTMyZjYxMDJjMmU0OWEwM2QnLFxuICAgICAgICAnMHg1OGRmMzMwNjY0MGRhMjc2ZmFhYWU3ZDZlOGViMTU3NzhjNDg1NTU1MWFlN2YzMTBjMzVhNWRkMjc5Y2QyZWNhNjc1N2NkNjM2Zjk2Zjg5MWUyNTM4YjUzZGJmNjdmMicsXG4gICAgICAgICcweDE2YjdkMjg4Nzk4ZTUzOTVmMjBkMjNiZjg5ZWRiNGQxZDExNWM1ZGJkZGJjZDMwZTEyM2RhNDg5ZTcyNmFmNDE3MjczNjRmMmMyODI5N2FkYThkMjZkOTg0NDVmNTQxNicsXG4gICAgICAgICcweGJlMGUwNzk1NDVmNDNlNGIwMGNjOTEyZjgyMjhkZGNjNmQxOWM5ZjBmNjliYmIwNTQyZWRhMGZjOWRlYzkxNmEyMGIxNWRjMGZkMmVkZWRkYTM5MTQyMzExYTUwMDFkJyxcbiAgICAgICAgJzB4OGQ5ZTUyOTcxODZkYjJkOWZiMjY2ZWFhYzc4MzE4MmI3MDE1MmM2NTU1MGQ4ODFjNWVjZDg3YjZmMGY1YTY0NDlmMzhkYjlkZmE5Y2NlMjAyYzY0NzdmYWFmOWI3YWMnLFxuICAgICAgICAnMHgxNjYwMDdjMDhhOTlkYjJmYzNiYTg3MzRhY2U5ODI0YjVlZWNmZGZhOGQwY2Y4ZWY1ZGQzNjViYzQwMGEwMDUxZDVmYTljMDFhNThiMWZiOTNkMWExMzk5MTI2YTc3NWMnLFxuICAgICAgICAnMHgxNmEzZWYwOGJlM2VhN2VhMDNiY2RkZmFiYmE2ZmY2ZWU1YTQzNzVlZmExZjRmZDdmZWIzNGZkMjA2MzU3MTMyYjkyMGY1YjAwODAxZGVlNDYwZWU0MTVhMTU4MTJlZDknLFxuICAgICAgICAnMHgxODY2YzhlZDMzNmM2MTIzMWExYmU1NGZkMWQ3NGNjNGY5ZmIwY2U0YzZhZjU5MjBhYmM1NzUwYzRiZjM5YjQ4NTJjZmUyZjdiYjkyNDg4MzZiMjMzZDlkNTU1MzVkNGEnLFxuICAgICAgICAnMHgxNjdhNTVjZGE3MGE2ZTFjZWE4MjA1OTdkOTRhODQ5MDMyMTZmNzYzZTEzZDg3YmI1MzA4NTkyZTdlYTdkNGZiYzczODVlYTNkNTI5YjM1ZTM0NmVmNDhiYjg5MTNmNTUnLFxuICAgICAgICAnMHg0ZDJmMjU5ZWVhNDA1YmQ0OGYwMTBhMDFhZDI5MTFkOWM2ZGQwMzliYjYxYTYyOTBlNTkxYjM2ZTYzNmE1Yzg3MWE1YzI5ZjRmODMwNjA0MDBmOGI0OWNiYThmNmFhOCcsXG4gICAgICAgICcweGFjY2JiNjc0ODFkMDMzZmY1ODUyYzFlNDhjNTBjNDc3Zjk0ZmY4YWVmY2U0MmQyOGMwZjlhODhjZWE3OTEzNTE2Zjk2ODk4NmY3ZWJiZWE5Njg0YjUyOWUyNTYxMDkyJyxcbiAgICAgICAgJzB4YWQ2Yjk1MTRjNzY3ZmUzYzM2MTMxNDRiNDVmMTQ5NjU0MzM0NmQ5OGFkZjAyMjY3ZDVjZWVmOWEwMGQ5Yjg2OTMwMDA3NjNlM2I5MGFjMTFlOTliMTM4NTczMzQ1Y2MnLFxuICAgICAgICAnMHgyNjYwNDAwZWIyZTRmM2I2MjhiZGQwZDUzY2Q3NmYyYmY1NjViOTRlNzI5MjdjMWNiNzQ4ZGYyNzk0MjQ4MGU0MjA1MTdiZDg3MTRjYzgwZDFmYWRjMTMyNmVkMDZmNycsXG4gICAgICAgICcweGUwZmExZDgxNmRkYzAzZTZiMjQyNTVlMGQ3ODE5YzE3MWM0MGY2NWUyNzNiODUzMzI0ZWZjZDYzNTZjYWEyMDVjYTJmNTcwZjEzNDk3ODA0NDE1NDczYTFkNjM0YjhmJyxcbiAgICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgXSxcbl0ubWFwKChpKSA9PiBpLm1hcCgoaikgPT4gQmlnSW50KGopKSkpO1xuLy8gU1dVIE1hcCAtIEZwMiB0byBHMic6IHnCsiA9IHjCsyArIDI0MGkgKiB4ICsgMTAxMiArIDEwMTJpXG5jb25zdCBHMl9TV1UgPSBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwMiwge1xuICAgIEE6IEZwMi5jcmVhdGUoeyBjMDogRnAuY3JlYXRlKF8wbiksIGMxOiBGcC5jcmVhdGUoQmlnSW50KDI0MCkpIH0pLCAvLyBBJyA9IDI0MCAqIElcbiAgICBCOiBGcDIuY3JlYXRlKHsgYzA6IEZwLmNyZWF0ZShCaWdJbnQoMTAxMikpLCBjMTogRnAuY3JlYXRlKEJpZ0ludCgxMDEyKSkgfSksIC8vIEInID0gMTAxMiAqICgxICsgSSlcbiAgICBaOiBGcDIuY3JlYXRlKHsgYzA6IEZwLmNyZWF0ZShCaWdJbnQoLTIpKSwgYzE6IEZwLmNyZWF0ZShCaWdJbnQoLTEpKSB9KSwgLy8gWjogLSgyICsgSSlcbn0pO1xuLy8gT3B0aW1pemVkIFNXVSBNYXAgLSBGcCB0byBHMVxuY29uc3QgRzFfU1dVID0gbWFwVG9DdXJ2ZVNpbXBsZVNXVShGcCwge1xuICAgIEE6IEZwLmNyZWF0ZShCaWdJbnQoJzB4MTQ0Njk4YTNiOGU5NDMzZDY5M2EwMmM5NmQ0OTgyYjBlYTk4NTM4M2VlNjZhOGQ4ZTg5ODFhZWZkODgxYWM5ODkzNmY4ZGEwZTBmOTdmNWNmNDI4MDgyZDU4NGMxZCcpKSxcbiAgICBCOiBGcC5jcmVhdGUoQmlnSW50KCcweDEyZTI5MDhkMTE2ODgwMzAwMThiMTJlODc1M2VlZTNiMjAxNmMxZjBmMjRmNDA3MGEwYjljMTRmY2VmMzVlZjU1YTIzMjE1YTMxNmNlYWE1ZDFjYzQ4ZTk4ZTE3MmJlMCcpKSxcbiAgICBaOiBGcC5jcmVhdGUoQmlnSW50KDExKSksXG59KTtcbi8vIEVuZG9tb3JwaGlzbXMgKGZvciBmYXN0IGNvZmFjdG9yIGNsZWFyaW5nKVxuLy8gzqgoUCkgZW5kb21vcnBoaXNtXG5jb25zdCB1dF9yb290ID0gRnA2LmNyZWF0ZSh7IGMwOiBGcDIuWkVSTywgYzE6IEZwMi5PTkUsIGMyOiBGcDIuWkVSTyB9KTtcbmNvbnN0IHdzcSA9IEZwMTIuY3JlYXRlKHsgYzA6IHV0X3Jvb3QsIGMxOiBGcDYuWkVSTyB9KTtcbmNvbnN0IHdjdSA9IEZwMTIuY3JlYXRlKHsgYzA6IEZwNi5aRVJPLCBjMTogdXRfcm9vdCB9KTtcbmNvbnN0IFt3c3FfaW52LCB3Y3VfaW52XSA9IEZwMTIuaW52ZXJ0QmF0Y2goW3dzcSwgd2N1XSk7XG5mdW5jdGlvbiBwc2koeCwgeSkge1xuICAgIC8vIFVudHdpc3QgRnAyLT5GcDEyICYmIGZyb2Jlbml1cygxKSAmJiB0d2lzdCBiYWNrXG4gICAgY29uc3QgeDIgPSBGcDEyLm11bChGcDEyLmZyb2Jlbml1c01hcChGcDEyLm11bHRpcGx5QnlGcDIod3NxX2ludiwgeCksIDEpLCB3c3EpLmMwLmMwO1xuICAgIGNvbnN0IHkyID0gRnAxMi5tdWwoRnAxMi5mcm9iZW5pdXNNYXAoRnAxMi5tdWx0aXBseUJ5RnAyKHdjdV9pbnYsIHkpLCAxKSwgd2N1KS5jMC5jMDtcbiAgICByZXR1cm4gW3gyLCB5Ml07XG59XG4vLyDOqCBlbmRvbW9ycGhpc21cbmZ1bmN0aW9uIEcycHNpKGMsIFApIHtcbiAgICBjb25zdCBhZmZpbmUgPSBQLnRvQWZmaW5lKCk7XG4gICAgY29uc3QgcCA9IHBzaShhZmZpbmUueCwgYWZmaW5lLnkpO1xuICAgIHJldHVybiBuZXcgYyhwWzBdLCBwWzFdLCBGcDIuT05FKTtcbn1cbi8vIM6owrIoUCkgZW5kb21vcnBoaXNtXG4vLyAxIC8gRjIoMileKChwLTEpLzMpIGluIEdGKHDCsilcbmNvbnN0IFBTSTJfQzEgPSBCaWdJbnQoJzB4MWEwMTExZWEzOTdmZTY5OWVjMDI0MDg2NjNkNGRlODVhYTBkODU3ZDg5NzU5YWQ0ODk3ZDI5NjUwZmI4NWY5YjQwOTQyN2ViNGY0OWZmZmQ4YmZkMDAwMDAwMDBhYWFjJyk7XG5mdW5jdGlvbiBwc2kyKHgsIHkpIHtcbiAgICByZXR1cm4gW0ZwMi5tdWwoeCwgUFNJMl9DMSksIEZwMi5uZWcoeSldO1xufVxuZnVuY3Rpb24gRzJwc2kyKGMsIFApIHtcbiAgICBjb25zdCBhZmZpbmUgPSBQLnRvQWZmaW5lKCk7XG4gICAgY29uc3QgcCA9IHBzaTIoYWZmaW5lLngsIGFmZmluZS55KTtcbiAgICByZXR1cm4gbmV3IGMocFswXSwgcFsxXSwgRnAyLk9ORSk7XG59XG4vLyBEZWZhdWx0IGhhc2hfdG9fZmllbGQgb3B0aW9ucyBhcmUgZm9yIGhhc2ggdG8gRzIuXG4vL1xuLy8gUGFyYW1ldGVyIGRlZmluaXRpb25zIGFyZSBpbiBzZWN0aW9uIDUuMyBvZiB0aGUgc3BlYyB1bmxlc3Mgb3RoZXJ3aXNlIG5vdGVkLlxuLy8gUGFyYW1ldGVyIHZhbHVlcyBjb21lIGZyb20gc2VjdGlvbiA4LjguMiBvZiB0aGUgc3BlYy5cbi8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tOC44LjJcbi8vXG4vLyBCYXNlIGZpZWxkIEYgaXMgR0YocF5tKVxuLy8gcCA9IDB4MWEwMTExZWEzOTdmZTY5YTRiMWJhN2I2NDM0YmFjZDc2NDc3NGI4NGYzODUxMmJmNjczMGQyYTBmNmIwZjYyNDFlYWJmZmZlYjE1M2ZmZmZiOWZlZmZmZmZmZmZhYWFiXG4vLyBtID0gMiAob3IgMSBmb3IgRzEgc2VlIHNlY3Rpb24gOC44LjEpXG4vLyBrID0gMTI4XG5jb25zdCBodGZEZWZhdWx0cyA9IE9iamVjdC5mcmVlemUoe1xuICAgIC8vIERTVDogYSBkb21haW4gc2VwYXJhdGlvbiB0YWdcbiAgICAvLyBkZWZpbmVkIGluIHNlY3Rpb24gMi4yLjVcbiAgICAvLyBVc2UgdXRpbHMuZ2V0RFNUTGFiZWwoKSwgdXRpbHMuc2V0RFNUTGFiZWwodmFsdWUpXG4gICAgRFNUOiAnQkxTX1NJR19CTFMxMjM4MUcyX1hNRDpTSEEtMjU2X1NTV1VfUk9fTlVMXycsXG4gICAgZW5jb2RlRFNUOiAnQkxTX1NJR19CTFMxMjM4MUcyX1hNRDpTSEEtMjU2X1NTV1VfUk9fTlVMXycsXG4gICAgLy8gcDogdGhlIGNoYXJhY3RlcmlzdGljIG9mIEZcbiAgICAvLyAgICB3aGVyZSBGIGlzIGEgZmluaXRlIGZpZWxkIG9mIGNoYXJhY3RlcmlzdGljIHAgYW5kIG9yZGVyIHEgPSBwXm1cbiAgICBwOiBGcC5PUkRFUixcbiAgICAvLyBtOiB0aGUgZXh0ZW5zaW9uIGRlZ3JlZSBvZiBGLCBtID49IDFcbiAgICAvLyAgICAgd2hlcmUgRiBpcyBhIGZpbml0ZSBmaWVsZCBvZiBjaGFyYWN0ZXJpc3RpYyBwIGFuZCBvcmRlciBxID0gcF5tXG4gICAgbTogMixcbiAgICAvLyBrOiB0aGUgdGFyZ2V0IHNlY3VyaXR5IGxldmVsIGZvciB0aGUgc3VpdGUgaW4gYml0c1xuICAgIC8vIGRlZmluZWQgaW4gc2VjdGlvbiA1LjFcbiAgICBrOiAxMjgsXG4gICAgLy8gb3B0aW9uIHRvIHVzZSBhIG1lc3NhZ2UgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIHByb2Nlc3NlZCBieVxuICAgIC8vIGV4cGFuZF9tZXNzYWdlX3htZFxuICAgIGV4cGFuZDogJ3htZCcsXG4gICAgLy8gSGFzaCBmdW5jdGlvbnMgZm9yOiBleHBhbmRfbWVzc2FnZV94bWQgaXMgYXBwcm9wcmlhdGUgZm9yIHVzZSB3aXRoIGFcbiAgICAvLyB3aWRlIHJhbmdlIG9mIGhhc2ggZnVuY3Rpb25zLCBpbmNsdWRpbmcgU0hBLTIsIFNIQS0zLCBCTEFLRTIsIGFuZCBvdGhlcnMuXG4gICAgLy8gQkJTKyB1c2VzIGJsYWtlMjogaHR0cHM6Ly9naXRodWIuY29tL2h5cGVybGVkZ2VyL2FyaWVzLWZyYW1ld29yay1nby9pc3N1ZXMvMjI0N1xuICAgIGhhc2g6IHNoYTI1Nixcbn0pO1xuLy8gRW5jb2RpbmcgdXRpbHNcbi8vIFBvaW50IG9uIEcxIGN1cnZlOiAoeCwgeSlcbi8vIENvbXByZXNzZWQgcG9pbnQgb2YgaW5maW5pdHlcbmNvbnN0IENPTVBSRVNTRURfWkVSTyA9IHNldE1hc2soRnAudG9CeXRlcyhfMG4pLCB7IGluZmluaXR5OiB0cnVlLCBjb21wcmVzc2VkOiB0cnVlIH0pOyAvLyBzZXQgY29tcHJlc3NlZCAmIHBvaW50LWF0LWluZmluaXR5IGJpdHNcbmZ1bmN0aW9uIHBhcnNlTWFzayhieXRlcykge1xuICAgIC8vIENvcHksIHNvIHdlIGNhbiByZW1vdmUgbWFzayBkYXRhLiBJdCB3aWxsIGJlIHJlbW92ZWQgYWxzbyBsYXRlciwgd2hlbiBGcC5jcmVhdGUgd2lsbCBjYWxsIG1vZHVsby5cbiAgICBieXRlcyA9IGJ5dGVzLnNsaWNlKCk7XG4gICAgY29uc3QgbWFzayA9IGJ5dGVzWzBdICYgMjI0O1xuICAgIGNvbnN0IGNvbXByZXNzZWQgPSAhISgobWFzayA+PiA3KSAmIDEpOyAvLyBjb21wcmVzc2lvbiBiaXQgKDBiMTAwMF8wMDAwKVxuICAgIGNvbnN0IGluZmluaXR5ID0gISEoKG1hc2sgPj4gNikgJiAxKTsgLy8gcG9pbnQgYXQgaW5maW5pdHkgYml0ICgwYjAxMDBfMDAwMClcbiAgICBjb25zdCBzb3J0ID0gISEoKG1hc2sgPj4gNSkgJiAxKTsgLy8gc29ydCBiaXQgKDBiMDAxMF8wMDAwKVxuICAgIGJ5dGVzWzBdICY9IDMxOyAvLyBjbGVhciBtYXNrICh6ZXJvIGZpcnN0IDMgYml0cylcbiAgICByZXR1cm4geyBjb21wcmVzc2VkLCBpbmZpbml0eSwgc29ydCwgdmFsdWU6IGJ5dGVzIH07XG59XG5mdW5jdGlvbiBzZXRNYXNrKGJ5dGVzLCBtYXNrKSB7XG4gICAgaWYgKGJ5dGVzWzBdICYgMjI0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldE1hc2s6IG5vbi1lbXB0eSBtYXNrJyk7XG4gICAgaWYgKG1hc2suY29tcHJlc3NlZClcbiAgICAgICAgYnl0ZXNbMF0gfD0gMTI4O1xuICAgIGlmIChtYXNrLmluZmluaXR5KVxuICAgICAgICBieXRlc1swXSB8PSA2NDtcbiAgICBpZiAobWFzay5zb3J0KVxuICAgICAgICBieXRlc1swXSB8PSAzMjtcbiAgICByZXR1cm4gYnl0ZXM7XG59XG5mdW5jdGlvbiBzaWduYXR1cmVHMVRvUmF3Qnl0ZXMocG9pbnQpIHtcbiAgICBwb2ludC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgIGNvbnN0IGlzWmVybyA9IHBvaW50LmVxdWFscyhibHMxMl8zODEuRzEuUHJvamVjdGl2ZVBvaW50LlpFUk8pO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gcG9pbnQudG9BZmZpbmUoKTtcbiAgICBpZiAoaXNaZXJvKVxuICAgICAgICByZXR1cm4gQ09NUFJFU1NFRF9aRVJPLnNsaWNlKCk7XG4gICAgY29uc3QgUCA9IEZwLk9SREVSO1xuICAgIGNvbnN0IHNvcnQgPSBCb29sZWFuKCh5ICogXzJuKSAvIFApO1xuICAgIHJldHVybiBzZXRNYXNrKG51bWJlclRvQnl0ZXNCRSh4LCBGcC5CWVRFUyksIHsgY29tcHJlc3NlZDogdHJ1ZSwgc29ydCB9KTtcbn1cbmZ1bmN0aW9uIHNpZ25hdHVyZUcyVG9SYXdCeXRlcyhwb2ludCkge1xuICAgIC8vIE5PVEU6IGJ5IHNvbWUgcmVhc29ucyBpdCB3YXMgbWlzc2VkIGluIGJsczEyLTM4MSwgbG9va3MgbGlrZSBidWdcbiAgICBwb2ludC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgIGNvbnN0IGxlbiA9IEZwLkJZVEVTO1xuICAgIGlmIChwb2ludC5lcXVhbHMoYmxzMTJfMzgxLkcyLlByb2plY3RpdmVQb2ludC5aRVJPKSlcbiAgICAgICAgcmV0dXJuIGNvbmNhdEIoQ09NUFJFU1NFRF9aRVJPLCBudW1iZXJUb0J5dGVzQkUoXzBuLCBsZW4pKTtcbiAgICBjb25zdCB7IHgsIHkgfSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgY29uc3QgeyByZTogeDAsIGltOiB4MSB9ID0gRnAyLnJlaW0oeCk7XG4gICAgY29uc3QgeyByZTogeTAsIGltOiB5MSB9ID0gRnAyLnJlaW0oeSk7XG4gICAgY29uc3QgdG1wID0geTEgPiBfMG4gPyB5MSAqIF8ybiA6IHkwICogXzJuO1xuICAgIGNvbnN0IHNvcnQgPSBCb29sZWFuKCh0bXAgLyBGcC5PUkRFUikgJiBfMW4pO1xuICAgIGNvbnN0IHoyID0geDA7XG4gICAgcmV0dXJuIGNvbmNhdEIoc2V0TWFzayhudW1iZXJUb0J5dGVzQkUoeDEsIGxlbiksIHsgc29ydCwgY29tcHJlc3NlZDogdHJ1ZSB9KSwgbnVtYmVyVG9CeXRlc0JFKHoyLCBsZW4pKTtcbn1cbi8vIFRvIHZlcmlmeSBjdXJ2ZSBwYXJhbWV0ZXJzLCBzZWUgcGFpcmluZy1mcmllbmRseS1jdXJ2ZXMgc3BlYzpcbi8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaXJ0Zi1jZnJnLXBhaXJpbmctZnJpZW5kbHktY3VydmVzLTExXG4vLyBCYXNpYyBtYXRoIGlzIGRvbmUgb3ZlciBmaW5pdGUgZmllbGRzIG92ZXIgcC5cbi8vIE1vcmUgY29tcGxpY2F0ZWQgbWF0aCBpcyBkb25lIG92ZXIgcG9seW5vbWluYWwgZXh0ZW5zaW9uIGZpZWxkcy5cbi8vIFRvIHNpbXBsaWZ5IGNhbGN1bGF0aW9ucyBpbiBGcDEyLCB3ZSBjb25zdHJ1Y3QgZXh0ZW5zaW9uIHRvd2VyOlxuLy8gRnDigoHigoIgPSBGcOKChsKyID0+IEZw4oKCwrNcbi8vIEZwKHUpIC8gKHXCsiAtIM6yKSB3aGVyZSDOsiA9IC0xXG4vLyBGcOKCgih2KSAvICh2wrMgLSDOvikgd2hlcmUgzr4gPSB1ICsgMVxuLy8gRnDigoYodykgLyAod8KyIC0gzrMpIHdoZXJlIM6zID0gdlxuLy8gSGVyZSBnb2VzIGNvbnN0YW50cyAmJiBwb2ludCBlbmNvZGluZyBmb3JtYXRcbmV4cG9ydCBjb25zdCBibHMxMl8zODEgPSBibHMoe1xuICAgIC8vIEZpZWxkc1xuICAgIGZpZWxkczoge1xuICAgICAgICBGcCxcbiAgICAgICAgRnAyLFxuICAgICAgICBGcDYsXG4gICAgICAgIEZwMTIsXG4gICAgICAgIEZyLFxuICAgIH0sXG4gICAgLy8gRzEgaXMgdGhlIG9yZGVyLXEgc3ViZ3JvdXAgb2YgRTEoRnApIDogecKyID0geMKzICsgNCwgI0UxKEZwKSA9IGgxcSwgd2hlcmVcbiAgICAvLyBjaGFyYWN0ZXJpc3RpYzsgeiArICh64oG0IC0gesKyICsgMSkoeiAtIDEpwrIvM1xuICAgIEcxOiB7XG4gICAgICAgIEZwLFxuICAgICAgICAvLyBjb2ZhY3RvcjsgKHogLSAxKcKyLzNcbiAgICAgICAgaDogQmlnSW50KCcweDM5NmM4YzAwNTU1NWUxNTY4YzAwYWFhYjAwMDBhYWFiJyksXG4gICAgICAgIC8vIGdlbmVyYXRvcidzIGNvb3JkaW5hdGVzXG4gICAgICAgIC8vIHggPSAzNjg1NDE2NzUzNzEzMzg3MDE2NzgxMDg4MzE1MTgzMDc3NzU3OTYxNjIwNzk1NzgyNTQ2NDA5ODk0NTc4Mzc4Njg4NjA3NTkyMzc4Mzc2MzE4ODM2MDU0OTQ3Njc2MzQ1ODIxNTQ4MTA0MTg1NDY0NTA3XG4gICAgICAgIC8vIHkgPSAxMzM5NTA2NTQ0OTQ0NDc2NDczMDIwNDcxMzc5OTQxOTIxMjIxNTg0OTMzODc1OTM4MzQ5NjIwNDI2NTQzNzM2NDE2NTExNDIzOTU2MzMzNTA2NDcyNzI0NjU1MzUzMzY2NTM0OTkyMzkxNzU2NDQxNTY5XG4gICAgICAgIEd4OiBCaWdJbnQoJzB4MTdmMWQzYTczMTk3ZDc5NDI2OTU2MzhjNGZhOWFjMGZjMzY4OGM0Zjk3NzRiOTA1YTE0ZTNhM2YxNzFiYWM1ODZjNTVlODNmZjk3YTFhZWZmYjNhZjAwYWRiMjJjNmJiJyksXG4gICAgICAgIEd5OiBCaWdJbnQoJzB4MDhiM2Y0ODFlM2FhYTBmMWEwOWUzMGVkNzQxZDhhZTRmY2Y1ZTA5NWQ1ZDAwYWY2MDBkYjE4Y2IyYzA0YjNlZGQwM2NjNzQ0YTI4ODhhZTQwY2FhMjMyOTQ2YzVlN2UxJyksXG4gICAgICAgIGE6IEZwLlpFUk8sXG4gICAgICAgIGI6IF80bixcbiAgICAgICAgaHRmRGVmYXVsdHM6IHsgLi4uaHRmRGVmYXVsdHMsIG06IDEsIERTVDogJ0JMU19TSUdfQkxTMTIzODFHMV9YTUQ6U0hBLTI1Nl9TU1dVX1JPX05VTF8nIH0sXG4gICAgICAgIHdyYXBQcml2YXRlS2V5OiB0cnVlLFxuICAgICAgICBhbGxvd0luZmluaXR5UG9pbnQ6IHRydWUsXG4gICAgICAgIC8vIENoZWNrcyBpcyB0aGUgcG9pbnQgcmVzaWRlcyBpbiBwcmltZS1vcmRlciBzdWJncm91cC5cbiAgICAgICAgLy8gcG9pbnQuaXNUb3JzaW9uRnJlZSgpIHNob3VsZCByZXR1cm4gdHJ1ZSBmb3IgdmFsaWQgcG9pbnRzXG4gICAgICAgIC8vIEl0IHJldHVybnMgZmFsc2UgZm9yIHNoaXR0eSBwb2ludHMuXG4gICAgICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMjEvMTEzMC5wZGZcbiAgICAgICAgaXNUb3JzaW9uRnJlZTogKGMsIHBvaW50KSA9PiB7XG4gICAgICAgICAgICAvLyDPhiBlbmRvbW9ycGhpc21cbiAgICAgICAgICAgIGNvbnN0IGN1YmljUm9vdE9mVW5pdHlNb2RQID0gQmlnSW50KCcweDVmMTk2NzJmZGY3NmNlNTFiYTY5YzYwNzZhMGY3N2VhZGRiM2E5M2JlNmY4OTY4OGRlMTdkODEzNjIwYTAwMDIyZTAxZmZmZmZmZmVmZmZlJyk7XG4gICAgICAgICAgICBjb25zdCBwaGkgPSBuZXcgYyhGcC5tdWwocG9pbnQucHgsIGN1YmljUm9vdE9mVW5pdHlNb2RQKSwgcG9pbnQucHksIHBvaW50LnB6KTtcbiAgICAgICAgICAgIC8vIHRvZG86IHVucm9sbFxuICAgICAgICAgICAgY29uc3QgeFAgPSBwb2ludC5tdWx0aXBseVVuc2FmZShibHMxMl8zODEucGFyYW1zLngpLm5lZ2F0ZSgpOyAvLyBbeF1QXG4gICAgICAgICAgICBjb25zdCB1MlAgPSB4UC5tdWx0aXBseVVuc2FmZShibHMxMl8zODEucGFyYW1zLngpOyAvLyBbdTJdUFxuICAgICAgICAgICAgcmV0dXJuIHUyUC5lcXVhbHMocGhpKTtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTkvODE0LnBkZlxuICAgICAgICAgICAgLy8gKHrCsiDiiJIgMSkvM1xuICAgICAgICAgICAgLy8gY29uc3QgYzEgPSBCaWdJbnQoJzB4Mzk2YzhjMDA1NTU1ZTE1NjAwMDAwMDAwNTU1NTU1NTUnKTtcbiAgICAgICAgICAgIC8vIGNvbnN0IFAgPSB0aGlzO1xuICAgICAgICAgICAgLy8gY29uc3QgUyA9IFAuc2lnbWEoKTtcbiAgICAgICAgICAgIC8vIGNvbnN0IFEgPSBTLmRvdWJsZSgpO1xuICAgICAgICAgICAgLy8gY29uc3QgUzIgPSBTLnNpZ21hKCk7XG4gICAgICAgICAgICAvLyAvLyBbKHrCsiDiiJIgMSkvM10oMs+DKFApIOKIkiBQIOKIkiDPg8KyKFApKSDiiJIgz4PCsihQKSA9IE9cbiAgICAgICAgICAgIC8vIGNvbnN0IGxlZnQgPSBRLnN1YnRyYWN0KFApLnN1YnRyYWN0KFMyKS5tdWx0aXBseVVuc2FmZShjMSk7XG4gICAgICAgICAgICAvLyBjb25zdCBDID0gbGVmdC5zdWJ0cmFjdChTMik7XG4gICAgICAgICAgICAvLyByZXR1cm4gQy5pc1plcm8oKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQ2xlYXIgY29mYWN0b3Igb2YgRzFcbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxOS80MDNcbiAgICAgICAgY2xlYXJDb2ZhY3RvcjogKF9jLCBwb2ludCkgPT4ge1xuICAgICAgICAgICAgLy8gcmV0dXJuIHRoaXMubXVsdGlwbHlVbnNhZmUoQ1VSVkUuaCk7XG4gICAgICAgICAgICByZXR1cm4gcG9pbnQubXVsdGlwbHlVbnNhZmUoYmxzMTJfMzgxLnBhcmFtcy54KS5hZGQocG9pbnQpOyAvLyB4KlAgKyBQXG4gICAgICAgIH0sXG4gICAgICAgIG1hcFRvQ3VydmU6IChzY2FsYXJzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IEcxX1NXVShGcC5jcmVhdGUoc2NhbGFyc1swXSkpO1xuICAgICAgICAgICAgcmV0dXJuIGlzb2dlbnlNYXBHMSh4LCB5KTtcbiAgICAgICAgfSxcbiAgICAgICAgZnJvbUJ5dGVzOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgY29tcHJlc3NlZCwgaW5maW5pdHksIHNvcnQsIHZhbHVlIH0gPSBwYXJzZU1hc2soYnl0ZXMpO1xuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gNDggJiYgY29tcHJlc3NlZCkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IEZwLmJ5dGVzXG4gICAgICAgICAgICAgICAgY29uc3QgUCA9IEZwLk9SREVSO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXByZXNzZWRWYWx1ZSA9IGJ5dGVzVG9OdW1iZXJCRSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgLy8gWmVyb1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBGcC5jcmVhdGUoY29tcHJlc3NlZFZhbHVlICYgRnAuTUFTSyk7XG4gICAgICAgICAgICAgICAgaWYgKGluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh4ICE9PSBfMG4pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0cxOiBub24tZW1wdHkgY29tcHJlc3NlZCBwb2ludCBhdCBpbmZpbml0eScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB4OiBfMG4sIHk6IF8wbiB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByaWdodCA9IEZwLmFkZChGcC5wb3coeCwgXzNuKSwgRnAuY3JlYXRlKGJsczEyXzM4MS5wYXJhbXMuRzFiKSk7IC8vIHnCsiA9IHjCsyArIGJcbiAgICAgICAgICAgICAgICBsZXQgeSA9IEZwLnNxcnQocmlnaHQpO1xuICAgICAgICAgICAgICAgIGlmICgheSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvbXByZXNzZWQgRzEgcG9pbnQnKTtcbiAgICAgICAgICAgICAgICBpZiAoKHkgKiBfMm4pIC8gUCAhPT0gQmlnSW50KHNvcnQpKVxuICAgICAgICAgICAgICAgICAgICB5ID0gRnAubmVnKHkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IEZwLmNyZWF0ZSh4KSwgeTogRnAuY3JlYXRlKHkpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5sZW5ndGggPT09IDk2ICYmICFjb21wcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGluZmluaXR5IGZsYWcgaXMgc2V0XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IGJ5dGVzVG9OdW1iZXJCRSh2YWx1ZS5zdWJhcnJheSgwLCBGcC5CWVRFUykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBieXRlc1RvTnVtYmVyQkUodmFsdWUuc3ViYXJyYXkoRnAuQllURVMpKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHggIT09IF8wbiB8fCB5ICE9PSBfMG4pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0cxOiBub24tZW1wdHkgcG9pbnQgYXQgaW5maW5pdHknKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJsczEyXzM4MS5HMS5Qcm9qZWN0aXZlUG9pbnQuWkVSTy50b0FmZmluZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyB4OiBGcC5jcmVhdGUoeCksIHk6IEZwLmNyZWF0ZSh5KSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBvaW50IEcxLCBleHBlY3RlZCA0OC85NiBieXRlcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0b0J5dGVzOiAoYywgcG9pbnQsIGlzQ29tcHJlc3NlZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXNaZXJvID0gcG9pbnQuZXF1YWxzKGMuWkVSTyk7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgICAgICAgICBpZiAoaXNDb21wcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzWmVybylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENPTVBSRVNTRURfWkVSTy5zbGljZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IFAgPSBGcC5PUkRFUjtcbiAgICAgICAgICAgICAgICBjb25zdCBzb3J0ID0gQm9vbGVhbigoeSAqIF8ybikgLyBQKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0TWFzayhudW1iZXJUb0J5dGVzQkUoeCwgRnAuQllURVMpLCB7IGNvbXByZXNzZWQ6IHRydWUsIHNvcnQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNaZXJvKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIDJ4IFBVQkxJQ19LRVlfTEVOR1RIXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHggPSBjb25jYXRCKG5ldyBVaW50OEFycmF5KFsweDQwXSksIG5ldyBVaW50OEFycmF5KDIgKiBGcC5CWVRFUyAtIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uY2F0QihudW1iZXJUb0J5dGVzQkUoeCwgRnAuQllURVMpLCBudW1iZXJUb0J5dGVzQkUoeSwgRnAuQllURVMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFNob3J0U2lnbmF0dXJlOiB7XG4gICAgICAgICAgICBmcm9tSGV4KGhleCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaW5maW5pdHksIHNvcnQsIHZhbHVlIH0gPSBwYXJzZU1hc2soZW5zdXJlQnl0ZXMoJ3NpZ25hdHVyZUhleCcsIGhleCwgNDgpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBQID0gRnAuT1JERVI7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcHJlc3NlZFZhbHVlID0gYnl0ZXNUb051bWJlckJFKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAvLyBaZXJvXG4gICAgICAgICAgICAgICAgaWYgKGluZmluaXR5KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmxzMTJfMzgxLkcxLlByb2plY3RpdmVQb2ludC5aRVJPO1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBGcC5jcmVhdGUoY29tcHJlc3NlZFZhbHVlICYgRnAuTUFTSyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBGcC5hZGQoRnAucG93KHgsIF8zbiksIEZwLmNyZWF0ZShibHMxMl8zODEucGFyYW1zLkcxYikpOyAvLyB5wrIgPSB4wrMgKyBiXG4gICAgICAgICAgICAgICAgbGV0IHkgPSBGcC5zcXJ0KHJpZ2h0KTtcbiAgICAgICAgICAgICAgICBpZiAoIXkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb21wcmVzc2VkIEcxIHBvaW50Jyk7XG4gICAgICAgICAgICAgICAgY29uc3QgYWZsYWcgPSBCaWdJbnQoc29ydCk7XG4gICAgICAgICAgICAgICAgaWYgKCh5ICogXzJuKSAvIFAgIT09IGFmbGFnKVxuICAgICAgICAgICAgICAgICAgICB5ID0gRnAubmVnKHkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gYmxzMTJfMzgxLkcxLlByb2plY3RpdmVQb2ludC5mcm9tQWZmaW5lKHsgeCwgeSB9KTtcbiAgICAgICAgICAgICAgICBwb2ludC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b1Jhd0J5dGVzKHBvaW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25hdHVyZUcxVG9SYXdCeXRlcyhwb2ludCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9IZXgocG9pbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnl0ZXNUb0hleChzaWduYXR1cmVHMVRvUmF3Qnl0ZXMocG9pbnQpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICAvLyBHMiBpcyB0aGUgb3JkZXItcSBzdWJncm91cCBvZiBFMihGcMKyKSA6IHnCsiA9IHjCsys0KDEr4oia4oiSMSksXG4gICAgLy8gd2hlcmUgRnAyIGlzIEZwW+KImuKIkjFdLyh4MisxKS4gI0UyKEZwMiApID0gaDJxLCB3aGVyZVxuICAgIC8vIEfCsiAtIDFcbiAgICAvLyBoMnFcbiAgICBHMjoge1xuICAgICAgICBGcDogRnAyLFxuICAgICAgICAvLyBjb2ZhY3RvclxuICAgICAgICBoOiBCaWdJbnQoJzB4NWQ1NDNhOTU0MTRlN2YxMDkxZDUwNzkyODc2YTIwMmNkOTFkZTQ1NDcwODVhYmFhNjhhMjA1YjJlNWE3ZGRmYTYyOGYxY2I0ZDllODJlZjIxNTM3ZTI5M2E2NjkxYWUxNjE2ZWM2ZTc4NmYwYzcwY2YxYzM4ZTMxYzcyMzhlNScpLFxuICAgICAgICBHeDogRnAyLmZyb21CaWdUdXBsZShbXG4gICAgICAgICAgICBCaWdJbnQoJzB4MDI0YWEyYjJmMDhmMGE5MTI2MDgwNTI3MmRjNTEwNTFjNmU0N2FkNGZhNDAzYjAyYjQ1MTBiNjQ3YWUzZDE3NzBiYWMwMzI2YTgwNWJiZWZkNDgwNTZjOGMxMjFiZGI4JyksXG4gICAgICAgICAgICBCaWdJbnQoJzB4MTNlMDJiNjA1MjcxOWY2MDdkYWNkM2EwODgyNzRmNjU1OTZiZDBkMDk5MjBiNjFhYjVkYTYxYmJkYzdmNTA0OTMzNGNmMTEyMTM5NDVkNTdlNWFjN2QwNTVkMDQyYjdlJyksXG4gICAgICAgIF0pLFxuICAgICAgICAvLyB5ID1cbiAgICAgICAgLy8gOTI3NTUzNjY1NDkyMzMyNDU1NzQ3MjAxOTY1Nzc2MDM3ODgwNzU3NzQwMTkzNDUzNTkyOTcwMDI1MDI3OTc4NzkzOTc2ODc3MDAyNjc1NTY0OTgwOTQ5Mjg5NzI3OTU3NTY1NTc1NDMzMzQ0MjE5NTgyLFxuICAgICAgICAvLyAxOTg1MTUwNjAyMjg3MjkxOTM1NTY4MDU0NTIxMTc3MTcxNjM4MzAwODY4OTc4MjE1NjU1NzMwODU5Mzc4NjY1MDY2MzQ0NzI2MzczODIzNzE4NDIzODY5MTA0MjYzMzMzOTg0NjQxNDk0MzQwMzQ3OTA1XG4gICAgICAgIEd5OiBGcDIuZnJvbUJpZ1R1cGxlKFtcbiAgICAgICAgICAgIEJpZ0ludCgnMHgwY2U1ZDUyNzcyN2Q2ZTExOGNjOWNkYzZkYTJlMzUxYWFkZmQ5YmFhOGNiZGQzYTc2ZDQyOWE2OTUxNjBkMTJjOTIzYWM5Y2MzYmFjYTI4OWUxOTM1NDg2MDhiODI4MDEnKSxcbiAgICAgICAgICAgIEJpZ0ludCgnMHgwNjA2YzRhMDJlYTczNGNjMzJhY2QyYjAyYmMyOGI5OWNiM2UyODdlODVhNzYzYWYyNjc0OTJhYjU3MmU5OWFiM2YzNzBkMjc1Y2VjMWRhMWFhYTkwNzVmZjA1Zjc5YmUnKSxcbiAgICAgICAgXSksXG4gICAgICAgIGE6IEZwMi5aRVJPLFxuICAgICAgICBiOiBGcDIuZnJvbUJpZ1R1cGxlKFtfNG4sIF80bl0pLFxuICAgICAgICBoRWZmOiBCaWdJbnQoJzB4YmM2OWYwOGYyZWU3NWIzNTg0YzZhMGVhOTFiMzUyODg4ZTJhOGU5MTQ1YWQ3Njg5OTg2ZmYwMzE1MDhmZmUxMzI5YzJmMTc4NzMxZGI5NTZkODJiZjAxNWQxMjEyYjAyZWMwZWM2OWQ3NDc3YzFhZTk1NGNiYzA2Njg5ZjZhMzU5ODk0YzBhZGViYmY2YjRlODAyMDAwNWFhYTk1NTUxJyksXG4gICAgICAgIGh0ZkRlZmF1bHRzOiB7IC4uLmh0ZkRlZmF1bHRzIH0sXG4gICAgICAgIHdyYXBQcml2YXRlS2V5OiB0cnVlLFxuICAgICAgICBhbGxvd0luZmluaXR5UG9pbnQ6IHRydWUsXG4gICAgICAgIG1hcFRvQ3VydmU6IChzY2FsYXJzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IEcyX1NXVShGcDIuZnJvbUJpZ1R1cGxlKHNjYWxhcnMpKTtcbiAgICAgICAgICAgIHJldHVybiBpc29nZW55TWFwRzIoeCwgeSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIENoZWNrcyBpcyB0aGUgcG9pbnQgcmVzaWRlcyBpbiBwcmltZS1vcmRlciBzdWJncm91cC5cbiAgICAgICAgLy8gcG9pbnQuaXNUb3JzaW9uRnJlZSgpIHNob3VsZCByZXR1cm4gdHJ1ZSBmb3IgdmFsaWQgcG9pbnRzXG4gICAgICAgIC8vIEl0IHJldHVybnMgZmFsc2UgZm9yIHNoaXR0eSBwb2ludHMuXG4gICAgICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMjEvMTEzMC5wZGZcbiAgICAgICAgaXNUb3JzaW9uRnJlZTogKGMsIFApID0+IHtcbiAgICAgICAgICAgIHJldHVybiBQLm11bHRpcGx5VW5zYWZlKGJsczEyXzM4MS5wYXJhbXMueCkubmVnYXRlKCkuZXF1YWxzKEcycHNpKGMsIFApKTsgLy8gz4goUCkgPT0gW3VdKFApXG4gICAgICAgICAgICAvLyBPbGRlciB2ZXJzaW9uOiBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE5LzgxNC5wZGZcbiAgICAgICAgICAgIC8vIM6owrIoUCkgPT4gzqjCsyhQKSA9PiBbel3OqMKzKFApIHdoZXJlIHogPSAteCA9PiBbel3OqMKzKFApIC0gzqjCsihQKSArIFAgPT0gT1xuICAgICAgICAgICAgLy8gcmV0dXJuIFAucHNpMigpLnBzaSgpLm11bE5lZ1goKS5zdWJ0cmFjdChwc2kyKS5hZGQoUCkuaXNaZXJvKCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIE1hcHMgdGhlIHBvaW50IGludG8gdGhlIHByaW1lLW9yZGVyIHN1Ymdyb3VwIEcyLlxuICAgICAgICAvLyBjbGVhcl9jb2ZhY3Rvcl9ibHMxMjM4MV9nMiBmcm9tIGNmcmctaGFzaC10by1jdXJ2ZS0xMVxuICAgICAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE3LzQxOS5wZGZcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGNsZWFyQ29mYWN0b3I6IChjLCBQKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB4ID0gYmxzMTJfMzgxLnBhcmFtcy54O1xuICAgICAgICAgICAgbGV0IHQxID0gUC5tdWx0aXBseVVuc2FmZSh4KS5uZWdhdGUoKTsgLy8gWy14XVBcbiAgICAgICAgICAgIGxldCB0MiA9IEcycHNpKGMsIFApOyAvLyDOqChQKVxuICAgICAgICAgICAgbGV0IHQzID0gUC5kb3VibGUoKTsgLy8gMlBcbiAgICAgICAgICAgIHQzID0gRzJwc2kyKGMsIHQzKTsgLy8gzqjCsigyUClcbiAgICAgICAgICAgIHQzID0gdDMuc3VidHJhY3QodDIpOyAvLyDOqMKyKDJQKSAtIM6oKFApXG4gICAgICAgICAgICB0MiA9IHQxLmFkZCh0Mik7IC8vIFsteF1QICsgzqgoUClcbiAgICAgICAgICAgIHQyID0gdDIubXVsdGlwbHlVbnNhZmUoeCkubmVnYXRlKCk7IC8vIFt4wrJdUCAtIFt4Xc6oKFApXG4gICAgICAgICAgICB0MyA9IHQzLmFkZCh0Mik7IC8vIM6owrIoMlApIC0gzqgoUCkgKyBbeMKyXVAgLSBbeF3OqChQKVxuICAgICAgICAgICAgdDMgPSB0My5zdWJ0cmFjdCh0MSk7IC8vIM6owrIoMlApIC0gzqgoUCkgKyBbeMKyXVAgLSBbeF3OqChQKSArIFt4XVBcbiAgICAgICAgICAgIGNvbnN0IFEgPSB0My5zdWJ0cmFjdChQKTsgLy8gzqjCsigyUCkgLSDOqChQKSArIFt4wrJdUCAtIFt4Xc6oKFApICsgW3hdUCAtIDFQXG4gICAgICAgICAgICByZXR1cm4gUTsgLy8gW3jCsi14LTFdUCArIFt4LTFdzqgoUCkgKyDOqMKyKDJQKVxuICAgICAgICB9LFxuICAgICAgICBmcm9tQnl0ZXM6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBjb21wcmVzc2VkLCBpbmZpbml0eSwgc29ydCwgdmFsdWUgfSA9IHBhcnNlTWFzayhieXRlcyk7XG4gICAgICAgICAgICBpZiAoKCFjb21wcmVzc2VkICYmICFpbmZpbml0eSAmJiBzb3J0KSB8fCAvLyAwMDEwMDAwMFxuICAgICAgICAgICAgICAgICghY29tcHJlc3NlZCAmJiBpbmZpbml0eSAmJiBzb3J0KSB8fCAvLyAwMTEwMDAwMFxuICAgICAgICAgICAgICAgIChzb3J0ICYmIGluZmluaXR5ICYmIGNvbXByZXNzZWQpIC8vIDExMTAwMDAwXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZW5jb2RpbmcgZmxhZzogJyArIChieXRlc1swXSAmIDIyNCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgTCA9IEZwLkJZVEVTO1xuICAgICAgICAgICAgY29uc3Qgc2xjID0gKGIsIGZyb20sIHRvKSA9PiBieXRlc1RvTnVtYmVyQkUoYi5zbGljZShmcm9tLCB0bykpO1xuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gOTYgJiYgY29tcHJlc3NlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGIgPSBibHMxMl8zODEucGFyYW1zLkcyYjtcbiAgICAgICAgICAgICAgICBjb25zdCBQID0gRnAuT1JERVI7XG4gICAgICAgICAgICAgICAgaWYgKGluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIHRoYXQgYWxsIGJ5dGVzIGFyZSAwXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5yZWR1Y2UoKHAsIGMpID0+IChwICE9PSAwID8gYyArIDEgOiBjKSwgMCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29tcHJlc3NlZCBHMiBwb2ludCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IEZwMi5aRVJPLCB5OiBGcDIuWkVSTyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB4XzEgPSBzbGModmFsdWUsIDAsIEwpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHhfMCA9IHNsYyh2YWx1ZSwgTCwgMiAqIEwpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBGcDIuY3JlYXRlKHsgYzA6IEZwLmNyZWF0ZSh4XzApLCBjMTogRnAuY3JlYXRlKHhfMSkgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBGcDIuYWRkKEZwMi5wb3coeCwgXzNuKSwgYik7IC8vIHnCsiA9IHjCsyArIDQgKiAodSsxKSA9IHjCsyArIGJcbiAgICAgICAgICAgICAgICBsZXQgeSA9IEZwMi5zcXJ0KHJpZ2h0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBZX2JpdCA9IHkuYzEgPT09IF8wbiA/ICh5LmMwICogXzJuKSAvIFAgOiAoeS5jMSAqIF8ybikgLyBQID8gXzFuIDogXzBuO1xuICAgICAgICAgICAgICAgIHkgPSBzb3J0ICYmIFlfYml0ID4gMCA/IHkgOiBGcDIubmVnKHkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMTkyICYmICFjb21wcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5yZWR1Y2UoKHAsIGMpID0+IChwICE9PSAwID8gYyArIDEgOiBjKSwgMCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdW5jb21wcmVzc2VkIEcyIHBvaW50Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogRnAyLlpFUk8sIHk6IEZwMi5aRVJPIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHgxID0gc2xjKHZhbHVlLCAwLCBMKTtcbiAgICAgICAgICAgICAgICBjb25zdCB4MCA9IHNsYyh2YWx1ZSwgTCwgMiAqIEwpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkxID0gc2xjKHZhbHVlLCAyICogTCwgMyAqIEwpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkwID0gc2xjKHZhbHVlLCAzICogTCwgNCAqIEwpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IEZwMi5mcm9tQmlnVHVwbGUoW3gwLCB4MV0pLCB5OiBGcDIuZnJvbUJpZ1R1cGxlKFt5MCwgeTFdKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBvaW50IEcyLCBleHBlY3RlZCA5Ni8xOTIgYnl0ZXMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdG9CeXRlczogKGMsIHBvaW50LCBpc0NvbXByZXNzZWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgQllURVM6IGxlbiwgT1JERVI6IFAgfSA9IEZwO1xuICAgICAgICAgICAgY29uc3QgaXNaZXJvID0gcG9pbnQuZXF1YWxzKGMuWkVSTyk7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgICAgICAgICBpZiAoaXNDb21wcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzWmVybylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbmNhdEIoQ09NUFJFU1NFRF9aRVJPLCBudW1iZXJUb0J5dGVzQkUoXzBuLCBsZW4pKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmbGFnID0gQm9vbGVhbih5LmMxID09PSBfMG4gPyAoeS5jMCAqIF8ybikgLyBQIDogKHkuYzEgKiBfMm4pIC8gUCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmNhdEIoc2V0TWFzayhudW1iZXJUb0J5dGVzQkUoeC5jMSwgbGVuKSwgeyBjb21wcmVzc2VkOiB0cnVlLCBzb3J0OiBmbGFnIH0pLCBudW1iZXJUb0J5dGVzQkUoeC5jMCwgbGVuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNaZXJvKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uY2F0QihuZXcgVWludDhBcnJheShbMHg0MF0pLCBuZXcgVWludDhBcnJheSg0ICogbGVuIC0gMSkpOyAvLyBieXRlc1swXSB8PSAxIDw8IDY7XG4gICAgICAgICAgICAgICAgY29uc3QgeyByZTogeDAsIGltOiB4MSB9ID0gRnAyLnJlaW0oeCk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyByZTogeTAsIGltOiB5MSB9ID0gRnAyLnJlaW0oeSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmNhdEIobnVtYmVyVG9CeXRlc0JFKHgxLCBsZW4pLCBudW1iZXJUb0J5dGVzQkUoeDAsIGxlbiksIG51bWJlclRvQnl0ZXNCRSh5MSwgbGVuKSwgbnVtYmVyVG9CeXRlc0JFKHkwLCBsZW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgU2lnbmF0dXJlOiB7XG4gICAgICAgICAgICAvLyBUT0RPOiBPcHRpbWl6ZSwgaXQncyB2ZXJ5IHNsb3cgYmVjYXVzZSBvZiBzcXJ0LlxuICAgICAgICAgICAgZnJvbUhleChoZXgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGluZmluaXR5LCBzb3J0LCB2YWx1ZSB9ID0gcGFyc2VNYXNrKGVuc3VyZUJ5dGVzKCdzaWduYXR1cmVIZXgnLCBoZXgpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBQID0gRnAuT1JERVI7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFsZiA9IHZhbHVlLmxlbmd0aCAvIDI7XG4gICAgICAgICAgICAgICAgaWYgKGhhbGYgIT09IDQ4ICYmIGhhbGYgIT09IDk2KVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29tcHJlc3NlZCBzaWduYXR1cmUgbGVuZ3RoLCBtdXN0IGJlIDk2IG9yIDE5MicpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHoxID0gYnl0ZXNUb051bWJlckJFKHZhbHVlLnNsaWNlKDAsIGhhbGYpKTtcbiAgICAgICAgICAgICAgICBjb25zdCB6MiA9IGJ5dGVzVG9OdW1iZXJCRSh2YWx1ZS5zbGljZShoYWxmKSk7XG4gICAgICAgICAgICAgICAgLy8gSW5kaWNhdGVzIHRoZSBpbmZpbml0eSBwb2ludFxuICAgICAgICAgICAgICAgIGlmIChpbmZpbml0eSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJsczEyXzM4MS5HMi5Qcm9qZWN0aXZlUG9pbnQuWkVSTztcbiAgICAgICAgICAgICAgICBjb25zdCB4MSA9IEZwLmNyZWF0ZSh6MSAmIEZwLk1BU0spO1xuICAgICAgICAgICAgICAgIGNvbnN0IHgyID0gRnAuY3JlYXRlKHoyKTtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gRnAyLmNyZWF0ZSh7IGMwOiB4MiwgYzE6IHgxIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkyID0gRnAyLmFkZChGcDIucG93KHgsIF8zbiksIGJsczEyXzM4MS5wYXJhbXMuRzJiKTsgLy8gecKyID0geMKzICsgNFxuICAgICAgICAgICAgICAgIC8vIFRoZSBzbG93IHBhcnRcbiAgICAgICAgICAgICAgICBsZXQgeSA9IEZwMi5zcXJ0KHkyKTtcbiAgICAgICAgICAgICAgICBpZiAoIXkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZpbmQgYSBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgICAgIC8vIENob29zZSB0aGUgeSB3aG9zZSBsZWZ0bW9zdCBiaXQgb2YgdGhlIGltYWdpbmFyeSBwYXJ0IGlzIGVxdWFsIHRvIHRoZSBhX2ZsYWcxXG4gICAgICAgICAgICAgICAgLy8gSWYgeTEgaGFwcGVucyB0byBiZSB6ZXJvLCB0aGVuIHVzZSB0aGUgYml0IG9mIHkwXG4gICAgICAgICAgICAgICAgY29uc3QgeyByZTogeTAsIGltOiB5MSB9ID0gRnAyLnJlaW0oeSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYWZsYWcxID0gQmlnSW50KHNvcnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzR3JlYXRlciA9IHkxID4gXzBuICYmICh5MSAqIF8ybikgLyBQICE9PSBhZmxhZzE7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNaZXJvID0geTEgPT09IF8wbiAmJiAoeTAgKiBfMm4pIC8gUCAhPT0gYWZsYWcxO1xuICAgICAgICAgICAgICAgIGlmIChpc0dyZWF0ZXIgfHwgaXNaZXJvKVxuICAgICAgICAgICAgICAgICAgICB5ID0gRnAyLm5lZyh5KTtcbiAgICAgICAgICAgICAgICBjb25zdCBwb2ludCA9IGJsczEyXzM4MS5HMi5Qcm9qZWN0aXZlUG9pbnQuZnJvbUFmZmluZSh7IHgsIHkgfSk7XG4gICAgICAgICAgICAgICAgcG9pbnQuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9SYXdCeXRlcyhwb2ludCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzaWduYXR1cmVHMlRvUmF3Qnl0ZXMocG9pbnQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvSGV4KHBvaW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ5dGVzVG9IZXgoc2lnbmF0dXJlRzJUb1Jhd0J5dGVzKHBvaW50KSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgcGFyYW1zOiB7XG4gICAgICAgIHg6IEJMU19YLCAvLyBUaGUgQkxTIHBhcmFtZXRlciB4IGZvciBCTFMxMi0zODFcbiAgICAgICAgcjogRnIuT1JERVIsIC8vIG9yZGVyOyB64oG0IOKIkiB6wrIgKyAxOyBDVVJWRS5uIGZyb20gb3RoZXIgY3VydmVzXG4gICAgfSxcbiAgICBodGZEZWZhdWx0cyxcbiAgICBoYXNoOiBzaGEyNTYsXG4gICAgcmFuZG9tQnl0ZXMsXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJsczEyLTM4MS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/@noble/curves/esm/bls12-381.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@noble/curves/esm/ed25519.js":
/*!*******************************************************!*\
  !*** ../../node_modules/@noble/curves/esm/ed25519.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ED25519_TORSION_SUBGROUP: function() { return /* binding */ ED25519_TORSION_SUBGROUP; },\n/* harmony export */   RistrettoPoint: function() { return /* binding */ RistrettoPoint; },\n/* harmony export */   ed25519: function() { return /* binding */ ed25519; },\n/* harmony export */   ed25519ctx: function() { return /* binding */ ed25519ctx; },\n/* harmony export */   ed25519ph: function() { return /* binding */ ed25519ph; },\n/* harmony export */   edwardsToMontgomery: function() { return /* binding */ edwardsToMontgomery; },\n/* harmony export */   edwardsToMontgomeryPriv: function() { return /* binding */ edwardsToMontgomeryPriv; },\n/* harmony export */   edwardsToMontgomeryPub: function() { return /* binding */ edwardsToMontgomeryPub; },\n/* harmony export */   encodeToCurve: function() { return /* binding */ encodeToCurve; },\n/* harmony export */   hashToCurve: function() { return /* binding */ hashToCurve; },\n/* harmony export */   hashToRistretto255: function() { return /* binding */ hashToRistretto255; },\n/* harmony export */   hash_to_ristretto255: function() { return /* binding */ hash_to_ristretto255; },\n/* harmony export */   x25519: function() { return /* binding */ x25519; }\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/sha512 */ \"(app-pages-browser)/../../node_modules/@noble/hashes/esm/sha512.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/../../node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_edwards_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/edwards.js */ \"(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/edwards.js\");\n/* harmony import */ var _abstract_montgomery_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./abstract/montgomery.js */ \"(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/montgomery.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/utils.js */ \"(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(app-pages-browser)/../../node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n\n\n\n\n/**\n * ed25519 Twisted Edwards curve with following addons:\n * - X25519 ECDH\n * - Ristretto cofactor elimination\n * - Elligator hash-to-group / point indistinguishability\n */\nconst ED25519_P = BigInt('57896044618658097711785492504343953926634992332820282019728792003956564819949');\n// (-1) aka (a) aka 2^((p-1)/4)\nconst ED25519_SQRT_M1 = BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _5n = BigInt(5);\n// prettier-ignore\nconst _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);\nfunction ed25519_pow_2_252_3(x) {\n    const P = ED25519_P;\n    const x2 = (x * x) % P;\n    const b2 = (x2 * x) % P; // x^3, 11\n    const b4 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b2, _2n, P) * b2) % P; // x^15, 1111\n    const b5 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b4, _1n, P) * x) % P; // x^31\n    const b10 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b5, _5n, P) * b5) % P;\n    const b20 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b10, _10n, P) * b10) % P;\n    const b40 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b20, _20n, P) * b20) % P;\n    const b80 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b40, _40n, P) * b40) % P;\n    const b160 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b80, _80n, P) * b80) % P;\n    const b240 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b160, _80n, P) * b80) % P;\n    const b250 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b240, _10n, P) * b10) % P;\n    const pow_p_5_8 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b250, _2n, P) * x) % P;\n    // ^ To pow to (p+3)/8, multiply it by x.\n    return { pow_p_5_8, b2 };\n}\nfunction adjustScalarBytes(bytes) {\n    // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,\n    // set the three least significant bits of the first byte\n    bytes[0] &= 248; // 0b1111_1000\n    // and the most significant bit of the last to zero,\n    bytes[31] &= 127; // 0b0111_1111\n    // set the second most significant bit of the last byte to 1\n    bytes[31] |= 64; // 0b0100_0000\n    return bytes;\n}\n// sqrt(u/v)\nfunction uvRatio(u, v) {\n    const P = ED25519_P;\n    const v3 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(v * v * v, P); // v\n    const v7 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(v3 * v3 * v, P); // v\n    // (p+3)/8 and (p-5)/8\n    const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;\n    let x = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(u * v3 * pow, P); // (uv)(uv)^(p-5)/8\n    const vx2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(v * x * x, P); // vx\n    const root1 = x; // First root candidate\n    const root2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x * ED25519_SQRT_M1, P); // Second root candidate\n    const useRoot1 = vx2 === u; // If vx = u (mod p), x is a square root\n    const useRoot2 = vx2 === (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-u, P); // If vx = -u, set x <-- x * 2^((p-1)/4)\n    const noRoot = vx2 === (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-u * ED25519_SQRT_M1, P); // There is no valid root, vx = -u(-1)\n    if (useRoot1)\n        x = root1;\n    if (useRoot2 || noRoot)\n        x = root2; // We return root2 anyway, for const-time\n    if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(x, P))\n        x = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-x, P);\n    return { isValid: useRoot1 || useRoot2, value: x };\n}\n// Just in case\nconst ED25519_TORSION_SUBGROUP = [\n    '0100000000000000000000000000000000000000000000000000000000000000',\n    'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n    '0000000000000000000000000000000000000000000000000000000000000080',\n    '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n    'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n    '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n    '0000000000000000000000000000000000000000000000000000000000000000',\n    'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n];\nconst Fp = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(ED25519_P, undefined, true);\nconst ed25519Defaults = {\n    // Param: a\n    a: BigInt(-1), // Fp.create(-1) is proper; our way still works and is faster\n    // d is equal to -121665/121666 over finite field.\n    // Negative number is P - number, and division is invert(number, P)\n    d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),\n    // Finite field p over which we'll do calculations; 2n**255n - 19n\n    Fp,\n    // Subgroup order: how many points curve has\n    // 2n**252n + 27742317777372353535851937790883648493n;\n    n: BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989'),\n    // Cofactor\n    h: BigInt(8),\n    // Base point (x, y) aka generator point\n    Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),\n    Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),\n    hash: _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512,\n    randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.randomBytes,\n    adjustScalarBytes,\n    // dom2\n    // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.\n    // Constant-time, u/v\n    uvRatio,\n};\nconst ed25519 = /* @__PURE__ */ (0,_abstract_edwards_js__WEBPACK_IMPORTED_MODULE_3__.twistedEdwards)(ed25519Defaults);\nfunction ed25519_domain(data, ctx, phflag) {\n    if (ctx.length > 255)\n        throw new Error('Context is too big');\n    return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.concatBytes)((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.utf8ToBytes)('SigEd25519 no Ed25519 collisions'), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);\n}\nconst ed25519ctx = /* @__PURE__ */ (0,_abstract_edwards_js__WEBPACK_IMPORTED_MODULE_3__.twistedEdwards)({\n    ...ed25519Defaults,\n    domain: ed25519_domain,\n});\nconst ed25519ph = /* @__PURE__ */ (0,_abstract_edwards_js__WEBPACK_IMPORTED_MODULE_3__.twistedEdwards)({\n    ...ed25519Defaults,\n    domain: ed25519_domain,\n    prehash: _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512,\n});\nconst x25519 = /* @__PURE__ */ (() => (0,_abstract_montgomery_js__WEBPACK_IMPORTED_MODULE_4__.montgomery)({\n    P: ED25519_P,\n    a: BigInt(486662),\n    montgomeryBits: 255, // n is 253 bits\n    nByteLength: 32,\n    Gu: BigInt(9),\n    powPminus2: (x) => {\n        const P = ED25519_P;\n        // x^(p-2) aka x^(2^255-21)\n        const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);\n        return (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(pow_p_5_8, BigInt(3), P) * b2, P);\n    },\n    adjustScalarBytes,\n    randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.randomBytes,\n}))();\n/**\n * Converts ed25519 public key to x25519 public key. Uses formula:\n * * `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`\n * * `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`\n * @example\n *   const someonesPub = ed25519.getPublicKey(ed25519.utils.randomPrivateKey());\n *   const aPriv = x25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(aPriv, edwardsToMontgomeryPub(someonesPub))\n */\nfunction edwardsToMontgomeryPub(edwardsPub) {\n    const { y } = ed25519.ExtendedPoint.fromHex(edwardsPub);\n    const _1n = BigInt(1);\n    return Fp.toBytes(Fp.create((_1n + y) * Fp.inv(_1n - y)));\n}\nconst edwardsToMontgomery = edwardsToMontgomeryPub; // deprecated\n/**\n * Converts ed25519 secret key to x25519 secret key.\n * @example\n *   const someonesPub = x25519.getPublicKey(x25519.utils.randomPrivateKey());\n *   const aPriv = ed25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(edwardsToMontgomeryPriv(aPriv), someonesPub)\n */\nfunction edwardsToMontgomeryPriv(edwardsPriv) {\n    const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));\n    return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);\n}\n// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)\n// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since\n// SageMath returns different root first and everything falls apart\nconst ELL2_C1 = (Fp.ORDER + BigInt(3)) / BigInt(8); // 1. c1 = (q + 3) / 8       # Integer arithmetic\nconst ELL2_C2 = Fp.pow(_2n, ELL2_C1); // 2. c2 = 2^c1\nconst ELL2_C3 = Fp.sqrt(Fp.neg(Fp.ONE)); // 3. c3 = sqrt(-1)\nconst ELL2_C4 = (Fp.ORDER - BigInt(5)) / BigInt(8); // 4. c4 = (q - 5) / 8       # Integer arithmetic\nconst ELL2_J = BigInt(486662);\n// prettier-ignore\nfunction map_to_curve_elligator2_curve25519(u) {\n    let tv1 = Fp.sqr(u); //  1.  tv1 = u^2\n    tv1 = Fp.mul(tv1, _2n); //  2.  tv1 = 2 * tv1\n    let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not\n    let x1n = Fp.neg(ELL2_J); //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)\n    let tv2 = Fp.sqr(xd); //  5.  tv2 = xd^2\n    let gxd = Fp.mul(tv2, xd); //  6.  gxd = tv2 * xd        # gxd = xd^3\n    let gx1 = Fp.mul(tv1, ELL2_J); //  7.  gx1 = J * tv1         # x1n + J * xd\n    gx1 = Fp.mul(gx1, x1n); //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd\n    gx1 = Fp.add(gx1, tv2); //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2\n    gx1 = Fp.mul(gx1, x1n); //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2\n    let tv3 = Fp.sqr(gxd); //  11. tv3 = gxd^2\n    tv2 = Fp.sqr(tv3); //  12. tv2 = tv3^2           # gxd^4\n    tv3 = Fp.mul(tv3, gxd); //  13. tv3 = tv3 * gxd       # gxd^3\n    tv3 = Fp.mul(tv3, gx1); //  14. tv3 = tv3 * gx1       # gx1 * gxd^3\n    tv2 = Fp.mul(tv2, tv3); //  15. tv2 = tv2 * tv3       # gx1 * gxd^7\n    let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)\n    y11 = Fp.mul(y11, tv3); //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)\n    let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3\n    tv2 = Fp.sqr(y11); //  19. tv2 = y11^2\n    tv2 = Fp.mul(tv2, gxd); //  20. tv2 = tv2 * gxd\n    let e1 = Fp.eql(tv2, gx1); //  21.  e1 = tv2 == gx1\n    let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt\n    let x2n = Fp.mul(x1n, tv1); //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd\n    let y21 = Fp.mul(y11, u); //  24. y21 = y11 * u\n    y21 = Fp.mul(y21, ELL2_C2); //  25. y21 = y21 * c2\n    let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3\n    let gx2 = Fp.mul(gx1, tv1); //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)\n    tv2 = Fp.sqr(y21); //  28. tv2 = y21^2\n    tv2 = Fp.mul(tv2, gxd); //  29. tv2 = tv2 * gxd\n    let e2 = Fp.eql(tv2, gx2); //  30.  e2 = tv2 == gx2\n    let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt\n    tv2 = Fp.sqr(y1); //  32. tv2 = y1^2\n    tv2 = Fp.mul(tv2, gxd); //  33. tv2 = tv2 * gxd\n    let e3 = Fp.eql(tv2, gx1); //  34.  e3 = tv2 == gx1\n    let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2\n    let y = Fp.cmov(y2, y1, e3); //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2\n    let e4 = Fp.isOdd(y); //  37.  e4 = sgn0(y) == 1        # Fix sign of y\n    y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)\n    return { xMn: xn, xMd: xd, yMn: y, yMd: _1n }; //  39. return (xn, xd, y, 1)\n}\nconst ELL2_C1_EDWARDS = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.FpSqrtEven)(Fp, Fp.neg(BigInt(486664))); // sgn0(c1) MUST equal 0\nfunction map_to_curve_elligator2_edwards25519(u) {\n    const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =\n    // map_to_curve_elligator2_curve25519(u)\n    let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd\n    xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1\n    let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM\n    let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd\n    let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)\n    let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd\n    let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0\n    xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)\n    xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)\n    yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)\n    yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)\n    const inv = Fp.invertBatch([xd, yd]); // batch division\n    return { x: Fp.mul(xn, inv[0]), y: Fp.mul(yn, inv[1]) }; //  13. return (xn, xd, yn, yd)\n}\nconst htf = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.createHasher)(ed25519.ExtendedPoint, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {\n    DST: 'edwards25519_XMD:SHA-512_ELL2_RO_',\n    encodeDST: 'edwards25519_XMD:SHA-512_ELL2_NU_',\n    p: Fp.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512,\n}))();\nconst hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nconst encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\nfunction assertRstPoint(other) {\n    if (!(other instanceof RistPoint))\n        throw new Error('RistrettoPoint expected');\n}\n// (-1) aka (a) aka 2^((p-1)/4)\nconst SQRT_M1 = ED25519_SQRT_M1;\n// (ad - 1)\nconst SQRT_AD_MINUS_ONE = BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');\n// 1 / (a-d)\nconst INVSQRT_A_MINUS_D = BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');\n// 1-d\nconst ONE_MINUS_D_SQ = BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');\n// (d-1)\nconst D_MINUS_ONE_SQ = BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');\n// Calculates 1/(number)\nconst invertSqrt = (number) => uvRatio(_1n, number);\nconst MAX_255B = BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\nconst bytes255ToNumberLE = (bytes) => ed25519.CURVE.Fp.create((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.bytesToNumberLE)(bytes) & MAX_255B);\n// Computes Elligator map for Ristretto\n// https://ristretto.group/formulas/elligator.html\nfunction calcElligatorRistrettoMap(r0) {\n    const { d } = ed25519.CURVE;\n    const P = ed25519.CURVE.Fp.ORDER;\n    const mod = ed25519.CURVE.Fp.create;\n    const r = mod(SQRT_M1 * r0 * r0); // 1\n    const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2\n    let c = BigInt(-1); // 3\n    const D = mod((c - d * r) * mod(r + d)); // 4\n    let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5\n    let s_ = mod(s * r0); // 6\n    if (!(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(s_, P))\n        s_ = mod(-s_);\n    if (!Ns_D_is_sq)\n        s = s_; // 7\n    if (!Ns_D_is_sq)\n        c = r; // 8\n    const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9\n    const s2 = s * s;\n    const W0 = mod((s + s) * D); // 10\n    const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11\n    const W2 = mod(_1n - s2); // 12\n    const W3 = mod(_1n + s2); // 13\n    return new ed25519.ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n}\n/**\n * Each ed25519/ExtendedPoint has 8 different equivalent points. This can be\n * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.\n * Ristretto point operates in X:Y:Z:T extended coordinates like ExtendedPoint,\n * but it should work in its own namespace: do not combine those two.\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448\n */\nclass RistPoint {\n    // Private property to discourage combining ExtendedPoint + RistrettoPoint\n    // Always use Ristretto encoding/decoding instead.\n    constructor(ep) {\n        this.ep = ep;\n    }\n    static fromAffine(ap) {\n        return new RistPoint(ed25519.ExtendedPoint.fromAffine(ap));\n    }\n    /**\n     * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.\n     * The hash-to-group operation applies Elligator twice and adds the results.\n     * **Note:** this is one-way map, there is no conversion from point to hash.\n     * https://ristretto.group/formulas/elligator.html\n     * @param hex 64-byte output of a hash function\n     */\n    static hashToCurve(hex) {\n        hex = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.ensureBytes)('ristrettoHash', hex, 64);\n        const r1 = bytes255ToNumberLE(hex.slice(0, 32));\n        const R1 = calcElligatorRistrettoMap(r1);\n        const r2 = bytes255ToNumberLE(hex.slice(32, 64));\n        const R2 = calcElligatorRistrettoMap(r2);\n        return new RistPoint(R1.add(R2));\n    }\n    /**\n     * Converts ristretto-encoded string to ristretto point.\n     * https://ristretto.group/formulas/decoding.html\n     * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding\n     */\n    static fromHex(hex) {\n        hex = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.ensureBytes)('ristrettoHex', hex, 32);\n        const { a, d } = ed25519.CURVE;\n        const P = ed25519.CURVE.Fp.ORDER;\n        const mod = ed25519.CURVE.Fp.create;\n        const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';\n        const s = bytes255ToNumberLE(hex);\n        // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.\n        // 3. Check that s is non-negative, or else abort\n        if (!(0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.equalBytes)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.numberToBytesLE)(s, 32), hex) || (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(s, P))\n            throw new Error(emsg);\n        const s2 = mod(s * s);\n        const u1 = mod(_1n + a * s2); // 4 (a is -1)\n        const u2 = mod(_1n - a * s2); // 5\n        const u1_2 = mod(u1 * u1);\n        const u2_2 = mod(u2 * u2);\n        const v = mod(a * d * u1_2 - u2_2); // 6\n        const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7\n        const Dx = mod(I * u2); // 8\n        const Dy = mod(I * Dx * v); // 9\n        let x = mod((s + s) * Dx); // 10\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(x, P))\n            x = mod(-x); // 10\n        const y = mod(u1 * Dy); // 11\n        const t = mod(x * y); // 12\n        if (!isValid || (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(t, P) || y === _0n)\n            throw new Error(emsg);\n        return new RistPoint(new ed25519.ExtendedPoint(x, y, _1n, t));\n    }\n    /**\n     * Encodes ristretto point to Uint8Array.\n     * https://ristretto.group/formulas/encoding.html\n     */\n    toRawBytes() {\n        let { ex: x, ey: y, ez: z, et: t } = this.ep;\n        const P = ed25519.CURVE.Fp.ORDER;\n        const mod = ed25519.CURVE.Fp.create;\n        const u1 = mod(mod(z + y) * mod(z - y)); // 1\n        const u2 = mod(x * y); // 2\n        // Square root always exists\n        const u2sq = mod(u2 * u2);\n        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3\n        const D1 = mod(invsqrt * u1); // 4\n        const D2 = mod(invsqrt * u2); // 5\n        const zInv = mod(D1 * D2 * t); // 6\n        let D; // 7\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(t * zInv, P)) {\n            let _x = mod(y * SQRT_M1);\n            let _y = mod(x * SQRT_M1);\n            x = _x;\n            y = _y;\n            D = mod(D1 * INVSQRT_A_MINUS_D);\n        }\n        else {\n            D = D2; // 8\n        }\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(x * zInv, P))\n            y = mod(-y); // 9\n        let s = mod((z - y) * D); // 10 (check footer's note, no sqrt(-a))\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(s, P))\n            s = mod(-s);\n        return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.numberToBytesLE)(s, 32); // 11\n    }\n    toHex() {\n        return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.bytesToHex)(this.toRawBytes());\n    }\n    toString() {\n        return this.toHex();\n    }\n    // Compare one point to another.\n    equals(other) {\n        assertRstPoint(other);\n        const { ex: X1, ey: Y1 } = this.ep;\n        const { ex: X2, ey: Y2 } = other.ep;\n        const mod = ed25519.CURVE.Fp.create;\n        // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)\n        const one = mod(X1 * Y2) === mod(Y1 * X2);\n        const two = mod(Y1 * Y2) === mod(X1 * X2);\n        return one || two;\n    }\n    add(other) {\n        assertRstPoint(other);\n        return new RistPoint(this.ep.add(other.ep));\n    }\n    subtract(other) {\n        assertRstPoint(other);\n        return new RistPoint(this.ep.subtract(other.ep));\n    }\n    multiply(scalar) {\n        return new RistPoint(this.ep.multiply(scalar));\n    }\n    multiplyUnsafe(scalar) {\n        return new RistPoint(this.ep.multiplyUnsafe(scalar));\n    }\n    double() {\n        return new RistPoint(this.ep.double());\n    }\n    negate() {\n        return new RistPoint(this.ep.negate());\n    }\n}\nconst RistrettoPoint = /* @__PURE__ */ (() => {\n    if (!RistPoint.BASE)\n        RistPoint.BASE = new RistPoint(ed25519.ExtendedPoint.BASE);\n    if (!RistPoint.ZERO)\n        RistPoint.ZERO = new RistPoint(ed25519.ExtendedPoint.ZERO);\n    return RistPoint;\n})();\n// Hashing to ristretto255. https://www.rfc-editor.org/rfc/rfc9380#appendix-B\nconst hashToRistretto255 = (msg, options) => {\n    const d = options.DST;\n    const DST = typeof d === 'string' ? (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.utf8ToBytes)(d) : d;\n    const uniform_bytes = (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.expand_message_xmd)(msg, DST, 64, _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512);\n    const P = RistPoint.hashToCurve(uniform_bytes);\n    return P;\n};\nconst hash_to_ristretto255 = hashToRistretto255; // legacy\n//# sourceMappingURL=ed25519.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vZWQyNTUxOS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQzhDO0FBQzhCO0FBQ3JCO0FBQ0Q7QUFDNkI7QUFDMEI7QUFDOUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsZ0JBQWdCLDBEQUFJLHdCQUF3QjtBQUM1QyxnQkFBZ0IsMERBQUksdUJBQXVCO0FBQzNDLGlCQUFpQiwwREFBSTtBQUNyQixpQkFBaUIsMERBQUk7QUFDckIsaUJBQWlCLDBEQUFJO0FBQ3JCLGlCQUFpQiwwREFBSTtBQUNyQixrQkFBa0IsMERBQUk7QUFDdEIsa0JBQWtCLDBEQUFJO0FBQ3RCLGtCQUFrQiwwREFBSTtBQUN0Qix1QkFBdUIsMERBQUk7QUFDM0I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseURBQUcsZ0JBQWdCO0FBQ2xDLGVBQWUseURBQUcsa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQSxZQUFZLHlEQUFHLG1CQUFtQjtBQUNsQyxnQkFBZ0IseURBQUcsZ0JBQWdCO0FBQ25DLHFCQUFxQjtBQUNyQixrQkFBa0IseURBQUcsMEJBQTBCO0FBQy9DLGdDQUFnQztBQUNoQyw2QkFBNkIseURBQUcsU0FBUztBQUN6QywyQkFBMkIseURBQUcsMkJBQTJCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixRQUFRLGtFQUFZO0FBQ3BCLFlBQVkseURBQUc7QUFDZixhQUFhO0FBQ2I7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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a0VBQVk7QUFDeEIseUJBQXlCO0FBQ3pCLGtDQUFrQztBQUNsQyxZQUFZLGtFQUFZO0FBQ3hCO0FBQ0EsZUFBZSxtRUFBZSxTQUFTO0FBQ3ZDO0FBQ0E7QUFDQSxlQUFlLDhEQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQyxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNPO0FBQ1A7QUFDQSx3Q0FBd0MsZ0VBQVc7QUFDbkQsMEJBQTBCLDhFQUFrQixlQUFlLHdEQUFNO0FBQ2pFO0FBQ0E7QUFDQTtBQUNPLGlEQUFpRDtBQUN4RCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2VkMjU1MTkuanM/ODAzZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBzaGE1MTIgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTUxMic7XG5pbXBvcnQgeyBjb25jYXRCeXRlcywgcmFuZG9tQnl0ZXMsIHV0ZjhUb0J5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5pbXBvcnQgeyB0d2lzdGVkRWR3YXJkcyB9IGZyb20gJy4vYWJzdHJhY3QvZWR3YXJkcy5qcyc7XG5pbXBvcnQgeyBtb250Z29tZXJ5IH0gZnJvbSAnLi9hYnN0cmFjdC9tb250Z29tZXJ5LmpzJztcbmltcG9ydCB7IEZpZWxkLCBGcFNxcnRFdmVuLCBpc05lZ2F0aXZlTEUsIG1vZCwgcG93MiB9IGZyb20gJy4vYWJzdHJhY3QvbW9kdWxhci5qcyc7XG5pbXBvcnQgeyBieXRlc1RvSGV4LCBieXRlc1RvTnVtYmVyTEUsIGVuc3VyZUJ5dGVzLCBlcXVhbEJ5dGVzLCBudW1iZXJUb0J5dGVzTEUsIH0gZnJvbSAnLi9hYnN0cmFjdC91dGlscy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVIYXNoZXIsIGV4cGFuZF9tZXNzYWdlX3htZCB9IGZyb20gJy4vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcyc7XG4vKipcbiAqIGVkMjU1MTkgVHdpc3RlZCBFZHdhcmRzIGN1cnZlIHdpdGggZm9sbG93aW5nIGFkZG9uczpcbiAqIC0gWDI1NTE5IEVDREhcbiAqIC0gUmlzdHJldHRvIGNvZmFjdG9yIGVsaW1pbmF0aW9uXG4gKiAtIEVsbGlnYXRvciBoYXNoLXRvLWdyb3VwIC8gcG9pbnQgaW5kaXN0aW5ndWlzaGFiaWxpdHlcbiAqL1xuY29uc3QgRUQyNTUxOV9QID0gQmlnSW50KCc1Nzg5NjA0NDYxODY1ODA5NzcxMTc4NTQ5MjUwNDM0Mzk1MzkyNjYzNDk5MjMzMjgyMDI4MjAxOTcyODc5MjAwMzk1NjU2NDgxOTk0OScpO1xuLy8g4oiaKC0xKSBha2Eg4oiaKGEpIGFrYSAyXigocC0xKS80KVxuY29uc3QgRUQyNTUxOV9TUVJUX00xID0gQmlnSW50KCcxOTY4MTE2MTM3NjcwNzUwNTk1NjgwNzA3OTMwNDk4ODU0MjAxNTQ0NjA2NjUxNTkyMzg5MDE2Mjc0NDAyMTA3MzEyMzgyOTc4NDc1MicpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gQmlnSW50KDIpLCBfNW4gPSBCaWdJbnQoNSk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8xMG4gPSBCaWdJbnQoMTApLCBfMjBuID0gQmlnSW50KDIwKSwgXzQwbiA9IEJpZ0ludCg0MCksIF84MG4gPSBCaWdJbnQoODApO1xuZnVuY3Rpb24gZWQyNTUxOV9wb3dfMl8yNTJfMyh4KSB7XG4gICAgY29uc3QgUCA9IEVEMjU1MTlfUDtcbiAgICBjb25zdCB4MiA9ICh4ICogeCkgJSBQO1xuICAgIGNvbnN0IGIyID0gKHgyICogeCkgJSBQOyAvLyB4XjMsIDExXG4gICAgY29uc3QgYjQgPSAocG93MihiMiwgXzJuLCBQKSAqIGIyKSAlIFA7IC8vIHheMTUsIDExMTFcbiAgICBjb25zdCBiNSA9IChwb3cyKGI0LCBfMW4sIFApICogeCkgJSBQOyAvLyB4XjMxXG4gICAgY29uc3QgYjEwID0gKHBvdzIoYjUsIF81biwgUCkgKiBiNSkgJSBQO1xuICAgIGNvbnN0IGIyMCA9IChwb3cyKGIxMCwgXzEwbiwgUCkgKiBiMTApICUgUDtcbiAgICBjb25zdCBiNDAgPSAocG93MihiMjAsIF8yMG4sIFApICogYjIwKSAlIFA7XG4gICAgY29uc3QgYjgwID0gKHBvdzIoYjQwLCBfNDBuLCBQKSAqIGI0MCkgJSBQO1xuICAgIGNvbnN0IGIxNjAgPSAocG93MihiODAsIF84MG4sIFApICogYjgwKSAlIFA7XG4gICAgY29uc3QgYjI0MCA9IChwb3cyKGIxNjAsIF84MG4sIFApICogYjgwKSAlIFA7XG4gICAgY29uc3QgYjI1MCA9IChwb3cyKGIyNDAsIF8xMG4sIFApICogYjEwKSAlIFA7XG4gICAgY29uc3QgcG93X3BfNV84ID0gKHBvdzIoYjI1MCwgXzJuLCBQKSAqIHgpICUgUDtcbiAgICAvLyBeIFRvIHBvdyB0byAocCszKS84LCBtdWx0aXBseSBpdCBieSB4LlxuICAgIHJldHVybiB7IHBvd19wXzVfOCwgYjIgfTtcbn1cbmZ1bmN0aW9uIGFkanVzdFNjYWxhckJ5dGVzKGJ5dGVzKSB7XG4gICAgLy8gU2VjdGlvbiA1OiBGb3IgWDI1NTE5LCBpbiBvcmRlciB0byBkZWNvZGUgMzIgcmFuZG9tIGJ5dGVzIGFzIGFuIGludGVnZXIgc2NhbGFyLFxuICAgIC8vIHNldCB0aGUgdGhyZWUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0cyBvZiB0aGUgZmlyc3QgYnl0ZVxuICAgIGJ5dGVzWzBdICY9IDI0ODsgLy8gMGIxMTExXzEwMDBcbiAgICAvLyBhbmQgdGhlIG1vc3Qgc2lnbmlmaWNhbnQgYml0IG9mIHRoZSBsYXN0IHRvIHplcm8sXG4gICAgYnl0ZXNbMzFdICY9IDEyNzsgLy8gMGIwMTExXzExMTFcbiAgICAvLyBzZXQgdGhlIHNlY29uZCBtb3N0IHNpZ25pZmljYW50IGJpdCBvZiB0aGUgbGFzdCBieXRlIHRvIDFcbiAgICBieXRlc1szMV0gfD0gNjQ7IC8vIDBiMDEwMF8wMDAwXG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuLy8gc3FydCh1L3YpXG5mdW5jdGlvbiB1dlJhdGlvKHUsIHYpIHtcbiAgICBjb25zdCBQID0gRUQyNTUxOV9QO1xuICAgIGNvbnN0IHYzID0gbW9kKHYgKiB2ICogdiwgUCk7IC8vIHbCs1xuICAgIGNvbnN0IHY3ID0gbW9kKHYzICogdjMgKiB2LCBQKTsgLy8gduKBt1xuICAgIC8vIChwKzMpLzggYW5kIChwLTUpLzhcbiAgICBjb25zdCBwb3cgPSBlZDI1NTE5X3Bvd18yXzI1Ml8zKHUgKiB2NykucG93X3BfNV84O1xuICAgIGxldCB4ID0gbW9kKHUgKiB2MyAqIHBvdywgUCk7IC8vICh1dsKzKSh1duKBtyleKHAtNSkvOFxuICAgIGNvbnN0IHZ4MiA9IG1vZCh2ICogeCAqIHgsIFApOyAvLyB2eMKyXG4gICAgY29uc3Qgcm9vdDEgPSB4OyAvLyBGaXJzdCByb290IGNhbmRpZGF0ZVxuICAgIGNvbnN0IHJvb3QyID0gbW9kKHggKiBFRDI1NTE5X1NRUlRfTTEsIFApOyAvLyBTZWNvbmQgcm9vdCBjYW5kaWRhdGVcbiAgICBjb25zdCB1c2VSb290MSA9IHZ4MiA9PT0gdTsgLy8gSWYgdnjCsiA9IHUgKG1vZCBwKSwgeCBpcyBhIHNxdWFyZSByb290XG4gICAgY29uc3QgdXNlUm9vdDIgPSB2eDIgPT09IG1vZCgtdSwgUCk7IC8vIElmIHZ4wrIgPSAtdSwgc2V0IHggPC0tIHggKiAyXigocC0xKS80KVxuICAgIGNvbnN0IG5vUm9vdCA9IHZ4MiA9PT0gbW9kKC11ICogRUQyNTUxOV9TUVJUX00xLCBQKTsgLy8gVGhlcmUgaXMgbm8gdmFsaWQgcm9vdCwgdnjCsiA9IC114oiaKC0xKVxuICAgIGlmICh1c2VSb290MSlcbiAgICAgICAgeCA9IHJvb3QxO1xuICAgIGlmICh1c2VSb290MiB8fCBub1Jvb3QpXG4gICAgICAgIHggPSByb290MjsgLy8gV2UgcmV0dXJuIHJvb3QyIGFueXdheSwgZm9yIGNvbnN0LXRpbWVcbiAgICBpZiAoaXNOZWdhdGl2ZUxFKHgsIFApKVxuICAgICAgICB4ID0gbW9kKC14LCBQKTtcbiAgICByZXR1cm4geyBpc1ZhbGlkOiB1c2VSb290MSB8fCB1c2VSb290MiwgdmFsdWU6IHggfTtcbn1cbi8vIEp1c3QgaW4gY2FzZVxuZXhwb3J0IGNvbnN0IEVEMjU1MTlfVE9SU0lPTl9TVUJHUk9VUCA9IFtcbiAgICAnMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJ2M3MTc2YTcwM2Q0ZGQ4NGZiYTNjMGI3NjBkMTA2NzBmMmEyMDUzZmEyYzM5Y2NjNjRlYzdmZDc3OTJhYzAzN2EnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDgwJyxcbiAgICAnMjZlODk1OGZjMmIyMjdiMDQ1YzNmNDg5ZjJlZjk4ZjBkNWRmYWMwNWQzYzYzMzM5YjEzODAyODg2ZDUzZmMwNScsXG4gICAgJ2VjZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmN2YnLFxuICAgICcyNmU4OTU4ZmMyYjIyN2IwNDVjM2Y0ODlmMmVmOThmMGQ1ZGZhYzA1ZDNjNjMzMzliMTM4MDI4ODZkNTNmYzg1JyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJ2M3MTc2YTcwM2Q0ZGQ4NGZiYTNjMGI3NjBkMTA2NzBmMmEyMDUzZmEyYzM5Y2NjNjRlYzdmZDc3OTJhYzAzZmEnLFxuXTtcbmNvbnN0IEZwID0gRmllbGQoRUQyNTUxOV9QLCB1bmRlZmluZWQsIHRydWUpO1xuY29uc3QgZWQyNTUxOURlZmF1bHRzID0ge1xuICAgIC8vIFBhcmFtOiBhXG4gICAgYTogQmlnSW50KC0xKSwgLy8gRnAuY3JlYXRlKC0xKSBpcyBwcm9wZXI7IG91ciB3YXkgc3RpbGwgd29ya3MgYW5kIGlzIGZhc3RlclxuICAgIC8vIGQgaXMgZXF1YWwgdG8gLTEyMTY2NS8xMjE2NjYgb3ZlciBmaW5pdGUgZmllbGQuXG4gICAgLy8gTmVnYXRpdmUgbnVtYmVyIGlzIFAgLSBudW1iZXIsIGFuZCBkaXZpc2lvbiBpcyBpbnZlcnQobnVtYmVyLCBQKVxuICAgIGQ6IEJpZ0ludCgnMzcwOTU3MDU5MzQ2Njk0MzkzNDMxMzgwODM1MDg3NTQ1NjUxODk1NDIxMTM4Nzk4NDMyMTkwMTYzODg3ODU1MzMwODU5NDAyODM1NTUnKSxcbiAgICAvLyBGaW5pdGUgZmllbGQg8J2UvXAgb3ZlciB3aGljaCB3ZSdsbCBkbyBjYWxjdWxhdGlvbnM7IDJuKioyNTVuIC0gMTluXG4gICAgRnAsXG4gICAgLy8gU3ViZ3JvdXAgb3JkZXI6IGhvdyBtYW55IHBvaW50cyBjdXJ2ZSBoYXNcbiAgICAvLyAybioqMjUybiArIDI3NzQyMzE3Nzc3MzcyMzUzNTM1ODUxOTM3NzkwODgzNjQ4NDkzbjtcbiAgICBuOiBCaWdJbnQoJzcyMzcwMDU1NzczMzIyNjIyMTM5NzMxODY1NjMwNDI5OTQyNDA4NTcxMTYzNTkzNzk5MDc2MDYwMDE5NTA5MzgyODU0NTQyNTA5ODknKSxcbiAgICAvLyBDb2ZhY3RvclxuICAgIGg6IEJpZ0ludCg4KSxcbiAgICAvLyBCYXNlIHBvaW50ICh4LCB5KSBha2EgZ2VuZXJhdG9yIHBvaW50XG4gICAgR3g6IEJpZ0ludCgnMTUxMTIyMjEzNDk1MzU0MDA3NzI1MDExNTE0MDk1ODg1MzE1MTE0NTQwMTI2OTMwNDE4NTcyMDYwNDYxMTMyODM5NDk4NDc3NjIyMDInKSxcbiAgICBHeTogQmlnSW50KCc0NjMxNjgzNTY5NDkyNjQ3ODE2OTQyODM5NDAwMzQ3NTE2MzE0MTMwNzk5Mzg2NjI1NjIyNTYxNTc4MzAzMzYwMzE2NTI1MTg1NTk2MCcpLFxuICAgIGhhc2g6IHNoYTUxMixcbiAgICByYW5kb21CeXRlcyxcbiAgICBhZGp1c3RTY2FsYXJCeXRlcyxcbiAgICAvLyBkb20yXG4gICAgLy8gUmF0aW8gb2YgdSB0byB2LiBBbGxvd3MgdXMgdG8gY29tYmluZSBpbnZlcnNpb24gYW5kIHNxdWFyZSByb290LiBVc2VzIGFsZ28gZnJvbSBSRkM4MDMyIDUuMS4zLlxuICAgIC8vIENvbnN0YW50LXRpbWUsIHUv4oiadlxuICAgIHV2UmF0aW8sXG59O1xuZXhwb3J0IGNvbnN0IGVkMjU1MTkgPSAvKiBAX19QVVJFX18gKi8gdHdpc3RlZEVkd2FyZHMoZWQyNTUxOURlZmF1bHRzKTtcbmZ1bmN0aW9uIGVkMjU1MTlfZG9tYWluKGRhdGEsIGN0eCwgcGhmbGFnKSB7XG4gICAgaWYgKGN0eC5sZW5ndGggPiAyNTUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ29udGV4dCBpcyB0b28gYmlnJyk7XG4gICAgcmV0dXJuIGNvbmNhdEJ5dGVzKHV0ZjhUb0J5dGVzKCdTaWdFZDI1NTE5IG5vIEVkMjU1MTkgY29sbGlzaW9ucycpLCBuZXcgVWludDhBcnJheShbcGhmbGFnID8gMSA6IDAsIGN0eC5sZW5ndGhdKSwgY3R4LCBkYXRhKTtcbn1cbmV4cG9ydCBjb25zdCBlZDI1NTE5Y3R4ID0gLyogQF9fUFVSRV9fICovIHR3aXN0ZWRFZHdhcmRzKHtcbiAgICAuLi5lZDI1NTE5RGVmYXVsdHMsXG4gICAgZG9tYWluOiBlZDI1NTE5X2RvbWFpbixcbn0pO1xuZXhwb3J0IGNvbnN0IGVkMjU1MTlwaCA9IC8qIEBfX1BVUkVfXyAqLyB0d2lzdGVkRWR3YXJkcyh7XG4gICAgLi4uZWQyNTUxOURlZmF1bHRzLFxuICAgIGRvbWFpbjogZWQyNTUxOV9kb21haW4sXG4gICAgcHJlaGFzaDogc2hhNTEyLFxufSk7XG5leHBvcnQgY29uc3QgeDI1NTE5ID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBtb250Z29tZXJ5KHtcbiAgICBQOiBFRDI1NTE5X1AsXG4gICAgYTogQmlnSW50KDQ4NjY2MiksXG4gICAgbW9udGdvbWVyeUJpdHM6IDI1NSwgLy8gbiBpcyAyNTMgYml0c1xuICAgIG5CeXRlTGVuZ3RoOiAzMixcbiAgICBHdTogQmlnSW50KDkpLFxuICAgIHBvd1BtaW51czI6ICh4KSA9PiB7XG4gICAgICAgIGNvbnN0IFAgPSBFRDI1NTE5X1A7XG4gICAgICAgIC8vIHheKHAtMikgYWthIHheKDJeMjU1LTIxKVxuICAgICAgICBjb25zdCB7IHBvd19wXzVfOCwgYjIgfSA9IGVkMjU1MTlfcG93XzJfMjUyXzMoeCk7XG4gICAgICAgIHJldHVybiBtb2QocG93Mihwb3dfcF81XzgsIEJpZ0ludCgzKSwgUCkgKiBiMiwgUCk7XG4gICAgfSxcbiAgICBhZGp1c3RTY2FsYXJCeXRlcyxcbiAgICByYW5kb21CeXRlcyxcbn0pKSgpO1xuLyoqXG4gKiBDb252ZXJ0cyBlZDI1NTE5IHB1YmxpYyBrZXkgdG8geDI1NTE5IHB1YmxpYyBrZXkuIFVzZXMgZm9ybXVsYTpcbiAqICogYCh1LCB2KSA9ICgoMSt5KS8oMS15KSwgc3FydCgtNDg2NjY0KSp1L3gpYFxuICogKiBgKHgsIHkpID0gKHNxcnQoLTQ4NjY2NCkqdS92LCAodS0xKS8odSsxKSlgXG4gKiBAZXhhbXBsZVxuICogICBjb25zdCBzb21lb25lc1B1YiA9IGVkMjU1MTkuZ2V0UHVibGljS2V5KGVkMjU1MTkudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpKTtcbiAqICAgY29uc3QgYVByaXYgPSB4MjU1MTkudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpO1xuICogICB4MjU1MTkuZ2V0U2hhcmVkU2VjcmV0KGFQcml2LCBlZHdhcmRzVG9Nb250Z29tZXJ5UHViKHNvbWVvbmVzUHViKSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVkd2FyZHNUb01vbnRnb21lcnlQdWIoZWR3YXJkc1B1Yikge1xuICAgIGNvbnN0IHsgeSB9ID0gZWQyNTUxOS5FeHRlbmRlZFBvaW50LmZyb21IZXgoZWR3YXJkc1B1Yik7XG4gICAgY29uc3QgXzFuID0gQmlnSW50KDEpO1xuICAgIHJldHVybiBGcC50b0J5dGVzKEZwLmNyZWF0ZSgoXzFuICsgeSkgKiBGcC5pbnYoXzFuIC0geSkpKTtcbn1cbmV4cG9ydCBjb25zdCBlZHdhcmRzVG9Nb250Z29tZXJ5ID0gZWR3YXJkc1RvTW9udGdvbWVyeVB1YjsgLy8gZGVwcmVjYXRlZFxuLyoqXG4gKiBDb252ZXJ0cyBlZDI1NTE5IHNlY3JldCBrZXkgdG8geDI1NTE5IHNlY3JldCBrZXkuXG4gKiBAZXhhbXBsZVxuICogICBjb25zdCBzb21lb25lc1B1YiA9IHgyNTUxOS5nZXRQdWJsaWNLZXkoeDI1NTE5LnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKSk7XG4gKiAgIGNvbnN0IGFQcml2ID0gZWQyNTUxOS51dGlscy5yYW5kb21Qcml2YXRlS2V5KCk7XG4gKiAgIHgyNTUxOS5nZXRTaGFyZWRTZWNyZXQoZWR3YXJkc1RvTW9udGdvbWVyeVByaXYoYVByaXYpLCBzb21lb25lc1B1YilcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVkd2FyZHNUb01vbnRnb21lcnlQcml2KGVkd2FyZHNQcml2KSB7XG4gICAgY29uc3QgaGFzaGVkID0gZWQyNTUxOURlZmF1bHRzLmhhc2goZWR3YXJkc1ByaXYuc3ViYXJyYXkoMCwgMzIpKTtcbiAgICByZXR1cm4gZWQyNTUxOURlZmF1bHRzLmFkanVzdFNjYWxhckJ5dGVzKGhhc2hlZCkuc3ViYXJyYXkoMCwgMzIpO1xufVxuLy8gSGFzaCBUbyBDdXJ2ZSBFbGxpZ2F0b3IyIE1hcCAoTk9URTogZGlmZmVyZW50IGZyb20gcmlzdHJldHRvMjU1IGVsbGlnYXRvcilcbi8vIE5PVEU6IHZlcnkgaW1wb3J0YW50IHBhcnQgaXMgdXNhZ2Ugb2YgRnBTcXJ0RXZlbiBmb3IgRUxMMl9DMV9FRFdBUkRTLCBzaW5jZVxuLy8gU2FnZU1hdGggcmV0dXJucyBkaWZmZXJlbnQgcm9vdCBmaXJzdCBhbmQgZXZlcnl0aGluZyBmYWxscyBhcGFydFxuY29uc3QgRUxMMl9DMSA9IChGcC5PUkRFUiArIEJpZ0ludCgzKSkgLyBCaWdJbnQoOCk7IC8vIDEuIGMxID0gKHEgKyAzKSAvIDggICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbmNvbnN0IEVMTDJfQzIgPSBGcC5wb3coXzJuLCBFTEwyX0MxKTsgLy8gMi4gYzIgPSAyXmMxXG5jb25zdCBFTEwyX0MzID0gRnAuc3FydChGcC5uZWcoRnAuT05FKSk7IC8vIDMuIGMzID0gc3FydCgtMSlcbmNvbnN0IEVMTDJfQzQgPSAoRnAuT1JERVIgLSBCaWdJbnQoNSkpIC8gQmlnSW50KDgpOyAvLyA0LiBjNCA9IChxIC0gNSkgLyA4ICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG5jb25zdCBFTEwyX0ogPSBCaWdJbnQoNDg2NjYyKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuZnVuY3Rpb24gbWFwX3RvX2N1cnZlX2VsbGlnYXRvcjJfY3VydmUyNTUxOSh1KSB7XG4gICAgbGV0IHR2MSA9IEZwLnNxcih1KTsgLy8gIDEuICB0djEgPSB1XjJcbiAgICB0djEgPSBGcC5tdWwodHYxLCBfMm4pOyAvLyAgMi4gIHR2MSA9IDIgKiB0djFcbiAgICBsZXQgeGQgPSBGcC5hZGQodHYxLCBGcC5PTkUpOyAvLyAgMy4gICB4ZCA9IHR2MSArIDEgICAgICAgICAjIE5vbnplcm86IC0xIGlzIHNxdWFyZSAobW9kIHApLCB0djEgaXMgbm90XG4gICAgbGV0IHgxbiA9IEZwLm5lZyhFTEwyX0opOyAvLyAgNC4gIHgxbiA9IC1KICAgICAgICAgICAgICAjIHgxID0geDFuIC8geGQgPSAtSiAvICgxICsgMiAqIHVeMilcbiAgICBsZXQgdHYyID0gRnAuc3FyKHhkKTsgLy8gIDUuICB0djIgPSB4ZF4yXG4gICAgbGV0IGd4ZCA9IEZwLm11bCh0djIsIHhkKTsgLy8gIDYuICBneGQgPSB0djIgKiB4ZCAgICAgICAgIyBneGQgPSB4ZF4zXG4gICAgbGV0IGd4MSA9IEZwLm11bCh0djEsIEVMTDJfSik7IC8vICA3LiAgZ3gxID0gSiAqIHR2MSAgICAgICAgICMgeDFuICsgSiAqIHhkXG4gICAgZ3gxID0gRnAubXVsKGd4MSwgeDFuKTsgLy8gIDguICBneDEgPSBneDEgKiB4MW4gICAgICAgIyB4MW5eMiArIEogKiB4MW4gKiB4ZFxuICAgIGd4MSA9IEZwLmFkZChneDEsIHR2Mik7IC8vICA5LiAgZ3gxID0gZ3gxICsgdHYyICAgICAgICMgeDFuXjIgKyBKICogeDFuICogeGQgKyB4ZF4yXG4gICAgZ3gxID0gRnAubXVsKGd4MSwgeDFuKTsgLy8gIDEwLiBneDEgPSBneDEgKiB4MW4gICAgICAgIyB4MW5eMyArIEogKiB4MW5eMiAqIHhkICsgeDFuICogeGReMlxuICAgIGxldCB0djMgPSBGcC5zcXIoZ3hkKTsgLy8gIDExLiB0djMgPSBneGReMlxuICAgIHR2MiA9IEZwLnNxcih0djMpOyAvLyAgMTIuIHR2MiA9IHR2M14yICAgICAgICAgICAjIGd4ZF40XG4gICAgdHYzID0gRnAubXVsKHR2MywgZ3hkKTsgLy8gIDEzLiB0djMgPSB0djMgKiBneGQgICAgICAgIyBneGReM1xuICAgIHR2MyA9IEZwLm11bCh0djMsIGd4MSk7IC8vICAxNC4gdHYzID0gdHYzICogZ3gxICAgICAgICMgZ3gxICogZ3hkXjNcbiAgICB0djIgPSBGcC5tdWwodHYyLCB0djMpOyAvLyAgMTUuIHR2MiA9IHR2MiAqIHR2MyAgICAgICAjIGd4MSAqIGd4ZF43XG4gICAgbGV0IHkxMSA9IEZwLnBvdyh0djIsIEVMTDJfQzQpOyAvLyAgMTYuIHkxMSA9IHR2Ml5jNCAgICAgICAgIyAoZ3gxICogZ3hkXjcpXigocCAtIDUpIC8gOClcbiAgICB5MTEgPSBGcC5tdWwoeTExLCB0djMpOyAvLyAgMTcuIHkxMSA9IHkxMSAqIHR2MyAgICAgICAjIGd4MSpneGReMyooZ3gxKmd4ZF43KV4oKHAtNSkvOClcbiAgICBsZXQgeTEyID0gRnAubXVsKHkxMSwgRUxMMl9DMyk7IC8vICAxOC4geTEyID0geTExICogYzNcbiAgICB0djIgPSBGcC5zcXIoeTExKTsgLy8gIDE5LiB0djIgPSB5MTFeMlxuICAgIHR2MiA9IEZwLm11bCh0djIsIGd4ZCk7IC8vICAyMC4gdHYyID0gdHYyICogZ3hkXG4gICAgbGV0IGUxID0gRnAuZXFsKHR2MiwgZ3gxKTsgLy8gIDIxLiAgZTEgPSB0djIgPT0gZ3gxXG4gICAgbGV0IHkxID0gRnAuY21vdih5MTIsIHkxMSwgZTEpOyAvLyAgMjIuICB5MSA9IENNT1YoeTEyLCB5MTEsIGUxKSAgIyBJZiBnKHgxKSBpcyBzcXVhcmUsIHRoaXMgaXMgaXRzIHNxcnRcbiAgICBsZXQgeDJuID0gRnAubXVsKHgxbiwgdHYxKTsgLy8gIDIzLiB4Mm4gPSB4MW4gKiB0djEgICAgICAgIyB4MiA9IHgybiAvIHhkID0gMiAqIHVeMiAqIHgxbiAvIHhkXG4gICAgbGV0IHkyMSA9IEZwLm11bCh5MTEsIHUpOyAvLyAgMjQuIHkyMSA9IHkxMSAqIHVcbiAgICB5MjEgPSBGcC5tdWwoeTIxLCBFTEwyX0MyKTsgLy8gIDI1LiB5MjEgPSB5MjEgKiBjMlxuICAgIGxldCB5MjIgPSBGcC5tdWwoeTIxLCBFTEwyX0MzKTsgLy8gIDI2LiB5MjIgPSB5MjEgKiBjM1xuICAgIGxldCBneDIgPSBGcC5tdWwoZ3gxLCB0djEpOyAvLyAgMjcuIGd4MiA9IGd4MSAqIHR2MSAgICAgICAjIGcoeDIpID0gZ3gyIC8gZ3hkID0gMiAqIHVeMiAqIGcoeDEpXG4gICAgdHYyID0gRnAuc3FyKHkyMSk7IC8vICAyOC4gdHYyID0geTIxXjJcbiAgICB0djIgPSBGcC5tdWwodHYyLCBneGQpOyAvLyAgMjkuIHR2MiA9IHR2MiAqIGd4ZFxuICAgIGxldCBlMiA9IEZwLmVxbCh0djIsIGd4Mik7IC8vICAzMC4gIGUyID0gdHYyID09IGd4MlxuICAgIGxldCB5MiA9IEZwLmNtb3YoeTIyLCB5MjEsIGUyKTsgLy8gIDMxLiAgeTIgPSBDTU9WKHkyMiwgeTIxLCBlMikgICMgSWYgZyh4MikgaXMgc3F1YXJlLCB0aGlzIGlzIGl0cyBzcXJ0XG4gICAgdHYyID0gRnAuc3FyKHkxKTsgLy8gIDMyLiB0djIgPSB5MV4yXG4gICAgdHYyID0gRnAubXVsKHR2MiwgZ3hkKTsgLy8gIDMzLiB0djIgPSB0djIgKiBneGRcbiAgICBsZXQgZTMgPSBGcC5lcWwodHYyLCBneDEpOyAvLyAgMzQuICBlMyA9IHR2MiA9PSBneDFcbiAgICBsZXQgeG4gPSBGcC5jbW92KHgybiwgeDFuLCBlMyk7IC8vICAzNS4gIHhuID0gQ01PVih4Mm4sIHgxbiwgZTMpICAjIElmIGUzLCB4ID0geDEsIGVsc2UgeCA9IHgyXG4gICAgbGV0IHkgPSBGcC5jbW92KHkyLCB5MSwgZTMpOyAvLyAgMzYuICAgeSA9IENNT1YoeTIsIHkxLCBlMykgICAgIyBJZiBlMywgeSA9IHkxLCBlbHNlIHkgPSB5MlxuICAgIGxldCBlNCA9IEZwLmlzT2RkKHkpOyAvLyAgMzcuICBlNCA9IHNnbjAoeSkgPT0gMSAgICAgICAgIyBGaXggc2lnbiBvZiB5XG4gICAgeSA9IEZwLmNtb3YoeSwgRnAubmVnKHkpLCBlMyAhPT0gZTQpOyAvLyAgMzguICAgeSA9IENNT1YoeSwgLXksIGUzIFhPUiBlNClcbiAgICByZXR1cm4geyB4TW46IHhuLCB4TWQ6IHhkLCB5TW46IHksIHlNZDogXzFuIH07IC8vICAzOS4gcmV0dXJuICh4biwgeGQsIHksIDEpXG59XG5jb25zdCBFTEwyX0MxX0VEV0FSRFMgPSBGcFNxcnRFdmVuKEZwLCBGcC5uZWcoQmlnSW50KDQ4NjY2NCkpKTsgLy8gc2duMChjMSkgTVVTVCBlcXVhbCAwXG5mdW5jdGlvbiBtYXBfdG9fY3VydmVfZWxsaWdhdG9yMl9lZHdhcmRzMjU1MTkodSkge1xuICAgIGNvbnN0IHsgeE1uLCB4TWQsIHlNbiwgeU1kIH0gPSBtYXBfdG9fY3VydmVfZWxsaWdhdG9yMl9jdXJ2ZTI1NTE5KHUpOyAvLyAgMS4gICh4TW4sIHhNZCwgeU1uLCB5TWQpID1cbiAgICAvLyBtYXBfdG9fY3VydmVfZWxsaWdhdG9yMl9jdXJ2ZTI1NTE5KHUpXG4gICAgbGV0IHhuID0gRnAubXVsKHhNbiwgeU1kKTsgLy8gIDIuICB4biA9IHhNbiAqIHlNZFxuICAgIHhuID0gRnAubXVsKHhuLCBFTEwyX0MxX0VEV0FSRFMpOyAvLyAgMy4gIHhuID0geG4gKiBjMVxuICAgIGxldCB4ZCA9IEZwLm11bCh4TWQsIHlNbik7IC8vICA0LiAgeGQgPSB4TWQgKiB5TW4gICAgIyB4biAvIHhkID0gYzEgKiB4TSAvIHlNXG4gICAgbGV0IHluID0gRnAuc3ViKHhNbiwgeE1kKTsgLy8gIDUuICB5biA9IHhNbiAtIHhNZFxuICAgIGxldCB5ZCA9IEZwLmFkZCh4TW4sIHhNZCk7IC8vICA2LiAgeWQgPSB4TW4gKyB4TWQgICAgIyAobiAvIGQgLSAxKSAvIChuIC8gZCArIDEpID0gKG4gLSBkKSAvIChuICsgZClcbiAgICBsZXQgdHYxID0gRnAubXVsKHhkLCB5ZCk7IC8vICA3LiB0djEgPSB4ZCAqIHlkXG4gICAgbGV0IGUgPSBGcC5lcWwodHYxLCBGcC5aRVJPKTsgLy8gIDguICAgZSA9IHR2MSA9PSAwXG4gICAgeG4gPSBGcC5jbW92KHhuLCBGcC5aRVJPLCBlKTsgLy8gIDkuICB4biA9IENNT1YoeG4sIDAsIGUpXG4gICAgeGQgPSBGcC5jbW92KHhkLCBGcC5PTkUsIGUpOyAvLyAgMTAuIHhkID0gQ01PVih4ZCwgMSwgZSlcbiAgICB5biA9IEZwLmNtb3YoeW4sIEZwLk9ORSwgZSk7IC8vICAxMS4geW4gPSBDTU9WKHluLCAxLCBlKVxuICAgIHlkID0gRnAuY21vdih5ZCwgRnAuT05FLCBlKTsgLy8gIDEyLiB5ZCA9IENNT1YoeWQsIDEsIGUpXG4gICAgY29uc3QgaW52ID0gRnAuaW52ZXJ0QmF0Y2goW3hkLCB5ZF0pOyAvLyBiYXRjaCBkaXZpc2lvblxuICAgIHJldHVybiB7IHg6IEZwLm11bCh4biwgaW52WzBdKSwgeTogRnAubXVsKHluLCBpbnZbMV0pIH07IC8vICAxMy4gcmV0dXJuICh4biwgeGQsIHluLCB5ZClcbn1cbmNvbnN0IGh0ZiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gY3JlYXRlSGFzaGVyKGVkMjU1MTkuRXh0ZW5kZWRQb2ludCwgKHNjYWxhcnMpID0+IG1hcF90b19jdXJ2ZV9lbGxpZ2F0b3IyX2Vkd2FyZHMyNTUxOShzY2FsYXJzWzBdKSwge1xuICAgIERTVDogJ2Vkd2FyZHMyNTUxOV9YTUQ6U0hBLTUxMl9FTEwyX1JPXycsXG4gICAgZW5jb2RlRFNUOiAnZWR3YXJkczI1NTE5X1hNRDpTSEEtNTEyX0VMTDJfTlVfJyxcbiAgICBwOiBGcC5PUkRFUixcbiAgICBtOiAxLFxuICAgIGs6IDEyOCxcbiAgICBleHBhbmQ6ICd4bWQnLFxuICAgIGhhc2g6IHNoYTUxMixcbn0pKSgpO1xuZXhwb3J0IGNvbnN0IGhhc2hUb0N1cnZlID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBodGYuaGFzaFRvQ3VydmUpKCk7XG5leHBvcnQgY29uc3QgZW5jb2RlVG9DdXJ2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gaHRmLmVuY29kZVRvQ3VydmUpKCk7XG5mdW5jdGlvbiBhc3NlcnRSc3RQb2ludChvdGhlcikge1xuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgUmlzdFBvaW50KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSaXN0cmV0dG9Qb2ludCBleHBlY3RlZCcpO1xufVxuLy8g4oiaKC0xKSBha2Eg4oiaKGEpIGFrYSAyXigocC0xKS80KVxuY29uc3QgU1FSVF9NMSA9IEVEMjU1MTlfU1FSVF9NMTtcbi8vIOKImihhZCAtIDEpXG5jb25zdCBTUVJUX0FEX01JTlVTX09ORSA9IEJpZ0ludCgnMjUwNjMwNjg5NTMzODQ2MjM0NzQxMTE0MTQxNTg3MDIxNTI3MDEyNDQ1MzE1MDI0OTI2NTY0NjAwNzkyMTA0ODI2MTA0MzA3NTAyMzUnKTtcbi8vIDEgLyDiiJooYS1kKVxuY29uc3QgSU5WU1FSVF9BX01JTlVTX0QgPSBCaWdJbnQoJzU0NDY5MzA3MDA4OTA5MzE2OTIwOTk1ODEzODY4NzQ1MTQxNjA1MzkzNTk3MjkyOTI3NDU2OTIxMjA1MzEyODk2MzExNzIxMDE3NTc4Jyk7XG4vLyAxLWTCslxuY29uc3QgT05FX01JTlVTX0RfU1EgPSBCaWdJbnQoJzExNTk4NDMwMjE2Njg3Nzk4NzkxOTM3NzU1MjE4NTU1ODY2NDc5MzczNTc3NTk3MTU0MTc2NTQ0Mzk4Nzk3MjA4NzYxMTE4MDY4MzgnKTtcbi8vIChkLTEpwrJcbmNvbnN0IERfTUlOVVNfT05FX1NRID0gQmlnSW50KCc0MDQ0MDgzNDM0NjMwODUzNjg1ODEwMTA0MjQ2OTMyMzE5MDgyNjI0ODM5OTE0NjIzODcwODM1MjI0MDEzMzIyMDg2NTEzNzI2NTk1MicpO1xuLy8gQ2FsY3VsYXRlcyAxL+KImihudW1iZXIpXG5jb25zdCBpbnZlcnRTcXJ0ID0gKG51bWJlcikgPT4gdXZSYXRpbyhfMW4sIG51bWJlcik7XG5jb25zdCBNQVhfMjU1QiA9IEJpZ0ludCgnMHg3ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmJyk7XG5jb25zdCBieXRlczI1NVRvTnVtYmVyTEUgPSAoYnl0ZXMpID0+IGVkMjU1MTkuQ1VSVkUuRnAuY3JlYXRlKGJ5dGVzVG9OdW1iZXJMRShieXRlcykgJiBNQVhfMjU1Qik7XG4vLyBDb21wdXRlcyBFbGxpZ2F0b3IgbWFwIGZvciBSaXN0cmV0dG9cbi8vIGh0dHBzOi8vcmlzdHJldHRvLmdyb3VwL2Zvcm11bGFzL2VsbGlnYXRvci5odG1sXG5mdW5jdGlvbiBjYWxjRWxsaWdhdG9yUmlzdHJldHRvTWFwKHIwKSB7XG4gICAgY29uc3QgeyBkIH0gPSBlZDI1NTE5LkNVUlZFO1xuICAgIGNvbnN0IFAgPSBlZDI1NTE5LkNVUlZFLkZwLk9SREVSO1xuICAgIGNvbnN0IG1vZCA9IGVkMjU1MTkuQ1VSVkUuRnAuY3JlYXRlO1xuICAgIGNvbnN0IHIgPSBtb2QoU1FSVF9NMSAqIHIwICogcjApOyAvLyAxXG4gICAgY29uc3QgTnMgPSBtb2QoKHIgKyBfMW4pICogT05FX01JTlVTX0RfU1EpOyAvLyAyXG4gICAgbGV0IGMgPSBCaWdJbnQoLTEpOyAvLyAzXG4gICAgY29uc3QgRCA9IG1vZCgoYyAtIGQgKiByKSAqIG1vZChyICsgZCkpOyAvLyA0XG4gICAgbGV0IHsgaXNWYWxpZDogTnNfRF9pc19zcSwgdmFsdWU6IHMgfSA9IHV2UmF0aW8oTnMsIEQpOyAvLyA1XG4gICAgbGV0IHNfID0gbW9kKHMgKiByMCk7IC8vIDZcbiAgICBpZiAoIWlzTmVnYXRpdmVMRShzXywgUCkpXG4gICAgICAgIHNfID0gbW9kKC1zXyk7XG4gICAgaWYgKCFOc19EX2lzX3NxKVxuICAgICAgICBzID0gc187IC8vIDdcbiAgICBpZiAoIU5zX0RfaXNfc3EpXG4gICAgICAgIGMgPSByOyAvLyA4XG4gICAgY29uc3QgTnQgPSBtb2QoYyAqIChyIC0gXzFuKSAqIERfTUlOVVNfT05FX1NRIC0gRCk7IC8vIDlcbiAgICBjb25zdCBzMiA9IHMgKiBzO1xuICAgIGNvbnN0IFcwID0gbW9kKChzICsgcykgKiBEKTsgLy8gMTBcbiAgICBjb25zdCBXMSA9IG1vZChOdCAqIFNRUlRfQURfTUlOVVNfT05FKTsgLy8gMTFcbiAgICBjb25zdCBXMiA9IG1vZChfMW4gLSBzMik7IC8vIDEyXG4gICAgY29uc3QgVzMgPSBtb2QoXzFuICsgczIpOyAvLyAxM1xuICAgIHJldHVybiBuZXcgZWQyNTUxOS5FeHRlbmRlZFBvaW50KG1vZChXMCAqIFczKSwgbW9kKFcyICogVzEpLCBtb2QoVzEgKiBXMyksIG1vZChXMCAqIFcyKSk7XG59XG4vKipcbiAqIEVhY2ggZWQyNTUxOS9FeHRlbmRlZFBvaW50IGhhcyA4IGRpZmZlcmVudCBlcXVpdmFsZW50IHBvaW50cy4gVGhpcyBjYW4gYmVcbiAqIGEgc291cmNlIG9mIGJ1Z3MgZm9yIHByb3RvY29scyBsaWtlIHJpbmcgc2lnbmF0dXJlcy4gUmlzdHJldHRvIHdhcyBjcmVhdGVkIHRvIHNvbHZlIHRoaXMuXG4gKiBSaXN0cmV0dG8gcG9pbnQgb3BlcmF0ZXMgaW4gWDpZOlo6VCBleHRlbmRlZCBjb29yZGluYXRlcyBsaWtlIEV4dGVuZGVkUG9pbnQsXG4gKiBidXQgaXQgc2hvdWxkIHdvcmsgaW4gaXRzIG93biBuYW1lc3BhY2U6IGRvIG5vdCBjb21iaW5lIHRob3NlIHR3by5cbiAqIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaXJ0Zi1jZnJnLXJpc3RyZXR0bzI1NS1kZWNhZjQ0OFxuICovXG5jbGFzcyBSaXN0UG9pbnQge1xuICAgIC8vIFByaXZhdGUgcHJvcGVydHkgdG8gZGlzY291cmFnZSBjb21iaW5pbmcgRXh0ZW5kZWRQb2ludCArIFJpc3RyZXR0b1BvaW50XG4gICAgLy8gQWx3YXlzIHVzZSBSaXN0cmV0dG8gZW5jb2RpbmcvZGVjb2RpbmcgaW5zdGVhZC5cbiAgICBjb25zdHJ1Y3RvcihlcCkge1xuICAgICAgICB0aGlzLmVwID0gZXA7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQWZmaW5lKGFwKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmlzdFBvaW50KGVkMjU1MTkuRXh0ZW5kZWRQb2ludC5mcm9tQWZmaW5lKGFwKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRha2VzIHVuaWZvcm0gb3V0cHV0IG9mIDY0LWJ5dGUgaGFzaCBmdW5jdGlvbiBsaWtlIHNoYTUxMiBhbmQgY29udmVydHMgaXQgdG8gYFJpc3RyZXR0b1BvaW50YC5cbiAgICAgKiBUaGUgaGFzaC10by1ncm91cCBvcGVyYXRpb24gYXBwbGllcyBFbGxpZ2F0b3IgdHdpY2UgYW5kIGFkZHMgdGhlIHJlc3VsdHMuXG4gICAgICogKipOb3RlOioqIHRoaXMgaXMgb25lLXdheSBtYXAsIHRoZXJlIGlzIG5vIGNvbnZlcnNpb24gZnJvbSBwb2ludCB0byBoYXNoLlxuICAgICAqIGh0dHBzOi8vcmlzdHJldHRvLmdyb3VwL2Zvcm11bGFzL2VsbGlnYXRvci5odG1sXG4gICAgICogQHBhcmFtIGhleCA2NC1ieXRlIG91dHB1dCBvZiBhIGhhc2ggZnVuY3Rpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgaGFzaFRvQ3VydmUoaGV4KSB7XG4gICAgICAgIGhleCA9IGVuc3VyZUJ5dGVzKCdyaXN0cmV0dG9IYXNoJywgaGV4LCA2NCk7XG4gICAgICAgIGNvbnN0IHIxID0gYnl0ZXMyNTVUb051bWJlckxFKGhleC5zbGljZSgwLCAzMikpO1xuICAgICAgICBjb25zdCBSMSA9IGNhbGNFbGxpZ2F0b3JSaXN0cmV0dG9NYXAocjEpO1xuICAgICAgICBjb25zdCByMiA9IGJ5dGVzMjU1VG9OdW1iZXJMRShoZXguc2xpY2UoMzIsIDY0KSk7XG4gICAgICAgIGNvbnN0IFIyID0gY2FsY0VsbGlnYXRvclJpc3RyZXR0b01hcChyMik7XG4gICAgICAgIHJldHVybiBuZXcgUmlzdFBvaW50KFIxLmFkZChSMikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyByaXN0cmV0dG8tZW5jb2RlZCBzdHJpbmcgdG8gcmlzdHJldHRvIHBvaW50LlxuICAgICAqIGh0dHBzOi8vcmlzdHJldHRvLmdyb3VwL2Zvcm11bGFzL2RlY29kaW5nLmh0bWxcbiAgICAgKiBAcGFyYW0gaGV4IFJpc3RyZXR0by1lbmNvZGVkIDMyIGJ5dGVzLiBOb3QgZXZlcnkgMzItYnl0ZSBzdHJpbmcgaXMgdmFsaWQgcmlzdHJldHRvIGVuY29kaW5nXG4gICAgICovXG4gICAgc3RhdGljIGZyb21IZXgoaGV4KSB7XG4gICAgICAgIGhleCA9IGVuc3VyZUJ5dGVzKCdyaXN0cmV0dG9IZXgnLCBoZXgsIDMyKTtcbiAgICAgICAgY29uc3QgeyBhLCBkIH0gPSBlZDI1NTE5LkNVUlZFO1xuICAgICAgICBjb25zdCBQID0gZWQyNTUxOS5DVVJWRS5GcC5PUkRFUjtcbiAgICAgICAgY29uc3QgbW9kID0gZWQyNTUxOS5DVVJWRS5GcC5jcmVhdGU7XG4gICAgICAgIGNvbnN0IGVtc2cgPSAnUmlzdHJldHRvUG9pbnQuZnJvbUhleDogdGhlIGhleCBpcyBub3QgdmFsaWQgZW5jb2Rpbmcgb2YgUmlzdHJldHRvUG9pbnQnO1xuICAgICAgICBjb25zdCBzID0gYnl0ZXMyNTVUb051bWJlckxFKGhleCk7XG4gICAgICAgIC8vIDEuIENoZWNrIHRoYXQgc19ieXRlcyBpcyB0aGUgY2Fub25pY2FsIGVuY29kaW5nIG9mIGEgZmllbGQgZWxlbWVudCwgb3IgZWxzZSBhYm9ydC5cbiAgICAgICAgLy8gMy4gQ2hlY2sgdGhhdCBzIGlzIG5vbi1uZWdhdGl2ZSwgb3IgZWxzZSBhYm9ydFxuICAgICAgICBpZiAoIWVxdWFsQnl0ZXMobnVtYmVyVG9CeXRlc0xFKHMsIDMyKSwgaGV4KSB8fCBpc05lZ2F0aXZlTEUocywgUCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZW1zZyk7XG4gICAgICAgIGNvbnN0IHMyID0gbW9kKHMgKiBzKTtcbiAgICAgICAgY29uc3QgdTEgPSBtb2QoXzFuICsgYSAqIHMyKTsgLy8gNCAoYSBpcyAtMSlcbiAgICAgICAgY29uc3QgdTIgPSBtb2QoXzFuIC0gYSAqIHMyKTsgLy8gNVxuICAgICAgICBjb25zdCB1MV8yID0gbW9kKHUxICogdTEpO1xuICAgICAgICBjb25zdCB1Ml8yID0gbW9kKHUyICogdTIpO1xuICAgICAgICBjb25zdCB2ID0gbW9kKGEgKiBkICogdTFfMiAtIHUyXzIpOyAvLyA2XG4gICAgICAgIGNvbnN0IHsgaXNWYWxpZCwgdmFsdWU6IEkgfSA9IGludmVydFNxcnQobW9kKHYgKiB1Ml8yKSk7IC8vIDdcbiAgICAgICAgY29uc3QgRHggPSBtb2QoSSAqIHUyKTsgLy8gOFxuICAgICAgICBjb25zdCBEeSA9IG1vZChJICogRHggKiB2KTsgLy8gOVxuICAgICAgICBsZXQgeCA9IG1vZCgocyArIHMpICogRHgpOyAvLyAxMFxuICAgICAgICBpZiAoaXNOZWdhdGl2ZUxFKHgsIFApKVxuICAgICAgICAgICAgeCA9IG1vZCgteCk7IC8vIDEwXG4gICAgICAgIGNvbnN0IHkgPSBtb2QodTEgKiBEeSk7IC8vIDExXG4gICAgICAgIGNvbnN0IHQgPSBtb2QoeCAqIHkpOyAvLyAxMlxuICAgICAgICBpZiAoIWlzVmFsaWQgfHwgaXNOZWdhdGl2ZUxFKHQsIFApIHx8IHkgPT09IF8wbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlbXNnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSaXN0UG9pbnQobmV3IGVkMjU1MTkuRXh0ZW5kZWRQb2ludCh4LCB5LCBfMW4sIHQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jb2RlcyByaXN0cmV0dG8gcG9pbnQgdG8gVWludDhBcnJheS5cbiAgICAgKiBodHRwczovL3Jpc3RyZXR0by5ncm91cC9mb3JtdWxhcy9lbmNvZGluZy5odG1sXG4gICAgICovXG4gICAgdG9SYXdCeXRlcygpIHtcbiAgICAgICAgbGV0IHsgZXg6IHgsIGV5OiB5LCBlejogeiwgZXQ6IHQgfSA9IHRoaXMuZXA7XG4gICAgICAgIGNvbnN0IFAgPSBlZDI1NTE5LkNVUlZFLkZwLk9SREVSO1xuICAgICAgICBjb25zdCBtb2QgPSBlZDI1NTE5LkNVUlZFLkZwLmNyZWF0ZTtcbiAgICAgICAgY29uc3QgdTEgPSBtb2QobW9kKHogKyB5KSAqIG1vZCh6IC0geSkpOyAvLyAxXG4gICAgICAgIGNvbnN0IHUyID0gbW9kKHggKiB5KTsgLy8gMlxuICAgICAgICAvLyBTcXVhcmUgcm9vdCBhbHdheXMgZXhpc3RzXG4gICAgICAgIGNvbnN0IHUyc3EgPSBtb2QodTIgKiB1Mik7XG4gICAgICAgIGNvbnN0IHsgdmFsdWU6IGludnNxcnQgfSA9IGludmVydFNxcnQobW9kKHUxICogdTJzcSkpOyAvLyAzXG4gICAgICAgIGNvbnN0IEQxID0gbW9kKGludnNxcnQgKiB1MSk7IC8vIDRcbiAgICAgICAgY29uc3QgRDIgPSBtb2QoaW52c3FydCAqIHUyKTsgLy8gNVxuICAgICAgICBjb25zdCB6SW52ID0gbW9kKEQxICogRDIgKiB0KTsgLy8gNlxuICAgICAgICBsZXQgRDsgLy8gN1xuICAgICAgICBpZiAoaXNOZWdhdGl2ZUxFKHQgKiB6SW52LCBQKSkge1xuICAgICAgICAgICAgbGV0IF94ID0gbW9kKHkgKiBTUVJUX00xKTtcbiAgICAgICAgICAgIGxldCBfeSA9IG1vZCh4ICogU1FSVF9NMSk7XG4gICAgICAgICAgICB4ID0gX3g7XG4gICAgICAgICAgICB5ID0gX3k7XG4gICAgICAgICAgICBEID0gbW9kKEQxICogSU5WU1FSVF9BX01JTlVTX0QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgRCA9IEQyOyAvLyA4XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmVnYXRpdmVMRSh4ICogekludiwgUCkpXG4gICAgICAgICAgICB5ID0gbW9kKC15KTsgLy8gOVxuICAgICAgICBsZXQgcyA9IG1vZCgoeiAtIHkpICogRCk7IC8vIDEwIChjaGVjayBmb290ZXIncyBub3RlLCBubyBzcXJ0KC1hKSlcbiAgICAgICAgaWYgKGlzTmVnYXRpdmVMRShzLCBQKSlcbiAgICAgICAgICAgIHMgPSBtb2QoLXMpO1xuICAgICAgICByZXR1cm4gbnVtYmVyVG9CeXRlc0xFKHMsIDMyKTsgLy8gMTFcbiAgICB9XG4gICAgdG9IZXgoKSB7XG4gICAgICAgIHJldHVybiBieXRlc1RvSGV4KHRoaXMudG9SYXdCeXRlcygpKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvSGV4KCk7XG4gICAgfVxuICAgIC8vIENvbXBhcmUgb25lIHBvaW50IHRvIGFub3RoZXIuXG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIGFzc2VydFJzdFBvaW50KG90aGVyKTtcbiAgICAgICAgY29uc3QgeyBleDogWDEsIGV5OiBZMSB9ID0gdGhpcy5lcDtcbiAgICAgICAgY29uc3QgeyBleDogWDIsIGV5OiBZMiB9ID0gb3RoZXIuZXA7XG4gICAgICAgIGNvbnN0IG1vZCA9IGVkMjU1MTkuQ1VSVkUuRnAuY3JlYXRlO1xuICAgICAgICAvLyAoeDEgKiB5MiA9PSB5MSAqIHgyKSB8ICh5MSAqIHkyID09IHgxICogeDIpXG4gICAgICAgIGNvbnN0IG9uZSA9IG1vZChYMSAqIFkyKSA9PT0gbW9kKFkxICogWDIpO1xuICAgICAgICBjb25zdCB0d28gPSBtb2QoWTEgKiBZMikgPT09IG1vZChYMSAqIFgyKTtcbiAgICAgICAgcmV0dXJuIG9uZSB8fCB0d287XG4gICAgfVxuICAgIGFkZChvdGhlcikge1xuICAgICAgICBhc3NlcnRSc3RQb2ludChvdGhlcik7XG4gICAgICAgIHJldHVybiBuZXcgUmlzdFBvaW50KHRoaXMuZXAuYWRkKG90aGVyLmVwKSk7XG4gICAgfVxuICAgIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgICAgIGFzc2VydFJzdFBvaW50KG90aGVyKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSaXN0UG9pbnQodGhpcy5lcC5zdWJ0cmFjdChvdGhlci5lcCkpO1xuICAgIH1cbiAgICBtdWx0aXBseShzY2FsYXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSaXN0UG9pbnQodGhpcy5lcC5tdWx0aXBseShzY2FsYXIpKTtcbiAgICB9XG4gICAgbXVsdGlwbHlVbnNhZmUoc2NhbGFyKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmlzdFBvaW50KHRoaXMuZXAubXVsdGlwbHlVbnNhZmUoc2NhbGFyKSk7XG4gICAgfVxuICAgIGRvdWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSaXN0UG9pbnQodGhpcy5lcC5kb3VibGUoKSk7XG4gICAgfVxuICAgIG5lZ2F0ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSaXN0UG9pbnQodGhpcy5lcC5uZWdhdGUoKSk7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IFJpc3RyZXR0b1BvaW50ID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG4gICAgaWYgKCFSaXN0UG9pbnQuQkFTRSlcbiAgICAgICAgUmlzdFBvaW50LkJBU0UgPSBuZXcgUmlzdFBvaW50KGVkMjU1MTkuRXh0ZW5kZWRQb2ludC5CQVNFKTtcbiAgICBpZiAoIVJpc3RQb2ludC5aRVJPKVxuICAgICAgICBSaXN0UG9pbnQuWkVSTyA9IG5ldyBSaXN0UG9pbnQoZWQyNTUxOS5FeHRlbmRlZFBvaW50LlpFUk8pO1xuICAgIHJldHVybiBSaXN0UG9pbnQ7XG59KSgpO1xuLy8gSGFzaGluZyB0byByaXN0cmV0dG8yNTUuIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI2FwcGVuZGl4LUJcbmV4cG9ydCBjb25zdCBoYXNoVG9SaXN0cmV0dG8yNTUgPSAobXNnLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgZCA9IG9wdGlvbnMuRFNUO1xuICAgIGNvbnN0IERTVCA9IHR5cGVvZiBkID09PSAnc3RyaW5nJyA/IHV0ZjhUb0J5dGVzKGQpIDogZDtcbiAgICBjb25zdCB1bmlmb3JtX2J5dGVzID0gZXhwYW5kX21lc3NhZ2VfeG1kKG1zZywgRFNULCA2NCwgc2hhNTEyKTtcbiAgICBjb25zdCBQID0gUmlzdFBvaW50Lmhhc2hUb0N1cnZlKHVuaWZvcm1fYnl0ZXMpO1xuICAgIHJldHVybiBQO1xufTtcbmV4cG9ydCBjb25zdCBoYXNoX3RvX3Jpc3RyZXR0bzI1NSA9IGhhc2hUb1Jpc3RyZXR0bzI1NTsgLy8gbGVnYWN5XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lZDI1NTE5LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/@noble/curves/esm/ed25519.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@noble/hashes/esm/_assert.js":
/*!*******************************************************!*\
  !*** ../../node_modules/@noble/hashes/esm/_assert.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: function() { return /* binding */ bool; },\n/* harmony export */   bytes: function() { return /* binding */ bytes; },\n/* harmony export */   exists: function() { return /* binding */ exists; },\n/* harmony export */   hash: function() { return /* binding */ hash; },\n/* harmony export */   isBytes: function() { return /* binding */ isBytes; },\n/* harmony export */   number: function() { return /* binding */ number; },\n/* harmony export */   output: function() { return /* binding */ output; }\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`positive integer expected, not ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`boolean expected, not ${b}`);\n}\n// copied from utils\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(h.outputLen);\n    number(h.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\n\nconst assert = { number, bool, bytes, hash, exists, output };\n/* harmony default export */ __webpack_exports__[\"default\"] = (assert);\n//# sourceMappingURL=_assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX2Fzc2VydC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBLDBEQUEwRCxFQUFFO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFFBQVEsa0JBQWtCLFNBQVM7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixJQUFJO0FBQ3JGO0FBQ0E7QUFDcUQ7QUFDckQsaUJBQWlCO0FBQ2pCLCtEQUFlLE1BQU0sRUFBQztBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19hc3NlcnQuanM/MWEyNyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBudW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgcG9zaXRpdmUgaW50ZWdlciBleHBlY3RlZCwgbm90ICR7bn1gKTtcbn1cbmZ1bmN0aW9uIGJvb2woYikge1xuICAgIGlmICh0eXBlb2YgYiAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJvb2xlYW4gZXhwZWN0ZWQsIG5vdCAke2J9YCk7XG59XG4vLyBjb3BpZWQgZnJvbSB1dGlsc1xuZXhwb3J0IGZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuICAgIHJldHVybiAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHxcbiAgICAgICAgKGEgIT0gbnVsbCAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpKTtcbn1cbmZ1bmN0aW9uIGJ5dGVzKGIsIC4uLmxlbmd0aHMpIHtcbiAgICBpZiAoIWlzQnl0ZXMoYikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIGlmIChsZW5ndGhzLmxlbmd0aCA+IDAgJiYgIWxlbmd0aHMuaW5jbHVkZXMoYi5sZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVpbnQ4QXJyYXkgZXhwZWN0ZWQgb2YgbGVuZ3RoICR7bGVuZ3Roc30sIG5vdCBvZiBsZW5ndGg9JHtiLmxlbmd0aH1gKTtcbn1cbmZ1bmN0aW9uIGhhc2goaCkge1xuICAgIGlmICh0eXBlb2YgaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaC5jcmVhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBzaG91bGQgYmUgd3JhcHBlZCBieSB1dGlscy53cmFwQ29uc3RydWN0b3InKTtcbiAgICBudW1iZXIoaC5vdXRwdXRMZW4pO1xuICAgIG51bWJlcihoLmJsb2NrTGVuKTtcbn1cbmZ1bmN0aW9uIGV4aXN0cyhpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xufVxuZnVuY3Rpb24gb3V0cHV0KG91dCwgaW5zdGFuY2UpIHtcbiAgICBieXRlcyhvdXQpO1xuICAgIGNvbnN0IG1pbiA9IGluc3RhbmNlLm91dHB1dExlbjtcbiAgICBpZiAob3V0Lmxlbmd0aCA8IG1pbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpZ2VzdEludG8oKSBleHBlY3RzIG91dHB1dCBidWZmZXIgb2YgbGVuZ3RoIGF0IGxlYXN0ICR7bWlufWApO1xuICAgIH1cbn1cbmV4cG9ydCB7IG51bWJlciwgYm9vbCwgYnl0ZXMsIGhhc2gsIGV4aXN0cywgb3V0cHV0IH07XG5jb25zdCBhc3NlcnQgPSB7IG51bWJlciwgYm9vbCwgYnl0ZXMsIGhhc2gsIGV4aXN0cywgb3V0cHV0IH07XG5leHBvcnQgZGVmYXVsdCBhc3NlcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fYXNzZXJ0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/@noble/hashes/esm/_assert.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@noble/hashes/esm/_md.js":
/*!***************************************************!*\
  !*** ../../node_modules/@noble/hashes/esm/_md.js ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Chi: function() { return /* binding */ Chi; },\n/* harmony export */   HashMD: function() { return /* binding */ HashMD; },\n/* harmony export */   Maj: function() { return /* binding */ Maj; }\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/../../node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../../node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nclass HashMD extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.output)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_md.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX21kLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQThDO0FBQ1M7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ08scUJBQXFCLDJDQUFJO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscURBQVU7QUFDOUI7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZCxnQkFBZ0IseUJBQXlCO0FBQ3pDLGVBQWUsa0RBQU87QUFDdEI7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMscURBQVU7QUFDM0MsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZCxRQUFRLGtEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0JBQStCO0FBQy9DLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxREFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFEQUFxRDtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19tZC5qcz80NjNmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGV4aXN0cywgb3V0cHV0IH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IEhhc2gsIGNyZWF0ZVZpZXcsIHRvQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFBvbHlmaWxsIGZvciBTYWZhcmkgMTRcbmZ1bmN0aW9uIHNldEJpZ1VpbnQ2NCh2aWV3LCBieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSkge1xuICAgIGlmICh0eXBlb2Ygdmlldy5zZXRCaWdVaW50NjQgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiB2aWV3LnNldEJpZ1VpbnQ2NChieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSk7XG4gICAgY29uc3QgXzMybiA9IEJpZ0ludCgzMik7XG4gICAgY29uc3QgX3UzMl9tYXggPSBCaWdJbnQoMHhmZmZmZmZmZik7XG4gICAgY29uc3Qgd2ggPSBOdW1iZXIoKHZhbHVlID4+IF8zMm4pICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IHdsID0gTnVtYmVyKHZhbHVlICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IGggPSBpc0xFID8gNCA6IDA7XG4gICAgY29uc3QgbCA9IGlzTEUgPyAwIDogNDtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgaCwgd2gsIGlzTEUpO1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBsLCB3bCwgaXNMRSk7XG59XG4vLyBDaG9pY2U6IGEgPyBiIDogY1xuZXhwb3J0IGNvbnN0IENoaSA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKH5hICYgYyk7XG4vLyBNYWpvcml0eSBmdW5jdGlvbiwgdHJ1ZSBpZiBhbnkgdHdvIGlucHVzdCBpcyB0cnVlXG5leHBvcnQgY29uc3QgTWFqID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAoYSAmIGMpIF4gKGIgJiBjKTtcbi8qKlxuICogTWVya2xlLURhbWdhcmQgaGFzaCBjb25zdHJ1Y3Rpb24gYmFzZSBjbGFzcy5cbiAqIENvdWxkIGJlIHVzZWQgdG8gY3JlYXRlIE1ENSwgUklQRU1ELCBTSEExLCBTSEEyLlxuICovXG5leHBvcnQgY2xhc3MgSGFzaE1EIGV4dGVuZHMgSGFzaCB7XG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIG91dHB1dExlbiwgcGFkT2Zmc2V0LCBpc0xFKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRoaXMucGFkT2Zmc2V0ID0gcGFkT2Zmc2V0O1xuICAgICAgICB0aGlzLmlzTEUgPSBpc0xFO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgdGhpcy52aWV3ID0gY3JlYXRlVmlldyh0aGlzLmJ1ZmZlcik7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIGV4aXN0cyh0aGlzKTtcbiAgICAgICAgY29uc3QgeyB2aWV3LCBidWZmZXIsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gdG9CeXRlcyhkYXRhKTtcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgLy8gRmFzdCBwYXRoOiB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBibG9jayBpbiBpbnB1dCwgY2FzdCBpdCB0byB2aWV3IGFuZCBwcm9jZXNzXG4gICAgICAgICAgICBpZiAodGFrZSA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhVmlldyA9IGNyZWF0ZVZpZXcoZGF0YSk7XG4gICAgICAgICAgICAgICAgZm9yICg7IGJsb2NrTGVuIDw9IGxlbiAtIHBvczsgcG9zICs9IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3MoZGF0YVZpZXcsIHBvcyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIuc2V0KGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyB0YWtlKSwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMucm91bmRDbGVhbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgZXhpc3RzKHRoaXMpO1xuICAgICAgICBvdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIC8vIFBhZGRpbmdcbiAgICAgICAgLy8gV2UgY2FuIGF2b2lkIGFsbG9jYXRpb24gb2YgYnVmZmVyIGZvciBwYWRkaW5nIGNvbXBsZXRlbHkgaWYgaXRcbiAgICAgICAgLy8gd2FzIHByZXZpb3VzbHkgbm90IGFsbG9jYXRlZCBoZXJlLiBCdXQgaXQgd29uJ3QgY2hhbmdlIHBlcmZvcm1hbmNlLlxuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgdmlldywgYmxvY2tMZW4sIGlzTEUgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHBvcyB9ID0gdGhpcztcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBiaXQgJzEnIHRvIHRoZSBtZXNzYWdlXG4gICAgICAgIGJ1ZmZlcltwb3MrK10gPSAwYjEwMDAwMDAwO1xuICAgICAgICB0aGlzLmJ1ZmZlci5zdWJhcnJheShwb3MpLmZpbGwoMCk7XG4gICAgICAgIC8vIHdlIGhhdmUgbGVzcyB0aGFuIHBhZE9mZnNldCBsZWZ0IGluIGJ1ZmZlciwgc28gd2UgY2Fubm90IHB1dCBsZW5ndGggaW5cbiAgICAgICAgLy8gY3VycmVudCBibG9jaywgbmVlZCBwcm9jZXNzIGl0IGFuZCBwYWQgYWdhaW5cbiAgICAgICAgaWYgKHRoaXMucGFkT2Zmc2V0ID4gYmxvY2tMZW4gLSBwb3MpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFkIHVudGlsIGZ1bGwgYmxvY2sgYnl0ZSB3aXRoIHplcm9zXG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBibG9ja0xlbjsgaSsrKVxuICAgICAgICAgICAgYnVmZmVyW2ldID0gMDtcbiAgICAgICAgLy8gTm90ZTogc2hhNTEyIHJlcXVpcmVzIGxlbmd0aCB0byBiZSAxMjhiaXQgaW50ZWdlciwgYnV0IGxlbmd0aCBpbiBKUyB3aWxsIG92ZXJmbG93IGJlZm9yZSB0aGF0XG4gICAgICAgIC8vIFlvdSBuZWVkIHRvIHdyaXRlIGFyb3VuZCAyIGV4YWJ5dGVzICh1NjRfbWF4IC8gOCAvICgxMDI0Kio2KSkgZm9yIHRoaXMgdG8gaGFwcGVuLlxuICAgICAgICAvLyBTbyB3ZSBqdXN0IHdyaXRlIGxvd2VzdCA2NCBiaXRzIG9mIHRoYXQgdmFsdWUuXG4gICAgICAgIHNldEJpZ1VpbnQ2NCh2aWV3LCBibG9ja0xlbiAtIDgsIEJpZ0ludCh0aGlzLmxlbmd0aCAqIDgpLCBpc0xFKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICBjb25zdCBvdmlldyA9IGNyZWF0ZVZpZXcob3V0KTtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5vdXRwdXRMZW47XG4gICAgICAgIC8vIE5PVEU6IHdlIGRvIGRpdmlzaW9uIGJ5IDQgbGF0ZXIsIHdoaWNoIHNob3VsZCBiZSBmdXNlZCBpbiBzaW5nbGUgb3Agd2l0aCBtb2R1bG8gYnkgSklUXG4gICAgICAgIGlmIChsZW4gJSA0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIHNob3VsZCBiZSBhbGlnbmVkIHRvIDMyYml0Jyk7XG4gICAgICAgIGNvbnN0IG91dExlbiA9IGxlbiAvIDQ7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgaWYgKG91dExlbiA+IHN0YXRlLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBiaWdnZXIgdGhhbiBzdGF0ZScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dExlbjsgaSsrKVxuICAgICAgICAgICAgb3ZpZXcuc2V0VWludDMyKDQgKiBpLCBzdGF0ZVtpXSwgaXNMRSk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpKTtcbiAgICAgICAgdG8uc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgcG9zIH0gPSB0aGlzO1xuICAgICAgICB0by5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRvLnBvcyA9IHBvcztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICBpZiAobGVuZ3RoICUgYmxvY2tMZW4pXG4gICAgICAgICAgICB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fbWQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/@noble/hashes/esm/_md.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@noble/hashes/esm/_u64.js":
/*!****************************************************!*\
  !*** ../../node_modules/@noble/hashes/esm/_u64.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: function() { return /* binding */ add; },\n/* harmony export */   add3H: function() { return /* binding */ add3H; },\n/* harmony export */   add3L: function() { return /* binding */ add3L; },\n/* harmony export */   add4H: function() { return /* binding */ add4H; },\n/* harmony export */   add4L: function() { return /* binding */ add4L; },\n/* harmony export */   add5H: function() { return /* binding */ add5H; },\n/* harmony export */   add5L: function() { return /* binding */ add5L; },\n/* harmony export */   fromBig: function() { return /* binding */ fromBig; },\n/* harmony export */   rotlBH: function() { return /* binding */ rotlBH; },\n/* harmony export */   rotlBL: function() { return /* binding */ rotlBL; },\n/* harmony export */   rotlSH: function() { return /* binding */ rotlSH; },\n/* harmony export */   rotlSL: function() { return /* binding */ rotlSL; },\n/* harmony export */   rotr32H: function() { return /* binding */ rotr32H; },\n/* harmony export */   rotr32L: function() { return /* binding */ rotr32L; },\n/* harmony export */   rotrBH: function() { return /* binding */ rotrBH; },\n/* harmony export */   rotrBL: function() { return /* binding */ rotrBL; },\n/* harmony export */   rotrSH: function() { return /* binding */ rotrSH; },\n/* harmony export */   rotrSL: function() { return /* binding */ rotrSL; },\n/* harmony export */   shrSH: function() { return /* binding */ shrSH; },\n/* harmony export */   shrSL: function() { return /* binding */ shrSL; },\n/* harmony export */   split: function() { return /* binding */ split; },\n/* harmony export */   toBig: function() { return /* binding */ toBig; }\n/* harmony export */ });\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\n\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (u64);\n//# sourceMappingURL=_u64.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3U2NC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDaUw7QUFDakw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQWUsR0FBRyxFQUFDO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3U2NC5qcz8yY2ZmIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFUzMl9NQVNLNjQgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDIgKiogMzIgLSAxKTtcbmNvbnN0IF8zMm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDMyKTtcbi8vIFdlIGFyZSBub3QgdXNpbmcgQmlnVWludDY0QXJyYXksIGJlY2F1c2UgdGhleSBhcmUgZXh0cmVtZWx5IHNsb3cgYXMgcGVyIDIwMjJcbmZ1bmN0aW9uIGZyb21CaWcobiwgbGUgPSBmYWxzZSkge1xuICAgIGlmIChsZSlcbiAgICAgICAgcmV0dXJuIHsgaDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSwgbDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfTtcbiAgICByZXR1cm4geyBoOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB8IDAsIGw6IE51bWJlcihuICYgVTMyX01BU0s2NCkgfCAwIH07XG59XG5mdW5jdGlvbiBzcGxpdChsc3QsIGxlID0gZmFsc2UpIHtcbiAgICBsZXQgQWggPSBuZXcgVWludDMyQXJyYXkobHN0Lmxlbmd0aCk7XG4gICAgbGV0IEFsID0gbmV3IFVpbnQzMkFycmF5KGxzdC5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbHN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHsgaCwgbCB9ID0gZnJvbUJpZyhsc3RbaV0sIGxlKTtcbiAgICAgICAgW0FoW2ldLCBBbFtpXV0gPSBbaCwgbF07XG4gICAgfVxuICAgIHJldHVybiBbQWgsIEFsXTtcbn1cbmNvbnN0IHRvQmlnID0gKGgsIGwpID0+IChCaWdJbnQoaCA+Pj4gMCkgPDwgXzMybikgfCBCaWdJbnQobCA+Pj4gMCk7XG4vLyBmb3IgU2hpZnQgaW4gWzAsIDMyKVxuY29uc3Qgc2hyU0ggPSAoaCwgX2wsIHMpID0+IGggPj4+IHM7XG5jb25zdCBzaHJTTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdHJTSCA9IChoLCBsLCBzKSA9PiAoaCA+Pj4gcykgfCAobCA8PCAoMzIgLSBzKSk7XG5jb25zdCByb3RyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiAoMzIsIDY0KSwgTk9URTogMzIgaXMgc3BlY2lhbCBjYXNlLlxuY29uc3Qgcm90ckJIID0gKGgsIGwsIHMpID0+IChoIDw8ICg2NCAtIHMpKSB8IChsID4+PiAocyAtIDMyKSk7XG5jb25zdCByb3RyQkwgPSAoaCwgbCwgcykgPT4gKGggPj4+IChzIC0gMzIpKSB8IChsIDw8ICg2NCAtIHMpKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3Igc2hpZnQ9PT0zMiAoanVzdCBzd2FwcyBsJmgpXG5jb25zdCByb3RyMzJIID0gKF9oLCBsKSA9PiBsO1xuY29uc3Qgcm90cjMyTCA9IChoLCBfbCkgPT4gaDtcbi8vIExlZnQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RsU0ggPSAoaCwgbCwgcykgPT4gKGggPDwgcykgfCAobCA+Pj4gKDMyIC0gcykpO1xuY29uc3Qgcm90bFNMID0gKGgsIGwsIHMpID0+IChsIDw8IHMpIHwgKGggPj4+ICgzMiAtIHMpKTtcbi8vIExlZnQgcm90YXRlIGZvciBTaGlmdCBpbiAoMzIsIDY0KSwgTk9URTogMzIgaXMgc3BlY2lhbCBjYXNlLlxuY29uc3Qgcm90bEJIID0gKGgsIGwsIHMpID0+IChsIDw8IChzIC0gMzIpKSB8IChoID4+PiAoNjQgLSBzKSk7XG5jb25zdCByb3RsQkwgPSAoaCwgbCwgcykgPT4gKGggPDwgKHMgLSAzMikpIHwgKGwgPj4+ICg2NCAtIHMpKTtcbi8vIEpTIHVzZXMgMzItYml0IHNpZ25lZCBpbnRlZ2VycyBmb3IgYml0d2lzZSBvcGVyYXRpb25zIHdoaWNoIG1lYW5zIHdlIGNhbm5vdFxuLy8gc2ltcGxlIHRha2UgY2Fycnkgb3V0IG9mIGxvdyBiaXQgc3VtIGJ5IHNoaWZ0LCB3ZSBuZWVkIHRvIHVzZSBkaXZpc2lvbi5cbmZ1bmN0aW9uIGFkZChBaCwgQWwsIEJoLCBCbCkge1xuICAgIGNvbnN0IGwgPSAoQWwgPj4+IDApICsgKEJsID4+PiAwKTtcbiAgICByZXR1cm4geyBoOiAoQWggKyBCaCArICgobCAvIDIgKiogMzIpIHwgMCkpIHwgMCwgbDogbCB8IDAgfTtcbn1cbi8vIEFkZGl0aW9uIHdpdGggbW9yZSB0aGFuIDIgZWxlbWVudHNcbmNvbnN0IGFkZDNMID0gKEFsLCBCbCwgQ2wpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKTtcbmNvbnN0IGFkZDNIID0gKGxvdywgQWgsIEJoLCBDaCkgPT4gKEFoICsgQmggKyBDaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuY29uc3QgYWRkNEwgPSAoQWwsIEJsLCBDbCwgRGwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCk7XG5jb25zdCBhZGQ0SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmNvbnN0IGFkZDVMID0gKEFsLCBCbCwgQ2wsIERsLCBFbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKSArIChFbCA+Pj4gMCk7XG5jb25zdCBhZGQ1SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoLCBFaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgRWggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbi8vIHByZXR0aWVyLWlnbm9yZVxuZXhwb3J0IHsgZnJvbUJpZywgc3BsaXQsIHRvQmlnLCBzaHJTSCwgc2hyU0wsIHJvdHJTSCwgcm90clNMLCByb3RyQkgsIHJvdHJCTCwgcm90cjMySCwgcm90cjMyTCwgcm90bFNILCByb3RsU0wsIHJvdGxCSCwgcm90bEJMLCBhZGQsIGFkZDNMLCBhZGQzSCwgYWRkNEwsIGFkZDRILCBhZGQ1SCwgYWRkNUwsIH07XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IHU2NCA9IHtcbiAgICBmcm9tQmlnLCBzcGxpdCwgdG9CaWcsXG4gICAgc2hyU0gsIHNoclNMLFxuICAgIHJvdHJTSCwgcm90clNMLCByb3RyQkgsIHJvdHJCTCxcbiAgICByb3RyMzJILCByb3RyMzJMLFxuICAgIHJvdGxTSCwgcm90bFNMLCByb3RsQkgsIHJvdGxCTCxcbiAgICBhZGQsIGFkZDNMLCBhZGQzSCwgYWRkNEwsIGFkZDRILCBhZGQ1SCwgYWRkNUwsXG59O1xuZXhwb3J0IGRlZmF1bHQgdTY0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3U2NC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/@noble/hashes/esm/_u64.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@noble/hashes/esm/crypto.js":
/*!******************************************************!*\
  !*** ../../node_modules/@noble/hashes/esm/crypto.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: function() { return /* binding */ crypto; }\n/* harmony export */ });\nconst crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vY3J5cHRvLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vY3J5cHRvLmpzPzk4MTMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IGNyeXB0byA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JyAmJiAnY3J5cHRvJyBpbiBnbG9iYWxUaGlzID8gZ2xvYmFsVGhpcy5jcnlwdG8gOiB1bmRlZmluZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcnlwdG8uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/@noble/hashes/esm/crypto.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@noble/hashes/esm/sha256.js":
/*!******************************************************!*\
  !*** ../../node_modules/@noble/hashes/esm/sha256.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha224: function() { return /* binding */ sha224; },\n/* harmony export */   sha256: function() { return /* binding */ sha256; }\n/* harmony export */ });\n/* harmony import */ var _md_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_md.js */ \"(app-pages-browser)/../../node_modules/@noble/hashes/esm/_md.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../../node_modules/@noble/hashes/esm/utils.js\");\n\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state:\n// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19\n// prettier-ignore\nconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = SHA256_IV[0] | 0;\n        this.B = SHA256_IV[1] | 0;\n        this.C = SHA256_IV[2] | 0;\n        this.D = SHA256_IV[3] | 0;\n        this.E = SHA256_IV[4] | 0;\n        this.F = SHA256_IV[5] | 0;\n        this.G = SHA256_IV[6] | 0;\n        this.H = SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = (H + sigma1 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = (sigma0 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Maj)(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nconst sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA256());\nconst sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMjU2LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBNEM7QUFDTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMENBQU07QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0EsdUJBQXVCLCtDQUFJLFdBQVcsK0NBQUk7QUFDMUMsdUJBQXVCLCtDQUFJLFdBQVcsK0NBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5QkFBeUI7QUFDdkMsd0JBQXdCLFFBQVE7QUFDaEMsMkJBQTJCLCtDQUFJLFNBQVMsK0NBQUksVUFBVSwrQ0FBSTtBQUMxRCxxQ0FBcUMsMkNBQUc7QUFDeEMsMkJBQTJCLCtDQUFJLFNBQVMsK0NBQUksVUFBVSwrQ0FBSTtBQUMxRCxpQ0FBaUMsMkNBQUc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLCtCQUErQiwwREFBZTtBQUM5QywrQkFBK0IsMERBQWU7QUFDckQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyNTYuanM/ZDljZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBIYXNoTUQsIENoaSwgTWFqIH0gZnJvbSAnLi9fbWQuanMnO1xuaW1wb3J0IHsgcm90ciwgd3JhcENvbnN0cnVjdG9yIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBTSEEyLTI1NiBuZWVkIHRvIHRyeSAyXjEyOCBoYXNoZXMgdG8gZXhlY3V0ZSBiaXJ0aGRheSBhdHRhY2suXG4vLyBCVEMgbmV0d29yayBpcyBkb2luZyAyXjY3IGhhc2hlcy9zZWMgYXMgcGVyIGVhcmx5IDIwMjMuXG4vLyBSb3VuZCBjb25zdGFudHM6XG4vLyBmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBjdWJlIHJvb3RzIG9mIHRoZSBmaXJzdCA2NCBwcmltZXMgMi4uMzExKVxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBTSEEyNTZfSyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NDI4YTJmOTgsIDB4NzEzNzQ0OTEsIDB4YjVjMGZiY2YsIDB4ZTliNWRiYTUsIDB4Mzk1NmMyNWIsIDB4NTlmMTExZjEsIDB4OTIzZjgyYTQsIDB4YWIxYzVlZDUsXG4gICAgMHhkODA3YWE5OCwgMHgxMjgzNWIwMSwgMHgyNDMxODViZSwgMHg1NTBjN2RjMywgMHg3MmJlNWQ3NCwgMHg4MGRlYjFmZSwgMHg5YmRjMDZhNywgMHhjMTliZjE3NCxcbiAgICAweGU0OWI2OWMxLCAweGVmYmU0Nzg2LCAweDBmYzE5ZGM2LCAweDI0MGNhMWNjLCAweDJkZTkyYzZmLCAweDRhNzQ4NGFhLCAweDVjYjBhOWRjLCAweDc2Zjk4OGRhLFxuICAgIDB4OTgzZTUxNTIsIDB4YTgzMWM2NmQsIDB4YjAwMzI3YzgsIDB4YmY1OTdmYzcsIDB4YzZlMDBiZjMsIDB4ZDVhNzkxNDcsIDB4MDZjYTYzNTEsIDB4MTQyOTI5NjcsXG4gICAgMHgyN2I3MGE4NSwgMHgyZTFiMjEzOCwgMHg0ZDJjNmRmYywgMHg1MzM4MGQxMywgMHg2NTBhNzM1NCwgMHg3NjZhMGFiYiwgMHg4MWMyYzkyZSwgMHg5MjcyMmM4NSxcbiAgICAweGEyYmZlOGExLCAweGE4MWE2NjRiLCAweGMyNGI4YjcwLCAweGM3NmM1MWEzLCAweGQxOTJlODE5LCAweGQ2OTkwNjI0LCAweGY0MGUzNTg1LCAweDEwNmFhMDcwLFxuICAgIDB4MTlhNGMxMTYsIDB4MWUzNzZjMDgsIDB4Mjc0ODc3NGMsIDB4MzRiMGJjYjUsIDB4MzkxYzBjYjMsIDB4NGVkOGFhNGEsIDB4NWI5Y2NhNGYsIDB4NjgyZTZmZjMsXG4gICAgMHg3NDhmODJlZSwgMHg3OGE1NjM2ZiwgMHg4NGM4NzgxNCwgMHg4Y2M3MDIwOCwgMHg5MGJlZmZmYSwgMHhhNDUwNmNlYiwgMHhiZWY5YTNmNywgMHhjNjcxNzhmMlxuXSk7XG4vLyBJbml0aWFsIHN0YXRlOlxuLy8gZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgc3F1YXJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4IHByaW1lcyAyLi4xOVxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBTSEEyNTZfSVYgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDZhMDllNjY3LCAweGJiNjdhZTg1LCAweDNjNmVmMzcyLCAweGE1NGZmNTNhLCAweDUxMGU1MjdmLCAweDliMDU2ODhjLCAweDFmODNkOWFiLCAweDViZTBjZDE5XG5dKTtcbi8vIFRlbXBvcmFyeSBidWZmZXIsIG5vdCB1c2VkIHRvIHN0b3JlIGFueXRoaW5nIGJldHdlZW4gcnVuc1xuLy8gTmFtZWQgdGhpcyB3YXkgYmVjYXVzZSBpdCBtYXRjaGVzIHNwZWNpZmljYXRpb24uXG5jb25zdCBTSEEyNTZfVyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoNjQpO1xuY2xhc3MgU0hBMjU2IGV4dGVuZHMgSGFzaE1EIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNjQsIDMyLCA4LCBmYWxzZSk7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGVcbiAgICAgICAgLy8gd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgICAgICB0aGlzLkEgPSBTSEEyNTZfSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkIgPSBTSEEyNTZfSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLkMgPSBTSEEyNTZfSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkQgPSBTSEEyNTZfSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkUgPSBTSEEyNTZfSVZbNF0gfCAwO1xuICAgICAgICB0aGlzLkYgPSBTSEEyNTZfSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkcgPSBTSEEyNTZfSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkggPSBTSEEyNTZfSVZbN10gfCAwO1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtBLCBCLCBDLCBELCBFLCBGLCBHLCBIXTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpIHtcbiAgICAgICAgdGhpcy5BID0gQSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IEIgfCAwO1xuICAgICAgICB0aGlzLkMgPSBDIHwgMDtcbiAgICAgICAgdGhpcy5EID0gRCB8IDA7XG4gICAgICAgIHRoaXMuRSA9IEUgfCAwO1xuICAgICAgICB0aGlzLkYgPSBGIHwgMDtcbiAgICAgICAgdGhpcy5HID0gRyB8IDA7XG4gICAgICAgIHRoaXMuSCA9IEggfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IDE2IHdvcmRzIGludG8gdGhlIHJlbWFpbmluZyA0OCB3b3JkcyB3WzE2Li42M10gb2YgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgYXJyYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcbiAgICAgICAgICAgIFNIQTI1Nl9XW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IFcxNSA9IFNIQTI1Nl9XW2kgLSAxNV07XG4gICAgICAgICAgICBjb25zdCBXMiA9IFNIQTI1Nl9XW2kgLSAyXTtcbiAgICAgICAgICAgIGNvbnN0IHMwID0gcm90cihXMTUsIDcpIF4gcm90cihXMTUsIDE4KSBeIChXMTUgPj4+IDMpO1xuICAgICAgICAgICAgY29uc3QgczEgPSByb3RyKFcyLCAxNykgXiByb3RyKFcyLCAxOSkgXiAoVzIgPj4+IDEwKTtcbiAgICAgICAgICAgIFNIQTI1Nl9XW2ldID0gKHMxICsgU0hBMjU2X1dbaSAtIDddICsgczAgKyBTSEEyNTZfV1tpIC0gMTZdKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA2NCByb3VuZHNcbiAgICAgICAgbGV0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTEgPSByb3RyKEUsIDYpIF4gcm90cihFLCAxMSkgXiByb3RyKEUsIDI1KTtcbiAgICAgICAgICAgIGNvbnN0IFQxID0gKEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTAgPSByb3RyKEEsIDIpIF4gcm90cihBLCAxMykgXiByb3RyKEEsIDIyKTtcbiAgICAgICAgICAgIGNvbnN0IFQyID0gKHNpZ21hMCArIE1haihBLCBCLCBDKSkgfCAwO1xuICAgICAgICAgICAgSCA9IEc7XG4gICAgICAgICAgICBHID0gRjtcbiAgICAgICAgICAgIEYgPSBFO1xuICAgICAgICAgICAgRSA9IChEICsgVDEpIHwgMDtcbiAgICAgICAgICAgIEQgPSBDO1xuICAgICAgICAgICAgQyA9IEI7XG4gICAgICAgICAgICBCID0gQTtcbiAgICAgICAgICAgIEEgPSAoVDEgKyBUMikgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgIEEgPSAoQSArIHRoaXMuQSkgfCAwO1xuICAgICAgICBCID0gKEIgKyB0aGlzLkIpIHwgMDtcbiAgICAgICAgQyA9IChDICsgdGhpcy5DKSB8IDA7XG4gICAgICAgIEQgPSAoRCArIHRoaXMuRCkgfCAwO1xuICAgICAgICBFID0gKEUgKyB0aGlzLkUpIHwgMDtcbiAgICAgICAgRiA9IChGICsgdGhpcy5GKSB8IDA7XG4gICAgICAgIEcgPSAoRyArIHRoaXMuRykgfCAwO1xuICAgICAgICBIID0gKEggKyB0aGlzLkgpIHwgMDtcbiAgICAgICAgdGhpcy5zZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgIFNIQTI1Nl9XLmZpbGwoMCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICB0aGlzLmJ1ZmZlci5maWxsKDApO1xuICAgIH1cbn1cbi8vIENvbnN0YW50cyBmcm9tIGh0dHBzOi8vbnZscHVicy5uaXN0Lmdvdi9uaXN0cHVicy9GSVBTL05JU1QuRklQUy4xODAtNC5wZGZcbmNsYXNzIFNIQTIyNCBleHRlbmRzIFNIQTI1NiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuQSA9IDB4YzEwNTllZDggfCAwO1xuICAgICAgICB0aGlzLkIgPSAweDM2N2NkNTA3IHwgMDtcbiAgICAgICAgdGhpcy5DID0gMHgzMDcwZGQxNyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IDB4ZjcwZTU5MzkgfCAwO1xuICAgICAgICB0aGlzLkUgPSAweGZmYzAwYjMxIHwgMDtcbiAgICAgICAgdGhpcy5GID0gMHg2ODU4MTUxMSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IDB4NjRmOThmYTcgfCAwO1xuICAgICAgICB0aGlzLkggPSAweGJlZmE0ZmE0IHwgMDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSAyODtcbiAgICB9XG59XG4vKipcbiAqIFNIQTItMjU2IGhhc2ggZnVuY3Rpb25cbiAqIEBwYXJhbSBtZXNzYWdlIC0gZGF0YSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnQgY29uc3Qgc2hhMjU2ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBMjU2KCkpO1xuZXhwb3J0IGNvbnN0IHNoYTIyNCA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTIyNCgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTI1Ni5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/@noble/hashes/esm/sha256.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@noble/hashes/esm/sha512.js":
/*!******************************************************!*\
  !*** ../../node_modules/@noble/hashes/esm/sha512.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA512: function() { return /* binding */ SHA512; },\n/* harmony export */   sha384: function() { return /* binding */ sha384; },\n/* harmony export */   sha512: function() { return /* binding */ sha512; },\n/* harmony export */   sha512_224: function() { return /* binding */ sha512_224; },\n/* harmony export */   sha512_256: function() { return /* binding */ sha512_256; }\n/* harmony export */ });\n/* harmony import */ var _md_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_md.js */ \"(app-pages-browser)/../../node_modules/@noble/hashes/esm/_md.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ \"(app-pages-browser)/../../node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../../node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nclass SHA512 extends _md_js__WEBPACK_IMPORTED_MODULE_1__.HashMD {\n    constructor() {\n        super(128, 64, 16, false);\n        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n        // Also looks cleaner and easier to verify with spec.\n        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x6a09e667 | 0;\n        this.Al = 0xf3bcc908 | 0;\n        this.Bh = 0xbb67ae85 | 0;\n        this.Bl = 0x84caa73b | 0;\n        this.Ch = 0x3c6ef372 | 0;\n        this.Cl = 0xfe94f82b | 0;\n        this.Dh = 0xa54ff53a | 0;\n        this.Dl = 0x5f1d36f1 | 0;\n        this.Eh = 0x510e527f | 0;\n        this.El = 0xade682d1 | 0;\n        this.Fh = 0x9b05688c | 0;\n        this.Fl = 0x2b3e6c1f | 0;\n        this.Gh = 0x1f83d9ab | 0;\n        this.Gl = 0xfb41bd6b | 0;\n        this.Hh = 0x5be0cd19 | 0;\n        this.Hl = 0x137e2179 | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSH(W15h, W15l, 7);\n            const s0l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSH(W2h, W2l, 6);\n            const s1l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Eh, El, 41);\n            const sigma1l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Ah, Al, 39);\n            const sigma0l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add3L(T1l, sigma0l, MAJl);\n            Ah = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        SHA512_W_H.fill(0);\n        SHA512_W_L.fill(0);\n    }\n    destroy() {\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nclass SHA512_224 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x8c3d37c8 | 0;\n        this.Al = 0x19544da2 | 0;\n        this.Bh = 0x73e19966 | 0;\n        this.Bl = 0x89dcd4d6 | 0;\n        this.Ch = 0x1dfab7ae | 0;\n        this.Cl = 0x32ff9c82 | 0;\n        this.Dh = 0x679dd514 | 0;\n        this.Dl = 0x582f9fcf | 0;\n        this.Eh = 0x0f6d2b69 | 0;\n        this.El = 0x7bd44da8 | 0;\n        this.Fh = 0x77e36f73 | 0;\n        this.Fl = 0x04c48942 | 0;\n        this.Gh = 0x3f9d85a8 | 0;\n        this.Gl = 0x6a1d36c8 | 0;\n        this.Hh = 0x1112e6ad | 0;\n        this.Hl = 0x91d692a1 | 0;\n        this.outputLen = 28;\n    }\n}\nclass SHA512_256 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x22312194 | 0;\n        this.Al = 0xfc2bf72c | 0;\n        this.Bh = 0x9f555fa3 | 0;\n        this.Bl = 0xc84c64c2 | 0;\n        this.Ch = 0x2393b86b | 0;\n        this.Cl = 0x6f53b151 | 0;\n        this.Dh = 0x96387719 | 0;\n        this.Dl = 0x5940eabd | 0;\n        this.Eh = 0x96283ee2 | 0;\n        this.El = 0xa88effe3 | 0;\n        this.Fh = 0xbe5e1e25 | 0;\n        this.Fl = 0x53863992 | 0;\n        this.Gh = 0x2b0199fc | 0;\n        this.Gl = 0x2c85b8aa | 0;\n        this.Hh = 0x0eb72ddc | 0;\n        this.Hl = 0x81c52ca2 | 0;\n        this.outputLen = 32;\n    }\n}\nclass SHA384 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0xcbbb9d5d | 0;\n        this.Al = 0xc1059ed8 | 0;\n        this.Bh = 0x629a292a | 0;\n        this.Bl = 0x367cd507 | 0;\n        this.Ch = 0x9159015a | 0;\n        this.Cl = 0x3070dd17 | 0;\n        this.Dh = 0x152fecd8 | 0;\n        this.Dl = 0xf70e5939 | 0;\n        this.Eh = 0x67332667 | 0;\n        this.El = 0xffc00b31 | 0;\n        this.Fh = 0x8eb44a87 | 0;\n        this.Fl = 0x68581511 | 0;\n        this.Gh = 0xdb0c2e0d | 0;\n        this.Gl = 0x64f98fa7 | 0;\n        this.Hh = 0x47b5481d | 0;\n        this.Hl = 0xbefa4fa4 | 0;\n        this.outputLen = 48;\n    }\n}\nconst sha512 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512());\nconst sha512_224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512_224());\nconst sha512_256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512_256());\nconst sha384 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA384());\n//# sourceMappingURL=sha512.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhNTEyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWtDO0FBQ047QUFDaUI7QUFDN0M7QUFDQTtBQUNBLHNEQUFzRCxxREFBUztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxxQkFBcUIsMENBQU07QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUVBQWlFO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0RBQVUsa0JBQWtCLHNEQUFVLGtCQUFrQixxREFBUztBQUN6Rix3QkFBd0Isc0RBQVUsa0JBQWtCLHNEQUFVLGtCQUFrQixxREFBUztBQUN6RjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0RBQVUsaUJBQWlCLHNEQUFVLGlCQUFpQixxREFBUztBQUN2Rix3QkFBd0Isc0RBQVUsaUJBQWlCLHNEQUFVLGlCQUFpQixxREFBUztBQUN2RjtBQUNBLHlCQUF5QixxREFBUztBQUNsQyx5QkFBeUIscURBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpRUFBaUU7QUFDL0U7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBLDRCQUE0QixzREFBVSxlQUFlLHNEQUFVLGVBQWUsc0RBQVU7QUFDeEYsNEJBQTRCLHNEQUFVLGVBQWUsc0RBQVUsZUFBZSxzREFBVTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFEQUFTO0FBQ2xDLHdCQUF3QixxREFBUztBQUNqQztBQUNBO0FBQ0EsNEJBQTRCLHNEQUFVLGVBQWUsc0RBQVUsZUFBZSxzREFBVTtBQUN4Riw0QkFBNEIsc0RBQVUsZUFBZSxzREFBVSxlQUFlLHNEQUFVO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWUsRUFBRSxtREFBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscURBQVM7QUFDakMsaUJBQWlCLHFEQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZSxFQUFFLG1EQUFPO0FBQ25DLFdBQVcsZUFBZSxFQUFFLG1EQUFPO0FBQ25DLFdBQVcsZUFBZSxFQUFFLG1EQUFPO0FBQ25DLFdBQVcsZUFBZSxFQUFFLG1EQUFPO0FBQ25DLFdBQVcsZUFBZSxFQUFFLG1EQUFPO0FBQ25DLFdBQVcsZUFBZSxFQUFFLG1EQUFPO0FBQ25DLFdBQVcsZUFBZSxFQUFFLG1EQUFPO0FBQ25DLFdBQVcsZUFBZSxFQUFFLG1EQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywrQkFBK0IsMERBQWU7QUFDOUMsbUNBQW1DLDBEQUFlO0FBQ2xELG1DQUFtQywwREFBZTtBQUNsRCwrQkFBK0IsMERBQWU7QUFDckQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGE1MTIuanM/YTNkOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBIYXNoTUQgfSBmcm9tICcuL19tZC5qcyc7XG5pbXBvcnQgdTY0IGZyb20gJy4vX3U2NC5qcyc7XG5pbXBvcnQgeyB3cmFwQ29uc3RydWN0b3IgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFJvdW5kIGNvbnRhbnRzIChmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBjdWJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4MCBwcmltZXMgMi4uNDA5KTpcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgW1NIQTUxMl9LaCwgU0hBNTEyX0tsXSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gdTY0LnNwbGl0KFtcbiAgICAnMHg0MjhhMmY5OGQ3MjhhZTIyJywgJzB4NzEzNzQ0OTEyM2VmNjVjZCcsICcweGI1YzBmYmNmZWM0ZDNiMmYnLCAnMHhlOWI1ZGJhNTgxODlkYmJjJyxcbiAgICAnMHgzOTU2YzI1YmYzNDhiNTM4JywgJzB4NTlmMTExZjFiNjA1ZDAxOScsICcweDkyM2Y4MmE0YWYxOTRmOWInLCAnMHhhYjFjNWVkNWRhNmQ4MTE4JyxcbiAgICAnMHhkODA3YWE5OGEzMDMwMjQyJywgJzB4MTI4MzViMDE0NTcwNmZiZScsICcweDI0MzE4NWJlNGVlNGIyOGMnLCAnMHg1NTBjN2RjM2Q1ZmZiNGUyJyxcbiAgICAnMHg3MmJlNWQ3NGYyN2I4OTZmJywgJzB4ODBkZWIxZmUzYjE2OTZiMScsICcweDliZGMwNmE3MjVjNzEyMzUnLCAnMHhjMTliZjE3NGNmNjkyNjk0JyxcbiAgICAnMHhlNDliNjljMTllZjE0YWQyJywgJzB4ZWZiZTQ3ODYzODRmMjVlMycsICcweDBmYzE5ZGM2OGI4Y2Q1YjUnLCAnMHgyNDBjYTFjYzc3YWM5YzY1JyxcbiAgICAnMHgyZGU5MmM2ZjU5MmIwMjc1JywgJzB4NGE3NDg0YWE2ZWE2ZTQ4MycsICcweDVjYjBhOWRjYmQ0MWZiZDQnLCAnMHg3NmY5ODhkYTgzMTE1M2I1JyxcbiAgICAnMHg5ODNlNTE1MmVlNjZkZmFiJywgJzB4YTgzMWM2NmQyZGI0MzIxMCcsICcweGIwMDMyN2M4OThmYjIxM2YnLCAnMHhiZjU5N2ZjN2JlZWYwZWU0JyxcbiAgICAnMHhjNmUwMGJmMzNkYTg4ZmMyJywgJzB4ZDVhNzkxNDc5MzBhYTcyNScsICcweDA2Y2E2MzUxZTAwMzgyNmYnLCAnMHgxNDI5Mjk2NzBhMGU2ZTcwJyxcbiAgICAnMHgyN2I3MGE4NTQ2ZDIyZmZjJywgJzB4MmUxYjIxMzg1YzI2YzkyNicsICcweDRkMmM2ZGZjNWFjNDJhZWQnLCAnMHg1MzM4MGQxMzlkOTViM2RmJyxcbiAgICAnMHg2NTBhNzM1NDhiYWY2M2RlJywgJzB4NzY2YTBhYmIzYzc3YjJhOCcsICcweDgxYzJjOTJlNDdlZGFlZTYnLCAnMHg5MjcyMmM4NTE0ODIzNTNiJyxcbiAgICAnMHhhMmJmZThhMTRjZjEwMzY0JywgJzB4YTgxYTY2NGJiYzQyMzAwMScsICcweGMyNGI4YjcwZDBmODk3OTEnLCAnMHhjNzZjNTFhMzA2NTRiZTMwJyxcbiAgICAnMHhkMTkyZTgxOWQ2ZWY1MjE4JywgJzB4ZDY5OTA2MjQ1NTY1YTkxMCcsICcweGY0MGUzNTg1NTc3MTIwMmEnLCAnMHgxMDZhYTA3MDMyYmJkMWI4JyxcbiAgICAnMHgxOWE0YzExNmI4ZDJkMGM4JywgJzB4MWUzNzZjMDg1MTQxYWI1MycsICcweDI3NDg3NzRjZGY4ZWViOTknLCAnMHgzNGIwYmNiNWUxOWI0OGE4JyxcbiAgICAnMHgzOTFjMGNiM2M1Yzk1YTYzJywgJzB4NGVkOGFhNGFlMzQxOGFjYicsICcweDViOWNjYTRmNzc2M2UzNzMnLCAnMHg2ODJlNmZmM2Q2YjJiOGEzJyxcbiAgICAnMHg3NDhmODJlZTVkZWZiMmZjJywgJzB4NzhhNTYzNmY0MzE3MmY2MCcsICcweDg0Yzg3ODE0YTFmMGFiNzInLCAnMHg4Y2M3MDIwODFhNjQzOWVjJyxcbiAgICAnMHg5MGJlZmZmYTIzNjMxZTI4JywgJzB4YTQ1MDZjZWJkZTgyYmRlOScsICcweGJlZjlhM2Y3YjJjNjc5MTUnLCAnMHhjNjcxNzhmMmUzNzI1MzJiJyxcbiAgICAnMHhjYTI3M2VjZWVhMjY2MTljJywgJzB4ZDE4NmI4YzcyMWMwYzIwNycsICcweGVhZGE3ZGQ2Y2RlMGViMWUnLCAnMHhmNTdkNGY3ZmVlNmVkMTc4JyxcbiAgICAnMHgwNmYwNjdhYTcyMTc2ZmJhJywgJzB4MGE2MzdkYzVhMmM4OThhNicsICcweDExM2Y5ODA0YmVmOTBkYWUnLCAnMHgxYjcxMGIzNTEzMWM0NzFiJyxcbiAgICAnMHgyOGRiNzdmNTIzMDQ3ZDg0JywgJzB4MzJjYWFiN2I0MGM3MjQ5MycsICcweDNjOWViZTBhMTVjOWJlYmMnLCAnMHg0MzFkNjdjNDljMTAwZDRjJyxcbiAgICAnMHg0Y2M1ZDRiZWNiM2U0MmI2JywgJzB4NTk3ZjI5OWNmYzY1N2UyYScsICcweDVmY2I2ZmFiM2FkNmZhZWMnLCAnMHg2YzQ0MTk4YzRhNDc1ODE3J1xuXS5tYXAobiA9PiBCaWdJbnQobikpKSkoKTtcbi8vIFRlbXBvcmFyeSBidWZmZXIsIG5vdCB1c2VkIHRvIHN0b3JlIGFueXRoaW5nIGJldHdlZW4gcnVuc1xuY29uc3QgU0hBNTEyX1dfSCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoODApO1xuY29uc3QgU0hBNTEyX1dfTCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoODApO1xuZXhwb3J0IGNsYXNzIFNIQTUxMiBleHRlbmRzIEhhc2hNRCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDEyOCwgNjQsIDE2LCBmYWxzZSk7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGUgd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgICAgICAvLyBBbHNvIGxvb2tzIGNsZWFuZXIgYW5kIGVhc2llciB0byB2ZXJpZnkgd2l0aCBzcGVjLlxuICAgICAgICAvLyBJbml0aWFsIHN0YXRlIChmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBzcXVhcmUgcm9vdHMgb2YgdGhlIGZpcnN0IDggcHJpbWVzIDIuLjE5KTpcbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcbiAgICAgICAgdGhpcy5BaCA9IDB4NmEwOWU2NjcgfCAwO1xuICAgICAgICB0aGlzLkFsID0gMHhmM2JjYzkwOCB8IDA7XG4gICAgICAgIHRoaXMuQmggPSAweGJiNjdhZTg1IHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IDB4ODRjYWE3M2IgfCAwO1xuICAgICAgICB0aGlzLkNoID0gMHgzYzZlZjM3MiB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSAweGZlOTRmODJiIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IDB4YTU0ZmY1M2EgfCAwO1xuICAgICAgICB0aGlzLkRsID0gMHg1ZjFkMzZmMSB8IDA7XG4gICAgICAgIHRoaXMuRWggPSAweDUxMGU1MjdmIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IDB4YWRlNjgyZDEgfCAwO1xuICAgICAgICB0aGlzLkZoID0gMHg5YjA1Njg4YyB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSAweDJiM2U2YzFmIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IDB4MWY4M2Q5YWIgfCAwO1xuICAgICAgICB0aGlzLkdsID0gMHhmYjQxYmQ2YiB8IDA7XG4gICAgICAgIHRoaXMuSGggPSAweDViZTBjZDE5IHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IDB4MTM3ZTIxNzkgfCAwO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGxdO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBzZXQoQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwpIHtcbiAgICAgICAgdGhpcy5BaCA9IEFoIHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IEFsIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IEJoIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IEJsIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IENoIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IENsIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IERoIHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IERsIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IEVoIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IEVsIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IEZoIHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IEZsIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IEdoIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IEdsIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IEhoIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IEhsIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNjQgd29yZHMgd1sxNi4uNzldIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpIHtcbiAgICAgICAgICAgIFNIQTUxMl9XX0hbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgICAgICAgICAgU0hBNTEyX1dfTFtpXSA9IHZpZXcuZ2V0VWludDMyKChvZmZzZXQgKz0gNCkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDgwOyBpKyspIHtcbiAgICAgICAgICAgIC8vIHMwIDo9ICh3W2ktMTVdIHJpZ2h0cm90YXRlIDEpIHhvciAod1tpLTE1XSByaWdodHJvdGF0ZSA4KSB4b3IgKHdbaS0xNV0gcmlnaHRzaGlmdCA3KVxuICAgICAgICAgICAgY29uc3QgVzE1aCA9IFNIQTUxMl9XX0hbaSAtIDE1XSB8IDA7XG4gICAgICAgICAgICBjb25zdCBXMTVsID0gU0hBNTEyX1dfTFtpIC0gMTVdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHMwaCA9IHU2NC5yb3RyU0goVzE1aCwgVzE1bCwgMSkgXiB1NjQucm90clNIKFcxNWgsIFcxNWwsIDgpIF4gdTY0LnNoclNIKFcxNWgsIFcxNWwsIDcpO1xuICAgICAgICAgICAgY29uc3QgczBsID0gdTY0LnJvdHJTTChXMTVoLCBXMTVsLCAxKSBeIHU2NC5yb3RyU0woVzE1aCwgVzE1bCwgOCkgXiB1NjQuc2hyU0woVzE1aCwgVzE1bCwgNyk7XG4gICAgICAgICAgICAvLyBzMSA6PSAod1tpLTJdIHJpZ2h0cm90YXRlIDE5KSB4b3IgKHdbaS0yXSByaWdodHJvdGF0ZSA2MSkgeG9yICh3W2ktMl0gcmlnaHRzaGlmdCA2KVxuICAgICAgICAgICAgY29uc3QgVzJoID0gU0hBNTEyX1dfSFtpIC0gMl0gfCAwO1xuICAgICAgICAgICAgY29uc3QgVzJsID0gU0hBNTEyX1dfTFtpIC0gMl0gfCAwO1xuICAgICAgICAgICAgY29uc3QgczFoID0gdTY0LnJvdHJTSChXMmgsIFcybCwgMTkpIF4gdTY0LnJvdHJCSChXMmgsIFcybCwgNjEpIF4gdTY0LnNoclNIKFcyaCwgVzJsLCA2KTtcbiAgICAgICAgICAgIGNvbnN0IHMxbCA9IHU2NC5yb3RyU0woVzJoLCBXMmwsIDE5KSBeIHU2NC5yb3RyQkwoVzJoLCBXMmwsIDYxKSBeIHU2NC5zaHJTTChXMmgsIFcybCwgNik7XG4gICAgICAgICAgICAvLyBTSEEyNTZfV1tpXSA9IHMwICsgczEgKyBTSEEyNTZfV1tpIC0gN10gKyBTSEEyNTZfV1tpIC0gMTZdO1xuICAgICAgICAgICAgY29uc3QgU1VNbCA9IHU2NC5hZGQ0TChzMGwsIHMxbCwgU0hBNTEyX1dfTFtpIC0gN10sIFNIQTUxMl9XX0xbaSAtIDE2XSk7XG4gICAgICAgICAgICBjb25zdCBTVU1oID0gdTY0LmFkZDRIKFNVTWwsIHMwaCwgczFoLCBTSEE1MTJfV19IW2kgLSA3XSwgU0hBNTEyX1dfSFtpIC0gMTZdKTtcbiAgICAgICAgICAgIFNIQTUxMl9XX0hbaV0gPSBTVU1oIHwgMDtcbiAgICAgICAgICAgIFNIQTUxMl9XX0xbaV0gPSBTVU1sIHwgMDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCB9ID0gdGhpcztcbiAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA4MCByb3VuZHNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4MDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBTMSA6PSAoZSByaWdodHJvdGF0ZSAxNCkgeG9yIChlIHJpZ2h0cm90YXRlIDE4KSB4b3IgKGUgcmlnaHRyb3RhdGUgNDEpXG4gICAgICAgICAgICBjb25zdCBzaWdtYTFoID0gdTY0LnJvdHJTSChFaCwgRWwsIDE0KSBeIHU2NC5yb3RyU0goRWgsIEVsLCAxOCkgXiB1NjQucm90ckJIKEVoLCBFbCwgNDEpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExbCA9IHU2NC5yb3RyU0woRWgsIEVsLCAxNCkgXiB1NjQucm90clNMKEVoLCBFbCwgMTgpIF4gdTY0LnJvdHJCTChFaCwgRWwsIDQxKTtcbiAgICAgICAgICAgIC8vY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IENISWggPSAoRWggJiBGaCkgXiAofkVoICYgR2gpO1xuICAgICAgICAgICAgY29uc3QgQ0hJbCA9IChFbCAmIEZsKSBeICh+RWwgJiBHbCk7XG4gICAgICAgICAgICAvLyBUMSA9IEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEE1MTJfS1tpXSArIFNIQTUxMl9XW2ldXG4gICAgICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IFQxbGwgPSB1NjQuYWRkNUwoSGwsIHNpZ21hMWwsIENISWwsIFNIQTUxMl9LbFtpXSwgU0hBNTEyX1dfTFtpXSk7XG4gICAgICAgICAgICBjb25zdCBUMWggPSB1NjQuYWRkNUgoVDFsbCwgSGgsIHNpZ21hMWgsIENISWgsIFNIQTUxMl9LaFtpXSwgU0hBNTEyX1dfSFtpXSk7XG4gICAgICAgICAgICBjb25zdCBUMWwgPSBUMWxsIHwgMDtcbiAgICAgICAgICAgIC8vIFMwIDo9IChhIHJpZ2h0cm90YXRlIDI4KSB4b3IgKGEgcmlnaHRyb3RhdGUgMzQpIHhvciAoYSByaWdodHJvdGF0ZSAzOSlcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMGggPSB1NjQucm90clNIKEFoLCBBbCwgMjgpIF4gdTY0LnJvdHJCSChBaCwgQWwsIDM0KSBeIHU2NC5yb3RyQkgoQWgsIEFsLCAzOSk7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTBsID0gdTY0LnJvdHJTTChBaCwgQWwsIDI4KSBeIHU2NC5yb3RyQkwoQWgsIEFsLCAzNCkgXiB1NjQucm90ckJMKEFoLCBBbCwgMzkpO1xuICAgICAgICAgICAgY29uc3QgTUFKaCA9IChBaCAmIEJoKSBeIChBaCAmIENoKSBeIChCaCAmIENoKTtcbiAgICAgICAgICAgIGNvbnN0IE1BSmwgPSAoQWwgJiBCbCkgXiAoQWwgJiBDbCkgXiAoQmwgJiBDbCk7XG4gICAgICAgICAgICBIaCA9IEdoIHwgMDtcbiAgICAgICAgICAgIEhsID0gR2wgfCAwO1xuICAgICAgICAgICAgR2ggPSBGaCB8IDA7XG4gICAgICAgICAgICBHbCA9IEZsIHwgMDtcbiAgICAgICAgICAgIEZoID0gRWggfCAwO1xuICAgICAgICAgICAgRmwgPSBFbCB8IDA7XG4gICAgICAgICAgICAoeyBoOiBFaCwgbDogRWwgfSA9IHU2NC5hZGQoRGggfCAwLCBEbCB8IDAsIFQxaCB8IDAsIFQxbCB8IDApKTtcbiAgICAgICAgICAgIERoID0gQ2ggfCAwO1xuICAgICAgICAgICAgRGwgPSBDbCB8IDA7XG4gICAgICAgICAgICBDaCA9IEJoIHwgMDtcbiAgICAgICAgICAgIENsID0gQmwgfCAwO1xuICAgICAgICAgICAgQmggPSBBaCB8IDA7XG4gICAgICAgICAgICBCbCA9IEFsIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IEFsbCA9IHU2NC5hZGQzTChUMWwsIHNpZ21hMGwsIE1BSmwpO1xuICAgICAgICAgICAgQWggPSB1NjQuYWRkM0goQWxsLCBUMWgsIHNpZ21hMGgsIE1BSmgpO1xuICAgICAgICAgICAgQWwgPSBBbGwgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgICh7IGg6IEFoLCBsOiBBbCB9ID0gdTY0LmFkZCh0aGlzLkFoIHwgMCwgdGhpcy5BbCB8IDAsIEFoIHwgMCwgQWwgfCAwKSk7XG4gICAgICAgICh7IGg6IEJoLCBsOiBCbCB9ID0gdTY0LmFkZCh0aGlzLkJoIHwgMCwgdGhpcy5CbCB8IDAsIEJoIHwgMCwgQmwgfCAwKSk7XG4gICAgICAgICh7IGg6IENoLCBsOiBDbCB9ID0gdTY0LmFkZCh0aGlzLkNoIHwgMCwgdGhpcy5DbCB8IDAsIENoIHwgMCwgQ2wgfCAwKSk7XG4gICAgICAgICh7IGg6IERoLCBsOiBEbCB9ID0gdTY0LmFkZCh0aGlzLkRoIHwgMCwgdGhpcy5EbCB8IDAsIERoIHwgMCwgRGwgfCAwKSk7XG4gICAgICAgICh7IGg6IEVoLCBsOiBFbCB9ID0gdTY0LmFkZCh0aGlzLkVoIHwgMCwgdGhpcy5FbCB8IDAsIEVoIHwgMCwgRWwgfCAwKSk7XG4gICAgICAgICh7IGg6IEZoLCBsOiBGbCB9ID0gdTY0LmFkZCh0aGlzLkZoIHwgMCwgdGhpcy5GbCB8IDAsIEZoIHwgMCwgRmwgfCAwKSk7XG4gICAgICAgICh7IGg6IEdoLCBsOiBHbCB9ID0gdTY0LmFkZCh0aGlzLkdoIHwgMCwgdGhpcy5HbCB8IDAsIEdoIHwgMCwgR2wgfCAwKSk7XG4gICAgICAgICh7IGg6IEhoLCBsOiBIbCB9ID0gdTY0LmFkZCh0aGlzLkhoIHwgMCwgdGhpcy5IbCB8IDAsIEhoIHwgMCwgSGwgfCAwKSk7XG4gICAgICAgIHRoaXMuc2V0KEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgU0hBNTEyX1dfSC5maWxsKDApO1xuICAgICAgICBTSEE1MTJfV19MLmZpbGwoMCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyLmZpbGwoMCk7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgIH1cbn1cbmNsYXNzIFNIQTUxMl8yMjQgZXh0ZW5kcyBTSEE1MTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xuICAgICAgICB0aGlzLkFoID0gMHg4YzNkMzdjOCB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSAweDE5NTQ0ZGEyIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IDB4NzNlMTk5NjYgfCAwO1xuICAgICAgICB0aGlzLkJsID0gMHg4OWRjZDRkNiB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSAweDFkZmFiN2FlIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IDB4MzJmZjljODIgfCAwO1xuICAgICAgICB0aGlzLkRoID0gMHg2NzlkZDUxNCB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSAweDU4MmY5ZmNmIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IDB4MGY2ZDJiNjkgfCAwO1xuICAgICAgICB0aGlzLkVsID0gMHg3YmQ0NGRhOCB8IDA7XG4gICAgICAgIHRoaXMuRmggPSAweDc3ZTM2ZjczIHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IDB4MDRjNDg5NDIgfCAwO1xuICAgICAgICB0aGlzLkdoID0gMHgzZjlkODVhOCB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSAweDZhMWQzNmM4IHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IDB4MTExMmU2YWQgfCAwO1xuICAgICAgICB0aGlzLkhsID0gMHg5MWQ2OTJhMSB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMjg7XG4gICAgfVxufVxuY2xhc3MgU0hBNTEyXzI1NiBleHRlbmRzIFNIQTUxMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIGggLS0gaGlnaCAzMiBiaXRzLCBsIC0tIGxvdyAzMiBiaXRzXG4gICAgICAgIHRoaXMuQWggPSAweDIyMzEyMTk0IHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IDB4ZmMyYmY3MmMgfCAwO1xuICAgICAgICB0aGlzLkJoID0gMHg5ZjU1NWZhMyB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSAweGM4NGM2NGMyIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IDB4MjM5M2I4NmIgfCAwO1xuICAgICAgICB0aGlzLkNsID0gMHg2ZjUzYjE1MSB8IDA7XG4gICAgICAgIHRoaXMuRGggPSAweDk2Mzg3NzE5IHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IDB4NTk0MGVhYmQgfCAwO1xuICAgICAgICB0aGlzLkVoID0gMHg5NjI4M2VlMiB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSAweGE4OGVmZmUzIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IDB4YmU1ZTFlMjUgfCAwO1xuICAgICAgICB0aGlzLkZsID0gMHg1Mzg2Mzk5MiB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSAweDJiMDE5OWZjIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IDB4MmM4NWI4YWEgfCAwO1xuICAgICAgICB0aGlzLkhoID0gMHgwZWI3MmRkYyB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSAweDgxYzUyY2EyIHwgMDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSAzMjtcbiAgICB9XG59XG5jbGFzcyBTSEEzODQgZXh0ZW5kcyBTSEE1MTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xuICAgICAgICB0aGlzLkFoID0gMHhjYmJiOWQ1ZCB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSAweGMxMDU5ZWQ4IHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IDB4NjI5YTI5MmEgfCAwO1xuICAgICAgICB0aGlzLkJsID0gMHgzNjdjZDUwNyB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSAweDkxNTkwMTVhIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IDB4MzA3MGRkMTcgfCAwO1xuICAgICAgICB0aGlzLkRoID0gMHgxNTJmZWNkOCB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSAweGY3MGU1OTM5IHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IDB4NjczMzI2NjcgfCAwO1xuICAgICAgICB0aGlzLkVsID0gMHhmZmMwMGIzMSB8IDA7XG4gICAgICAgIHRoaXMuRmggPSAweDhlYjQ0YTg3IHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IDB4Njg1ODE1MTEgfCAwO1xuICAgICAgICB0aGlzLkdoID0gMHhkYjBjMmUwZCB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSAweDY0Zjk4ZmE3IHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IDB4NDdiNTQ4MWQgfCAwO1xuICAgICAgICB0aGlzLkhsID0gMHhiZWZhNGZhNCB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gNDg7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IHNoYTUxMiA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTUxMigpKTtcbmV4cG9ydCBjb25zdCBzaGE1MTJfMjI0ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBNTEyXzIyNCgpKTtcbmV4cG9ydCBjb25zdCBzaGE1MTJfMjU2ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBNTEyXzI1NigpKTtcbmV4cG9ydCBjb25zdCBzaGEzODQgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEEzODQoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGE1MTIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/@noble/hashes/esm/sha512.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@noble/hashes/esm/utils.js":
/*!*****************************************************!*\
  !*** ../../node_modules/@noble/hashes/esm/utils.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: function() { return /* binding */ Hash; },\n/* harmony export */   asyncLoop: function() { return /* binding */ asyncLoop; },\n/* harmony export */   byteSwap: function() { return /* binding */ byteSwap; },\n/* harmony export */   byteSwap32: function() { return /* binding */ byteSwap32; },\n/* harmony export */   byteSwapIfBE: function() { return /* binding */ byteSwapIfBE; },\n/* harmony export */   bytesToHex: function() { return /* binding */ bytesToHex; },\n/* harmony export */   checkOpts: function() { return /* binding */ checkOpts; },\n/* harmony export */   concatBytes: function() { return /* binding */ concatBytes; },\n/* harmony export */   createView: function() { return /* binding */ createView; },\n/* harmony export */   hexToBytes: function() { return /* binding */ hexToBytes; },\n/* harmony export */   isBytes: function() { return /* binding */ isBytes; },\n/* harmony export */   isLE: function() { return /* binding */ isLE; },\n/* harmony export */   nextTick: function() { return /* binding */ nextTick; },\n/* harmony export */   randomBytes: function() { return /* binding */ randomBytes; },\n/* harmony export */   rotl: function() { return /* binding */ rotl; },\n/* harmony export */   rotr: function() { return /* binding */ rotr; },\n/* harmony export */   toBytes: function() { return /* binding */ toBytes; },\n/* harmony export */   u32: function() { return /* binding */ u32; },\n/* harmony export */   u8: function() { return /* binding */ u8; },\n/* harmony export */   utf8ToBytes: function() { return /* binding */ utf8ToBytes; },\n/* harmony export */   wrapConstructor: function() { return /* binding */ wrapConstructor; },\n/* harmony export */   wrapConstructorWithOpts: function() { return /* binding */ wrapConstructorWithOpts; },\n/* harmony export */   wrapXOFConstructorWithOpts: function() { return /* binding */ wrapXOFConstructorWithOpts; }\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(app-pages-browser)/../../node_modules/@noble/hashes/esm/crypto.js\");\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/../../node_modules/@noble/hashes/esm/_assert.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\n\n\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word, shift) => (word << shift) | ((word >>> (32 - shift)) >>> 0);\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// The byte swap operation for uint32\nconst byteSwap = (word) => ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff);\n// Conditionally byte swap if on a big-endian platform\nconst byteSwapIfBE = isLE ? (n) => n : (n) => byteSwap(n);\n// In place byte swap for Uint32Array\nfunction byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(data);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.getRandomValues === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzhDO0FBQ0M7QUFDL0MsWUFBWSxVQUFVO0FBQ3RCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDQTtBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDTztBQUNQLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsYUFBYTtBQUN4RDtBQUNBO0FBQ0E7QUFDTztBQUNQLElBQUksaURBQU07QUFDVjtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDREQUE0RCxXQUFXO0FBQ3ZFLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxJQUFJLGlEQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0EsUUFBUSxpREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBbUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDVDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxRQUFRLHdEQUFNLFdBQVcsd0RBQU07QUFDL0IsZUFBZSx3REFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3V0aWxzLmpzPzA2YjAiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWhhc2hlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gV2UgdXNlIFdlYkNyeXB0byBha2EgZ2xvYmFsVGhpcy5jcnlwdG8sIHdoaWNoIGV4aXN0cyBpbiBicm93c2VycyBhbmQgbm9kZS5qcyAxNisuXG4vLyBub2RlLmpzIHZlcnNpb25zIGVhcmxpZXIgdGhhbiB2MTkgZG9uJ3QgZGVjbGFyZSBpdCBpbiBnbG9iYWwgc2NvcGUuXG4vLyBGb3Igbm9kZS5qcywgcGFja2FnZS5qc29uI2V4cG9ydHMgZmllbGQgbWFwcGluZyByZXdyaXRlcyBpbXBvcnRcbi8vIGZyb20gYGNyeXB0b2AgdG8gYGNyeXB0b05vZGVgLCB3aGljaCBpbXBvcnRzIG5hdGl2ZSBtb2R1bGUuXG4vLyBNYWtlcyB0aGUgdXRpbHMgdW4taW1wb3J0YWJsZSBpbiBicm93c2VycyB3aXRob3V0IGEgYnVuZGxlci5cbi8vIE9uY2Ugbm9kZS5qcyAxOCBpcyBkZXByZWNhdGVkICgyMDI1LTA0LTMwKSwgd2UgY2FuIGp1c3QgZHJvcCB0aGUgaW1wb3J0LlxuaW1wb3J0IHsgY3J5cHRvIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9jcnlwdG8nO1xuaW1wb3J0IHsgYnl0ZXMgYXMgYWJ5dGVzIH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbi8vIGV4cG9ydCB7IGlzQnl0ZXMgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuLy8gV2UgY2FuJ3QgcmV1c2UgaXNCeXRlcyBmcm9tIF9hc3NlcnQsIGJlY2F1c2Ugc29tZWhvdyB0aGlzIGNhdXNlcyBodWdlIHBlcmYgaXNzdWVzXG5leHBvcnQgZnVuY3Rpb24gaXNCeXRlcyhhKSB7XG4gICAgcmV0dXJuIChhIGluc3RhbmNlb2YgVWludDhBcnJheSB8fFxuICAgICAgICAoYSAhPSBudWxsICYmIHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiBhLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdVaW50OEFycmF5JykpO1xufVxuLy8gQ2FzdCBhcnJheSB0byBkaWZmZXJlbnQgdHlwZVxuZXhwb3J0IGNvbnN0IHU4ID0gKGFycikgPT4gbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbmV4cG9ydCBjb25zdCB1MzIgPSAoYXJyKSA9PiBuZXcgVWludDMyQXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIE1hdGguZmxvb3IoYXJyLmJ5dGVMZW5ndGggLyA0KSk7XG4vLyBDYXN0IGFycmF5IHRvIHZpZXdcbmV4cG9ydCBjb25zdCBjcmVhdGVWaWV3ID0gKGFycikgPT4gbmV3IERhdGFWaWV3KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG4vLyBUaGUgcm90YXRlIHJpZ2h0IChjaXJjdWxhciByaWdodCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzJcbmV4cG9ydCBjb25zdCByb3RyID0gKHdvcmQsIHNoaWZ0KSA9PiAod29yZCA8PCAoMzIgLSBzaGlmdCkpIHwgKHdvcmQgPj4+IHNoaWZ0KTtcbi8vIFRoZSByb3RhdGUgbGVmdCAoY2lyY3VsYXIgbGVmdCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzJcbmV4cG9ydCBjb25zdCByb3RsID0gKHdvcmQsIHNoaWZ0KSA9PiAod29yZCA8PCBzaGlmdCkgfCAoKHdvcmQgPj4+ICgzMiAtIHNoaWZ0KSkgPj4+IDApO1xuZXhwb3J0IGNvbnN0IGlzTEUgPSBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0O1xuLy8gVGhlIGJ5dGUgc3dhcCBvcGVyYXRpb24gZm9yIHVpbnQzMlxuZXhwb3J0IGNvbnN0IGJ5dGVTd2FwID0gKHdvcmQpID0+ICgod29yZCA8PCAyNCkgJiAweGZmMDAwMDAwKSB8XG4gICAgKCh3b3JkIDw8IDgpICYgMHhmZjAwMDApIHxcbiAgICAoKHdvcmQgPj4+IDgpICYgMHhmZjAwKSB8XG4gICAgKCh3b3JkID4+PiAyNCkgJiAweGZmKTtcbi8vIENvbmRpdGlvbmFsbHkgYnl0ZSBzd2FwIGlmIG9uIGEgYmlnLWVuZGlhbiBwbGF0Zm9ybVxuZXhwb3J0IGNvbnN0IGJ5dGVTd2FwSWZCRSA9IGlzTEUgPyAobikgPT4gbiA6IChuKSA9PiBieXRlU3dhcChuKTtcbi8vIEluIHBsYWNlIGJ5dGUgc3dhcCBmb3IgVWludDMyQXJyYXlcbmV4cG9ydCBmdW5jdGlvbiBieXRlU3dhcDMyKGFycikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IGJ5dGVTd2FwKGFycltpXSk7XG4gICAgfVxufVxuLy8gQXJyYXkgd2hlcmUgaW5kZXggMHhmMCAoMjQwKSBpcyBtYXBwZWQgdG8gc3RyaW5nICdmMCdcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBhYnl0ZXMoYnl0ZXMpO1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG4vLyBXZSB1c2Ugb3B0aW1pemVkIHRlY2huaXF1ZSB0byBjb252ZXJ0IGhleCBzdHJpbmcgdG8gYnl0ZSBhcnJheVxuY29uc3QgYXNjaWlzID0geyBfMDogNDgsIF85OiA1NywgX0E6IDY1LCBfRjogNzAsIF9hOiA5NywgX2Y6IDEwMiB9O1xuZnVuY3Rpb24gYXNjaWlUb0Jhc2UxNihjaGFyKSB7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl8wICYmIGNoYXIgPD0gYXNjaWlzLl85KVxuICAgICAgICByZXR1cm4gY2hhciAtIGFzY2lpcy5fMDtcbiAgICBpZiAoY2hhciA+PSBhc2NpaXMuX0EgJiYgY2hhciA8PSBhc2NpaXMuX0YpXG4gICAgICAgIHJldHVybiBjaGFyIC0gKGFzY2lpcy5fQSAtIDEwKTtcbiAgICBpZiAoY2hhciA+PSBhc2NpaXMuX2EgJiYgY2hhciA8PSBhc2NpaXMuX2YpXG4gICAgICAgIHJldHVybiBjaGFyIC0gKGFzY2lpcy5fYSAtIDEwKTtcbiAgICByZXR1cm47XG59XG4vKipcbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgY29uc3QgaGwgPSBoZXgubGVuZ3RoO1xuICAgIGNvbnN0IGFsID0gaGwgLyAyO1xuICAgIGlmIChobCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGVkIGhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBobCk7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShhbCk7XG4gICAgZm9yIChsZXQgYWkgPSAwLCBoaSA9IDA7IGFpIDwgYWw7IGFpKyssIGhpICs9IDIpIHtcbiAgICAgICAgY29uc3QgbjEgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpKSk7XG4gICAgICAgIGNvbnN0IG4yID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSArIDEpKTtcbiAgICAgICAgaWYgKG4xID09PSB1bmRlZmluZWQgfHwgbjIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY2hhciA9IGhleFtoaV0gKyBoZXhbaGkgKyAxXTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IG5vbi1oZXggY2hhcmFjdGVyIFwiJyArIGNoYXIgKyAnXCIgYXQgaW5kZXggJyArIGhpKTtcbiAgICAgICAgfVxuICAgICAgICBhcnJheVthaV0gPSBuMSAqIDE2ICsgbjI7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8vIFRoZXJlIGlzIG5vIHNldEltbWVkaWF0ZSBpbiBicm93c2VyIGFuZCBzZXRUaW1lb3V0IGlzIHNsb3cuXG4vLyBjYWxsIG9mIGFzeW5jIGZuIHdpbGwgcmV0dXJuIFByb21pc2UsIHdoaWNoIHdpbGwgYmUgZnVsbGZpbGVkIG9ubHkgb25cbi8vIG5leHQgc2NoZWR1bGVyIHF1ZXVlIHByb2Nlc3Npbmcgc3RlcCBhbmQgdGhpcyBpcyBleGFjdGx5IHdoYXQgd2UgbmVlZC5cbmV4cG9ydCBjb25zdCBuZXh0VGljayA9IGFzeW5jICgpID0+IHsgfTtcbi8vIFJldHVybnMgY29udHJvbCB0byB0aHJlYWQgZWFjaCAndGljaycgbXMgdG8gYXZvaWQgYmxvY2tpbmdcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY0xvb3AoaXRlcnMsIHRpY2ssIGNiKSB7XG4gICAgbGV0IHRzID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcbiAgICAgICAgY2IoaSk7XG4gICAgICAgIC8vIERhdGUubm93KCkgaXMgbm90IG1vbm90b25pYywgc28gaW4gY2FzZSBpZiBjbG9jayBnb2VzIGJhY2t3YXJkcyB3ZSByZXR1cm4gcmV0dXJuIGNvbnRyb2wgdG9vXG4gICAgICAgIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gdHM7XG4gICAgICAgIGlmIChkaWZmID49IDAgJiYgZGlmZiA8IHRpY2spXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXdhaXQgbmV4dFRpY2soKTtcbiAgICAgICAgdHMgKz0gZGlmZjtcbiAgICB9XG59XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbi8qKlxuICogTm9ybWFsaXplcyAobm9uLWhleCkgc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gVWludDhBcnJheS5cbiAqIFdhcm5pbmc6IHdoZW4gVWludDhBcnJheSBpcyBwYXNzZWQsIGl0IHdvdWxkIE5PVCBnZXQgY29waWVkLlxuICogS2VlcCBpbiBtaW5kIGZvciBmdXR1cmUgbXV0YWJsZSBvcGVyYXRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlcyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xuICAgIGFieXRlcyhkYXRhKTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8qKlxuICogQ29waWVzIHNldmVyYWwgVWludDhBcnJheXMgaW50byBvbmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICBhYnl0ZXMoYSk7XG4gICAgICAgIHN1bSArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoc3VtKTtcbiAgICBmb3IgKGxldCBpID0gMCwgcGFkID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICByZXMuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIEZvciBydW50aW1lIGNoZWNrIGlmIGNsYXNzIGltcGxlbWVudHMgaW50ZXJmYWNlXG5leHBvcnQgY2xhc3MgSGFzaCB7XG4gICAgLy8gU2FmZSB2ZXJzaW9uIHRoYXQgY2xvbmVzIGludGVybmFsIHN0YXRlXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgICB9XG59XG5jb25zdCB0b1N0ciA9IHt9LnRvU3RyaW5nO1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrT3B0cyhkZWZhdWx0cywgb3B0cykge1xuICAgIGlmIChvcHRzICE9PSB1bmRlZmluZWQgJiYgdG9TdHIuY2FsbChvcHRzKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT3B0aW9ucyBzaG91bGQgYmUgb2JqZWN0IG9yIHVuZGVmaW5lZCcpO1xuICAgIGNvbnN0IG1lcmdlZCA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdHMsIG9wdHMpO1xuICAgIHJldHVybiBtZXJnZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnKSA9PiBoYXNoQ29ucygpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKCk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAoKSA9PiBoYXNoQ29ucygpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbi8qKlxuICogU2VjdXJlIFBSTkcuIFVzZXMgYGNyeXB0by5nZXRSYW5kb21WYWx1ZXNgLCB3aGljaCBkZWZlcnMgdG8gT1MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21CeXRlcyhieXRlc0xlbmd0aCA9IDMyKSB7XG4gICAgaWYgKGNyeXB0byAmJiB0eXBlb2YgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShieXRlc0xlbmd0aCkpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMgbXVzdCBiZSBkZWZpbmVkJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/@noble/hashes/esm/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@tanstack/query-core/build/modern/focusManager.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/@tanstack/query-core/build/modern/focusManager.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FocusManager: function() { return /* binding */ FocusManager; },\n/* harmony export */   focusManager: function() { return /* binding */ focusManager; }\n/* harmony export */ });\n/* harmony import */ var _subscribable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./subscribable.js */ \"(app-pages-browser)/../../node_modules/@tanstack/query-core/build/modern/subscribable.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../../node_modules/@tanstack/query-core/build/modern/utils.js\");\n// src/focusManager.ts\n\n\nvar FocusManager = class extends _subscribable_js__WEBPACK_IMPORTED_MODULE_0__.Subscribable {\n  #focused;\n  #cleanup;\n  #setup;\n  constructor() {\n    super();\n    this.#setup = (onFocus) => {\n      if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__.isServer && window.addEventListener) {\n        const listener = () => onFocus();\n        window.addEventListener(\"visibilitychange\", listener, false);\n        return () => {\n          window.removeEventListener(\"visibilitychange\", listener);\n        };\n      }\n      return;\n    };\n  }\n  onSubscribe() {\n    if (!this.#cleanup) {\n      this.setEventListener(this.#setup);\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#cleanup?.();\n      this.#cleanup = void 0;\n    }\n  }\n  setEventListener(setup) {\n    this.#setup = setup;\n    this.#cleanup?.();\n    this.#cleanup = setup((focused) => {\n      if (typeof focused === \"boolean\") {\n        this.setFocused(focused);\n      } else {\n        this.onFocus();\n      }\n    });\n  }\n  setFocused(focused) {\n    const changed = this.#focused !== focused;\n    if (changed) {\n      this.#focused = focused;\n      this.onFocus();\n    }\n  }\n  onFocus() {\n    const isFocused = this.isFocused();\n    this.listeners.forEach((listener) => {\n      listener(isFocused);\n    });\n  }\n  isFocused() {\n    if (typeof this.#focused === \"boolean\") {\n      return this.#focused;\n    }\n    return globalThis.document?.visibilityState !== \"hidden\";\n  }\n};\nvar focusManager = new FocusManager();\n\n//# sourceMappingURL=focusManager.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbW9kZXJuL2ZvY3VzTWFuYWdlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDaUQ7QUFDWDtBQUN0QyxpQ0FBaUMsMERBQVk7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywrQ0FBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vZm9jdXNNYW5hZ2VyLmpzPzE4MmQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2ZvY3VzTWFuYWdlci50c1xuaW1wb3J0IHsgU3Vic2NyaWJhYmxlIH0gZnJvbSBcIi4vc3Vic2NyaWJhYmxlLmpzXCI7XG5pbXBvcnQgeyBpc1NlcnZlciB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG52YXIgRm9jdXNNYW5hZ2VyID0gY2xhc3MgZXh0ZW5kcyBTdWJzY3JpYmFibGUge1xuICAjZm9jdXNlZDtcbiAgI2NsZWFudXA7XG4gICNzZXR1cDtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLiNzZXR1cCA9IChvbkZvY3VzKSA9PiB7XG4gICAgICBpZiAoIWlzU2VydmVyICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyID0gKCkgPT4gb25Gb2N1cygpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgbGlzdGVuZXIpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH07XG4gIH1cbiAgb25TdWJzY3JpYmUoKSB7XG4gICAgaWYgKCF0aGlzLiNjbGVhbnVwKSB7XG4gICAgICB0aGlzLnNldEV2ZW50TGlzdGVuZXIodGhpcy4jc2V0dXApO1xuICAgIH1cbiAgfVxuICBvblVuc3Vic2NyaWJlKCkge1xuICAgIGlmICghdGhpcy5oYXNMaXN0ZW5lcnMoKSkge1xuICAgICAgdGhpcy4jY2xlYW51cD8uKCk7XG4gICAgICB0aGlzLiNjbGVhbnVwID0gdm9pZCAwO1xuICAgIH1cbiAgfVxuICBzZXRFdmVudExpc3RlbmVyKHNldHVwKSB7XG4gICAgdGhpcy4jc2V0dXAgPSBzZXR1cDtcbiAgICB0aGlzLiNjbGVhbnVwPy4oKTtcbiAgICB0aGlzLiNjbGVhbnVwID0gc2V0dXAoKGZvY3VzZWQpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgZm9jdXNlZCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgdGhpcy5zZXRGb2N1c2VkKGZvY3VzZWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vbkZvY3VzKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc2V0Rm9jdXNlZChmb2N1c2VkKSB7XG4gICAgY29uc3QgY2hhbmdlZCA9IHRoaXMuI2ZvY3VzZWQgIT09IGZvY3VzZWQ7XG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHRoaXMuI2ZvY3VzZWQgPSBmb2N1c2VkO1xuICAgICAgdGhpcy5vbkZvY3VzKCk7XG4gICAgfVxuICB9XG4gIG9uRm9jdXMoKSB7XG4gICAgY29uc3QgaXNGb2N1c2VkID0gdGhpcy5pc0ZvY3VzZWQoKTtcbiAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xuICAgICAgbGlzdGVuZXIoaXNGb2N1c2VkKTtcbiAgICB9KTtcbiAgfVxuICBpc0ZvY3VzZWQoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLiNmb2N1c2VkID09PSBcImJvb2xlYW5cIikge1xuICAgICAgcmV0dXJuIHRoaXMuI2ZvY3VzZWQ7XG4gICAgfVxuICAgIHJldHVybiBnbG9iYWxUaGlzLmRvY3VtZW50Py52aXNpYmlsaXR5U3RhdGUgIT09IFwiaGlkZGVuXCI7XG4gIH1cbn07XG52YXIgZm9jdXNNYW5hZ2VyID0gbmV3IEZvY3VzTWFuYWdlcigpO1xuZXhwb3J0IHtcbiAgRm9jdXNNYW5hZ2VyLFxuICBmb2N1c01hbmFnZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1c01hbmFnZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/@tanstack/query-core/build/modern/focusManager.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@tanstack/query-core/build/modern/notifyManager.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/@tanstack/query-core/build/modern/notifyManager.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createNotifyManager: function() { return /* binding */ createNotifyManager; },\n/* harmony export */   notifyManager: function() { return /* binding */ notifyManager; }\n/* harmony export */ });\n// src/notifyManager.ts\nfunction createNotifyManager() {\n  let queue = [];\n  let transactions = 0;\n  let notifyFn = (callback) => {\n    callback();\n  };\n  let batchNotifyFn = (callback) => {\n    callback();\n  };\n  let scheduleFn = (cb) => setTimeout(cb, 0);\n  const setScheduler = (fn) => {\n    scheduleFn = fn;\n  };\n  const batch = (callback) => {\n    let result;\n    transactions++;\n    try {\n      result = callback();\n    } finally {\n      transactions--;\n      if (!transactions) {\n        flush();\n      }\n    }\n    return result;\n  };\n  const schedule = (callback) => {\n    if (transactions) {\n      queue.push(callback);\n    } else {\n      scheduleFn(() => {\n        notifyFn(callback);\n      });\n    }\n  };\n  const batchCalls = (callback) => {\n    return (...args) => {\n      schedule(() => {\n        callback(...args);\n      });\n    };\n  };\n  const flush = () => {\n    const originalQueue = queue;\n    queue = [];\n    if (originalQueue.length) {\n      scheduleFn(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach((callback) => {\n            notifyFn(callback);\n          });\n        });\n      });\n    }\n  };\n  const setNotifyFunction = (fn) => {\n    notifyFn = fn;\n  };\n  const setBatchNotifyFunction = (fn) => {\n    batchNotifyFn = fn;\n  };\n  return {\n    batch,\n    batchCalls,\n    schedule,\n    setNotifyFunction,\n    setBatchNotifyFunction,\n    setScheduler\n  };\n}\nvar notifyManager = createNotifyManager();\n\n//# sourceMappingURL=notifyManager.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbW9kZXJuL25vdGlmeU1hbmFnZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vbm90aWZ5TWFuYWdlci5qcz9kOTQ2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9ub3RpZnlNYW5hZ2VyLnRzXG5mdW5jdGlvbiBjcmVhdGVOb3RpZnlNYW5hZ2VyKCkge1xuICBsZXQgcXVldWUgPSBbXTtcbiAgbGV0IHRyYW5zYWN0aW9ucyA9IDA7XG4gIGxldCBub3RpZnlGbiA9IChjYWxsYmFjaykgPT4ge1xuICAgIGNhbGxiYWNrKCk7XG4gIH07XG4gIGxldCBiYXRjaE5vdGlmeUZuID0gKGNhbGxiYWNrKSA9PiB7XG4gICAgY2FsbGJhY2soKTtcbiAgfTtcbiAgbGV0IHNjaGVkdWxlRm4gPSAoY2IpID0+IHNldFRpbWVvdXQoY2IsIDApO1xuICBjb25zdCBzZXRTY2hlZHVsZXIgPSAoZm4pID0+IHtcbiAgICBzY2hlZHVsZUZuID0gZm47XG4gIH07XG4gIGNvbnN0IGJhdGNoID0gKGNhbGxiYWNrKSA9PiB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0cmFuc2FjdGlvbnMrKztcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gY2FsbGJhY2soKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJhbnNhY3Rpb25zLS07XG4gICAgICBpZiAoIXRyYW5zYWN0aW9ucykge1xuICAgICAgICBmbHVzaCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBjb25zdCBzY2hlZHVsZSA9IChjYWxsYmFjaykgPT4ge1xuICAgIGlmICh0cmFuc2FjdGlvbnMpIHtcbiAgICAgIHF1ZXVlLnB1c2goY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2hlZHVsZUZuKCgpID0+IHtcbiAgICAgICAgbm90aWZ5Rm4oY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBiYXRjaENhbGxzID0gKGNhbGxiYWNrKSA9PiB7XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICBzY2hlZHVsZSgoKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKC4uLmFyZ3MpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcbiAgY29uc3QgZmx1c2ggPSAoKSA9PiB7XG4gICAgY29uc3Qgb3JpZ2luYWxRdWV1ZSA9IHF1ZXVlO1xuICAgIHF1ZXVlID0gW107XG4gICAgaWYgKG9yaWdpbmFsUXVldWUubGVuZ3RoKSB7XG4gICAgICBzY2hlZHVsZUZuKCgpID0+IHtcbiAgICAgICAgYmF0Y2hOb3RpZnlGbigoKSA9PiB7XG4gICAgICAgICAgb3JpZ2luYWxRdWV1ZS5mb3JFYWNoKChjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgbm90aWZ5Rm4oY2FsbGJhY2spO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc2V0Tm90aWZ5RnVuY3Rpb24gPSAoZm4pID0+IHtcbiAgICBub3RpZnlGbiA9IGZuO1xuICB9O1xuICBjb25zdCBzZXRCYXRjaE5vdGlmeUZ1bmN0aW9uID0gKGZuKSA9PiB7XG4gICAgYmF0Y2hOb3RpZnlGbiA9IGZuO1xuICB9O1xuICByZXR1cm4ge1xuICAgIGJhdGNoLFxuICAgIGJhdGNoQ2FsbHMsXG4gICAgc2NoZWR1bGUsXG4gICAgc2V0Tm90aWZ5RnVuY3Rpb24sXG4gICAgc2V0QmF0Y2hOb3RpZnlGdW5jdGlvbixcbiAgICBzZXRTY2hlZHVsZXJcbiAgfTtcbn1cbnZhciBub3RpZnlNYW5hZ2VyID0gY3JlYXRlTm90aWZ5TWFuYWdlcigpO1xuZXhwb3J0IHtcbiAgY3JlYXRlTm90aWZ5TWFuYWdlcixcbiAgbm90aWZ5TWFuYWdlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vdGlmeU1hbmFnZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/@tanstack/query-core/build/modern/notifyManager.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@tanstack/query-core/build/modern/onlineManager.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/@tanstack/query-core/build/modern/onlineManager.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OnlineManager: function() { return /* binding */ OnlineManager; },\n/* harmony export */   onlineManager: function() { return /* binding */ onlineManager; }\n/* harmony export */ });\n/* harmony import */ var _subscribable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./subscribable.js */ \"(app-pages-browser)/../../node_modules/@tanstack/query-core/build/modern/subscribable.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../../node_modules/@tanstack/query-core/build/modern/utils.js\");\n// src/onlineManager.ts\n\n\nvar OnlineManager = class extends _subscribable_js__WEBPACK_IMPORTED_MODULE_0__.Subscribable {\n  #online = true;\n  #cleanup;\n  #setup;\n  constructor() {\n    super();\n    this.#setup = (onOnline) => {\n      if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__.isServer && window.addEventListener) {\n        const onlineListener = () => onOnline(true);\n        const offlineListener = () => onOnline(false);\n        window.addEventListener(\"online\", onlineListener, false);\n        window.addEventListener(\"offline\", offlineListener, false);\n        return () => {\n          window.removeEventListener(\"online\", onlineListener);\n          window.removeEventListener(\"offline\", offlineListener);\n        };\n      }\n      return;\n    };\n  }\n  onSubscribe() {\n    if (!this.#cleanup) {\n      this.setEventListener(this.#setup);\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#cleanup?.();\n      this.#cleanup = void 0;\n    }\n  }\n  setEventListener(setup) {\n    this.#setup = setup;\n    this.#cleanup?.();\n    this.#cleanup = setup(this.setOnline.bind(this));\n  }\n  setOnline(online) {\n    const changed = this.#online !== online;\n    if (changed) {\n      this.#online = online;\n      this.listeners.forEach((listener) => {\n        listener(online);\n      });\n    }\n  }\n  isOnline() {\n    return this.#online;\n  }\n};\nvar onlineManager = new OnlineManager();\n\n//# sourceMappingURL=onlineManager.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbW9kZXJuL29ubGluZU1hbmFnZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ2lEO0FBQ1g7QUFDdEMsa0NBQWtDLDBEQUFZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsK0NBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbW9kZXJuL29ubGluZU1hbmFnZXIuanM/Mzc4YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvb25saW5lTWFuYWdlci50c1xuaW1wb3J0IHsgU3Vic2NyaWJhYmxlIH0gZnJvbSBcIi4vc3Vic2NyaWJhYmxlLmpzXCI7XG5pbXBvcnQgeyBpc1NlcnZlciB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG52YXIgT25saW5lTWFuYWdlciA9IGNsYXNzIGV4dGVuZHMgU3Vic2NyaWJhYmxlIHtcbiAgI29ubGluZSA9IHRydWU7XG4gICNjbGVhbnVwO1xuICAjc2V0dXA7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy4jc2V0dXAgPSAob25PbmxpbmUpID0+IHtcbiAgICAgIGlmICghaXNTZXJ2ZXIgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3Qgb25saW5lTGlzdGVuZXIgPSAoKSA9PiBvbk9ubGluZSh0cnVlKTtcbiAgICAgICAgY29uc3Qgb2ZmbGluZUxpc3RlbmVyID0gKCkgPT4gb25PbmxpbmUoZmFsc2UpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLCBvbmxpbmVMaXN0ZW5lciwgZmFsc2UpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9mZmxpbmVcIiwgb2ZmbGluZUxpc3RlbmVyLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIiwgb25saW5lTGlzdGVuZXIpO1xuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwib2ZmbGluZVwiLCBvZmZsaW5lTGlzdGVuZXIpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH07XG4gIH1cbiAgb25TdWJzY3JpYmUoKSB7XG4gICAgaWYgKCF0aGlzLiNjbGVhbnVwKSB7XG4gICAgICB0aGlzLnNldEV2ZW50TGlzdGVuZXIodGhpcy4jc2V0dXApO1xuICAgIH1cbiAgfVxuICBvblVuc3Vic2NyaWJlKCkge1xuICAgIGlmICghdGhpcy5oYXNMaXN0ZW5lcnMoKSkge1xuICAgICAgdGhpcy4jY2xlYW51cD8uKCk7XG4gICAgICB0aGlzLiNjbGVhbnVwID0gdm9pZCAwO1xuICAgIH1cbiAgfVxuICBzZXRFdmVudExpc3RlbmVyKHNldHVwKSB7XG4gICAgdGhpcy4jc2V0dXAgPSBzZXR1cDtcbiAgICB0aGlzLiNjbGVhbnVwPy4oKTtcbiAgICB0aGlzLiNjbGVhbnVwID0gc2V0dXAodGhpcy5zZXRPbmxpbmUuYmluZCh0aGlzKSk7XG4gIH1cbiAgc2V0T25saW5lKG9ubGluZSkge1xuICAgIGNvbnN0IGNoYW5nZWQgPSB0aGlzLiNvbmxpbmUgIT09IG9ubGluZTtcbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgdGhpcy4jb25saW5lID0gb25saW5lO1xuICAgICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIpID0+IHtcbiAgICAgICAgbGlzdGVuZXIob25saW5lKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpc09ubGluZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jb25saW5lO1xuICB9XG59O1xudmFyIG9ubGluZU1hbmFnZXIgPSBuZXcgT25saW5lTWFuYWdlcigpO1xuZXhwb3J0IHtcbiAgT25saW5lTWFuYWdlcixcbiAgb25saW5lTWFuYWdlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9ubGluZU1hbmFnZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/@tanstack/query-core/build/modern/onlineManager.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@tanstack/query-core/build/modern/query.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@tanstack/query-core/build/modern/query.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Query: function() { return /* binding */ Query; },\n/* harmony export */   fetchState: function() { return /* binding */ fetchState; }\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../../node_modules/@tanstack/query-core/build/modern/utils.js\");\n/* harmony import */ var _notifyManager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./notifyManager.js */ \"(app-pages-browser)/../../node_modules/@tanstack/query-core/build/modern/notifyManager.js\");\n/* harmony import */ var _retryer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./retryer.js */ \"(app-pages-browser)/../../node_modules/@tanstack/query-core/build/modern/retryer.js\");\n/* harmony import */ var _removable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./removable.js */ \"(app-pages-browser)/../../node_modules/@tanstack/query-core/build/modern/removable.js\");\n// src/query.ts\n\n\n\n\nvar Query = class extends _removable_js__WEBPACK_IMPORTED_MODULE_0__.Removable {\n  #initialState;\n  #revertState;\n  #cache;\n  #retryer;\n  #defaultOptions;\n  #abortSignalConsumed;\n  constructor(config) {\n    super();\n    this.#abortSignalConsumed = false;\n    this.#defaultOptions = config.defaultOptions;\n    this.setOptions(config.options);\n    this.observers = [];\n    this.#cache = config.cache;\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.#initialState = getDefaultState(this.options);\n    this.state = config.state ?? this.#initialState;\n    this.scheduleGc();\n  }\n  get meta() {\n    return this.options.meta;\n  }\n  get promise() {\n    return this.#retryer?.promise;\n  }\n  setOptions(options) {\n    this.options = { ...this.#defaultOptions, ...options };\n    this.updateGcTime(this.options.gcTime);\n  }\n  optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === \"idle\") {\n      this.#cache.remove(this);\n    }\n  }\n  setData(newData, options) {\n    const data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.replaceData)(this.state.data, newData, this.options);\n    this.#dispatch({\n      data,\n      type: \"success\",\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual\n    });\n    return data;\n  }\n  setState(state, setStateOptions) {\n    this.#dispatch({ type: \"setState\", state, setStateOptions });\n  }\n  cancel(options) {\n    const promise = this.#retryer?.promise;\n    this.#retryer?.cancel(options);\n    return promise ? promise.then(_utils_js__WEBPACK_IMPORTED_MODULE_1__.noop).catch(_utils_js__WEBPACK_IMPORTED_MODULE_1__.noop) : Promise.resolve();\n  }\n  destroy() {\n    super.destroy();\n    this.cancel({ silent: true });\n  }\n  reset() {\n    this.destroy();\n    this.setState(this.#initialState);\n  }\n  isActive() {\n    return this.observers.some(\n      (observer) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.resolveEnabled)(observer.options.enabled, this) !== false\n    );\n  }\n  isDisabled() {\n    return this.getObserversCount() > 0 && !this.isActive();\n  }\n  isStale() {\n    if (this.state.isInvalidated) {\n      return true;\n    }\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) => observer.getCurrentResult().isStale\n      );\n    }\n    return this.state.data === void 0;\n  }\n  isStaleByTime(staleTime = 0) {\n    return this.state.isInvalidated || this.state.data === void 0 || !(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.timeUntilStale)(this.state.dataUpdatedAt, staleTime);\n  }\n  onFocus() {\n    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus());\n    observer?.refetch({ cancelRefetch: false });\n    this.#retryer?.continue();\n  }\n  onOnline() {\n    const observer = this.observers.find((x) => x.shouldFetchOnReconnect());\n    observer?.refetch({ cancelRefetch: false });\n    this.#retryer?.continue();\n  }\n  addObserver(observer) {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer);\n      this.clearGcTimeout();\n      this.#cache.notify({ type: \"observerAdded\", query: this, observer });\n    }\n  }\n  removeObserver(observer) {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter((x) => x !== observer);\n      if (!this.observers.length) {\n        if (this.#retryer) {\n          if (this.#abortSignalConsumed) {\n            this.#retryer.cancel({ revert: true });\n          } else {\n            this.#retryer.cancelRetry();\n          }\n        }\n        this.scheduleGc();\n      }\n      this.#cache.notify({ type: \"observerRemoved\", query: this, observer });\n    }\n  }\n  getObserversCount() {\n    return this.observers.length;\n  }\n  invalidate() {\n    if (!this.state.isInvalidated) {\n      this.#dispatch({ type: \"invalidate\" });\n    }\n  }\n  fetch(options, fetchOptions) {\n    if (this.state.fetchStatus !== \"idle\") {\n      if (this.state.data !== void 0 && fetchOptions?.cancelRefetch) {\n        this.cancel({ silent: true });\n      } else if (this.#retryer) {\n        this.#retryer.continueRetry();\n        return this.#retryer.promise;\n      }\n    }\n    if (options) {\n      this.setOptions(options);\n    }\n    if (!this.options.queryFn) {\n      const observer = this.observers.find((x) => x.options.queryFn);\n      if (observer) {\n        this.setOptions(observer.options);\n      }\n    }\n    if (true) {\n      if (!Array.isArray(this.options.queryKey)) {\n        console.error(\n          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`\n        );\n      }\n    }\n    const abortController = new AbortController();\n    const addSignalProperty = (object) => {\n      Object.defineProperty(object, \"signal\", {\n        enumerable: true,\n        get: () => {\n          this.#abortSignalConsumed = true;\n          return abortController.signal;\n        }\n      });\n    };\n    const fetchFn = () => {\n      const queryFn = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureQueryFn)(this.options, fetchOptions);\n      const queryFnContext = {\n        queryKey: this.queryKey,\n        meta: this.meta\n      };\n      addSignalProperty(queryFnContext);\n      this.#abortSignalConsumed = false;\n      if (this.options.persister) {\n        return this.options.persister(\n          queryFn,\n          queryFnContext,\n          this\n        );\n      }\n      return queryFn(queryFnContext);\n    };\n    const context = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn\n    };\n    addSignalProperty(context);\n    this.options.behavior?.onFetch(\n      context,\n      this\n    );\n    this.#revertState = this.state;\n    if (this.state.fetchStatus === \"idle\" || this.state.fetchMeta !== context.fetchOptions?.meta) {\n      this.#dispatch({ type: \"fetch\", meta: context.fetchOptions?.meta });\n    }\n    const onError = (error) => {\n      if (!((0,_retryer_js__WEBPACK_IMPORTED_MODULE_2__.isCancelledError)(error) && error.silent)) {\n        this.#dispatch({\n          type: \"error\",\n          error\n        });\n      }\n      if (!(0,_retryer_js__WEBPACK_IMPORTED_MODULE_2__.isCancelledError)(error)) {\n        this.#cache.config.onError?.(\n          error,\n          this\n        );\n        this.#cache.config.onSettled?.(\n          this.state.data,\n          error,\n          this\n        );\n      }\n      if (!this.isFetchingOptimistic) {\n        this.scheduleGc();\n      }\n      this.isFetchingOptimistic = false;\n    };\n    this.#retryer = (0,_retryer_js__WEBPACK_IMPORTED_MODULE_2__.createRetryer)({\n      initialPromise: fetchOptions?.initialPromise,\n      fn: context.fetchFn,\n      abort: abortController.abort.bind(abortController),\n      onSuccess: (data) => {\n        if (data === void 0) {\n          if (true) {\n            console.error(\n              `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`\n            );\n          }\n          onError(new Error(`${this.queryHash} data is undefined`));\n          return;\n        }\n        try {\n          this.setData(data);\n        } catch (error) {\n          onError(error);\n          return;\n        }\n        this.#cache.config.onSuccess?.(data, this);\n        this.#cache.config.onSettled?.(\n          data,\n          this.state.error,\n          this\n        );\n        if (!this.isFetchingOptimistic) {\n          this.scheduleGc();\n        }\n        this.isFetchingOptimistic = false;\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: \"failed\", failureCount, error });\n      },\n      onPause: () => {\n        this.#dispatch({ type: \"pause\" });\n      },\n      onContinue: () => {\n        this.#dispatch({ type: \"continue\" });\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n      canRun: () => true\n    });\n    return this.#retryer.start();\n  }\n  #dispatch(action) {\n    const reducer = (state) => {\n      switch (action.type) {\n        case \"failed\":\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error\n          };\n        case \"pause\":\n          return {\n            ...state,\n            fetchStatus: \"paused\"\n          };\n        case \"continue\":\n          return {\n            ...state,\n            fetchStatus: \"fetching\"\n          };\n        case \"fetch\":\n          return {\n            ...state,\n            ...fetchState(state.data, this.options),\n            fetchMeta: action.meta ?? null\n          };\n        case \"success\":\n          return {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: \"success\",\n            ...!action.manual && {\n              fetchStatus: \"idle\",\n              fetchFailureCount: 0,\n              fetchFailureReason: null\n            }\n          };\n        case \"error\":\n          const error = action.error;\n          if ((0,_retryer_js__WEBPACK_IMPORTED_MODULE_2__.isCancelledError)(error) && error.revert && this.#revertState) {\n            return { ...this.#revertState, fetchStatus: \"idle\" };\n          }\n          return {\n            ...state,\n            error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: \"idle\",\n            status: \"error\"\n          };\n        case \"invalidate\":\n          return {\n            ...state,\n            isInvalidated: true\n          };\n        case \"setState\":\n          return {\n            ...state,\n            ...action.state\n          };\n      }\n    };\n    this.state = reducer(this.state);\n    _notifyManager_js__WEBPACK_IMPORTED_MODULE_3__.notifyManager.batch(() => {\n      this.observers.forEach((observer) => {\n        observer.onQueryUpdate();\n      });\n      this.#cache.notify({ query: this, type: \"updated\", action });\n    });\n  }\n};\nfunction fetchState(data, options) {\n  return {\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchStatus: (0,_retryer_js__WEBPACK_IMPORTED_MODULE_2__.canFetch)(options.networkMode) ? \"fetching\" : \"paused\",\n    ...data === void 0 && {\n      error: null,\n      status: \"pending\"\n    }\n  };\n}\nfunction getDefaultState(options) {\n  const data = typeof options.initialData === \"function\" ? options.initialData() : options.initialData;\n  const hasData = data !== void 0;\n  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === \"function\" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? \"success\" : \"pending\",\n    fetchStatus: \"idle\"\n  };\n}\n\n//# sourceMappingURL=query.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbW9kZXJuL3F1ZXJ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBT29CO0FBQytCO0FBQ3NCO0FBQzlCO0FBQzNDLDBCQUEwQixvREFBUztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0RBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMENBQTBDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDJDQUFJLFFBQVEsMkNBQUk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseURBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSx5REFBYztBQUNwRjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsOENBQThDO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsY0FBYztBQUNqRCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnREFBZ0Q7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHNCQUFzQix3REFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlEQUFpRDtBQUN4RTtBQUNBO0FBQ0EsWUFBWSw2REFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsV0FBVyw2REFBZ0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBEQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLElBQXFDO0FBQ25EO0FBQ0EsdUpBQXVKLGVBQWU7QUFDdEs7QUFDQTtBQUNBLCtCQUErQixnQkFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHlCQUF5QixxQ0FBcUM7QUFDOUQsT0FBTztBQUNQO0FBQ0EseUJBQXlCLGVBQWU7QUFDeEMsT0FBTztBQUNQO0FBQ0EseUJBQXlCLGtCQUFrQjtBQUMzQyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkRBQWdCO0FBQzlCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDREQUFhO0FBQ2pCO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsMkJBQTJCLHNDQUFzQztBQUNqRSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFEQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL21vZGVybi9xdWVyeS5qcz80YzA1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9xdWVyeS50c1xuaW1wb3J0IHtcbiAgZW5zdXJlUXVlcnlGbixcbiAgbm9vcCxcbiAgcmVwbGFjZURhdGEsXG4gIHJlc29sdmVFbmFibGVkLFxuICB0aW1lVW50aWxTdGFsZVxufSBmcm9tIFwiLi91dGlscy5qc1wiO1xuaW1wb3J0IHsgbm90aWZ5TWFuYWdlciB9IGZyb20gXCIuL25vdGlmeU1hbmFnZXIuanNcIjtcbmltcG9ydCB7IGNhbkZldGNoLCBjcmVhdGVSZXRyeWVyLCBpc0NhbmNlbGxlZEVycm9yIH0gZnJvbSBcIi4vcmV0cnllci5qc1wiO1xuaW1wb3J0IHsgUmVtb3ZhYmxlIH0gZnJvbSBcIi4vcmVtb3ZhYmxlLmpzXCI7XG52YXIgUXVlcnkgPSBjbGFzcyBleHRlbmRzIFJlbW92YWJsZSB7XG4gICNpbml0aWFsU3RhdGU7XG4gICNyZXZlcnRTdGF0ZTtcbiAgI2NhY2hlO1xuICAjcmV0cnllcjtcbiAgI2RlZmF1bHRPcHRpb25zO1xuICAjYWJvcnRTaWduYWxDb25zdW1lZDtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLiNhYm9ydFNpZ25hbENvbnN1bWVkID0gZmFsc2U7XG4gICAgdGhpcy4jZGVmYXVsdE9wdGlvbnMgPSBjb25maWcuZGVmYXVsdE9wdGlvbnM7XG4gICAgdGhpcy5zZXRPcHRpb25zKGNvbmZpZy5vcHRpb25zKTtcbiAgICB0aGlzLm9ic2VydmVycyA9IFtdO1xuICAgIHRoaXMuI2NhY2hlID0gY29uZmlnLmNhY2hlO1xuICAgIHRoaXMucXVlcnlLZXkgPSBjb25maWcucXVlcnlLZXk7XG4gICAgdGhpcy5xdWVyeUhhc2ggPSBjb25maWcucXVlcnlIYXNoO1xuICAgIHRoaXMuI2luaXRpYWxTdGF0ZSA9IGdldERlZmF1bHRTdGF0ZSh0aGlzLm9wdGlvbnMpO1xuICAgIHRoaXMuc3RhdGUgPSBjb25maWcuc3RhdGUgPz8gdGhpcy4jaW5pdGlhbFN0YXRlO1xuICAgIHRoaXMuc2NoZWR1bGVHYygpO1xuICB9XG4gIGdldCBtZXRhKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMubWV0YTtcbiAgfVxuICBnZXQgcHJvbWlzZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jcmV0cnllcj8ucHJvbWlzZTtcbiAgfVxuICBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSB7IC4uLnRoaXMuI2RlZmF1bHRPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgdGhpcy51cGRhdGVHY1RpbWUodGhpcy5vcHRpb25zLmdjVGltZSk7XG4gIH1cbiAgb3B0aW9uYWxSZW1vdmUoKSB7XG4gICAgaWYgKCF0aGlzLm9ic2VydmVycy5sZW5ndGggJiYgdGhpcy5zdGF0ZS5mZXRjaFN0YXR1cyA9PT0gXCJpZGxlXCIpIHtcbiAgICAgIHRoaXMuI2NhY2hlLnJlbW92ZSh0aGlzKTtcbiAgICB9XG4gIH1cbiAgc2V0RGF0YShuZXdEYXRhLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZGF0YSA9IHJlcGxhY2VEYXRhKHRoaXMuc3RhdGUuZGF0YSwgbmV3RGF0YSwgdGhpcy5vcHRpb25zKTtcbiAgICB0aGlzLiNkaXNwYXRjaCh7XG4gICAgICBkYXRhLFxuICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICBkYXRhVXBkYXRlZEF0OiBvcHRpb25zPy51cGRhdGVkQXQsXG4gICAgICBtYW51YWw6IG9wdGlvbnM/Lm1hbnVhbFxuICAgIH0pO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIHNldFN0YXRlKHN0YXRlLCBzZXRTdGF0ZU9wdGlvbnMpIHtcbiAgICB0aGlzLiNkaXNwYXRjaCh7IHR5cGU6IFwic2V0U3RhdGVcIiwgc3RhdGUsIHNldFN0YXRlT3B0aW9ucyB9KTtcbiAgfVxuICBjYW5jZWwob3B0aW9ucykge1xuICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLiNyZXRyeWVyPy5wcm9taXNlO1xuICAgIHRoaXMuI3JldHJ5ZXI/LmNhbmNlbChvcHRpb25zKTtcbiAgICByZXR1cm4gcHJvbWlzZSA/IHByb21pc2UudGhlbihub29wKS5jYXRjaChub29wKSA6IFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuY2FuY2VsKHsgc2lsZW50OiB0cnVlIH0pO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIHRoaXMuc2V0U3RhdGUodGhpcy4jaW5pdGlhbFN0YXRlKTtcbiAgfVxuICBpc0FjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5vYnNlcnZlcnMuc29tZShcbiAgICAgIChvYnNlcnZlcikgPT4gcmVzb2x2ZUVuYWJsZWQob2JzZXJ2ZXIub3B0aW9ucy5lbmFibGVkLCB0aGlzKSAhPT0gZmFsc2VcbiAgICApO1xuICB9XG4gIGlzRGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0T2JzZXJ2ZXJzQ291bnQoKSA+IDAgJiYgIXRoaXMuaXNBY3RpdmUoKTtcbiAgfVxuICBpc1N0YWxlKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLmlzSW52YWxpZGF0ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5nZXRPYnNlcnZlcnNDb3VudCgpID4gMCkge1xuICAgICAgcmV0dXJuIHRoaXMub2JzZXJ2ZXJzLnNvbWUoXG4gICAgICAgIChvYnNlcnZlcikgPT4gb2JzZXJ2ZXIuZ2V0Q3VycmVudFJlc3VsdCgpLmlzU3RhbGVcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnN0YXRlLmRhdGEgPT09IHZvaWQgMDtcbiAgfVxuICBpc1N0YWxlQnlUaW1lKHN0YWxlVGltZSA9IDApIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5pc0ludmFsaWRhdGVkIHx8IHRoaXMuc3RhdGUuZGF0YSA9PT0gdm9pZCAwIHx8ICF0aW1lVW50aWxTdGFsZSh0aGlzLnN0YXRlLmRhdGFVcGRhdGVkQXQsIHN0YWxlVGltZSk7XG4gIH1cbiAgb25Gb2N1cygpIHtcbiAgICBjb25zdCBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXJzLmZpbmQoKHgpID0+IHguc2hvdWxkRmV0Y2hPbldpbmRvd0ZvY3VzKCkpO1xuICAgIG9ic2VydmVyPy5yZWZldGNoKHsgY2FuY2VsUmVmZXRjaDogZmFsc2UgfSk7XG4gICAgdGhpcy4jcmV0cnllcj8uY29udGludWUoKTtcbiAgfVxuICBvbk9ubGluZSgpIHtcbiAgICBjb25zdCBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXJzLmZpbmQoKHgpID0+IHguc2hvdWxkRmV0Y2hPblJlY29ubmVjdCgpKTtcbiAgICBvYnNlcnZlcj8ucmVmZXRjaCh7IGNhbmNlbFJlZmV0Y2g6IGZhbHNlIH0pO1xuICAgIHRoaXMuI3JldHJ5ZXI/LmNvbnRpbnVlKCk7XG4gIH1cbiAgYWRkT2JzZXJ2ZXIob2JzZXJ2ZXIpIHtcbiAgICBpZiAoIXRoaXMub2JzZXJ2ZXJzLmluY2x1ZGVzKG9ic2VydmVyKSkge1xuICAgICAgdGhpcy5vYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XG4gICAgICB0aGlzLmNsZWFyR2NUaW1lb3V0KCk7XG4gICAgICB0aGlzLiNjYWNoZS5ub3RpZnkoeyB0eXBlOiBcIm9ic2VydmVyQWRkZWRcIiwgcXVlcnk6IHRoaXMsIG9ic2VydmVyIH0pO1xuICAgIH1cbiAgfVxuICByZW1vdmVPYnNlcnZlcihvYnNlcnZlcikge1xuICAgIGlmICh0aGlzLm9ic2VydmVycy5pbmNsdWRlcyhvYnNlcnZlcikpIHtcbiAgICAgIHRoaXMub2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnMuZmlsdGVyKCh4KSA9PiB4ICE9PSBvYnNlcnZlcik7XG4gICAgICBpZiAoIXRoaXMub2JzZXJ2ZXJzLmxlbmd0aCkge1xuICAgICAgICBpZiAodGhpcy4jcmV0cnllcikge1xuICAgICAgICAgIGlmICh0aGlzLiNhYm9ydFNpZ25hbENvbnN1bWVkKSB7XG4gICAgICAgICAgICB0aGlzLiNyZXRyeWVyLmNhbmNlbCh7IHJldmVydDogdHJ1ZSB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jcmV0cnllci5jYW5jZWxSZXRyeSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjaGVkdWxlR2MoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI2NhY2hlLm5vdGlmeSh7IHR5cGU6IFwib2JzZXJ2ZXJSZW1vdmVkXCIsIHF1ZXJ5OiB0aGlzLCBvYnNlcnZlciB9KTtcbiAgICB9XG4gIH1cbiAgZ2V0T2JzZXJ2ZXJzQ291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aDtcbiAgfVxuICBpbnZhbGlkYXRlKCkge1xuICAgIGlmICghdGhpcy5zdGF0ZS5pc0ludmFsaWRhdGVkKSB7XG4gICAgICB0aGlzLiNkaXNwYXRjaCh7IHR5cGU6IFwiaW52YWxpZGF0ZVwiIH0pO1xuICAgIH1cbiAgfVxuICBmZXRjaChvcHRpb25zLCBmZXRjaE9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5mZXRjaFN0YXR1cyAhPT0gXCJpZGxlXCIpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLmRhdGEgIT09IHZvaWQgMCAmJiBmZXRjaE9wdGlvbnM/LmNhbmNlbFJlZmV0Y2gpIHtcbiAgICAgICAgdGhpcy5jYW5jZWwoeyBzaWxlbnQ6IHRydWUgfSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuI3JldHJ5ZXIpIHtcbiAgICAgICAgdGhpcy4jcmV0cnllci5jb250aW51ZVJldHJ5KCk7XG4gICAgICAgIHJldHVybiB0aGlzLiNyZXRyeWVyLnByb21pc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfVxuICAgIGlmICghdGhpcy5vcHRpb25zLnF1ZXJ5Rm4pIHtcbiAgICAgIGNvbnN0IG9ic2VydmVyID0gdGhpcy5vYnNlcnZlcnMuZmluZCgoeCkgPT4geC5vcHRpb25zLnF1ZXJ5Rm4pO1xuICAgICAgaWYgKG9ic2VydmVyKSB7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9ucyhvYnNlcnZlci5vcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMub3B0aW9ucy5xdWVyeUtleSkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBgQXMgb2YgdjQsIHF1ZXJ5S2V5IG5lZWRzIHRvIGJlIGFuIEFycmF5LiBJZiB5b3UgYXJlIHVzaW5nIGEgc3RyaW5nIGxpa2UgJ3JlcG9EYXRhJywgcGxlYXNlIGNoYW5nZSBpdCB0byBhbiBBcnJheSwgZS5nLiBbJ3JlcG9EYXRhJ11gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBhZGRTaWduYWxQcm9wZXJ0eSA9IChvYmplY3QpID0+IHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIFwic2lnbmFsXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy4jYWJvcnRTaWduYWxDb25zdW1lZCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIGFib3J0Q29udHJvbGxlci5zaWduYWw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgZmV0Y2hGbiA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHF1ZXJ5Rm4gPSBlbnN1cmVRdWVyeUZuKHRoaXMub3B0aW9ucywgZmV0Y2hPcHRpb25zKTtcbiAgICAgIGNvbnN0IHF1ZXJ5Rm5Db250ZXh0ID0ge1xuICAgICAgICBxdWVyeUtleTogdGhpcy5xdWVyeUtleSxcbiAgICAgICAgbWV0YTogdGhpcy5tZXRhXG4gICAgICB9O1xuICAgICAgYWRkU2lnbmFsUHJvcGVydHkocXVlcnlGbkNvbnRleHQpO1xuICAgICAgdGhpcy4jYWJvcnRTaWduYWxDb25zdW1lZCA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZXJzaXN0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5wZXJzaXN0ZXIoXG4gICAgICAgICAgcXVlcnlGbixcbiAgICAgICAgICBxdWVyeUZuQ29udGV4dCxcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcXVlcnlGbihxdWVyeUZuQ29udGV4dCk7XG4gICAgfTtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgZmV0Y2hPcHRpb25zLFxuICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxuICAgICAgcXVlcnlLZXk6IHRoaXMucXVlcnlLZXksXG4gICAgICBzdGF0ZTogdGhpcy5zdGF0ZSxcbiAgICAgIGZldGNoRm5cbiAgICB9O1xuICAgIGFkZFNpZ25hbFByb3BlcnR5KGNvbnRleHQpO1xuICAgIHRoaXMub3B0aW9ucy5iZWhhdmlvcj8ub25GZXRjaChcbiAgICAgIGNvbnRleHQsXG4gICAgICB0aGlzXG4gICAgKTtcbiAgICB0aGlzLiNyZXZlcnRTdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHRoaXMuc3RhdGUuZmV0Y2hTdGF0dXMgPT09IFwiaWRsZVwiIHx8IHRoaXMuc3RhdGUuZmV0Y2hNZXRhICE9PSBjb250ZXh0LmZldGNoT3B0aW9ucz8ubWV0YSkge1xuICAgICAgdGhpcy4jZGlzcGF0Y2goeyB0eXBlOiBcImZldGNoXCIsIG1ldGE6IGNvbnRleHQuZmV0Y2hPcHRpb25zPy5tZXRhIH0pO1xuICAgIH1cbiAgICBjb25zdCBvbkVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICBpZiAoIShpc0NhbmNlbGxlZEVycm9yKGVycm9yKSAmJiBlcnJvci5zaWxlbnQpKSB7XG4gICAgICAgIHRoaXMuI2Rpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgZXJyb3JcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzQ2FuY2VsbGVkRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHRoaXMuI2NhY2hlLmNvbmZpZy5vbkVycm9yPy4oXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgICB0aGlzLiNjYWNoZS5jb25maWcub25TZXR0bGVkPy4oXG4gICAgICAgICAgdGhpcy5zdGF0ZS5kYXRhLFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5pc0ZldGNoaW5nT3B0aW1pc3RpYykge1xuICAgICAgICB0aGlzLnNjaGVkdWxlR2MoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaXNGZXRjaGluZ09wdGltaXN0aWMgPSBmYWxzZTtcbiAgICB9O1xuICAgIHRoaXMuI3JldHJ5ZXIgPSBjcmVhdGVSZXRyeWVyKHtcbiAgICAgIGluaXRpYWxQcm9taXNlOiBmZXRjaE9wdGlvbnM/LmluaXRpYWxQcm9taXNlLFxuICAgICAgZm46IGNvbnRleHQuZmV0Y2hGbixcbiAgICAgIGFib3J0OiBhYm9ydENvbnRyb2xsZXIuYWJvcnQuYmluZChhYm9ydENvbnRyb2xsZXIpLFxuICAgICAgb25TdWNjZXNzOiAoZGF0YSkgPT4ge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgYFF1ZXJ5IGRhdGEgY2Fubm90IGJlIHVuZGVmaW5lZC4gUGxlYXNlIG1ha2Ugc3VyZSB0byByZXR1cm4gYSB2YWx1ZSBvdGhlciB0aGFuIHVuZGVmaW5lZCBmcm9tIHlvdXIgcXVlcnkgZnVuY3Rpb24uIEFmZmVjdGVkIHF1ZXJ5IGtleTogJHt0aGlzLnF1ZXJ5SGFzaH1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvbkVycm9yKG5ldyBFcnJvcihgJHt0aGlzLnF1ZXJ5SGFzaH0gZGF0YSBpcyB1bmRlZmluZWRgKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5zZXREYXRhKGRhdGEpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNjYWNoZS5jb25maWcub25TdWNjZXNzPy4oZGF0YSwgdGhpcyk7XG4gICAgICAgIHRoaXMuI2NhY2hlLmNvbmZpZy5vblNldHRsZWQ/LihcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIHRoaXMuc3RhdGUuZXJyb3IsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgICBpZiAoIXRoaXMuaXNGZXRjaGluZ09wdGltaXN0aWMpIHtcbiAgICAgICAgICB0aGlzLnNjaGVkdWxlR2MoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzRmV0Y2hpbmdPcHRpbWlzdGljID0gZmFsc2U7XG4gICAgICB9LFxuICAgICAgb25FcnJvcixcbiAgICAgIG9uRmFpbDogKGZhaWx1cmVDb3VudCwgZXJyb3IpID0+IHtcbiAgICAgICAgdGhpcy4jZGlzcGF0Y2goeyB0eXBlOiBcImZhaWxlZFwiLCBmYWlsdXJlQ291bnQsIGVycm9yIH0pO1xuICAgICAgfSxcbiAgICAgIG9uUGF1c2U6ICgpID0+IHtcbiAgICAgICAgdGhpcy4jZGlzcGF0Y2goeyB0eXBlOiBcInBhdXNlXCIgfSk7XG4gICAgICB9LFxuICAgICAgb25Db250aW51ZTogKCkgPT4ge1xuICAgICAgICB0aGlzLiNkaXNwYXRjaCh7IHR5cGU6IFwiY29udGludWVcIiB9KTtcbiAgICAgIH0sXG4gICAgICByZXRyeTogY29udGV4dC5vcHRpb25zLnJldHJ5LFxuICAgICAgcmV0cnlEZWxheTogY29udGV4dC5vcHRpb25zLnJldHJ5RGVsYXksXG4gICAgICBuZXR3b3JrTW9kZTogY29udGV4dC5vcHRpb25zLm5ldHdvcmtNb2RlLFxuICAgICAgY2FuUnVuOiAoKSA9PiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuI3JldHJ5ZXIuc3RhcnQoKTtcbiAgfVxuICAjZGlzcGF0Y2goYWN0aW9uKSB7XG4gICAgY29uc3QgcmVkdWNlciA9IChzdGF0ZSkgPT4ge1xuICAgICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlIFwiZmFpbGVkXCI6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgZmV0Y2hGYWlsdXJlQ291bnQ6IGFjdGlvbi5mYWlsdXJlQ291bnQsXG4gICAgICAgICAgICBmZXRjaEZhaWx1cmVSZWFzb246IGFjdGlvbi5lcnJvclxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJwYXVzZVwiOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgIGZldGNoU3RhdHVzOiBcInBhdXNlZFwiXG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcImNvbnRpbnVlXCI6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgZmV0Y2hTdGF0dXM6IFwiZmV0Y2hpbmdcIlxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJmZXRjaFwiOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgIC4uLmZldGNoU3RhdGUoc3RhdGUuZGF0YSwgdGhpcy5vcHRpb25zKSxcbiAgICAgICAgICAgIGZldGNoTWV0YTogYWN0aW9uLm1ldGEgPz8gbnVsbFxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJzdWNjZXNzXCI6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgZGF0YTogYWN0aW9uLmRhdGEsXG4gICAgICAgICAgICBkYXRhVXBkYXRlQ291bnQ6IHN0YXRlLmRhdGFVcGRhdGVDb3VudCArIDEsXG4gICAgICAgICAgICBkYXRhVXBkYXRlZEF0OiBhY3Rpb24uZGF0YVVwZGF0ZWRBdCA/PyBEYXRlLm5vdygpLFxuICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICBpc0ludmFsaWRhdGVkOiBmYWxzZSxcbiAgICAgICAgICAgIHN0YXR1czogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgICAuLi4hYWN0aW9uLm1hbnVhbCAmJiB7XG4gICAgICAgICAgICAgIGZldGNoU3RhdHVzOiBcImlkbGVcIixcbiAgICAgICAgICAgICAgZmV0Y2hGYWlsdXJlQ291bnQ6IDAsXG4gICAgICAgICAgICAgIGZldGNoRmFpbHVyZVJlYXNvbjogbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgIGNvbnN0IGVycm9yID0gYWN0aW9uLmVycm9yO1xuICAgICAgICAgIGlmIChpc0NhbmNlbGxlZEVycm9yKGVycm9yKSAmJiBlcnJvci5yZXZlcnQgJiYgdGhpcy4jcmV2ZXJ0U3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IC4uLnRoaXMuI3JldmVydFN0YXRlLCBmZXRjaFN0YXR1czogXCJpZGxlXCIgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICBlcnJvclVwZGF0ZUNvdW50OiBzdGF0ZS5lcnJvclVwZGF0ZUNvdW50ICsgMSxcbiAgICAgICAgICAgIGVycm9yVXBkYXRlZEF0OiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgZmV0Y2hGYWlsdXJlQ291bnQ6IHN0YXRlLmZldGNoRmFpbHVyZUNvdW50ICsgMSxcbiAgICAgICAgICAgIGZldGNoRmFpbHVyZVJlYXNvbjogZXJyb3IsXG4gICAgICAgICAgICBmZXRjaFN0YXR1czogXCJpZGxlXCIsXG4gICAgICAgICAgICBzdGF0dXM6IFwiZXJyb3JcIlxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJpbnZhbGlkYXRlXCI6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgaXNJbnZhbGlkYXRlZDogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJzZXRTdGF0ZVwiOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgIC4uLmFjdGlvbi5zdGF0ZVxuICAgICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnN0YXRlID0gcmVkdWNlcih0aGlzLnN0YXRlKTtcbiAgICBub3RpZnlNYW5hZ2VyLmJhdGNoKCgpID0+IHtcbiAgICAgIHRoaXMub2JzZXJ2ZXJzLmZvckVhY2goKG9ic2VydmVyKSA9PiB7XG4gICAgICAgIG9ic2VydmVyLm9uUXVlcnlVcGRhdGUoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy4jY2FjaGUubm90aWZ5KHsgcXVlcnk6IHRoaXMsIHR5cGU6IFwidXBkYXRlZFwiLCBhY3Rpb24gfSk7XG4gICAgfSk7XG4gIH1cbn07XG5mdW5jdGlvbiBmZXRjaFN0YXRlKGRhdGEsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBmZXRjaEZhaWx1cmVDb3VudDogMCxcbiAgICBmZXRjaEZhaWx1cmVSZWFzb246IG51bGwsXG4gICAgZmV0Y2hTdGF0dXM6IGNhbkZldGNoKG9wdGlvbnMubmV0d29ya01vZGUpID8gXCJmZXRjaGluZ1wiIDogXCJwYXVzZWRcIixcbiAgICAuLi5kYXRhID09PSB2b2lkIDAgJiYge1xuICAgICAgZXJyb3I6IG51bGwsXG4gICAgICBzdGF0dXM6IFwicGVuZGluZ1wiXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdFN0YXRlKG9wdGlvbnMpIHtcbiAgY29uc3QgZGF0YSA9IHR5cGVvZiBvcHRpb25zLmluaXRpYWxEYXRhID09PSBcImZ1bmN0aW9uXCIgPyBvcHRpb25zLmluaXRpYWxEYXRhKCkgOiBvcHRpb25zLmluaXRpYWxEYXRhO1xuICBjb25zdCBoYXNEYXRhID0gZGF0YSAhPT0gdm9pZCAwO1xuICBjb25zdCBpbml0aWFsRGF0YVVwZGF0ZWRBdCA9IGhhc0RhdGEgPyB0eXBlb2Ygb3B0aW9ucy5pbml0aWFsRGF0YVVwZGF0ZWRBdCA9PT0gXCJmdW5jdGlvblwiID8gb3B0aW9ucy5pbml0aWFsRGF0YVVwZGF0ZWRBdCgpIDogb3B0aW9ucy5pbml0aWFsRGF0YVVwZGF0ZWRBdCA6IDA7XG4gIHJldHVybiB7XG4gICAgZGF0YSxcbiAgICBkYXRhVXBkYXRlQ291bnQ6IDAsXG4gICAgZGF0YVVwZGF0ZWRBdDogaGFzRGF0YSA/IGluaXRpYWxEYXRhVXBkYXRlZEF0ID8/IERhdGUubm93KCkgOiAwLFxuICAgIGVycm9yOiBudWxsLFxuICAgIGVycm9yVXBkYXRlQ291bnQ6IDAsXG4gICAgZXJyb3JVcGRhdGVkQXQ6IDAsXG4gICAgZmV0Y2hGYWlsdXJlQ291bnQ6IDAsXG4gICAgZmV0Y2hGYWlsdXJlUmVhc29uOiBudWxsLFxuICAgIGZldGNoTWV0YTogbnVsbCxcbiAgICBpc0ludmFsaWRhdGVkOiBmYWxzZSxcbiAgICBzdGF0dXM6IGhhc0RhdGEgPyBcInN1Y2Nlc3NcIiA6IFwicGVuZGluZ1wiLFxuICAgIGZldGNoU3RhdHVzOiBcImlkbGVcIlxuICB9O1xufVxuZXhwb3J0IHtcbiAgUXVlcnksXG4gIGZldGNoU3RhdGVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/@tanstack/query-core/build/modern/query.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@tanstack/query-core/build/modern/queryObserver.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/@tanstack/query-core/build/modern/queryObserver.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueryObserver: function() { return /* binding */ QueryObserver; }\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../../node_modules/@tanstack/query-core/build/modern/utils.js\");\n/* harmony import */ var _notifyManager_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./notifyManager.js */ \"(app-pages-browser)/../../node_modules/@tanstack/query-core/build/modern/notifyManager.js\");\n/* harmony import */ var _focusManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./focusManager.js */ \"(app-pages-browser)/../../node_modules/@tanstack/query-core/build/modern/focusManager.js\");\n/* harmony import */ var _subscribable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./subscribable.js */ \"(app-pages-browser)/../../node_modules/@tanstack/query-core/build/modern/subscribable.js\");\n/* harmony import */ var _query_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./query.js */ \"(app-pages-browser)/../../node_modules/@tanstack/query-core/build/modern/query.js\");\n// src/queryObserver.ts\n\n\n\n\n\nvar QueryObserver = class extends _subscribable_js__WEBPACK_IMPORTED_MODULE_0__.Subscribable {\n  constructor(client, options) {\n    super();\n    this.options = options;\n    this.#client = client;\n    this.#selectError = null;\n    this.bindMethods();\n    this.setOptions(options);\n  }\n  #client;\n  #currentQuery = void 0;\n  #currentQueryInitialState = void 0;\n  #currentResult = void 0;\n  #currentResultState;\n  #currentResultOptions;\n  #selectError;\n  #selectFn;\n  #selectResult;\n  // This property keeps track of the last query with defined data.\n  // It will be used to pass the previous data and query to the placeholder function between renders.\n  #lastQueryWithDefinedData;\n  #staleTimeoutId;\n  #refetchIntervalId;\n  #currentRefetchInterval;\n  #trackedProps = /* @__PURE__ */ new Set();\n  bindMethods() {\n    this.refetch = this.refetch.bind(this);\n  }\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      this.#currentQuery.addObserver(this);\n      if (shouldFetchOnMount(this.#currentQuery, this.options)) {\n        this.#executeFetch();\n      } else {\n        this.updateResult();\n      }\n      this.#updateTimers();\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.destroy();\n    }\n  }\n  shouldFetchOnReconnect() {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnReconnect\n    );\n  }\n  shouldFetchOnWindowFocus() {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnWindowFocus\n    );\n  }\n  destroy() {\n    this.listeners = /* @__PURE__ */ new Set();\n    this.#clearStaleTimeout();\n    this.#clearRefetchInterval();\n    this.#currentQuery.removeObserver(this);\n  }\n  setOptions(options, notifyOptions) {\n    const prevOptions = this.options;\n    const prevQuery = this.#currentQuery;\n    this.options = this.#client.defaultQueryOptions(options);\n    if (this.options.enabled !== void 0 && typeof this.options.enabled !== \"boolean\" && typeof this.options.enabled !== \"function\" && typeof (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.resolveEnabled)(this.options.enabled, this.#currentQuery) !== \"boolean\") {\n      throw new Error(\n        \"Expected enabled to be a boolean or a callback that returns a boolean\"\n      );\n    }\n    this.#updateQuery();\n    this.#currentQuery.setOptions(this.options);\n    if (prevOptions._defaulted && !(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.shallowEqualObjects)(this.options, prevOptions)) {\n      this.#client.getQueryCache().notify({\n        type: \"observerOptionsUpdated\",\n        query: this.#currentQuery,\n        observer: this\n      });\n    }\n    const mounted = this.hasListeners();\n    if (mounted && shouldFetchOptionally(\n      this.#currentQuery,\n      prevQuery,\n      this.options,\n      prevOptions\n    )) {\n      this.#executeFetch();\n    }\n    this.updateResult(notifyOptions);\n    if (mounted && (this.#currentQuery !== prevQuery || (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.resolveEnabled)(this.options.enabled, this.#currentQuery) !== (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.resolveEnabled)(prevOptions.enabled, this.#currentQuery) || (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.resolveStaleTime)(this.options.staleTime, this.#currentQuery) !== (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.resolveStaleTime)(prevOptions.staleTime, this.#currentQuery))) {\n      this.#updateStaleTimeout();\n    }\n    const nextRefetchInterval = this.#computeRefetchInterval();\n    if (mounted && (this.#currentQuery !== prevQuery || (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.resolveEnabled)(this.options.enabled, this.#currentQuery) !== (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.resolveEnabled)(prevOptions.enabled, this.#currentQuery) || nextRefetchInterval !== this.#currentRefetchInterval)) {\n      this.#updateRefetchInterval(nextRefetchInterval);\n    }\n  }\n  getOptimisticResult(options) {\n    const query = this.#client.getQueryCache().build(this.#client, options);\n    const result = this.createResult(query, options);\n    if (shouldAssignObserverCurrentProperties(this, result)) {\n      this.#currentResult = result;\n      this.#currentResultOptions = this.options;\n      this.#currentResultState = this.#currentQuery.state;\n    }\n    return result;\n  }\n  getCurrentResult() {\n    return this.#currentResult;\n  }\n  trackResult(result, onPropTracked) {\n    const trackedResult = {};\n    Object.keys(result).forEach((key) => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.trackProp(key);\n          onPropTracked?.(key);\n          return result[key];\n        }\n      });\n    });\n    return trackedResult;\n  }\n  trackProp(key) {\n    this.#trackedProps.add(key);\n  }\n  getCurrentQuery() {\n    return this.#currentQuery;\n  }\n  refetch({ ...options } = {}) {\n    return this.fetch({\n      ...options\n    });\n  }\n  fetchOptimistic(options) {\n    const defaultedOptions = this.#client.defaultQueryOptions(options);\n    const query = this.#client.getQueryCache().build(this.#client, defaultedOptions);\n    query.isFetchingOptimistic = true;\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\n  }\n  fetch(fetchOptions) {\n    return this.#executeFetch({\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true\n    }).then(() => {\n      this.updateResult();\n      return this.#currentResult;\n    });\n  }\n  #executeFetch(fetchOptions) {\n    this.#updateQuery();\n    let promise = this.#currentQuery.fetch(\n      this.options,\n      fetchOptions\n    );\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(_utils_js__WEBPACK_IMPORTED_MODULE_1__.noop);\n    }\n    return promise;\n  }\n  #updateStaleTimeout() {\n    this.#clearStaleTimeout();\n    const staleTime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.resolveStaleTime)(\n      this.options.staleTime,\n      this.#currentQuery\n    );\n    if (_utils_js__WEBPACK_IMPORTED_MODULE_1__.isServer || this.#currentResult.isStale || !(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isValidTimeout)(staleTime)) {\n      return;\n    }\n    const time = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.timeUntilStale)(this.#currentResult.dataUpdatedAt, staleTime);\n    const timeout = time + 1;\n    this.#staleTimeoutId = setTimeout(() => {\n      if (!this.#currentResult.isStale) {\n        this.updateResult();\n      }\n    }, timeout);\n  }\n  #computeRefetchInterval() {\n    return (typeof this.options.refetchInterval === \"function\" ? this.options.refetchInterval(this.#currentQuery) : this.options.refetchInterval) ?? false;\n  }\n  #updateRefetchInterval(nextInterval) {\n    this.#clearRefetchInterval();\n    this.#currentRefetchInterval = nextInterval;\n    if (_utils_js__WEBPACK_IMPORTED_MODULE_1__.isServer || (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.resolveEnabled)(this.options.enabled, this.#currentQuery) === false || !(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isValidTimeout)(this.#currentRefetchInterval) || this.#currentRefetchInterval === 0) {\n      return;\n    }\n    this.#refetchIntervalId = setInterval(() => {\n      if (this.options.refetchIntervalInBackground || _focusManager_js__WEBPACK_IMPORTED_MODULE_2__.focusManager.isFocused()) {\n        this.#executeFetch();\n      }\n    }, this.#currentRefetchInterval);\n  }\n  #updateTimers() {\n    this.#updateStaleTimeout();\n    this.#updateRefetchInterval(this.#computeRefetchInterval());\n  }\n  #clearStaleTimeout() {\n    if (this.#staleTimeoutId) {\n      clearTimeout(this.#staleTimeoutId);\n      this.#staleTimeoutId = void 0;\n    }\n  }\n  #clearRefetchInterval() {\n    if (this.#refetchIntervalId) {\n      clearInterval(this.#refetchIntervalId);\n      this.#refetchIntervalId = void 0;\n    }\n  }\n  createResult(query, options) {\n    const prevQuery = this.#currentQuery;\n    const prevOptions = this.options;\n    const prevResult = this.#currentResult;\n    const prevResultState = this.#currentResultState;\n    const prevResultOptions = this.#currentResultOptions;\n    const queryChange = query !== prevQuery;\n    const queryInitialState = queryChange ? query.state : this.#currentQueryInitialState;\n    const { state } = query;\n    let newState = { ...state };\n    let isPlaceholderData = false;\n    let data;\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners();\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n      if (fetchOnMount || fetchOptionally) {\n        newState = {\n          ...newState,\n          ...(0,_query_js__WEBPACK_IMPORTED_MODULE_3__.fetchState)(state.data, query.options)\n        };\n      }\n      if (options._optimisticResults === \"isRestoring\") {\n        newState.fetchStatus = \"idle\";\n      }\n    }\n    let { error, errorUpdatedAt, status } = newState;\n    if (options.select && newState.data !== void 0) {\n      if (prevResult && newState.data === prevResultState?.data && options.select === this.#selectFn) {\n        data = this.#selectResult;\n      } else {\n        try {\n          this.#selectFn = options.select;\n          data = options.select(newState.data);\n          data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.replaceData)(prevResult?.data, data, options);\n          this.#selectResult = data;\n          this.#selectError = null;\n        } catch (selectError) {\n          this.#selectError = selectError;\n        }\n      }\n    } else {\n      data = newState.data;\n    }\n    if (options.placeholderData !== void 0 && data === void 0 && status === \"pending\") {\n      let placeholderData;\n      if (prevResult?.isPlaceholderData && options.placeholderData === prevResultOptions?.placeholderData) {\n        placeholderData = prevResult.data;\n      } else {\n        placeholderData = typeof options.placeholderData === \"function\" ? options.placeholderData(\n          this.#lastQueryWithDefinedData?.state.data,\n          this.#lastQueryWithDefinedData\n        ) : options.placeholderData;\n        if (options.select && placeholderData !== void 0) {\n          try {\n            placeholderData = options.select(placeholderData);\n            this.#selectError = null;\n          } catch (selectError) {\n            this.#selectError = selectError;\n          }\n        }\n      }\n      if (placeholderData !== void 0) {\n        status = \"success\";\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.replaceData)(\n          prevResult?.data,\n          placeholderData,\n          options\n        );\n        isPlaceholderData = true;\n      }\n    }\n    if (this.#selectError) {\n      error = this.#selectError;\n      data = this.#selectResult;\n      errorUpdatedAt = Date.now();\n      status = \"error\";\n    }\n    const isFetching = newState.fetchStatus === \"fetching\";\n    const isPending = status === \"pending\";\n    const isError = status === \"error\";\n    const isLoading = isPending && isFetching;\n    const hasData = data !== void 0;\n    const result = {\n      status,\n      fetchStatus: newState.fetchStatus,\n      isPending,\n      isSuccess: status === \"success\",\n      isError,\n      isInitialLoading: isLoading,\n      isLoading,\n      data,\n      dataUpdatedAt: newState.dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: newState.fetchFailureCount,\n      failureReason: newState.fetchFailureReason,\n      errorUpdateCount: newState.errorUpdateCount,\n      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,\n      isFetchedAfterMount: newState.dataUpdateCount > queryInitialState.dataUpdateCount || newState.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isPending,\n      isLoadingError: isError && !hasData,\n      isPaused: newState.fetchStatus === \"paused\",\n      isPlaceholderData,\n      isRefetchError: isError && hasData,\n      isStale: isStale(query, options),\n      refetch: this.refetch\n    };\n    return result;\n  }\n  updateResult(notifyOptions) {\n    const prevResult = this.#currentResult;\n    const nextResult = this.createResult(this.#currentQuery, this.options);\n    this.#currentResultState = this.#currentQuery.state;\n    this.#currentResultOptions = this.options;\n    if (this.#currentResultState.data !== void 0) {\n      this.#lastQueryWithDefinedData = this.#currentQuery;\n    }\n    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.shallowEqualObjects)(nextResult, prevResult)) {\n      return;\n    }\n    this.#currentResult = nextResult;\n    const defaultNotifyOptions = {};\n    const shouldNotifyListeners = () => {\n      if (!prevResult) {\n        return true;\n      }\n      const { notifyOnChangeProps } = this.options;\n      const notifyOnChangePropsValue = typeof notifyOnChangeProps === \"function\" ? notifyOnChangeProps() : notifyOnChangeProps;\n      if (notifyOnChangePropsValue === \"all\" || !notifyOnChangePropsValue && !this.#trackedProps.size) {\n        return true;\n      }\n      const includedProps = new Set(\n        notifyOnChangePropsValue ?? this.#trackedProps\n      );\n      if (this.options.throwOnError) {\n        includedProps.add(\"error\");\n      }\n      return Object.keys(this.#currentResult).some((key) => {\n        const typedKey = key;\n        const changed = this.#currentResult[typedKey] !== prevResult[typedKey];\n        return changed && includedProps.has(typedKey);\n      });\n    };\n    if (notifyOptions?.listeners !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true;\n    }\n    this.#notify({ ...defaultNotifyOptions, ...notifyOptions });\n  }\n  #updateQuery() {\n    const query = this.#client.getQueryCache().build(this.#client, this.options);\n    if (query === this.#currentQuery) {\n      return;\n    }\n    const prevQuery = this.#currentQuery;\n    this.#currentQuery = query;\n    this.#currentQueryInitialState = query.state;\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this);\n      query.addObserver(this);\n    }\n  }\n  onQueryUpdate() {\n    this.updateResult();\n    if (this.hasListeners()) {\n      this.#updateTimers();\n    }\n  }\n  #notify(notifyOptions) {\n    _notifyManager_js__WEBPACK_IMPORTED_MODULE_4__.notifyManager.batch(() => {\n      if (notifyOptions.listeners) {\n        this.listeners.forEach((listener) => {\n          listener(this.#currentResult);\n        });\n      }\n      this.#client.getQueryCache().notify({\n        query: this.#currentQuery,\n        type: \"observerResultsUpdated\"\n      });\n    });\n  }\n};\nfunction shouldLoadOnMount(query, options) {\n  return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.resolveEnabled)(options.enabled, query) !== false && query.state.data === void 0 && !(query.state.status === \"error\" && options.retryOnMount === false);\n}\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.data !== void 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\nfunction shouldFetchOn(query, options, field) {\n  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.resolveEnabled)(options.enabled, query) !== false) {\n    const value = typeof field === \"function\" ? field(query) : field;\n    return value === \"always\" || value !== false && isStale(query, options);\n  }\n  return false;\n}\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return (query !== prevQuery || (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.resolveEnabled)(prevOptions.enabled, query) === false) && (!options.suspense || query.state.status !== \"error\") && isStale(query, options);\n}\nfunction isStale(query, options) {\n  return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.resolveEnabled)(options.enabled, query) !== false && query.isStaleByTime((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.resolveStaleTime)(options.staleTime, query));\n}\nfunction shouldAssignObserverCurrentProperties(observer, optimisticResult) {\n  if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.shallowEqualObjects)(observer.getCurrentResult(), optimisticResult)) {\n    return true;\n  }\n  return false;\n}\n\n//# sourceMappingURL=queryObserver.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbW9kZXJuL3F1ZXJ5T2JzZXJ2ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFVb0I7QUFDK0I7QUFDRjtBQUNBO0FBQ1Q7QUFDeEMsa0NBQWtDLDBEQUFZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2SUFBNkkseURBQWM7QUFDM0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDhEQUFtQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHlEQUFjLCtDQUErQyx5REFBYyw2Q0FBNkMsMkRBQWdCLGlEQUFpRCwyREFBZ0I7QUFDalE7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHlEQUFjLCtDQUErQyx5REFBYztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMseURBQWM7QUFDL0M7QUFDQTtBQUNBLFNBQVMseURBQWMsMERBQTBELDJEQUFnQjtBQUNqRztBQUNBO0FBQ0EsT0FBTyw4REFBbUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFHRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbW9kZXJuL3F1ZXJ5T2JzZXJ2ZXIuanM/MTQ5NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvcXVlcnlPYnNlcnZlci50c1xuaW1wb3J0IHtcbiAgaXNTZXJ2ZXIsXG4gIGlzVmFsaWRUaW1lb3V0LFxuICBub29wLFxuICByZXBsYWNlRGF0YSxcbiAgcmVzb2x2ZUVuYWJsZWQsXG4gIHJlc29sdmVTdGFsZVRpbWUsXG4gIHNoYWxsb3dFcXVhbE9iamVjdHMsXG4gIHRpbWVVbnRpbFN0YWxlXG59IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBub3RpZnlNYW5hZ2VyIH0gZnJvbSBcIi4vbm90aWZ5TWFuYWdlci5qc1wiO1xuaW1wb3J0IHsgZm9jdXNNYW5hZ2VyIH0gZnJvbSBcIi4vZm9jdXNNYW5hZ2VyLmpzXCI7XG5pbXBvcnQgeyBTdWJzY3JpYmFibGUgfSBmcm9tIFwiLi9zdWJzY3JpYmFibGUuanNcIjtcbmltcG9ydCB7IGZldGNoU3RhdGUgfSBmcm9tIFwiLi9xdWVyeS5qc1wiO1xudmFyIFF1ZXJ5T2JzZXJ2ZXIgPSBjbGFzcyBleHRlbmRzIFN1YnNjcmliYWJsZSB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgb3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLiNjbGllbnQgPSBjbGllbnQ7XG4gICAgdGhpcy4jc2VsZWN0RXJyb3IgPSBudWxsO1xuICAgIHRoaXMuYmluZE1ldGhvZHMoKTtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIH1cbiAgI2NsaWVudDtcbiAgI2N1cnJlbnRRdWVyeSA9IHZvaWQgMDtcbiAgI2N1cnJlbnRRdWVyeUluaXRpYWxTdGF0ZSA9IHZvaWQgMDtcbiAgI2N1cnJlbnRSZXN1bHQgPSB2b2lkIDA7XG4gICNjdXJyZW50UmVzdWx0U3RhdGU7XG4gICNjdXJyZW50UmVzdWx0T3B0aW9ucztcbiAgI3NlbGVjdEVycm9yO1xuICAjc2VsZWN0Rm47XG4gICNzZWxlY3RSZXN1bHQ7XG4gIC8vIFRoaXMgcHJvcGVydHkga2VlcHMgdHJhY2sgb2YgdGhlIGxhc3QgcXVlcnkgd2l0aCBkZWZpbmVkIGRhdGEuXG4gIC8vIEl0IHdpbGwgYmUgdXNlZCB0byBwYXNzIHRoZSBwcmV2aW91cyBkYXRhIGFuZCBxdWVyeSB0byB0aGUgcGxhY2Vob2xkZXIgZnVuY3Rpb24gYmV0d2VlbiByZW5kZXJzLlxuICAjbGFzdFF1ZXJ5V2l0aERlZmluZWREYXRhO1xuICAjc3RhbGVUaW1lb3V0SWQ7XG4gICNyZWZldGNoSW50ZXJ2YWxJZDtcbiAgI2N1cnJlbnRSZWZldGNoSW50ZXJ2YWw7XG4gICN0cmFja2VkUHJvcHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBiaW5kTWV0aG9kcygpIHtcbiAgICB0aGlzLnJlZmV0Y2ggPSB0aGlzLnJlZmV0Y2guYmluZCh0aGlzKTtcbiAgfVxuICBvblN1YnNjcmliZSgpIHtcbiAgICBpZiAodGhpcy5saXN0ZW5lcnMuc2l6ZSA9PT0gMSkge1xuICAgICAgdGhpcy4jY3VycmVudFF1ZXJ5LmFkZE9ic2VydmVyKHRoaXMpO1xuICAgICAgaWYgKHNob3VsZEZldGNoT25Nb3VudCh0aGlzLiNjdXJyZW50UXVlcnksIHRoaXMub3B0aW9ucykpIHtcbiAgICAgICAgdGhpcy4jZXhlY3V0ZUZldGNoKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnVwZGF0ZVJlc3VsdCgpO1xuICAgICAgfVxuICAgICAgdGhpcy4jdXBkYXRlVGltZXJzKCk7XG4gICAgfVxuICB9XG4gIG9uVW5zdWJzY3JpYmUoKSB7XG4gICAgaWYgKCF0aGlzLmhhc0xpc3RlbmVycygpKSB7XG4gICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbiAgc2hvdWxkRmV0Y2hPblJlY29ubmVjdCgpIHtcbiAgICByZXR1cm4gc2hvdWxkRmV0Y2hPbihcbiAgICAgIHRoaXMuI2N1cnJlbnRRdWVyeSxcbiAgICAgIHRoaXMub3B0aW9ucyxcbiAgICAgIHRoaXMub3B0aW9ucy5yZWZldGNoT25SZWNvbm5lY3RcbiAgICApO1xuICB9XG4gIHNob3VsZEZldGNoT25XaW5kb3dGb2N1cygpIHtcbiAgICByZXR1cm4gc2hvdWxkRmV0Y2hPbihcbiAgICAgIHRoaXMuI2N1cnJlbnRRdWVyeSxcbiAgICAgIHRoaXMub3B0aW9ucyxcbiAgICAgIHRoaXMub3B0aW9ucy5yZWZldGNoT25XaW5kb3dGb2N1c1xuICAgICk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmxpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy4jY2xlYXJTdGFsZVRpbWVvdXQoKTtcbiAgICB0aGlzLiNjbGVhclJlZmV0Y2hJbnRlcnZhbCgpO1xuICAgIHRoaXMuI2N1cnJlbnRRdWVyeS5yZW1vdmVPYnNlcnZlcih0aGlzKTtcbiAgfVxuICBzZXRPcHRpb25zKG9wdGlvbnMsIG5vdGlmeU9wdGlvbnMpIHtcbiAgICBjb25zdCBwcmV2T3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBwcmV2UXVlcnkgPSB0aGlzLiNjdXJyZW50UXVlcnk7XG4gICAgdGhpcy5vcHRpb25zID0gdGhpcy4jY2xpZW50LmRlZmF1bHRRdWVyeU9wdGlvbnMob3B0aW9ucyk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lbmFibGVkICE9PSB2b2lkIDAgJiYgdHlwZW9mIHRoaXMub3B0aW9ucy5lbmFibGVkICE9PSBcImJvb2xlYW5cIiAmJiB0eXBlb2YgdGhpcy5vcHRpb25zLmVuYWJsZWQgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgcmVzb2x2ZUVuYWJsZWQodGhpcy5vcHRpb25zLmVuYWJsZWQsIHRoaXMuI2N1cnJlbnRRdWVyeSkgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiRXhwZWN0ZWQgZW5hYmxlZCB0byBiZSBhIGJvb2xlYW4gb3IgYSBjYWxsYmFjayB0aGF0IHJldHVybnMgYSBib29sZWFuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuI3VwZGF0ZVF1ZXJ5KCk7XG4gICAgdGhpcy4jY3VycmVudFF1ZXJ5LnNldE9wdGlvbnModGhpcy5vcHRpb25zKTtcbiAgICBpZiAocHJldk9wdGlvbnMuX2RlZmF1bHRlZCAmJiAhc2hhbGxvd0VxdWFsT2JqZWN0cyh0aGlzLm9wdGlvbnMsIHByZXZPcHRpb25zKSkge1xuICAgICAgdGhpcy4jY2xpZW50LmdldFF1ZXJ5Q2FjaGUoKS5ub3RpZnkoe1xuICAgICAgICB0eXBlOiBcIm9ic2VydmVyT3B0aW9uc1VwZGF0ZWRcIixcbiAgICAgICAgcXVlcnk6IHRoaXMuI2N1cnJlbnRRdWVyeSxcbiAgICAgICAgb2JzZXJ2ZXI6IHRoaXNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBtb3VudGVkID0gdGhpcy5oYXNMaXN0ZW5lcnMoKTtcbiAgICBpZiAobW91bnRlZCAmJiBzaG91bGRGZXRjaE9wdGlvbmFsbHkoXG4gICAgICB0aGlzLiNjdXJyZW50UXVlcnksXG4gICAgICBwcmV2UXVlcnksXG4gICAgICB0aGlzLm9wdGlvbnMsXG4gICAgICBwcmV2T3B0aW9uc1xuICAgICkpIHtcbiAgICAgIHRoaXMuI2V4ZWN1dGVGZXRjaCgpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVJlc3VsdChub3RpZnlPcHRpb25zKTtcbiAgICBpZiAobW91bnRlZCAmJiAodGhpcy4jY3VycmVudFF1ZXJ5ICE9PSBwcmV2UXVlcnkgfHwgcmVzb2x2ZUVuYWJsZWQodGhpcy5vcHRpb25zLmVuYWJsZWQsIHRoaXMuI2N1cnJlbnRRdWVyeSkgIT09IHJlc29sdmVFbmFibGVkKHByZXZPcHRpb25zLmVuYWJsZWQsIHRoaXMuI2N1cnJlbnRRdWVyeSkgfHwgcmVzb2x2ZVN0YWxlVGltZSh0aGlzLm9wdGlvbnMuc3RhbGVUaW1lLCB0aGlzLiNjdXJyZW50UXVlcnkpICE9PSByZXNvbHZlU3RhbGVUaW1lKHByZXZPcHRpb25zLnN0YWxlVGltZSwgdGhpcy4jY3VycmVudFF1ZXJ5KSkpIHtcbiAgICAgIHRoaXMuI3VwZGF0ZVN0YWxlVGltZW91dCgpO1xuICAgIH1cbiAgICBjb25zdCBuZXh0UmVmZXRjaEludGVydmFsID0gdGhpcy4jY29tcHV0ZVJlZmV0Y2hJbnRlcnZhbCgpO1xuICAgIGlmIChtb3VudGVkICYmICh0aGlzLiNjdXJyZW50UXVlcnkgIT09IHByZXZRdWVyeSB8fCByZXNvbHZlRW5hYmxlZCh0aGlzLm9wdGlvbnMuZW5hYmxlZCwgdGhpcy4jY3VycmVudFF1ZXJ5KSAhPT0gcmVzb2x2ZUVuYWJsZWQocHJldk9wdGlvbnMuZW5hYmxlZCwgdGhpcy4jY3VycmVudFF1ZXJ5KSB8fCBuZXh0UmVmZXRjaEludGVydmFsICE9PSB0aGlzLiNjdXJyZW50UmVmZXRjaEludGVydmFsKSkge1xuICAgICAgdGhpcy4jdXBkYXRlUmVmZXRjaEludGVydmFsKG5leHRSZWZldGNoSW50ZXJ2YWwpO1xuICAgIH1cbiAgfVxuICBnZXRPcHRpbWlzdGljUmVzdWx0KG9wdGlvbnMpIHtcbiAgICBjb25zdCBxdWVyeSA9IHRoaXMuI2NsaWVudC5nZXRRdWVyeUNhY2hlKCkuYnVpbGQodGhpcy4jY2xpZW50LCBvcHRpb25zKTtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLmNyZWF0ZVJlc3VsdChxdWVyeSwgb3B0aW9ucyk7XG4gICAgaWYgKHNob3VsZEFzc2lnbk9ic2VydmVyQ3VycmVudFByb3BlcnRpZXModGhpcywgcmVzdWx0KSkge1xuICAgICAgdGhpcy4jY3VycmVudFJlc3VsdCA9IHJlc3VsdDtcbiAgICAgIHRoaXMuI2N1cnJlbnRSZXN1bHRPcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgdGhpcy4jY3VycmVudFJlc3VsdFN0YXRlID0gdGhpcy4jY3VycmVudFF1ZXJ5LnN0YXRlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGdldEN1cnJlbnRSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2N1cnJlbnRSZXN1bHQ7XG4gIH1cbiAgdHJhY2tSZXN1bHQocmVzdWx0LCBvblByb3BUcmFja2VkKSB7XG4gICAgY29uc3QgdHJhY2tlZFJlc3VsdCA9IHt9O1xuICAgIE9iamVjdC5rZXlzKHJlc3VsdCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHJhY2tlZFJlc3VsdCwga2V5LCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4ge1xuICAgICAgICAgIHRoaXMudHJhY2tQcm9wKGtleSk7XG4gICAgICAgICAgb25Qcm9wVHJhY2tlZD8uKGtleSk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdFtrZXldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gdHJhY2tlZFJlc3VsdDtcbiAgfVxuICB0cmFja1Byb3Aoa2V5KSB7XG4gICAgdGhpcy4jdHJhY2tlZFByb3BzLmFkZChrZXkpO1xuICB9XG4gIGdldEN1cnJlbnRRdWVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy4jY3VycmVudFF1ZXJ5O1xuICB9XG4gIHJlZmV0Y2goeyAuLi5vcHRpb25zIH0gPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmZldGNoKHtcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICBmZXRjaE9wdGltaXN0aWMob3B0aW9ucykge1xuICAgIGNvbnN0IGRlZmF1bHRlZE9wdGlvbnMgPSB0aGlzLiNjbGllbnQuZGVmYXVsdFF1ZXJ5T3B0aW9ucyhvcHRpb25zKTtcbiAgICBjb25zdCBxdWVyeSA9IHRoaXMuI2NsaWVudC5nZXRRdWVyeUNhY2hlKCkuYnVpbGQodGhpcy4jY2xpZW50LCBkZWZhdWx0ZWRPcHRpb25zKTtcbiAgICBxdWVyeS5pc0ZldGNoaW5nT3B0aW1pc3RpYyA9IHRydWU7XG4gICAgcmV0dXJuIHF1ZXJ5LmZldGNoKCkudGhlbigoKSA9PiB0aGlzLmNyZWF0ZVJlc3VsdChxdWVyeSwgZGVmYXVsdGVkT3B0aW9ucykpO1xuICB9XG4gIGZldGNoKGZldGNoT3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLiNleGVjdXRlRmV0Y2goe1xuICAgICAgLi4uZmV0Y2hPcHRpb25zLFxuICAgICAgY2FuY2VsUmVmZXRjaDogZmV0Y2hPcHRpb25zLmNhbmNlbFJlZmV0Y2ggPz8gdHJ1ZVxuICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy51cGRhdGVSZXN1bHQoKTtcbiAgICAgIHJldHVybiB0aGlzLiNjdXJyZW50UmVzdWx0O1xuICAgIH0pO1xuICB9XG4gICNleGVjdXRlRmV0Y2goZmV0Y2hPcHRpb25zKSB7XG4gICAgdGhpcy4jdXBkYXRlUXVlcnkoKTtcbiAgICBsZXQgcHJvbWlzZSA9IHRoaXMuI2N1cnJlbnRRdWVyeS5mZXRjaChcbiAgICAgIHRoaXMub3B0aW9ucyxcbiAgICAgIGZldGNoT3B0aW9uc1xuICAgICk7XG4gICAgaWYgKCFmZXRjaE9wdGlvbnM/LnRocm93T25FcnJvcikge1xuICAgICAgcHJvbWlzZSA9IHByb21pc2UuY2F0Y2gobm9vcCk7XG4gICAgfVxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gICN1cGRhdGVTdGFsZVRpbWVvdXQoKSB7XG4gICAgdGhpcy4jY2xlYXJTdGFsZVRpbWVvdXQoKTtcbiAgICBjb25zdCBzdGFsZVRpbWUgPSByZXNvbHZlU3RhbGVUaW1lKFxuICAgICAgdGhpcy5vcHRpb25zLnN0YWxlVGltZSxcbiAgICAgIHRoaXMuI2N1cnJlbnRRdWVyeVxuICAgICk7XG4gICAgaWYgKGlzU2VydmVyIHx8IHRoaXMuI2N1cnJlbnRSZXN1bHQuaXNTdGFsZSB8fCAhaXNWYWxpZFRpbWVvdXQoc3RhbGVUaW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0aW1lID0gdGltZVVudGlsU3RhbGUodGhpcy4jY3VycmVudFJlc3VsdC5kYXRhVXBkYXRlZEF0LCBzdGFsZVRpbWUpO1xuICAgIGNvbnN0IHRpbWVvdXQgPSB0aW1lICsgMTtcbiAgICB0aGlzLiNzdGFsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLiNjdXJyZW50UmVzdWx0LmlzU3RhbGUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVSZXN1bHQoKTtcbiAgICAgIH1cbiAgICB9LCB0aW1lb3V0KTtcbiAgfVxuICAjY29tcHV0ZVJlZmV0Y2hJbnRlcnZhbCgpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB0aGlzLm9wdGlvbnMucmVmZXRjaEludGVydmFsID09PSBcImZ1bmN0aW9uXCIgPyB0aGlzLm9wdGlvbnMucmVmZXRjaEludGVydmFsKHRoaXMuI2N1cnJlbnRRdWVyeSkgOiB0aGlzLm9wdGlvbnMucmVmZXRjaEludGVydmFsKSA/PyBmYWxzZTtcbiAgfVxuICAjdXBkYXRlUmVmZXRjaEludGVydmFsKG5leHRJbnRlcnZhbCkge1xuICAgIHRoaXMuI2NsZWFyUmVmZXRjaEludGVydmFsKCk7XG4gICAgdGhpcy4jY3VycmVudFJlZmV0Y2hJbnRlcnZhbCA9IG5leHRJbnRlcnZhbDtcbiAgICBpZiAoaXNTZXJ2ZXIgfHwgcmVzb2x2ZUVuYWJsZWQodGhpcy5vcHRpb25zLmVuYWJsZWQsIHRoaXMuI2N1cnJlbnRRdWVyeSkgPT09IGZhbHNlIHx8ICFpc1ZhbGlkVGltZW91dCh0aGlzLiNjdXJyZW50UmVmZXRjaEludGVydmFsKSB8fCB0aGlzLiNjdXJyZW50UmVmZXRjaEludGVydmFsID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3JlZmV0Y2hJbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZWZldGNoSW50ZXJ2YWxJbkJhY2tncm91bmQgfHwgZm9jdXNNYW5hZ2VyLmlzRm9jdXNlZCgpKSB7XG4gICAgICAgIHRoaXMuI2V4ZWN1dGVGZXRjaCgpO1xuICAgICAgfVxuICAgIH0sIHRoaXMuI2N1cnJlbnRSZWZldGNoSW50ZXJ2YWwpO1xuICB9XG4gICN1cGRhdGVUaW1lcnMoKSB7XG4gICAgdGhpcy4jdXBkYXRlU3RhbGVUaW1lb3V0KCk7XG4gICAgdGhpcy4jdXBkYXRlUmVmZXRjaEludGVydmFsKHRoaXMuI2NvbXB1dGVSZWZldGNoSW50ZXJ2YWwoKSk7XG4gIH1cbiAgI2NsZWFyU3RhbGVUaW1lb3V0KCkge1xuICAgIGlmICh0aGlzLiNzdGFsZVRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI3N0YWxlVGltZW91dElkKTtcbiAgICAgIHRoaXMuI3N0YWxlVGltZW91dElkID0gdm9pZCAwO1xuICAgIH1cbiAgfVxuICAjY2xlYXJSZWZldGNoSW50ZXJ2YWwoKSB7XG4gICAgaWYgKHRoaXMuI3JlZmV0Y2hJbnRlcnZhbElkKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuI3JlZmV0Y2hJbnRlcnZhbElkKTtcbiAgICAgIHRoaXMuI3JlZmV0Y2hJbnRlcnZhbElkID0gdm9pZCAwO1xuICAgIH1cbiAgfVxuICBjcmVhdGVSZXN1bHQocXVlcnksIG9wdGlvbnMpIHtcbiAgICBjb25zdCBwcmV2UXVlcnkgPSB0aGlzLiNjdXJyZW50UXVlcnk7XG4gICAgY29uc3QgcHJldk9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgcHJldlJlc3VsdCA9IHRoaXMuI2N1cnJlbnRSZXN1bHQ7XG4gICAgY29uc3QgcHJldlJlc3VsdFN0YXRlID0gdGhpcy4jY3VycmVudFJlc3VsdFN0YXRlO1xuICAgIGNvbnN0IHByZXZSZXN1bHRPcHRpb25zID0gdGhpcy4jY3VycmVudFJlc3VsdE9wdGlvbnM7XG4gICAgY29uc3QgcXVlcnlDaGFuZ2UgPSBxdWVyeSAhPT0gcHJldlF1ZXJ5O1xuICAgIGNvbnN0IHF1ZXJ5SW5pdGlhbFN0YXRlID0gcXVlcnlDaGFuZ2UgPyBxdWVyeS5zdGF0ZSA6IHRoaXMuI2N1cnJlbnRRdWVyeUluaXRpYWxTdGF0ZTtcbiAgICBjb25zdCB7IHN0YXRlIH0gPSBxdWVyeTtcbiAgICBsZXQgbmV3U3RhdGUgPSB7IC4uLnN0YXRlIH07XG4gICAgbGV0IGlzUGxhY2Vob2xkZXJEYXRhID0gZmFsc2U7XG4gICAgbGV0IGRhdGE7XG4gICAgaWYgKG9wdGlvbnMuX29wdGltaXN0aWNSZXN1bHRzKSB7XG4gICAgICBjb25zdCBtb3VudGVkID0gdGhpcy5oYXNMaXN0ZW5lcnMoKTtcbiAgICAgIGNvbnN0IGZldGNoT25Nb3VudCA9ICFtb3VudGVkICYmIHNob3VsZEZldGNoT25Nb3VudChxdWVyeSwgb3B0aW9ucyk7XG4gICAgICBjb25zdCBmZXRjaE9wdGlvbmFsbHkgPSBtb3VudGVkICYmIHNob3VsZEZldGNoT3B0aW9uYWxseShxdWVyeSwgcHJldlF1ZXJ5LCBvcHRpb25zLCBwcmV2T3B0aW9ucyk7XG4gICAgICBpZiAoZmV0Y2hPbk1vdW50IHx8IGZldGNoT3B0aW9uYWxseSkge1xuICAgICAgICBuZXdTdGF0ZSA9IHtcbiAgICAgICAgICAuLi5uZXdTdGF0ZSxcbiAgICAgICAgICAuLi5mZXRjaFN0YXRlKHN0YXRlLmRhdGEsIHF1ZXJ5Lm9wdGlvbnMpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5fb3B0aW1pc3RpY1Jlc3VsdHMgPT09IFwiaXNSZXN0b3JpbmdcIikge1xuICAgICAgICBuZXdTdGF0ZS5mZXRjaFN0YXR1cyA9IFwiaWRsZVwiO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgeyBlcnJvciwgZXJyb3JVcGRhdGVkQXQsIHN0YXR1cyB9ID0gbmV3U3RhdGU7XG4gICAgaWYgKG9wdGlvbnMuc2VsZWN0ICYmIG5ld1N0YXRlLmRhdGEgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKHByZXZSZXN1bHQgJiYgbmV3U3RhdGUuZGF0YSA9PT0gcHJldlJlc3VsdFN0YXRlPy5kYXRhICYmIG9wdGlvbnMuc2VsZWN0ID09PSB0aGlzLiNzZWxlY3RGbikge1xuICAgICAgICBkYXRhID0gdGhpcy4jc2VsZWN0UmVzdWx0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLiNzZWxlY3RGbiA9IG9wdGlvbnMuc2VsZWN0O1xuICAgICAgICAgIGRhdGEgPSBvcHRpb25zLnNlbGVjdChuZXdTdGF0ZS5kYXRhKTtcbiAgICAgICAgICBkYXRhID0gcmVwbGFjZURhdGEocHJldlJlc3VsdD8uZGF0YSwgZGF0YSwgb3B0aW9ucyk7XG4gICAgICAgICAgdGhpcy4jc2VsZWN0UmVzdWx0ID0gZGF0YTtcbiAgICAgICAgICB0aGlzLiNzZWxlY3RFcnJvciA9IG51bGw7XG4gICAgICAgIH0gY2F0Y2ggKHNlbGVjdEVycm9yKSB7XG4gICAgICAgICAgdGhpcy4jc2VsZWN0RXJyb3IgPSBzZWxlY3RFcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gbmV3U3RhdGUuZGF0YTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucGxhY2Vob2xkZXJEYXRhICE9PSB2b2lkIDAgJiYgZGF0YSA9PT0gdm9pZCAwICYmIHN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgIGxldCBwbGFjZWhvbGRlckRhdGE7XG4gICAgICBpZiAocHJldlJlc3VsdD8uaXNQbGFjZWhvbGRlckRhdGEgJiYgb3B0aW9ucy5wbGFjZWhvbGRlckRhdGEgPT09IHByZXZSZXN1bHRPcHRpb25zPy5wbGFjZWhvbGRlckRhdGEpIHtcbiAgICAgICAgcGxhY2Vob2xkZXJEYXRhID0gcHJldlJlc3VsdC5kYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGxhY2Vob2xkZXJEYXRhID0gdHlwZW9mIG9wdGlvbnMucGxhY2Vob2xkZXJEYXRhID09PSBcImZ1bmN0aW9uXCIgPyBvcHRpb25zLnBsYWNlaG9sZGVyRGF0YShcbiAgICAgICAgICB0aGlzLiNsYXN0UXVlcnlXaXRoRGVmaW5lZERhdGE/LnN0YXRlLmRhdGEsXG4gICAgICAgICAgdGhpcy4jbGFzdFF1ZXJ5V2l0aERlZmluZWREYXRhXG4gICAgICAgICkgOiBvcHRpb25zLnBsYWNlaG9sZGVyRGF0YTtcbiAgICAgICAgaWYgKG9wdGlvbnMuc2VsZWN0ICYmIHBsYWNlaG9sZGVyRGF0YSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyRGF0YSA9IG9wdGlvbnMuc2VsZWN0KHBsYWNlaG9sZGVyRGF0YSk7XG4gICAgICAgICAgICB0aGlzLiNzZWxlY3RFcnJvciA9IG51bGw7XG4gICAgICAgICAgfSBjYXRjaCAoc2VsZWN0RXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuI3NlbGVjdEVycm9yID0gc2VsZWN0RXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGxhY2Vob2xkZXJEYXRhICE9PSB2b2lkIDApIHtcbiAgICAgICAgc3RhdHVzID0gXCJzdWNjZXNzXCI7XG4gICAgICAgIGRhdGEgPSByZXBsYWNlRGF0YShcbiAgICAgICAgICBwcmV2UmVzdWx0Py5kYXRhLFxuICAgICAgICAgIHBsYWNlaG9sZGVyRGF0YSxcbiAgICAgICAgICBvcHRpb25zXG4gICAgICAgICk7XG4gICAgICAgIGlzUGxhY2Vob2xkZXJEYXRhID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuI3NlbGVjdEVycm9yKSB7XG4gICAgICBlcnJvciA9IHRoaXMuI3NlbGVjdEVycm9yO1xuICAgICAgZGF0YSA9IHRoaXMuI3NlbGVjdFJlc3VsdDtcbiAgICAgIGVycm9yVXBkYXRlZEF0ID0gRGF0ZS5ub3coKTtcbiAgICAgIHN0YXR1cyA9IFwiZXJyb3JcIjtcbiAgICB9XG4gICAgY29uc3QgaXNGZXRjaGluZyA9IG5ld1N0YXRlLmZldGNoU3RhdHVzID09PSBcImZldGNoaW5nXCI7XG4gICAgY29uc3QgaXNQZW5kaW5nID0gc3RhdHVzID09PSBcInBlbmRpbmdcIjtcbiAgICBjb25zdCBpc0Vycm9yID0gc3RhdHVzID09PSBcImVycm9yXCI7XG4gICAgY29uc3QgaXNMb2FkaW5nID0gaXNQZW5kaW5nICYmIGlzRmV0Y2hpbmc7XG4gICAgY29uc3QgaGFzRGF0YSA9IGRhdGEgIT09IHZvaWQgMDtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBzdGF0dXMsXG4gICAgICBmZXRjaFN0YXR1czogbmV3U3RhdGUuZmV0Y2hTdGF0dXMsXG4gICAgICBpc1BlbmRpbmcsXG4gICAgICBpc1N1Y2Nlc3M6IHN0YXR1cyA9PT0gXCJzdWNjZXNzXCIsXG4gICAgICBpc0Vycm9yLFxuICAgICAgaXNJbml0aWFsTG9hZGluZzogaXNMb2FkaW5nLFxuICAgICAgaXNMb2FkaW5nLFxuICAgICAgZGF0YSxcbiAgICAgIGRhdGFVcGRhdGVkQXQ6IG5ld1N0YXRlLmRhdGFVcGRhdGVkQXQsXG4gICAgICBlcnJvcixcbiAgICAgIGVycm9yVXBkYXRlZEF0LFxuICAgICAgZmFpbHVyZUNvdW50OiBuZXdTdGF0ZS5mZXRjaEZhaWx1cmVDb3VudCxcbiAgICAgIGZhaWx1cmVSZWFzb246IG5ld1N0YXRlLmZldGNoRmFpbHVyZVJlYXNvbixcbiAgICAgIGVycm9yVXBkYXRlQ291bnQ6IG5ld1N0YXRlLmVycm9yVXBkYXRlQ291bnQsXG4gICAgICBpc0ZldGNoZWQ6IG5ld1N0YXRlLmRhdGFVcGRhdGVDb3VudCA+IDAgfHwgbmV3U3RhdGUuZXJyb3JVcGRhdGVDb3VudCA+IDAsXG4gICAgICBpc0ZldGNoZWRBZnRlck1vdW50OiBuZXdTdGF0ZS5kYXRhVXBkYXRlQ291bnQgPiBxdWVyeUluaXRpYWxTdGF0ZS5kYXRhVXBkYXRlQ291bnQgfHwgbmV3U3RhdGUuZXJyb3JVcGRhdGVDb3VudCA+IHF1ZXJ5SW5pdGlhbFN0YXRlLmVycm9yVXBkYXRlQ291bnQsXG4gICAgICBpc0ZldGNoaW5nLFxuICAgICAgaXNSZWZldGNoaW5nOiBpc0ZldGNoaW5nICYmICFpc1BlbmRpbmcsXG4gICAgICBpc0xvYWRpbmdFcnJvcjogaXNFcnJvciAmJiAhaGFzRGF0YSxcbiAgICAgIGlzUGF1c2VkOiBuZXdTdGF0ZS5mZXRjaFN0YXR1cyA9PT0gXCJwYXVzZWRcIixcbiAgICAgIGlzUGxhY2Vob2xkZXJEYXRhLFxuICAgICAgaXNSZWZldGNoRXJyb3I6IGlzRXJyb3IgJiYgaGFzRGF0YSxcbiAgICAgIGlzU3RhbGU6IGlzU3RhbGUocXVlcnksIG9wdGlvbnMpLFxuICAgICAgcmVmZXRjaDogdGhpcy5yZWZldGNoXG4gICAgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHVwZGF0ZVJlc3VsdChub3RpZnlPcHRpb25zKSB7XG4gICAgY29uc3QgcHJldlJlc3VsdCA9IHRoaXMuI2N1cnJlbnRSZXN1bHQ7XG4gICAgY29uc3QgbmV4dFJlc3VsdCA9IHRoaXMuY3JlYXRlUmVzdWx0KHRoaXMuI2N1cnJlbnRRdWVyeSwgdGhpcy5vcHRpb25zKTtcbiAgICB0aGlzLiNjdXJyZW50UmVzdWx0U3RhdGUgPSB0aGlzLiNjdXJyZW50UXVlcnkuc3RhdGU7XG4gICAgdGhpcy4jY3VycmVudFJlc3VsdE9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKHRoaXMuI2N1cnJlbnRSZXN1bHRTdGF0ZS5kYXRhICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuI2xhc3RRdWVyeVdpdGhEZWZpbmVkRGF0YSA9IHRoaXMuI2N1cnJlbnRRdWVyeTtcbiAgICB9XG4gICAgaWYgKHNoYWxsb3dFcXVhbE9iamVjdHMobmV4dFJlc3VsdCwgcHJldlJlc3VsdCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jY3VycmVudFJlc3VsdCA9IG5leHRSZXN1bHQ7XG4gICAgY29uc3QgZGVmYXVsdE5vdGlmeU9wdGlvbnMgPSB7fTtcbiAgICBjb25zdCBzaG91bGROb3RpZnlMaXN0ZW5lcnMgPSAoKSA9PiB7XG4gICAgICBpZiAoIXByZXZSZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCB7IG5vdGlmeU9uQ2hhbmdlUHJvcHMgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgIGNvbnN0IG5vdGlmeU9uQ2hhbmdlUHJvcHNWYWx1ZSA9IHR5cGVvZiBub3RpZnlPbkNoYW5nZVByb3BzID09PSBcImZ1bmN0aW9uXCIgPyBub3RpZnlPbkNoYW5nZVByb3BzKCkgOiBub3RpZnlPbkNoYW5nZVByb3BzO1xuICAgICAgaWYgKG5vdGlmeU9uQ2hhbmdlUHJvcHNWYWx1ZSA9PT0gXCJhbGxcIiB8fCAhbm90aWZ5T25DaGFuZ2VQcm9wc1ZhbHVlICYmICF0aGlzLiN0cmFja2VkUHJvcHMuc2l6ZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGluY2x1ZGVkUHJvcHMgPSBuZXcgU2V0KFxuICAgICAgICBub3RpZnlPbkNoYW5nZVByb3BzVmFsdWUgPz8gdGhpcy4jdHJhY2tlZFByb3BzXG4gICAgICApO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy50aHJvd09uRXJyb3IpIHtcbiAgICAgICAgaW5jbHVkZWRQcm9wcy5hZGQoXCJlcnJvclwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLiNjdXJyZW50UmVzdWx0KS5zb21lKChrZXkpID0+IHtcbiAgICAgICAgY29uc3QgdHlwZWRLZXkgPSBrZXk7XG4gICAgICAgIGNvbnN0IGNoYW5nZWQgPSB0aGlzLiNjdXJyZW50UmVzdWx0W3R5cGVkS2V5XSAhPT0gcHJldlJlc3VsdFt0eXBlZEtleV07XG4gICAgICAgIHJldHVybiBjaGFuZ2VkICYmIGluY2x1ZGVkUHJvcHMuaGFzKHR5cGVkS2V5KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgaWYgKG5vdGlmeU9wdGlvbnM/Lmxpc3RlbmVycyAhPT0gZmFsc2UgJiYgc2hvdWxkTm90aWZ5TGlzdGVuZXJzKCkpIHtcbiAgICAgIGRlZmF1bHROb3RpZnlPcHRpb25zLmxpc3RlbmVycyA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuI25vdGlmeSh7IC4uLmRlZmF1bHROb3RpZnlPcHRpb25zLCAuLi5ub3RpZnlPcHRpb25zIH0pO1xuICB9XG4gICN1cGRhdGVRdWVyeSgpIHtcbiAgICBjb25zdCBxdWVyeSA9IHRoaXMuI2NsaWVudC5nZXRRdWVyeUNhY2hlKCkuYnVpbGQodGhpcy4jY2xpZW50LCB0aGlzLm9wdGlvbnMpO1xuICAgIGlmIChxdWVyeSA9PT0gdGhpcy4jY3VycmVudFF1ZXJ5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHByZXZRdWVyeSA9IHRoaXMuI2N1cnJlbnRRdWVyeTtcbiAgICB0aGlzLiNjdXJyZW50UXVlcnkgPSBxdWVyeTtcbiAgICB0aGlzLiNjdXJyZW50UXVlcnlJbml0aWFsU3RhdGUgPSBxdWVyeS5zdGF0ZTtcbiAgICBpZiAodGhpcy5oYXNMaXN0ZW5lcnMoKSkge1xuICAgICAgcHJldlF1ZXJ5Py5yZW1vdmVPYnNlcnZlcih0aGlzKTtcbiAgICAgIHF1ZXJ5LmFkZE9ic2VydmVyKHRoaXMpO1xuICAgIH1cbiAgfVxuICBvblF1ZXJ5VXBkYXRlKCkge1xuICAgIHRoaXMudXBkYXRlUmVzdWx0KCk7XG4gICAgaWYgKHRoaXMuaGFzTGlzdGVuZXJzKCkpIHtcbiAgICAgIHRoaXMuI3VwZGF0ZVRpbWVycygpO1xuICAgIH1cbiAgfVxuICAjbm90aWZ5KG5vdGlmeU9wdGlvbnMpIHtcbiAgICBub3RpZnlNYW5hZ2VyLmJhdGNoKCgpID0+IHtcbiAgICAgIGlmIChub3RpZnlPcHRpb25zLmxpc3RlbmVycykge1xuICAgICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xuICAgICAgICAgIGxpc3RlbmVyKHRoaXMuI2N1cnJlbnRSZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI2NsaWVudC5nZXRRdWVyeUNhY2hlKCkubm90aWZ5KHtcbiAgICAgICAgcXVlcnk6IHRoaXMuI2N1cnJlbnRRdWVyeSxcbiAgICAgICAgdHlwZTogXCJvYnNlcnZlclJlc3VsdHNVcGRhdGVkXCJcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59O1xuZnVuY3Rpb24gc2hvdWxkTG9hZE9uTW91bnQocXVlcnksIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHJlc29sdmVFbmFibGVkKG9wdGlvbnMuZW5hYmxlZCwgcXVlcnkpICE9PSBmYWxzZSAmJiBxdWVyeS5zdGF0ZS5kYXRhID09PSB2b2lkIDAgJiYgIShxdWVyeS5zdGF0ZS5zdGF0dXMgPT09IFwiZXJyb3JcIiAmJiBvcHRpb25zLnJldHJ5T25Nb3VudCA9PT0gZmFsc2UpO1xufVxuZnVuY3Rpb24gc2hvdWxkRmV0Y2hPbk1vdW50KHF1ZXJ5LCBvcHRpb25zKSB7XG4gIHJldHVybiBzaG91bGRMb2FkT25Nb3VudChxdWVyeSwgb3B0aW9ucykgfHwgcXVlcnkuc3RhdGUuZGF0YSAhPT0gdm9pZCAwICYmIHNob3VsZEZldGNoT24ocXVlcnksIG9wdGlvbnMsIG9wdGlvbnMucmVmZXRjaE9uTW91bnQpO1xufVxuZnVuY3Rpb24gc2hvdWxkRmV0Y2hPbihxdWVyeSwgb3B0aW9ucywgZmllbGQpIHtcbiAgaWYgKHJlc29sdmVFbmFibGVkKG9wdGlvbnMuZW5hYmxlZCwgcXVlcnkpICE9PSBmYWxzZSkge1xuICAgIGNvbnN0IHZhbHVlID0gdHlwZW9mIGZpZWxkID09PSBcImZ1bmN0aW9uXCIgPyBmaWVsZChxdWVyeSkgOiBmaWVsZDtcbiAgICByZXR1cm4gdmFsdWUgPT09IFwiYWx3YXlzXCIgfHwgdmFsdWUgIT09IGZhbHNlICYmIGlzU3RhbGUocXVlcnksIG9wdGlvbnMpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHNob3VsZEZldGNoT3B0aW9uYWxseShxdWVyeSwgcHJldlF1ZXJ5LCBvcHRpb25zLCBwcmV2T3B0aW9ucykge1xuICByZXR1cm4gKHF1ZXJ5ICE9PSBwcmV2UXVlcnkgfHwgcmVzb2x2ZUVuYWJsZWQocHJldk9wdGlvbnMuZW5hYmxlZCwgcXVlcnkpID09PSBmYWxzZSkgJiYgKCFvcHRpb25zLnN1c3BlbnNlIHx8IHF1ZXJ5LnN0YXRlLnN0YXR1cyAhPT0gXCJlcnJvclwiKSAmJiBpc1N0YWxlKHF1ZXJ5LCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGlzU3RhbGUocXVlcnksIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHJlc29sdmVFbmFibGVkKG9wdGlvbnMuZW5hYmxlZCwgcXVlcnkpICE9PSBmYWxzZSAmJiBxdWVyeS5pc1N0YWxlQnlUaW1lKHJlc29sdmVTdGFsZVRpbWUob3B0aW9ucy5zdGFsZVRpbWUsIHF1ZXJ5KSk7XG59XG5mdW5jdGlvbiBzaG91bGRBc3NpZ25PYnNlcnZlckN1cnJlbnRQcm9wZXJ0aWVzKG9ic2VydmVyLCBvcHRpbWlzdGljUmVzdWx0KSB7XG4gIGlmICghc2hhbGxvd0VxdWFsT2JqZWN0cyhvYnNlcnZlci5nZXRDdXJyZW50UmVzdWx0KCksIG9wdGltaXN0aWNSZXN1bHQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0IHtcbiAgUXVlcnlPYnNlcnZlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5T2JzZXJ2ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/@tanstack/query-core/build/modern/queryObserver.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@tanstack/query-core/build/modern/removable.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/@tanstack/query-core/build/modern/removable.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Removable: function() { return /* binding */ Removable; }\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../../node_modules/@tanstack/query-core/build/modern/utils.js\");\n// src/removable.ts\n\nvar Removable = class {\n  #gcTimeout;\n  destroy() {\n    this.clearGcTimeout();\n  }\n  scheduleGc() {\n    this.clearGcTimeout();\n    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isValidTimeout)(this.gcTime)) {\n      this.#gcTimeout = setTimeout(() => {\n        this.optionalRemove();\n      }, this.gcTime);\n    }\n  }\n  updateGcTime(newGcTime) {\n    this.gcTime = Math.max(\n      this.gcTime || 0,\n      newGcTime ?? (_utils_js__WEBPACK_IMPORTED_MODULE_0__.isServer ? Infinity : 5 * 60 * 1e3)\n    );\n  }\n  clearGcTimeout() {\n    if (this.#gcTimeout) {\n      clearTimeout(this.#gcTimeout);\n      this.#gcTimeout = void 0;\n    }\n  }\n};\n\n//# sourceMappingURL=removable.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbW9kZXJuL3JlbW92YWJsZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ3NEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5REFBYztBQUN0QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0NBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL21vZGVybi9yZW1vdmFibGUuanM/NWQyOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvcmVtb3ZhYmxlLnRzXG5pbXBvcnQgeyBpc1NlcnZlciwgaXNWYWxpZFRpbWVvdXQgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xudmFyIFJlbW92YWJsZSA9IGNsYXNzIHtcbiAgI2djVGltZW91dDtcbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmNsZWFyR2NUaW1lb3V0KCk7XG4gIH1cbiAgc2NoZWR1bGVHYygpIHtcbiAgICB0aGlzLmNsZWFyR2NUaW1lb3V0KCk7XG4gICAgaWYgKGlzVmFsaWRUaW1lb3V0KHRoaXMuZ2NUaW1lKSkge1xuICAgICAgdGhpcy4jZ2NUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMub3B0aW9uYWxSZW1vdmUoKTtcbiAgICAgIH0sIHRoaXMuZ2NUaW1lKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlR2NUaW1lKG5ld0djVGltZSkge1xuICAgIHRoaXMuZ2NUaW1lID0gTWF0aC5tYXgoXG4gICAgICB0aGlzLmdjVGltZSB8fCAwLFxuICAgICAgbmV3R2NUaW1lID8/IChpc1NlcnZlciA/IEluZmluaXR5IDogNSAqIDYwICogMWUzKVxuICAgICk7XG4gIH1cbiAgY2xlYXJHY1RpbWVvdXQoKSB7XG4gICAgaWYgKHRoaXMuI2djVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI2djVGltZW91dCk7XG4gICAgICB0aGlzLiNnY1RpbWVvdXQgPSB2b2lkIDA7XG4gICAgfVxuICB9XG59O1xuZXhwb3J0IHtcbiAgUmVtb3ZhYmxlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVtb3ZhYmxlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/@tanstack/query-core/build/modern/removable.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@tanstack/query-core/build/modern/retryer.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/@tanstack/query-core/build/modern/retryer.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CancelledError: function() { return /* binding */ CancelledError; },\n/* harmony export */   canFetch: function() { return /* binding */ canFetch; },\n/* harmony export */   createRetryer: function() { return /* binding */ createRetryer; },\n/* harmony export */   isCancelledError: function() { return /* binding */ isCancelledError; }\n/* harmony export */ });\n/* harmony import */ var _focusManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./focusManager.js */ \"(app-pages-browser)/../../node_modules/@tanstack/query-core/build/modern/focusManager.js\");\n/* harmony import */ var _onlineManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./onlineManager.js */ \"(app-pages-browser)/../../node_modules/@tanstack/query-core/build/modern/onlineManager.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../../node_modules/@tanstack/query-core/build/modern/utils.js\");\n// src/retryer.ts\n\n\n\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1e3 * 2 ** failureCount, 3e4);\n}\nfunction canFetch(networkMode) {\n  return (networkMode ?? \"online\") === \"online\" ? _onlineManager_js__WEBPACK_IMPORTED_MODULE_0__.onlineManager.isOnline() : true;\n}\nvar CancelledError = class extends Error {\n  constructor(options) {\n    super(\"CancelledError\");\n    this.revert = options?.revert;\n    this.silent = options?.silent;\n  }\n};\nfunction isCancelledError(value) {\n  return value instanceof CancelledError;\n}\nfunction createRetryer(config) {\n  let isRetryCancelled = false;\n  let failureCount = 0;\n  let isResolved = false;\n  let continueFn;\n  let promiseResolve;\n  let promiseReject;\n  const promise = new Promise((outerResolve, outerReject) => {\n    promiseResolve = outerResolve;\n    promiseReject = outerReject;\n  });\n  const cancel = (cancelOptions) => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions));\n      config.abort?.();\n    }\n  };\n  const cancelRetry = () => {\n    isRetryCancelled = true;\n  };\n  const continueRetry = () => {\n    isRetryCancelled = false;\n  };\n  const canContinue = () => _focusManager_js__WEBPACK_IMPORTED_MODULE_1__.focusManager.isFocused() && (config.networkMode === \"always\" || _onlineManager_js__WEBPACK_IMPORTED_MODULE_0__.onlineManager.isOnline()) && config.canRun();\n  const canStart = () => canFetch(config.networkMode) && config.canRun();\n  const resolve = (value) => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onSuccess?.(value);\n      continueFn?.();\n      promiseResolve(value);\n    }\n  };\n  const reject = (value) => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onError?.(value);\n      continueFn?.();\n      promiseReject(value);\n    }\n  };\n  const pause = () => {\n    return new Promise((continueResolve) => {\n      continueFn = (value) => {\n        if (isResolved || canContinue()) {\n          continueResolve(value);\n        }\n      };\n      config.onPause?.();\n    }).then(() => {\n      continueFn = void 0;\n      if (!isResolved) {\n        config.onContinue?.();\n      }\n    });\n  };\n  const run = () => {\n    if (isResolved) {\n      return;\n    }\n    let promiseOrValue;\n    const initialPromise = failureCount === 0 ? config.initialPromise : void 0;\n    try {\n      promiseOrValue = initialPromise ?? config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    }\n    Promise.resolve(promiseOrValue).then(resolve).catch((error) => {\n      if (isResolved) {\n        return;\n      }\n      const retry = config.retry ?? (_utils_js__WEBPACK_IMPORTED_MODULE_2__.isServer ? 0 : 3);\n      const retryDelay = config.retryDelay ?? defaultRetryDelay;\n      const delay = typeof retryDelay === \"function\" ? retryDelay(failureCount, error) : retryDelay;\n      const shouldRetry = retry === true || typeof retry === \"number\" && failureCount < retry || typeof retry === \"function\" && retry(failureCount, error);\n      if (isRetryCancelled || !shouldRetry) {\n        reject(error);\n        return;\n      }\n      failureCount++;\n      config.onFail?.(failureCount, error);\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.sleep)(delay).then(() => {\n        return canContinue() ? void 0 : pause();\n      }).then(() => {\n        if (isRetryCancelled) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  };\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      continueFn?.();\n      return promise;\n    },\n    cancelRetry,\n    continueRetry,\n    canStart,\n    start: () => {\n      if (canStart()) {\n        run();\n      } else {\n        pause().then(run);\n      }\n      return promise;\n    }\n  };\n}\n\n//# sourceMappingURL=retryer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbW9kZXJuL3JldHJ5ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ2lEO0FBQ0U7QUFDTjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCw0REFBYTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBEQUFZLG9EQUFvRCw0REFBYTtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLCtDQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sZ0RBQUs7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbW9kZXJuL3JldHJ5ZXIuanM/NjFhNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvcmV0cnllci50c1xuaW1wb3J0IHsgZm9jdXNNYW5hZ2VyIH0gZnJvbSBcIi4vZm9jdXNNYW5hZ2VyLmpzXCI7XG5pbXBvcnQgeyBvbmxpbmVNYW5hZ2VyIH0gZnJvbSBcIi4vb25saW5lTWFuYWdlci5qc1wiO1xuaW1wb3J0IHsgaXNTZXJ2ZXIsIHNsZWVwIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbmZ1bmN0aW9uIGRlZmF1bHRSZXRyeURlbGF5KGZhaWx1cmVDb3VudCkge1xuICByZXR1cm4gTWF0aC5taW4oMWUzICogMiAqKiBmYWlsdXJlQ291bnQsIDNlNCk7XG59XG5mdW5jdGlvbiBjYW5GZXRjaChuZXR3b3JrTW9kZSkge1xuICByZXR1cm4gKG5ldHdvcmtNb2RlID8/IFwib25saW5lXCIpID09PSBcIm9ubGluZVwiID8gb25saW5lTWFuYWdlci5pc09ubGluZSgpIDogdHJ1ZTtcbn1cbnZhciBDYW5jZWxsZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoXCJDYW5jZWxsZWRFcnJvclwiKTtcbiAgICB0aGlzLnJldmVydCA9IG9wdGlvbnM/LnJldmVydDtcbiAgICB0aGlzLnNpbGVudCA9IG9wdGlvbnM/LnNpbGVudDtcbiAgfVxufTtcbmZ1bmN0aW9uIGlzQ2FuY2VsbGVkRXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgQ2FuY2VsbGVkRXJyb3I7XG59XG5mdW5jdGlvbiBjcmVhdGVSZXRyeWVyKGNvbmZpZykge1xuICBsZXQgaXNSZXRyeUNhbmNlbGxlZCA9IGZhbHNlO1xuICBsZXQgZmFpbHVyZUNvdW50ID0gMDtcbiAgbGV0IGlzUmVzb2x2ZWQgPSBmYWxzZTtcbiAgbGV0IGNvbnRpbnVlRm47XG4gIGxldCBwcm9taXNlUmVzb2x2ZTtcbiAgbGV0IHByb21pc2VSZWplY3Q7XG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgob3V0ZXJSZXNvbHZlLCBvdXRlclJlamVjdCkgPT4ge1xuICAgIHByb21pc2VSZXNvbHZlID0gb3V0ZXJSZXNvbHZlO1xuICAgIHByb21pc2VSZWplY3QgPSBvdXRlclJlamVjdDtcbiAgfSk7XG4gIGNvbnN0IGNhbmNlbCA9IChjYW5jZWxPcHRpb25zKSA9PiB7XG4gICAgaWYgKCFpc1Jlc29sdmVkKSB7XG4gICAgICByZWplY3QobmV3IENhbmNlbGxlZEVycm9yKGNhbmNlbE9wdGlvbnMpKTtcbiAgICAgIGNvbmZpZy5hYm9ydD8uKCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBjYW5jZWxSZXRyeSA9ICgpID0+IHtcbiAgICBpc1JldHJ5Q2FuY2VsbGVkID0gdHJ1ZTtcbiAgfTtcbiAgY29uc3QgY29udGludWVSZXRyeSA9ICgpID0+IHtcbiAgICBpc1JldHJ5Q2FuY2VsbGVkID0gZmFsc2U7XG4gIH07XG4gIGNvbnN0IGNhbkNvbnRpbnVlID0gKCkgPT4gZm9jdXNNYW5hZ2VyLmlzRm9jdXNlZCgpICYmIChjb25maWcubmV0d29ya01vZGUgPT09IFwiYWx3YXlzXCIgfHwgb25saW5lTWFuYWdlci5pc09ubGluZSgpKSAmJiBjb25maWcuY2FuUnVuKCk7XG4gIGNvbnN0IGNhblN0YXJ0ID0gKCkgPT4gY2FuRmV0Y2goY29uZmlnLm5ldHdvcmtNb2RlKSAmJiBjb25maWcuY2FuUnVuKCk7XG4gIGNvbnN0IHJlc29sdmUgPSAodmFsdWUpID0+IHtcbiAgICBpZiAoIWlzUmVzb2x2ZWQpIHtcbiAgICAgIGlzUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgY29uZmlnLm9uU3VjY2Vzcz8uKHZhbHVlKTtcbiAgICAgIGNvbnRpbnVlRm4/LigpO1xuICAgICAgcHJvbWlzZVJlc29sdmUodmFsdWUpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcmVqZWN0ID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKCFpc1Jlc29sdmVkKSB7XG4gICAgICBpc1Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgIGNvbmZpZy5vbkVycm9yPy4odmFsdWUpO1xuICAgICAgY29udGludWVGbj8uKCk7XG4gICAgICBwcm9taXNlUmVqZWN0KHZhbHVlKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHBhdXNlID0gKCkgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgoY29udGludWVSZXNvbHZlKSA9PiB7XG4gICAgICBjb250aW51ZUZuID0gKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmIChpc1Jlc29sdmVkIHx8IGNhbkNvbnRpbnVlKCkpIHtcbiAgICAgICAgICBjb250aW51ZVJlc29sdmUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uZmlnLm9uUGF1c2U/LigpO1xuICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgY29udGludWVGbiA9IHZvaWQgMDtcbiAgICAgIGlmICghaXNSZXNvbHZlZCkge1xuICAgICAgICBjb25maWcub25Db250aW51ZT8uKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHJ1biA9ICgpID0+IHtcbiAgICBpZiAoaXNSZXNvbHZlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgcHJvbWlzZU9yVmFsdWU7XG4gICAgY29uc3QgaW5pdGlhbFByb21pc2UgPSBmYWlsdXJlQ291bnQgPT09IDAgPyBjb25maWcuaW5pdGlhbFByb21pc2UgOiB2b2lkIDA7XG4gICAgdHJ5IHtcbiAgICAgIHByb21pc2VPclZhbHVlID0gaW5pdGlhbFByb21pc2UgPz8gY29uZmlnLmZuKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHByb21pc2VPclZhbHVlID0gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cbiAgICBQcm9taXNlLnJlc29sdmUocHJvbWlzZU9yVmFsdWUpLnRoZW4ocmVzb2x2ZSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICBpZiAoaXNSZXNvbHZlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByZXRyeSA9IGNvbmZpZy5yZXRyeSA/PyAoaXNTZXJ2ZXIgPyAwIDogMyk7XG4gICAgICBjb25zdCByZXRyeURlbGF5ID0gY29uZmlnLnJldHJ5RGVsYXkgPz8gZGVmYXVsdFJldHJ5RGVsYXk7XG4gICAgICBjb25zdCBkZWxheSA9IHR5cGVvZiByZXRyeURlbGF5ID09PSBcImZ1bmN0aW9uXCIgPyByZXRyeURlbGF5KGZhaWx1cmVDb3VudCwgZXJyb3IpIDogcmV0cnlEZWxheTtcbiAgICAgIGNvbnN0IHNob3VsZFJldHJ5ID0gcmV0cnkgPT09IHRydWUgfHwgdHlwZW9mIHJldHJ5ID09PSBcIm51bWJlclwiICYmIGZhaWx1cmVDb3VudCA8IHJldHJ5IHx8IHR5cGVvZiByZXRyeSA9PT0gXCJmdW5jdGlvblwiICYmIHJldHJ5KGZhaWx1cmVDb3VudCwgZXJyb3IpO1xuICAgICAgaWYgKGlzUmV0cnlDYW5jZWxsZWQgfHwgIXNob3VsZFJldHJ5KSB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZhaWx1cmVDb3VudCsrO1xuICAgICAgY29uZmlnLm9uRmFpbD8uKGZhaWx1cmVDb3VudCwgZXJyb3IpO1xuICAgICAgc2xlZXAoZGVsYXkpLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXR1cm4gY2FuQ29udGludWUoKSA/IHZvaWQgMCA6IHBhdXNlKCk7XG4gICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKGlzUmV0cnlDYW5jZWxsZWQpIHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJ1bigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBwcm9taXNlLFxuICAgIGNhbmNlbCxcbiAgICBjb250aW51ZTogKCkgPT4ge1xuICAgICAgY29udGludWVGbj8uKCk7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9LFxuICAgIGNhbmNlbFJldHJ5LFxuICAgIGNvbnRpbnVlUmV0cnksXG4gICAgY2FuU3RhcnQsXG4gICAgc3RhcnQ6ICgpID0+IHtcbiAgICAgIGlmIChjYW5TdGFydCgpKSB7XG4gICAgICAgIHJ1bigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF1c2UoKS50aGVuKHJ1bik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gIH07XG59XG5leHBvcnQge1xuICBDYW5jZWxsZWRFcnJvcixcbiAgY2FuRmV0Y2gsXG4gIGNyZWF0ZVJldHJ5ZXIsXG4gIGlzQ2FuY2VsbGVkRXJyb3Jcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXRyeWVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/@tanstack/query-core/build/modern/retryer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@tanstack/query-core/build/modern/subscribable.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/@tanstack/query-core/build/modern/subscribable.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Subscribable: function() { return /* binding */ Subscribable; }\n/* harmony export */ });\n// src/subscribable.ts\nvar Subscribable = class {\n  constructor() {\n    this.listeners = /* @__PURE__ */ new Set();\n    this.subscribe = this.subscribe.bind(this);\n  }\n  subscribe(listener) {\n    this.listeners.add(listener);\n    this.onSubscribe();\n    return () => {\n      this.listeners.delete(listener);\n      this.onUnsubscribe();\n    };\n  }\n  hasListeners() {\n    return this.listeners.size > 0;\n  }\n  onSubscribe() {\n  }\n  onUnsubscribe() {\n  }\n};\n\n//# sourceMappingURL=subscribable.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbW9kZXJuL3N1YnNjcmliYWJsZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbW9kZXJuL3N1YnNjcmliYWJsZS5qcz81NTcyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9zdWJzY3JpYmFibGUudHNcbnZhciBTdWJzY3JpYmFibGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLnN1YnNjcmliZSA9IHRoaXMuc3Vic2NyaWJlLmJpbmQodGhpcyk7XG4gIH1cbiAgc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICB0aGlzLm9uU3Vic2NyaWJlKCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRoaXMubGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgICB0aGlzLm9uVW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICB9XG4gIGhhc0xpc3RlbmVycygpIHtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lcnMuc2l6ZSA+IDA7XG4gIH1cbiAgb25TdWJzY3JpYmUoKSB7XG4gIH1cbiAgb25VbnN1YnNjcmliZSgpIHtcbiAgfVxufTtcbmV4cG9ydCB7XG4gIFN1YnNjcmliYWJsZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YnNjcmliYWJsZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/@tanstack/query-core/build/modern/subscribable.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@tanstack/query-core/build/modern/utils.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@tanstack/query-core/build/modern/utils.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addToEnd: function() { return /* binding */ addToEnd; },\n/* harmony export */   addToStart: function() { return /* binding */ addToStart; },\n/* harmony export */   ensureQueryFn: function() { return /* binding */ ensureQueryFn; },\n/* harmony export */   functionalUpdate: function() { return /* binding */ functionalUpdate; },\n/* harmony export */   hashKey: function() { return /* binding */ hashKey; },\n/* harmony export */   hashQueryKeyByOptions: function() { return /* binding */ hashQueryKeyByOptions; },\n/* harmony export */   isPlainArray: function() { return /* binding */ isPlainArray; },\n/* harmony export */   isPlainObject: function() { return /* binding */ isPlainObject; },\n/* harmony export */   isServer: function() { return /* binding */ isServer; },\n/* harmony export */   isValidTimeout: function() { return /* binding */ isValidTimeout; },\n/* harmony export */   keepPreviousData: function() { return /* binding */ keepPreviousData; },\n/* harmony export */   matchMutation: function() { return /* binding */ matchMutation; },\n/* harmony export */   matchQuery: function() { return /* binding */ matchQuery; },\n/* harmony export */   noop: function() { return /* binding */ noop; },\n/* harmony export */   partialMatchKey: function() { return /* binding */ partialMatchKey; },\n/* harmony export */   replaceData: function() { return /* binding */ replaceData; },\n/* harmony export */   replaceEqualDeep: function() { return /* binding */ replaceEqualDeep; },\n/* harmony export */   resolveEnabled: function() { return /* binding */ resolveEnabled; },\n/* harmony export */   resolveStaleTime: function() { return /* binding */ resolveStaleTime; },\n/* harmony export */   shallowEqualObjects: function() { return /* binding */ shallowEqualObjects; },\n/* harmony export */   skipToken: function() { return /* binding */ skipToken; },\n/* harmony export */   sleep: function() { return /* binding */ sleep; },\n/* harmony export */   timeUntilStale: function() { return /* binding */ timeUntilStale; }\n/* harmony export */ });\n// src/utils.ts\nvar isServer = typeof window === \"undefined\" || \"Deno\" in globalThis;\nfunction noop() {\n  return void 0;\n}\nfunction functionalUpdate(updater, input) {\n  return typeof updater === \"function\" ? updater(input) : updater;\n}\nfunction isValidTimeout(value) {\n  return typeof value === \"number\" && value >= 0 && value !== Infinity;\n}\nfunction timeUntilStale(updatedAt, staleTime) {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);\n}\nfunction resolveStaleTime(staleTime, query) {\n  return typeof staleTime === \"function\" ? staleTime(query) : staleTime;\n}\nfunction resolveEnabled(enabled, query) {\n  return typeof enabled === \"function\" ? enabled(query) : enabled;\n}\nfunction matchQuery(filters, query) {\n  const {\n    type = \"all\",\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale\n  } = filters;\n  if (queryKey) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false;\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false;\n    }\n  }\n  if (type !== \"all\") {\n    const isActive = query.isActive();\n    if (type === \"active\" && !isActive) {\n      return false;\n    }\n    if (type === \"inactive\" && isActive) {\n      return false;\n    }\n  }\n  if (typeof stale === \"boolean\" && query.isStale() !== stale) {\n    return false;\n  }\n  if (fetchStatus && fetchStatus !== query.state.fetchStatus) {\n    return false;\n  }\n  if (predicate && !predicate(query)) {\n    return false;\n  }\n  return true;\n}\nfunction matchMutation(filters, mutation) {\n  const { exact, status, predicate, mutationKey } = filters;\n  if (mutationKey) {\n    if (!mutation.options.mutationKey) {\n      return false;\n    }\n    if (exact) {\n      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {\n        return false;\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false;\n    }\n  }\n  if (status && mutation.state.status !== status) {\n    return false;\n  }\n  if (predicate && !predicate(mutation)) {\n    return false;\n  }\n  return true;\n}\nfunction hashQueryKeyByOptions(queryKey, options) {\n  const hashFn = options?.queryKeyHashFn || hashKey;\n  return hashFn(queryKey);\n}\nfunction hashKey(queryKey) {\n  return JSON.stringify(\n    queryKey,\n    (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {\n      result[key] = val[key];\n      return result;\n    }, {}) : val\n  );\n}\nfunction partialMatchKey(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (a && b && typeof a === \"object\" && typeof b === \"object\") {\n    return !Object.keys(b).some((key) => !partialMatchKey(a[key], b[key]));\n  }\n  return false;\n}\nfunction replaceEqualDeep(a, b) {\n  if (a === b) {\n    return a;\n  }\n  const array = isPlainArray(a) && isPlainArray(b);\n  if (array || isPlainObject(a) && isPlainObject(b)) {\n    const aItems = array ? a : Object.keys(a);\n    const aSize = aItems.length;\n    const bItems = array ? b : Object.keys(b);\n    const bSize = bItems.length;\n    const copy = array ? [] : {};\n    let equalItems = 0;\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i];\n      if ((!array && aItems.includes(key) || array) && a[key] === void 0 && b[key] === void 0) {\n        copy[key] = void 0;\n        equalItems++;\n      } else {\n        copy[key] = replaceEqualDeep(a[key], b[key]);\n        if (copy[key] === a[key] && a[key] !== void 0) {\n          equalItems++;\n        }\n      }\n    }\n    return aSize === bSize && equalItems === aSize ? a : copy;\n  }\n  return b;\n}\nfunction shallowEqualObjects(a, b) {\n  if (!b || Object.keys(a).length !== Object.keys(b).length) {\n    return false;\n  }\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isPlainArray(value) {\n  return Array.isArray(value) && value.length === Object.keys(value).length;\n}\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  }\n  const ctor = o.constructor;\n  if (ctor === void 0) {\n    return true;\n  }\n  const prot = ctor.prototype;\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  }\n  if (!prot.hasOwnProperty(\"isPrototypeOf\")) {\n    return false;\n  }\n  if (Object.getPrototypeOf(o) !== Object.prototype) {\n    return false;\n  }\n  return true;\n}\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === \"[object Object]\";\n}\nfunction sleep(timeout) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, timeout);\n  });\n}\nfunction replaceData(prevData, data, options) {\n  if (typeof options.structuralSharing === \"function\") {\n    return options.structuralSharing(prevData, data);\n  } else if (options.structuralSharing !== false) {\n    if (true) {\n      try {\n        JSON.stringify(prevData);\n        JSON.stringify(data);\n      } catch (error) {\n        console.error(\n          `StructuralSharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${options.queryHash}]: ${error}`\n        );\n      }\n    }\n    return replaceEqualDeep(prevData, data);\n  }\n  return data;\n}\nfunction keepPreviousData(previousData) {\n  return previousData;\n}\nfunction addToEnd(items, item, max = 0) {\n  const newItems = [...items, item];\n  return max && newItems.length > max ? newItems.slice(1) : newItems;\n}\nfunction addToStart(items, item, max = 0) {\n  const newItems = [item, ...items];\n  return max && newItems.length > max ? newItems.slice(0, -1) : newItems;\n}\nvar skipToken = Symbol();\nfunction ensureQueryFn(options, fetchOptions) {\n  if (true) {\n    if (options.queryFn === skipToken) {\n      console.error(\n        `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${options.queryHash}'`\n      );\n    }\n  }\n  if (!options.queryFn && fetchOptions?.initialPromise) {\n    return () => fetchOptions.initialPromise;\n  }\n  if (!options.queryFn || options.queryFn === skipToken) {\n    return () => Promise.reject(new Error(`Missing queryFn: '${options.queryHash}'`));\n  }\n  return options.queryFn;\n}\n\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbW9kZXJuL3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHdDQUF3QztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsbUtBQW1LLGtCQUFrQixLQUFLLE1BQU07QUFDaE07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBLGlIQUFpSCxrQkFBa0I7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Qsa0JBQWtCO0FBQ2pGO0FBQ0E7QUFDQTtBQXlCRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbW9kZXJuL3V0aWxzLmpzP2JlMTEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3V0aWxzLnRzXG52YXIgaXNTZXJ2ZXIgPSB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8IFwiRGVub1wiIGluIGdsb2JhbFRoaXM7XG5mdW5jdGlvbiBub29wKCkge1xuICByZXR1cm4gdm9pZCAwO1xufVxuZnVuY3Rpb24gZnVuY3Rpb25hbFVwZGF0ZSh1cGRhdGVyLCBpbnB1dCkge1xuICByZXR1cm4gdHlwZW9mIHVwZGF0ZXIgPT09IFwiZnVuY3Rpb25cIiA/IHVwZGF0ZXIoaW5wdXQpIDogdXBkYXRlcjtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRUaW1lb3V0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgdmFsdWUgPj0gMCAmJiB2YWx1ZSAhPT0gSW5maW5pdHk7XG59XG5mdW5jdGlvbiB0aW1lVW50aWxTdGFsZSh1cGRhdGVkQXQsIHN0YWxlVGltZSkge1xuICByZXR1cm4gTWF0aC5tYXgodXBkYXRlZEF0ICsgKHN0YWxlVGltZSB8fCAwKSAtIERhdGUubm93KCksIDApO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVN0YWxlVGltZShzdGFsZVRpbWUsIHF1ZXJ5KSB7XG4gIHJldHVybiB0eXBlb2Ygc3RhbGVUaW1lID09PSBcImZ1bmN0aW9uXCIgPyBzdGFsZVRpbWUocXVlcnkpIDogc3RhbGVUaW1lO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUVuYWJsZWQoZW5hYmxlZCwgcXVlcnkpIHtcbiAgcmV0dXJuIHR5cGVvZiBlbmFibGVkID09PSBcImZ1bmN0aW9uXCIgPyBlbmFibGVkKHF1ZXJ5KSA6IGVuYWJsZWQ7XG59XG5mdW5jdGlvbiBtYXRjaFF1ZXJ5KGZpbHRlcnMsIHF1ZXJ5KSB7XG4gIGNvbnN0IHtcbiAgICB0eXBlID0gXCJhbGxcIixcbiAgICBleGFjdCxcbiAgICBmZXRjaFN0YXR1cyxcbiAgICBwcmVkaWNhdGUsXG4gICAgcXVlcnlLZXksXG4gICAgc3RhbGVcbiAgfSA9IGZpbHRlcnM7XG4gIGlmIChxdWVyeUtleSkge1xuICAgIGlmIChleGFjdCkge1xuICAgICAgaWYgKHF1ZXJ5LnF1ZXJ5SGFzaCAhPT0gaGFzaFF1ZXJ5S2V5QnlPcHRpb25zKHF1ZXJ5S2V5LCBxdWVyeS5vcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghcGFydGlhbE1hdGNoS2V5KHF1ZXJ5LnF1ZXJ5S2V5LCBxdWVyeUtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGUgIT09IFwiYWxsXCIpIHtcbiAgICBjb25zdCBpc0FjdGl2ZSA9IHF1ZXJ5LmlzQWN0aXZlKCk7XG4gICAgaWYgKHR5cGUgPT09IFwiYWN0aXZlXCIgJiYgIWlzQWN0aXZlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcImluYWN0aXZlXCIgJiYgaXNBY3RpdmUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBzdGFsZSA9PT0gXCJib29sZWFuXCIgJiYgcXVlcnkuaXNTdGFsZSgpICE9PSBzdGFsZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZmV0Y2hTdGF0dXMgJiYgZmV0Y2hTdGF0dXMgIT09IHF1ZXJ5LnN0YXRlLmZldGNoU3RhdHVzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChwcmVkaWNhdGUgJiYgIXByZWRpY2F0ZShxdWVyeSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBtYXRjaE11dGF0aW9uKGZpbHRlcnMsIG11dGF0aW9uKSB7XG4gIGNvbnN0IHsgZXhhY3QsIHN0YXR1cywgcHJlZGljYXRlLCBtdXRhdGlvbktleSB9ID0gZmlsdGVycztcbiAgaWYgKG11dGF0aW9uS2V5KSB7XG4gICAgaWYgKCFtdXRhdGlvbi5vcHRpb25zLm11dGF0aW9uS2V5KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChleGFjdCkge1xuICAgICAgaWYgKGhhc2hLZXkobXV0YXRpb24ub3B0aW9ucy5tdXRhdGlvbktleSkgIT09IGhhc2hLZXkobXV0YXRpb25LZXkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFwYXJ0aWFsTWF0Y2hLZXkobXV0YXRpb24ub3B0aW9ucy5tdXRhdGlvbktleSwgbXV0YXRpb25LZXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChzdGF0dXMgJiYgbXV0YXRpb24uc3RhdGUuc3RhdHVzICE9PSBzdGF0dXMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHByZWRpY2F0ZSAmJiAhcHJlZGljYXRlKG11dGF0aW9uKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGhhc2hRdWVyeUtleUJ5T3B0aW9ucyhxdWVyeUtleSwgb3B0aW9ucykge1xuICBjb25zdCBoYXNoRm4gPSBvcHRpb25zPy5xdWVyeUtleUhhc2hGbiB8fCBoYXNoS2V5O1xuICByZXR1cm4gaGFzaEZuKHF1ZXJ5S2V5KTtcbn1cbmZ1bmN0aW9uIGhhc2hLZXkocXVlcnlLZXkpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFxuICAgIHF1ZXJ5S2V5LFxuICAgIChfLCB2YWwpID0+IGlzUGxhaW5PYmplY3QodmFsKSA/IE9iamVjdC5rZXlzKHZhbCkuc29ydCgpLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsW2tleV07XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIHt9KSA6IHZhbFxuICApO1xufVxuZnVuY3Rpb24gcGFydGlhbE1hdGNoS2V5KGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZW9mIGEgIT09IHR5cGVvZiBiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChhICYmIGIgJiYgdHlwZW9mIGEgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGIgPT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gIU9iamVjdC5rZXlzKGIpLnNvbWUoKGtleSkgPT4gIXBhcnRpYWxNYXRjaEtleShhW2tleV0sIGJba2V5XSkpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VFcXVhbERlZXAoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiBhO1xuICB9XG4gIGNvbnN0IGFycmF5ID0gaXNQbGFpbkFycmF5KGEpICYmIGlzUGxhaW5BcnJheShiKTtcbiAgaWYgKGFycmF5IHx8IGlzUGxhaW5PYmplY3QoYSkgJiYgaXNQbGFpbk9iamVjdChiKSkge1xuICAgIGNvbnN0IGFJdGVtcyA9IGFycmF5ID8gYSA6IE9iamVjdC5rZXlzKGEpO1xuICAgIGNvbnN0IGFTaXplID0gYUl0ZW1zLmxlbmd0aDtcbiAgICBjb25zdCBiSXRlbXMgPSBhcnJheSA/IGIgOiBPYmplY3Qua2V5cyhiKTtcbiAgICBjb25zdCBiU2l6ZSA9IGJJdGVtcy5sZW5ndGg7XG4gICAgY29uc3QgY29weSA9IGFycmF5ID8gW10gOiB7fTtcbiAgICBsZXQgZXF1YWxJdGVtcyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiU2l6ZTsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSBhcnJheSA/IGkgOiBiSXRlbXNbaV07XG4gICAgICBpZiAoKCFhcnJheSAmJiBhSXRlbXMuaW5jbHVkZXMoa2V5KSB8fCBhcnJheSkgJiYgYVtrZXldID09PSB2b2lkIDAgJiYgYltrZXldID09PSB2b2lkIDApIHtcbiAgICAgICAgY29weVtrZXldID0gdm9pZCAwO1xuICAgICAgICBlcXVhbEl0ZW1zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb3B5W2tleV0gPSByZXBsYWNlRXF1YWxEZWVwKGFba2V5XSwgYltrZXldKTtcbiAgICAgICAgaWYgKGNvcHlba2V5XSA9PT0gYVtrZXldICYmIGFba2V5XSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgZXF1YWxJdGVtcysrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhU2l6ZSA9PT0gYlNpemUgJiYgZXF1YWxJdGVtcyA9PT0gYVNpemUgPyBhIDogY29weTtcbiAgfVxuICByZXR1cm4gYjtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbE9iamVjdHMoYSwgYikge1xuICBpZiAoIWIgfHwgT2JqZWN0LmtleXMoYSkubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gYSkge1xuICAgIGlmIChhW2tleV0gIT09IGJba2V5XSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGlzUGxhaW5BcnJheSh2YWx1ZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoO1xufVxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvKSB7XG4gIGlmICghaGFzT2JqZWN0UHJvdG90eXBlKG8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGN0b3IgPSBvLmNvbnN0cnVjdG9yO1xuICBpZiAoY3RvciA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgcHJvdCA9IGN0b3IucHJvdG90eXBlO1xuICBpZiAoIWhhc09iamVjdFByb3RvdHlwZShwcm90KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIXByb3QuaGFzT3duUHJvcGVydHkoXCJpc1Byb3RvdHlwZU9mXCIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YobykgIT09IE9iamVjdC5wcm90b3R5cGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBoYXNPYmplY3RQcm90b3R5cGUobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pID09PSBcIltvYmplY3QgT2JqZWN0XVwiO1xufVxuZnVuY3Rpb24gc2xlZXAodGltZW91dCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWVvdXQpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VEYXRhKHByZXZEYXRhLCBkYXRhLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5zdHJ1Y3R1cmFsU2hhcmluZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuc3RydWN0dXJhbFNoYXJpbmcocHJldkRhdGEsIGRhdGEpO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMuc3RydWN0dXJhbFNoYXJpbmcgIT09IGZhbHNlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkocHJldkRhdGEpO1xuICAgICAgICBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgYFN0cnVjdHVyYWxTaGFyaW5nIHJlcXVpcmVzIGRhdGEgdG8gYmUgSlNPTiBzZXJpYWxpemFibGUuIFRvIGZpeCB0aGlzLCB0dXJuIG9mZiBzdHJ1Y3R1cmFsU2hhcmluZyBvciByZXR1cm4gSlNPTi1zZXJpYWxpemFibGUgZGF0YSBmcm9tIHlvdXIgcXVlcnlGbi4gWyR7b3B0aW9ucy5xdWVyeUhhc2h9XTogJHtlcnJvcn1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXBsYWNlRXF1YWxEZWVwKHByZXZEYXRhLCBkYXRhKTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cbmZ1bmN0aW9uIGtlZXBQcmV2aW91c0RhdGEocHJldmlvdXNEYXRhKSB7XG4gIHJldHVybiBwcmV2aW91c0RhdGE7XG59XG5mdW5jdGlvbiBhZGRUb0VuZChpdGVtcywgaXRlbSwgbWF4ID0gMCkge1xuICBjb25zdCBuZXdJdGVtcyA9IFsuLi5pdGVtcywgaXRlbV07XG4gIHJldHVybiBtYXggJiYgbmV3SXRlbXMubGVuZ3RoID4gbWF4ID8gbmV3SXRlbXMuc2xpY2UoMSkgOiBuZXdJdGVtcztcbn1cbmZ1bmN0aW9uIGFkZFRvU3RhcnQoaXRlbXMsIGl0ZW0sIG1heCA9IDApIHtcbiAgY29uc3QgbmV3SXRlbXMgPSBbaXRlbSwgLi4uaXRlbXNdO1xuICByZXR1cm4gbWF4ICYmIG5ld0l0ZW1zLmxlbmd0aCA+IG1heCA/IG5ld0l0ZW1zLnNsaWNlKDAsIC0xKSA6IG5ld0l0ZW1zO1xufVxudmFyIHNraXBUb2tlbiA9IFN5bWJvbCgpO1xuZnVuY3Rpb24gZW5zdXJlUXVlcnlGbihvcHRpb25zLCBmZXRjaE9wdGlvbnMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmIChvcHRpb25zLnF1ZXJ5Rm4gPT09IHNraXBUb2tlbikge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgYEF0dGVtcHRlZCB0byBpbnZva2UgcXVlcnlGbiB3aGVuIHNldCB0byBza2lwVG9rZW4uIFRoaXMgaXMgbGlrZWx5IGEgY29uZmlndXJhdGlvbiBlcnJvci4gUXVlcnkgaGFzaDogJyR7b3B0aW9ucy5xdWVyeUhhc2h9J2BcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmICghb3B0aW9ucy5xdWVyeUZuICYmIGZldGNoT3B0aW9ucz8uaW5pdGlhbFByb21pc2UpIHtcbiAgICByZXR1cm4gKCkgPT4gZmV0Y2hPcHRpb25zLmluaXRpYWxQcm9taXNlO1xuICB9XG4gIGlmICghb3B0aW9ucy5xdWVyeUZuIHx8IG9wdGlvbnMucXVlcnlGbiA9PT0gc2tpcFRva2VuKSB7XG4gICAgcmV0dXJuICgpID0+IFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgTWlzc2luZyBxdWVyeUZuOiAnJHtvcHRpb25zLnF1ZXJ5SGFzaH0nYCkpO1xuICB9XG4gIHJldHVybiBvcHRpb25zLnF1ZXJ5Rm47XG59XG5leHBvcnQge1xuICBhZGRUb0VuZCxcbiAgYWRkVG9TdGFydCxcbiAgZW5zdXJlUXVlcnlGbixcbiAgZnVuY3Rpb25hbFVwZGF0ZSxcbiAgaGFzaEtleSxcbiAgaGFzaFF1ZXJ5S2V5QnlPcHRpb25zLFxuICBpc1BsYWluQXJyYXksXG4gIGlzUGxhaW5PYmplY3QsXG4gIGlzU2VydmVyLFxuICBpc1ZhbGlkVGltZW91dCxcbiAga2VlcFByZXZpb3VzRGF0YSxcbiAgbWF0Y2hNdXRhdGlvbixcbiAgbWF0Y2hRdWVyeSxcbiAgbm9vcCxcbiAgcGFydGlhbE1hdGNoS2V5LFxuICByZXBsYWNlRGF0YSxcbiAgcmVwbGFjZUVxdWFsRGVlcCxcbiAgcmVzb2x2ZUVuYWJsZWQsXG4gIHJlc29sdmVTdGFsZVRpbWUsXG4gIHNoYWxsb3dFcXVhbE9iamVjdHMsXG4gIHNraXBUb2tlbixcbiAgc2xlZXAsXG4gIHRpbWVVbnRpbFN0YWxlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/@tanstack/query-core/build/modern/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueryClientContext: function() { return /* binding */ QueryClientContext; },\n/* harmony export */   QueryClientProvider: function() { return /* binding */ QueryClientProvider; },\n/* harmony export */   useQueryClient: function() { return /* binding */ useQueryClient; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\n/* __next_internal_client_entry_do_not_use__ QueryClientContext,QueryClientProvider,useQueryClient auto */ var _s = $RefreshSig$(), _s1 = $RefreshSig$();\n// src/QueryClientProvider.tsx\n\n\nvar QueryClientContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(void 0);\nvar useQueryClient = (queryClient)=>{\n    _s();\n    const client = react__WEBPACK_IMPORTED_MODULE_0__.useContext(QueryClientContext);\n    if (queryClient) {\n        return queryClient;\n    }\n    if (!client) {\n        throw new Error(\"No QueryClient set, use QueryClientProvider to set one\");\n    }\n    return client;\n};\n_s(useQueryClient, \"6C1IqtdJdCPZ/voWsX/6r3Oc32M=\");\nvar QueryClientProvider = (param)=>{\n    let { client, children } = param;\n    _s1();\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        client.mount();\n        return ()=>{\n            client.unmount();\n        };\n    }, [\n        client\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(QueryClientContext.Provider, {\n        value: client,\n        children\n    });\n};\n_s1(QueryClientProvider, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n_c = QueryClientProvider;\n //# sourceMappingURL=QueryClientProvider.js.map\nvar _c;\n$RefreshReg$(_c, \"QueryClientProvider\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXF1ZXJ5L2J1aWxkL21vZGVybi9RdWVyeUNsaWVudFByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFDdUI7QUF1Q25CO0FBbkNHLElBQU1FLG1DQUEyQkYsZ0RBQUEsQ0FDdEM7QUFHSyxJQUFNSSxpQkFBaUIsQ0FBQ0M7O0lBQzdCLE1BQU1DLFNBQWVOLDZDQUFBLENBQVdFO0lBRWhDLElBQUlHLGFBQWE7UUFDZixPQUFPQTtJQUNUO0lBRUEsSUFBSSxDQUFDQyxRQUFRO1FBQ1gsTUFBTSxJQUFJRSxNQUFNO0lBQ2xCO0lBRUEsT0FBT0Y7QUFDVDtHQVphRjtBQW1CTixJQUFNSyxzQkFBc0I7UUFBQyxFQUNsQ0gsTUFBQSxFQUNBSSxRQUFBLEVBQ0Y7O0lBQ1FWLDRDQUFBLENBQVU7UUFDZE0sT0FBT00sS0FBQTtRQUNQLE9BQU87WUFDTE4sT0FBT08sT0FBQTtRQUNUO0lBQ0YsR0FBRztRQUFDUDtLQUFPO0lBRVgsT0FDRSxnQkFBQUwsc0RBQUFBLENBQUNDLG1CQUFtQlksUUFBQSxFQUFuQjtRQUE0QkMsT0FBT1Q7UUFDakNJO0lBQUE7QUFHUDtJQWhCYUQ7S0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3NyYy9RdWVyeUNsaWVudFByb3ZpZGVyLnRzeD85OWVjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnXG5cbmltcG9ydCB0eXBlIHsgUXVlcnlDbGllbnQgfSBmcm9tICdAdGFuc3RhY2svcXVlcnktY29yZSdcblxuZXhwb3J0IGNvbnN0IFF1ZXJ5Q2xpZW50Q29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8UXVlcnlDbGllbnQgfCB1bmRlZmluZWQ+KFxuICB1bmRlZmluZWQsXG4pXG5cbmV4cG9ydCBjb25zdCB1c2VRdWVyeUNsaWVudCA9IChxdWVyeUNsaWVudD86IFF1ZXJ5Q2xpZW50KSA9PiB7XG4gIGNvbnN0IGNsaWVudCA9IFJlYWN0LnVzZUNvbnRleHQoUXVlcnlDbGllbnRDb250ZXh0KVxuXG4gIGlmIChxdWVyeUNsaWVudCkge1xuICAgIHJldHVybiBxdWVyeUNsaWVudFxuICB9XG5cbiAgaWYgKCFjbGllbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIFF1ZXJ5Q2xpZW50IHNldCwgdXNlIFF1ZXJ5Q2xpZW50UHJvdmlkZXIgdG8gc2V0IG9uZScpXG4gIH1cblxuICByZXR1cm4gY2xpZW50XG59XG5cbmV4cG9ydCB0eXBlIFF1ZXJ5Q2xpZW50UHJvdmlkZXJQcm9wcyA9IHtcbiAgY2xpZW50OiBRdWVyeUNsaWVudFxuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZVxufVxuXG5leHBvcnQgY29uc3QgUXVlcnlDbGllbnRQcm92aWRlciA9ICh7XG4gIGNsaWVudCxcbiAgY2hpbGRyZW4sXG59OiBRdWVyeUNsaWVudFByb3ZpZGVyUHJvcHMpOiBSZWFjdC5KU1guRWxlbWVudCA9PiB7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY2xpZW50Lm1vdW50KClcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xpZW50LnVubW91bnQoKVxuICAgIH1cbiAgfSwgW2NsaWVudF0pXG5cbiAgcmV0dXJuIChcbiAgICA8UXVlcnlDbGllbnRDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtjbGllbnR9PlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvUXVlcnlDbGllbnRDb250ZXh0LlByb3ZpZGVyPlxuICApXG59XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJqc3giLCJRdWVyeUNsaWVudENvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwidXNlUXVlcnlDbGllbnQiLCJxdWVyeUNsaWVudCIsImNsaWVudCIsInVzZUNvbnRleHQiLCJFcnJvciIsIlF1ZXJ5Q2xpZW50UHJvdmlkZXIiLCJjaGlsZHJlbiIsInVzZUVmZmVjdCIsIm1vdW50IiwidW5tb3VudCIsIlByb3ZpZGVyIiwidmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@tanstack/react-query/build/modern/QueryErrorResetBoundary.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/@tanstack/react-query/build/modern/QueryErrorResetBoundary.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueryErrorResetBoundary: function() { return /* binding */ QueryErrorResetBoundary; },\n/* harmony export */   useQueryErrorResetBoundary: function() { return /* binding */ useQueryErrorResetBoundary; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\n/* __next_internal_client_entry_do_not_use__ QueryErrorResetBoundary,useQueryErrorResetBoundary auto */ var _s = $RefreshSig$(), _s1 = $RefreshSig$();\n// src/QueryErrorResetBoundary.tsx\n\n\nfunction createValue() {\n    let isReset = false;\n    return {\n        clearReset: ()=>{\n            isReset = false;\n        },\n        reset: ()=>{\n            isReset = true;\n        },\n        isReset: ()=>{\n            return isReset;\n        }\n    };\n}\nvar QueryErrorResetBoundaryContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(createValue());\nvar useQueryErrorResetBoundary = ()=>{\n    _s();\n    return react__WEBPACK_IMPORTED_MODULE_0__.useContext(QueryErrorResetBoundaryContext);\n};\n_s(useQueryErrorResetBoundary, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nvar QueryErrorResetBoundary = (param)=>{\n    let { children } = param;\n    _s1();\n    const [value] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>createValue());\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(QueryErrorResetBoundaryContext.Provider, {\n        value,\n        children: typeof children === \"function\" ? children(value) : children\n    });\n};\n_s1(QueryErrorResetBoundary, \"L9UPBb11nR62tM6xIubumSAcs3Y=\");\n_c = QueryErrorResetBoundary;\n //# sourceMappingURL=QueryErrorResetBoundary.js.map\nvar _c;\n$RefreshReg$(_c, \"QueryErrorResetBoundary\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXF1ZXJ5L2J1aWxkL21vZGVybi9RdWVyeUVycm9yUmVzZXRCb3VuZGFyeS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFDdUI7QUE2Q25CO0FBbkNKLFNBQVNFO0lBQ1AsSUFBSUMsVUFBVTtJQUNkLE9BQU87UUFDTEMsWUFBWTtZQUNWRCxVQUFVO1FBQ1o7UUFDQUUsT0FBTztZQUNMRixVQUFVO1FBQ1o7UUFDQUEsU0FBUztZQUNQLE9BQU9BO1FBQ1Q7SUFDRjtBQUNGO0FBRUEsSUFBTUcsK0NBQXVDTixnREFBQSxDQUFjRTtBQUlwRCxJQUFNTSw2QkFBNkI7O0lBQ2xDUixPQUFBQSw2Q0FBQSxDQUFXTTtBQUE4QjtHQURwQ0U7QUFXTixJQUFNRSwwQkFBMEI7UUFBQyxFQUN0Q0MsUUFBQSxFQUNGOztJQUNFLE1BQU0sQ0FBQ0MsTUFBSyxHQUFVWiwyQ0FBQSxDQUFTLElBQU1FO0lBQ3JDLE9BQ0UsZ0JBQUFELHNEQUFBQSxDQUFDSywrQkFBK0JRLFFBQUEsRUFBL0I7UUFBd0NGO1FBQ3RDRCxVQUFBLE9BQU9BLGFBQWEsYUFDaEJBLFNBQXNCQyxTQUN2QkQ7SUFBQTtBQUdWO0lBWGFEO0tBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9zcmMvUXVlcnlFcnJvclJlc2V0Qm91bmRhcnkudHN4P2VhNWQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCdcblxuLy8gQ09OVEVYVFxuXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXJ5RXJyb3JSZXNldEJvdW5kYXJ5VmFsdWUge1xuICBjbGVhclJlc2V0OiAoKSA9PiB2b2lkXG4gIGlzUmVzZXQ6ICgpID0+IGJvb2xlYW5cbiAgcmVzZXQ6ICgpID0+IHZvaWRcbn1cblxuZnVuY3Rpb24gY3JlYXRlVmFsdWUoKTogUXVlcnlFcnJvclJlc2V0Qm91bmRhcnlWYWx1ZSB7XG4gIGxldCBpc1Jlc2V0ID0gZmFsc2VcbiAgcmV0dXJuIHtcbiAgICBjbGVhclJlc2V0OiAoKSA9PiB7XG4gICAgICBpc1Jlc2V0ID0gZmFsc2VcbiAgICB9LFxuICAgIHJlc2V0OiAoKSA9PiB7XG4gICAgICBpc1Jlc2V0ID0gdHJ1ZVxuICAgIH0sXG4gICAgaXNSZXNldDogKCkgPT4ge1xuICAgICAgcmV0dXJuIGlzUmVzZXRcbiAgICB9LFxuICB9XG59XG5cbmNvbnN0IFF1ZXJ5RXJyb3JSZXNldEJvdW5kYXJ5Q29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoY3JlYXRlVmFsdWUoKSlcblxuLy8gSE9PS1xuXG5leHBvcnQgY29uc3QgdXNlUXVlcnlFcnJvclJlc2V0Qm91bmRhcnkgPSAoKSA9PlxuICBSZWFjdC51c2VDb250ZXh0KFF1ZXJ5RXJyb3JSZXNldEJvdW5kYXJ5Q29udGV4dClcblxuLy8gQ09NUE9ORU5UXG5cbmV4cG9ydCBpbnRlcmZhY2UgUXVlcnlFcnJvclJlc2V0Qm91bmRhcnlQcm9wcyB7XG4gIGNoaWxkcmVuOlxuICAgIHwgKCh2YWx1ZTogUXVlcnlFcnJvclJlc2V0Qm91bmRhcnlWYWx1ZSkgPT4gUmVhY3QuUmVhY3ROb2RlKVxuICAgIHwgUmVhY3QuUmVhY3ROb2RlXG59XG5cbmV4cG9ydCBjb25zdCBRdWVyeUVycm9yUmVzZXRCb3VuZGFyeSA9ICh7XG4gIGNoaWxkcmVuLFxufTogUXVlcnlFcnJvclJlc2V0Qm91bmRhcnlQcm9wcykgPT4ge1xuICBjb25zdCBbdmFsdWVdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gY3JlYXRlVmFsdWUoKSlcbiAgcmV0dXJuIChcbiAgICA8UXVlcnlFcnJvclJlc2V0Qm91bmRhcnlDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt2YWx1ZX0+XG4gICAgICB7dHlwZW9mIGNoaWxkcmVuID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gKGNoaWxkcmVuIGFzIEZ1bmN0aW9uKSh2YWx1ZSlcbiAgICAgICAgOiBjaGlsZHJlbn1cbiAgICA8L1F1ZXJ5RXJyb3JSZXNldEJvdW5kYXJ5Q29udGV4dC5Qcm92aWRlcj5cbiAgKVxufVxuIl0sIm5hbWVzIjpbIlJlYWN0IiwianN4IiwiY3JlYXRlVmFsdWUiLCJpc1Jlc2V0IiwiY2xlYXJSZXNldCIsInJlc2V0IiwiUXVlcnlFcnJvclJlc2V0Qm91bmRhcnlDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsInVzZVF1ZXJ5RXJyb3JSZXNldEJvdW5kYXJ5IiwidXNlQ29udGV4dCIsIlF1ZXJ5RXJyb3JSZXNldEJvdW5kYXJ5IiwiY2hpbGRyZW4iLCJ2YWx1ZSIsInVzZVN0YXRlIiwiUHJvdmlkZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/@tanstack/react-query/build/modern/QueryErrorResetBoundary.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@tanstack/react-query/build/modern/errorBoundaryUtils.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/@tanstack/react-query/build/modern/errorBoundaryUtils.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ensurePreventErrorBoundaryRetry: function() { return /* binding */ ensurePreventErrorBoundaryRetry; },\n/* harmony export */   getHasError: function() { return /* binding */ getHasError; },\n/* harmony export */   useClearResetErrorBoundary: function() { return /* binding */ useClearResetErrorBoundary; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../../node_modules/@tanstack/react-query/build/modern/utils.js\");\n/* __next_internal_client_entry_do_not_use__ ensurePreventErrorBoundaryRetry,getHasError,useClearResetErrorBoundary auto */ var _s = $RefreshSig$();\n// src/errorBoundaryUtils.ts\n\n\nvar ensurePreventErrorBoundaryRetry = (options, errorResetBoundary)=>{\n    if (options.suspense || options.throwOnError) {\n        if (!errorResetBoundary.isReset()) {\n            options.retryOnMount = false;\n        }\n    }\n};\nvar useClearResetErrorBoundary = (errorResetBoundary)=>{\n    _s();\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        errorResetBoundary.clearReset();\n    }, [\n        errorResetBoundary\n    ]);\n};\n_s(useClearResetErrorBoundary, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\nvar getHasError = (param)=>{\n    let { result, errorResetBoundary, throwOnError, query } = param;\n    return result.isError && !errorResetBoundary.isReset() && !result.isFetching && query && (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.shouldThrowError)(throwOnError, [\n        result.error,\n        query\n    ]);\n};\n //# sourceMappingURL=errorBoundaryUtils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXF1ZXJ5L2J1aWxkL21vZGVybi9lcnJvckJvdW5kYXJ5VXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUN1QjtBQUNVO0FBVTFCLElBQU1FLGtDQUFrQyxDQU83Q0MsU0FPQUM7SUFFQSxJQUFJRCxRQUFRRSxRQUFBLElBQVlGLFFBQVFHLFlBQUEsRUFBYztRQUU1QyxJQUFJLENBQUNGLG1CQUFtQkcsT0FBQSxJQUFXO1lBQ2pDSixRQUFRSyxZQUFBLEdBQWU7UUFDekI7SUFDRjtBQUNGO0FBRU8sSUFBTUMsNkJBQTZCLENBQ3hDTDs7SUFFTUosNENBQUEsQ0FBVTtRQUNkSSxtQkFBbUJPLFVBQUE7SUFDckIsR0FBRztRQUFDUDtLQUFtQjtBQUN6QjtHQU5hSztBQVFOLElBQU1HLGNBQWM7UUFNekIsRUFDQUMsTUFBQSxFQUNBVCxrQkFBQSxFQUNBRSxZQUFBLEVBQ0FRLEtBQUEsRUFDRjtJQU1FLE9BQ0VELE9BQU9FLE9BQUEsSUFDUCxDQUFDWCxtQkFBbUJHLE9BQUEsTUFDcEIsQ0FBQ00sT0FBT0csVUFBQSxJQUNSRixTQUNBYiwyREFBZ0JBLENBQUNLLGNBQWM7UUFBQ08sT0FBT0ksS0FBQTtRQUFPSDtLQUFNO0FBRXhEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9zcmMvZXJyb3JCb3VuZGFyeVV0aWxzLnRzPzljMmMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB7IHNob3VsZFRocm93RXJyb3IgfSBmcm9tICcuL3V0aWxzJ1xuaW1wb3J0IHR5cGUge1xuICBEZWZhdWx0ZWRRdWVyeU9ic2VydmVyT3B0aW9ucyxcbiAgUXVlcnksXG4gIFF1ZXJ5S2V5LFxuICBRdWVyeU9ic2VydmVyUmVzdWx0LFxuICBUaHJvd09uRXJyb3IsXG59IGZyb20gJ0B0YW5zdGFjay9xdWVyeS1jb3JlJ1xuaW1wb3J0IHR5cGUgeyBRdWVyeUVycm9yUmVzZXRCb3VuZGFyeVZhbHVlIH0gZnJvbSAnLi9RdWVyeUVycm9yUmVzZXRCb3VuZGFyeSdcblxuZXhwb3J0IGNvbnN0IGVuc3VyZVByZXZlbnRFcnJvckJvdW5kYXJ5UmV0cnkgPSA8XG4gIFRRdWVyeUZuRGF0YSxcbiAgVEVycm9yLFxuICBURGF0YSxcbiAgVFF1ZXJ5RGF0YSxcbiAgVFF1ZXJ5S2V5IGV4dGVuZHMgUXVlcnlLZXksXG4+KFxuICBvcHRpb25zOiBEZWZhdWx0ZWRRdWVyeU9ic2VydmVyT3B0aW9uczxcbiAgICBUUXVlcnlGbkRhdGEsXG4gICAgVEVycm9yLFxuICAgIFREYXRhLFxuICAgIFRRdWVyeURhdGEsXG4gICAgVFF1ZXJ5S2V5XG4gID4sXG4gIGVycm9yUmVzZXRCb3VuZGFyeTogUXVlcnlFcnJvclJlc2V0Qm91bmRhcnlWYWx1ZSxcbikgPT4ge1xuICBpZiAob3B0aW9ucy5zdXNwZW5zZSB8fCBvcHRpb25zLnRocm93T25FcnJvcikge1xuICAgIC8vIFByZXZlbnQgcmV0cnlpbmcgZmFpbGVkIHF1ZXJ5IGlmIHRoZSBlcnJvciBib3VuZGFyeSBoYXMgbm90IGJlZW4gcmVzZXQgeWV0XG4gICAgaWYgKCFlcnJvclJlc2V0Qm91bmRhcnkuaXNSZXNldCgpKSB7XG4gICAgICBvcHRpb25zLnJldHJ5T25Nb3VudCA9IGZhbHNlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCB1c2VDbGVhclJlc2V0RXJyb3JCb3VuZGFyeSA9IChcbiAgZXJyb3JSZXNldEJvdW5kYXJ5OiBRdWVyeUVycm9yUmVzZXRCb3VuZGFyeVZhbHVlLFxuKSA9PiB7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgZXJyb3JSZXNldEJvdW5kYXJ5LmNsZWFyUmVzZXQoKVxuICB9LCBbZXJyb3JSZXNldEJvdW5kYXJ5XSlcbn1cblxuZXhwb3J0IGNvbnN0IGdldEhhc0Vycm9yID0gPFxuICBURGF0YSxcbiAgVEVycm9yLFxuICBUUXVlcnlGbkRhdGEsXG4gIFRRdWVyeURhdGEsXG4gIFRRdWVyeUtleSBleHRlbmRzIFF1ZXJ5S2V5LFxuPih7XG4gIHJlc3VsdCxcbiAgZXJyb3JSZXNldEJvdW5kYXJ5LFxuICB0aHJvd09uRXJyb3IsXG4gIHF1ZXJ5LFxufToge1xuICByZXN1bHQ6IFF1ZXJ5T2JzZXJ2ZXJSZXN1bHQ8VERhdGEsIFRFcnJvcj5cbiAgZXJyb3JSZXNldEJvdW5kYXJ5OiBRdWVyeUVycm9yUmVzZXRCb3VuZGFyeVZhbHVlXG4gIHRocm93T25FcnJvcjogVGhyb3dPbkVycm9yPFRRdWVyeUZuRGF0YSwgVEVycm9yLCBUUXVlcnlEYXRhLCBUUXVlcnlLZXk+XG4gIHF1ZXJ5OiBRdWVyeTxUUXVlcnlGbkRhdGEsIFRFcnJvciwgVFF1ZXJ5RGF0YSwgVFF1ZXJ5S2V5PiB8IHVuZGVmaW5lZFxufSkgPT4ge1xuICByZXR1cm4gKFxuICAgIHJlc3VsdC5pc0Vycm9yICYmXG4gICAgIWVycm9yUmVzZXRCb3VuZGFyeS5pc1Jlc2V0KCkgJiZcbiAgICAhcmVzdWx0LmlzRmV0Y2hpbmcgJiZcbiAgICBxdWVyeSAmJlxuICAgIHNob3VsZFRocm93RXJyb3IodGhyb3dPbkVycm9yLCBbcmVzdWx0LmVycm9yLCBxdWVyeV0pXG4gIClcbn1cbiJdLCJuYW1lcyI6WyJSZWFjdCIsInNob3VsZFRocm93RXJyb3IiLCJlbnN1cmVQcmV2ZW50RXJyb3JCb3VuZGFyeVJldHJ5Iiwib3B0aW9ucyIsImVycm9yUmVzZXRCb3VuZGFyeSIsInN1c3BlbnNlIiwidGhyb3dPbkVycm9yIiwiaXNSZXNldCIsInJldHJ5T25Nb3VudCIsInVzZUNsZWFyUmVzZXRFcnJvckJvdW5kYXJ5IiwidXNlRWZmZWN0IiwiY2xlYXJSZXNldCIsImdldEhhc0Vycm9yIiwicmVzdWx0IiwicXVlcnkiLCJpc0Vycm9yIiwiaXNGZXRjaGluZyIsImVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/@tanstack/react-query/build/modern/errorBoundaryUtils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@tanstack/react-query/build/modern/isRestoring.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/@tanstack/react-query/build/modern/isRestoring.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IsRestoringProvider: function() { return /* binding */ IsRestoringProvider; },\n/* harmony export */   useIsRestoring: function() { return /* binding */ useIsRestoring; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* __next_internal_client_entry_do_not_use__ IsRestoringProvider,useIsRestoring auto */ var _s = $RefreshSig$();\n// src/isRestoring.ts\n\nvar IsRestoringContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(false);\nvar useIsRestoring = ()=>{\n    _s();\n    return react__WEBPACK_IMPORTED_MODULE_0__.useContext(IsRestoringContext);\n};\n_s(useIsRestoring, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nvar IsRestoringProvider = IsRestoringContext.Provider;\n //# sourceMappingURL=isRestoring.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXF1ZXJ5L2J1aWxkL21vZGVybi9pc1Jlc3RvcmluZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUN1QjtBQUV2QixJQUFNQyxtQ0FBMkJELGdEQUFBLENBQWM7QUFFeEMsSUFBTUcsaUJBQWlCOztJQUFZSCxPQUFBQSw2Q0FBQSxDQUFXQztBQUFrQjtHQUExREU7QUFDTixJQUFNRSxzQkFBc0JKLG1CQUFtQkssUUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vc3JjL2lzUmVzdG9yaW5nLnRzPzYyYTQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCdcblxuY29uc3QgSXNSZXN0b3JpbmdDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChmYWxzZSlcblxuZXhwb3J0IGNvbnN0IHVzZUlzUmVzdG9yaW5nID0gKCkgPT4gUmVhY3QudXNlQ29udGV4dChJc1Jlc3RvcmluZ0NvbnRleHQpXG5leHBvcnQgY29uc3QgSXNSZXN0b3JpbmdQcm92aWRlciA9IElzUmVzdG9yaW5nQ29udGV4dC5Qcm92aWRlclxuIl0sIm5hbWVzIjpbIlJlYWN0IiwiSXNSZXN0b3JpbmdDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsInVzZUlzUmVzdG9yaW5nIiwidXNlQ29udGV4dCIsIklzUmVzdG9yaW5nUHJvdmlkZXIiLCJQcm92aWRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/@tanstack/react-query/build/modern/isRestoring.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@tanstack/react-query/build/modern/suspense.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/@tanstack/react-query/build/modern/suspense.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultThrowOnError: function() { return /* binding */ defaultThrowOnError; },\n/* harmony export */   ensureSuspenseTimers: function() { return /* binding */ ensureSuspenseTimers; },\n/* harmony export */   fetchOptimistic: function() { return /* binding */ fetchOptimistic; },\n/* harmony export */   shouldSuspend: function() { return /* binding */ shouldSuspend; },\n/* harmony export */   willFetch: function() { return /* binding */ willFetch; }\n/* harmony export */ });\n// src/suspense.ts\nvar defaultThrowOnError = (_error, query) => query.state.data === void 0;\nvar ensureSuspenseTimers = (defaultedOptions) => {\n  if (defaultedOptions.suspense) {\n    if (typeof defaultedOptions.staleTime !== \"number\") {\n      defaultedOptions.staleTime = 1e3;\n    }\n    if (typeof defaultedOptions.gcTime === \"number\") {\n      defaultedOptions.gcTime = Math.max(defaultedOptions.gcTime, 1e3);\n    }\n  }\n};\nvar willFetch = (result, isRestoring) => result.isLoading && result.isFetching && !isRestoring;\nvar shouldSuspend = (defaultedOptions, result) => defaultedOptions?.suspense && result.isPending;\nvar fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).catch(() => {\n  errorResetBoundary.clearReset();\n});\n\n//# sourceMappingURL=suspense.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXF1ZXJ5L2J1aWxkL21vZGVybi9zdXNwZW5zZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQU9DO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcmVhY3QtcXVlcnkvYnVpbGQvbW9kZXJuL3N1c3BlbnNlLmpzPzNiMWIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3N1c3BlbnNlLnRzXG52YXIgZGVmYXVsdFRocm93T25FcnJvciA9IChfZXJyb3IsIHF1ZXJ5KSA9PiBxdWVyeS5zdGF0ZS5kYXRhID09PSB2b2lkIDA7XG52YXIgZW5zdXJlU3VzcGVuc2VUaW1lcnMgPSAoZGVmYXVsdGVkT3B0aW9ucykgPT4ge1xuICBpZiAoZGVmYXVsdGVkT3B0aW9ucy5zdXNwZW5zZSkge1xuICAgIGlmICh0eXBlb2YgZGVmYXVsdGVkT3B0aW9ucy5zdGFsZVRpbWUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGRlZmF1bHRlZE9wdGlvbnMuc3RhbGVUaW1lID0gMWUzO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRlZmF1bHRlZE9wdGlvbnMuZ2NUaW1lID09PSBcIm51bWJlclwiKSB7XG4gICAgICBkZWZhdWx0ZWRPcHRpb25zLmdjVGltZSA9IE1hdGgubWF4KGRlZmF1bHRlZE9wdGlvbnMuZ2NUaW1lLCAxZTMpO1xuICAgIH1cbiAgfVxufTtcbnZhciB3aWxsRmV0Y2ggPSAocmVzdWx0LCBpc1Jlc3RvcmluZykgPT4gcmVzdWx0LmlzTG9hZGluZyAmJiByZXN1bHQuaXNGZXRjaGluZyAmJiAhaXNSZXN0b3Jpbmc7XG52YXIgc2hvdWxkU3VzcGVuZCA9IChkZWZhdWx0ZWRPcHRpb25zLCByZXN1bHQpID0+IGRlZmF1bHRlZE9wdGlvbnM/LnN1c3BlbnNlICYmIHJlc3VsdC5pc1BlbmRpbmc7XG52YXIgZmV0Y2hPcHRpbWlzdGljID0gKGRlZmF1bHRlZE9wdGlvbnMsIG9ic2VydmVyLCBlcnJvclJlc2V0Qm91bmRhcnkpID0+IG9ic2VydmVyLmZldGNoT3B0aW1pc3RpYyhkZWZhdWx0ZWRPcHRpb25zKS5jYXRjaCgoKSA9PiB7XG4gIGVycm9yUmVzZXRCb3VuZGFyeS5jbGVhclJlc2V0KCk7XG59KTtcbmV4cG9ydCB7XG4gIGRlZmF1bHRUaHJvd09uRXJyb3IsXG4gIGVuc3VyZVN1c3BlbnNlVGltZXJzLFxuICBmZXRjaE9wdGltaXN0aWMsXG4gIHNob3VsZFN1c3BlbmQsXG4gIHdpbGxGZXRjaFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1c3BlbnNlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/@tanstack/react-query/build/modern/suspense.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@tanstack/react-query/build/modern/useBaseQuery.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/@tanstack/react-query/build/modern/useBaseQuery.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useBaseQuery: function() { return /* binding */ useBaseQuery; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _tanstack_query_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tanstack/query-core */ \"(app-pages-browser)/../../node_modules/@tanstack/query-core/build/modern/notifyManager.js\");\n/* harmony import */ var _QueryErrorResetBoundary_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./QueryErrorResetBoundary.js */ \"(app-pages-browser)/../../node_modules/@tanstack/react-query/build/modern/QueryErrorResetBoundary.js\");\n/* harmony import */ var _QueryClientProvider_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./QueryClientProvider.js */ \"(app-pages-browser)/../../node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js\");\n/* harmony import */ var _isRestoring_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isRestoring.js */ \"(app-pages-browser)/../../node_modules/@tanstack/react-query/build/modern/isRestoring.js\");\n/* harmony import */ var _errorBoundaryUtils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./errorBoundaryUtils.js */ \"(app-pages-browser)/../../node_modules/@tanstack/react-query/build/modern/errorBoundaryUtils.js\");\n/* harmony import */ var _suspense_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./suspense.js */ \"(app-pages-browser)/../../node_modules/@tanstack/react-query/build/modern/suspense.js\");\n/* __next_internal_client_entry_do_not_use__ useBaseQuery auto */ var _s = $RefreshSig$();\n// src/useBaseQuery.ts\n\n\n\n\n\n\n\nfunction useBaseQuery(options, Observer, queryClient) {\n    var _client_getDefaultOptions_queries__experimental_beforeQuery, _client_getDefaultOptions_queries, _client_getDefaultOptions_queries__experimental_afterQuery, _client_getDefaultOptions_queries1;\n    _s();\n    if (true) {\n        if (typeof options !== \"object\" || Array.isArray(options)) {\n            throw new Error('Bad argument type. Starting with v5, only the \"Object\" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object');\n        }\n    }\n    const client = (0,_QueryClientProvider_js__WEBPACK_IMPORTED_MODULE_1__.useQueryClient)(queryClient);\n    const isRestoring = (0,_isRestoring_js__WEBPACK_IMPORTED_MODULE_2__.useIsRestoring)();\n    const errorResetBoundary = (0,_QueryErrorResetBoundary_js__WEBPACK_IMPORTED_MODULE_3__.useQueryErrorResetBoundary)();\n    const defaultedOptions = client.defaultQueryOptions(options);\n    (_client_getDefaultOptions_queries = client.getDefaultOptions().queries) === null || _client_getDefaultOptions_queries === void 0 ? void 0 : (_client_getDefaultOptions_queries__experimental_beforeQuery = _client_getDefaultOptions_queries._experimental_beforeQuery) === null || _client_getDefaultOptions_queries__experimental_beforeQuery === void 0 ? void 0 : _client_getDefaultOptions_queries__experimental_beforeQuery.call(_client_getDefaultOptions_queries, defaultedOptions);\n    defaultedOptions._optimisticResults = isRestoring ? \"isRestoring\" : \"optimistic\";\n    (0,_suspense_js__WEBPACK_IMPORTED_MODULE_4__.ensureSuspenseTimers)(defaultedOptions);\n    (0,_errorBoundaryUtils_js__WEBPACK_IMPORTED_MODULE_5__.ensurePreventErrorBoundaryRetry)(defaultedOptions, errorResetBoundary);\n    (0,_errorBoundaryUtils_js__WEBPACK_IMPORTED_MODULE_5__.useClearResetErrorBoundary)(errorResetBoundary);\n    const [observer] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>new Observer(client, defaultedOptions));\n    const result = observer.getOptimisticResult(defaultedOptions);\n    react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore(react__WEBPACK_IMPORTED_MODULE_0__.useCallback((onStoreChange)=>{\n        const unsubscribe = isRestoring ? ()=>void 0 : observer.subscribe(_tanstack_query_core__WEBPACK_IMPORTED_MODULE_6__.notifyManager.batchCalls(onStoreChange));\n        observer.updateResult();\n        return unsubscribe;\n    }, [\n        observer,\n        isRestoring\n    ]), ()=>observer.getCurrentResult(), ()=>observer.getCurrentResult());\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        observer.setOptions(defaultedOptions, {\n            listeners: false\n        });\n    }, [\n        defaultedOptions,\n        observer\n    ]);\n    if ((0,_suspense_js__WEBPACK_IMPORTED_MODULE_4__.shouldSuspend)(defaultedOptions, result)) {\n        throw (0,_suspense_js__WEBPACK_IMPORTED_MODULE_4__.fetchOptimistic)(defaultedOptions, observer, errorResetBoundary);\n    }\n    if ((0,_errorBoundaryUtils_js__WEBPACK_IMPORTED_MODULE_5__.getHasError)({\n        result,\n        errorResetBoundary,\n        throwOnError: defaultedOptions.throwOnError,\n        query: client.getQueryCache().get(defaultedOptions.queryHash)\n    })) {\n        throw result.error;\n    }\n    ;\n    (_client_getDefaultOptions_queries1 = client.getDefaultOptions().queries) === null || _client_getDefaultOptions_queries1 === void 0 ? void 0 : (_client_getDefaultOptions_queries__experimental_afterQuery = _client_getDefaultOptions_queries1._experimental_afterQuery) === null || _client_getDefaultOptions_queries__experimental_afterQuery === void 0 ? void 0 : _client_getDefaultOptions_queries__experimental_afterQuery.call(_client_getDefaultOptions_queries1, defaultedOptions, result);\n    return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;\n}\n_s(useBaseQuery, \"RdnjPuVKRWykd09y/1yZ8ZcDrqw=\", false, function() {\n    return [\n        _QueryClientProvider_js__WEBPACK_IMPORTED_MODULE_1__.useQueryClient,\n        _isRestoring_js__WEBPACK_IMPORTED_MODULE_2__.useIsRestoring,\n        _QueryErrorResetBoundary_js__WEBPACK_IMPORTED_MODULE_3__.useQueryErrorResetBoundary,\n        _errorBoundaryUtils_js__WEBPACK_IMPORTED_MODULE_5__.useClearResetErrorBoundary\n    ];\n});\n //# sourceMappingURL=useBaseQuery.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXF1ZXJ5L2J1aWxkL21vZGVybi91c2VCYXNlUXVlcnkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUN1QjtBQUVPO0FBQ2E7QUFDWjtBQUNBO0FBS3hCO0FBS0E7QUFTQSxTQUFTVyxhQU9kQyxPQUFBLEVBT0FDLFFBQUEsRUFDQUMsV0FBQTtRQWVFQyw2REFBQUEsbUNBeUVBQSw0REFBQUE7O0lBdEZGLElBQUlDLElBQXlCLEVBQWM7UUFDekMsSUFBSSxPQUFPSixZQUFZLFlBQVlLLE1BQU1DLE9BQUEsQ0FBUU4sVUFBVTtZQUN6RCxNQUFNLElBQUlPLE1BQ1I7UUFFSjtJQUNGO0lBRUEsTUFBTUosU0FBU1osdUVBQWNBLENBQUNXO0lBQzlCLE1BQU1NLGNBQWNoQiwrREFBY0E7SUFDbEMsTUFBTWlCLHFCQUFxQm5CLHVGQUEwQkE7SUFDckQsTUFBTW9CLG1CQUFtQlAsT0FBT1EsbUJBQUEsQ0FBb0JYO0tBRWxERyxvQ0FBQUEsT0FBT1MsaUJBQUEsR0FBb0JDLE9BQUEsY0FBM0JWLHlEQUFBQSw4REFBQUEsa0NBQTRDVyx5QkFBQSxjQUE1Q1gsa0ZBQUFBLGlFQUFBQSxtQ0FDQU87SUFJRkEsaUJBQWlCSyxrQkFBQSxHQUFxQlAsY0FDbEMsZ0JBQ0E7SUFFSlosa0VBQW9CQSxDQUFDYztJQUNyQmpCLHVGQUErQkEsQ0FBQ2lCLGtCQUFrQkQ7SUFFbERkLGtGQUEwQkEsQ0FBQ2M7SUFFM0IsTUFBTSxDQUFDTyxTQUFRLEdBQVU1QiwyQ0FBQSxDQUN2QixJQUNFLElBQUlhLFNBQ0ZFLFFBQ0FPO0lBSU4sTUFBTVEsU0FBU0YsU0FBU0csbUJBQUEsQ0FBb0JUO0lBRXRDdEIsdURBQUEsQ0FDRUEsOENBQUEsQ0FDSixDQUFDa0M7UUFDQyxNQUFNQyxjQUFjZixjQUNoQixJQUFNLFNBQ05RLFNBQVNRLFNBQUEsQ0FBVW5DLCtEQUFhQSxDQUFDb0MsVUFBQSxDQUFXSDtRQUloRE4sU0FBU1UsWUFBQTtRQUVULE9BQU9IO0lBQ1QsR0FDQTtRQUFDUDtRQUFVUjtLQUFXLEdBRXhCLElBQU1RLFNBQVNXLGdCQUFBLElBQ2YsSUFBTVgsU0FBU1csZ0JBQUE7SUFHWHZDLDRDQUFBLENBQVU7UUFHZDRCLFNBQVNhLFVBQUEsQ0FBV25CLGtCQUFrQjtZQUFFb0IsV0FBVztRQUFNO0lBQzNELEdBQUc7UUFBQ3BCO1FBQWtCTTtLQUFTO0lBRy9CLElBQUlsQiwyREFBYUEsQ0FBQ1ksa0JBQWtCUSxTQUFTO1FBQzNDLE1BQU1yQiw2REFBZUEsQ0FBQ2Esa0JBQWtCTSxVQUFVUDtJQUNwRDtJQUdBLElBQ0VmLG1FQUFXQSxDQUFDO1FBQ1Z3QjtRQUNBVDtRQUNBc0IsY0FBY3JCLGlCQUFpQnFCLFlBQUE7UUFDL0JDLE9BQU83QixPQUNKOEIsYUFBQSxHQUNBQyxHQUFBLENBS0N4QixpQkFBaUJ5QixTQUFTO0lBQ2hDLElBQ0E7UUFDQSxNQUFNakIsT0FBT2tCLEtBQUE7SUFDZjs7S0FFRWpDLHFDQUFBQSxPQUFPUyxpQkFBQSxHQUFvQkMsT0FBQSxjQUEzQlYsMERBQUFBLDZEQUFBQSxtQ0FBNENrQyx3QkFBQSxjQUE1Q2xDLGlGQUFBQSxnRUFBQUEsb0NBQ0FPLGtCQUNBUTtJQUlGLE9BQU8sQ0FBQ1IsaUJBQWlCNEIsbUJBQUEsR0FDckJ0QixTQUFTdUIsV0FBQSxDQUFZckIsVUFDckJBO0FBQ047R0FoSGdCbkI7O1FBeUJDUixtRUFBY0E7UUFDVEMsMkRBQWNBO1FBQ1BGLG1GQUEwQkE7UUFlckRLLDhFQUEwQkEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3NyYy91c2VCYXNlUXVlcnkudHM/MjhiNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0J1xuXG5pbXBvcnQgeyBub3RpZnlNYW5hZ2VyIH0gZnJvbSAnQHRhbnN0YWNrL3F1ZXJ5LWNvcmUnXG5pbXBvcnQgeyB1c2VRdWVyeUVycm9yUmVzZXRCb3VuZGFyeSB9IGZyb20gJy4vUXVlcnlFcnJvclJlc2V0Qm91bmRhcnknXG5pbXBvcnQgeyB1c2VRdWVyeUNsaWVudCB9IGZyb20gJy4vUXVlcnlDbGllbnRQcm92aWRlcidcbmltcG9ydCB7IHVzZUlzUmVzdG9yaW5nIH0gZnJvbSAnLi9pc1Jlc3RvcmluZydcbmltcG9ydCB7XG4gIGVuc3VyZVByZXZlbnRFcnJvckJvdW5kYXJ5UmV0cnksXG4gIGdldEhhc0Vycm9yLFxuICB1c2VDbGVhclJlc2V0RXJyb3JCb3VuZGFyeSxcbn0gZnJvbSAnLi9lcnJvckJvdW5kYXJ5VXRpbHMnXG5pbXBvcnQge1xuICBlbnN1cmVTdXNwZW5zZVRpbWVycyxcbiAgZmV0Y2hPcHRpbWlzdGljLFxuICBzaG91bGRTdXNwZW5kLFxufSBmcm9tICcuL3N1c3BlbnNlJ1xuaW1wb3J0IHR5cGUgeyBVc2VCYXNlUXVlcnlPcHRpb25zIH0gZnJvbSAnLi90eXBlcydcbmltcG9ydCB0eXBlIHtcbiAgUXVlcnlDbGllbnQsXG4gIFF1ZXJ5S2V5LFxuICBRdWVyeU9ic2VydmVyLFxuICBRdWVyeU9ic2VydmVyUmVzdWx0LFxufSBmcm9tICdAdGFuc3RhY2svcXVlcnktY29yZSdcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUJhc2VRdWVyeTxcbiAgVFF1ZXJ5Rm5EYXRhLFxuICBURXJyb3IsXG4gIFREYXRhLFxuICBUUXVlcnlEYXRhLFxuICBUUXVlcnlLZXkgZXh0ZW5kcyBRdWVyeUtleSxcbj4oXG4gIG9wdGlvbnM6IFVzZUJhc2VRdWVyeU9wdGlvbnM8XG4gICAgVFF1ZXJ5Rm5EYXRhLFxuICAgIFRFcnJvcixcbiAgICBURGF0YSxcbiAgICBUUXVlcnlEYXRhLFxuICAgIFRRdWVyeUtleVxuICA+LFxuICBPYnNlcnZlcjogdHlwZW9mIFF1ZXJ5T2JzZXJ2ZXIsXG4gIHF1ZXJ5Q2xpZW50PzogUXVlcnlDbGllbnQsXG4pOiBRdWVyeU9ic2VydmVyUmVzdWx0PFREYXRhLCBURXJyb3I+IHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0JhZCBhcmd1bWVudCB0eXBlLiBTdGFydGluZyB3aXRoIHY1LCBvbmx5IHRoZSBcIk9iamVjdFwiIGZvcm0gaXMgYWxsb3dlZCB3aGVuIGNhbGxpbmcgcXVlcnkgcmVsYXRlZCBmdW5jdGlvbnMuIFBsZWFzZSB1c2UgdGhlIGVycm9yIHN0YWNrIHRvIGZpbmQgdGhlIGN1bHByaXQgY2FsbC4gTW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vdGFuc3RhY2suY29tL3F1ZXJ5L2xhdGVzdC9kb2NzL3JlYWN0L2d1aWRlcy9taWdyYXRpbmctdG8tdjUjc3VwcG9ydHMtYS1zaW5nbGUtc2lnbmF0dXJlLW9uZS1vYmplY3QnLFxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGNsaWVudCA9IHVzZVF1ZXJ5Q2xpZW50KHF1ZXJ5Q2xpZW50KVxuICBjb25zdCBpc1Jlc3RvcmluZyA9IHVzZUlzUmVzdG9yaW5nKClcbiAgY29uc3QgZXJyb3JSZXNldEJvdW5kYXJ5ID0gdXNlUXVlcnlFcnJvclJlc2V0Qm91bmRhcnkoKVxuICBjb25zdCBkZWZhdWx0ZWRPcHRpb25zID0gY2xpZW50LmRlZmF1bHRRdWVyeU9wdGlvbnMob3B0aW9ucylcblxuICA7KGNsaWVudC5nZXREZWZhdWx0T3B0aW9ucygpLnF1ZXJpZXMgYXMgYW55KT8uX2V4cGVyaW1lbnRhbF9iZWZvcmVRdWVyeT8uKFxuICAgIGRlZmF1bHRlZE9wdGlvbnMsXG4gIClcblxuICAvLyBNYWtlIHN1cmUgcmVzdWx0cyBhcmUgb3B0aW1pc3RpY2FsbHkgc2V0IGluIGZldGNoaW5nIHN0YXRlIGJlZm9yZSBzdWJzY3JpYmluZyBvciB1cGRhdGluZyBvcHRpb25zXG4gIGRlZmF1bHRlZE9wdGlvbnMuX29wdGltaXN0aWNSZXN1bHRzID0gaXNSZXN0b3JpbmdcbiAgICA/ICdpc1Jlc3RvcmluZydcbiAgICA6ICdvcHRpbWlzdGljJ1xuXG4gIGVuc3VyZVN1c3BlbnNlVGltZXJzKGRlZmF1bHRlZE9wdGlvbnMpXG4gIGVuc3VyZVByZXZlbnRFcnJvckJvdW5kYXJ5UmV0cnkoZGVmYXVsdGVkT3B0aW9ucywgZXJyb3JSZXNldEJvdW5kYXJ5KVxuXG4gIHVzZUNsZWFyUmVzZXRFcnJvckJvdW5kYXJ5KGVycm9yUmVzZXRCb3VuZGFyeSlcblxuICBjb25zdCBbb2JzZXJ2ZXJdID0gUmVhY3QudXNlU3RhdGUoXG4gICAgKCkgPT5cbiAgICAgIG5ldyBPYnNlcnZlcjxUUXVlcnlGbkRhdGEsIFRFcnJvciwgVERhdGEsIFRRdWVyeURhdGEsIFRRdWVyeUtleT4oXG4gICAgICAgIGNsaWVudCxcbiAgICAgICAgZGVmYXVsdGVkT3B0aW9ucyxcbiAgICAgICksXG4gIClcblxuICBjb25zdCByZXN1bHQgPSBvYnNlcnZlci5nZXRPcHRpbWlzdGljUmVzdWx0KGRlZmF1bHRlZE9wdGlvbnMpXG5cbiAgUmVhY3QudXNlU3luY0V4dGVybmFsU3RvcmUoXG4gICAgUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAob25TdG9yZUNoYW5nZSkgPT4ge1xuICAgICAgICBjb25zdCB1bnN1YnNjcmliZSA9IGlzUmVzdG9yaW5nXG4gICAgICAgICAgPyAoKSA9PiB1bmRlZmluZWRcbiAgICAgICAgICA6IG9ic2VydmVyLnN1YnNjcmliZShub3RpZnlNYW5hZ2VyLmJhdGNoQ2FsbHMob25TdG9yZUNoYW5nZSkpXG5cbiAgICAgICAgLy8gVXBkYXRlIHJlc3VsdCB0byBtYWtlIHN1cmUgd2UgZGlkIG5vdCBtaXNzIGFueSBxdWVyeSB1cGRhdGVzXG4gICAgICAgIC8vIGJldHdlZW4gY3JlYXRpbmcgdGhlIG9ic2VydmVyIGFuZCBzdWJzY3JpYmluZyB0byBpdC5cbiAgICAgICAgb2JzZXJ2ZXIudXBkYXRlUmVzdWx0KClcblxuICAgICAgICByZXR1cm4gdW5zdWJzY3JpYmVcbiAgICAgIH0sXG4gICAgICBbb2JzZXJ2ZXIsIGlzUmVzdG9yaW5nXSxcbiAgICApLFxuICAgICgpID0+IG9ic2VydmVyLmdldEN1cnJlbnRSZXN1bHQoKSxcbiAgICAoKSA9PiBvYnNlcnZlci5nZXRDdXJyZW50UmVzdWx0KCksXG4gIClcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIERvIG5vdCBub3RpZnkgb24gdXBkYXRlcyBiZWNhdXNlIG9mIGNoYW5nZXMgaW4gdGhlIG9wdGlvbnMgYmVjYXVzZVxuICAgIC8vIHRoZXNlIGNoYW5nZXMgc2hvdWxkIGFscmVhZHkgYmUgcmVmbGVjdGVkIGluIHRoZSBvcHRpbWlzdGljIHJlc3VsdC5cbiAgICBvYnNlcnZlci5zZXRPcHRpb25zKGRlZmF1bHRlZE9wdGlvbnMsIHsgbGlzdGVuZXJzOiBmYWxzZSB9KVxuICB9LCBbZGVmYXVsdGVkT3B0aW9ucywgb2JzZXJ2ZXJdKVxuXG4gIC8vIEhhbmRsZSBzdXNwZW5zZVxuICBpZiAoc2hvdWxkU3VzcGVuZChkZWZhdWx0ZWRPcHRpb25zLCByZXN1bHQpKSB7XG4gICAgdGhyb3cgZmV0Y2hPcHRpbWlzdGljKGRlZmF1bHRlZE9wdGlvbnMsIG9ic2VydmVyLCBlcnJvclJlc2V0Qm91bmRhcnkpXG4gIH1cblxuICAvLyBIYW5kbGUgZXJyb3IgYm91bmRhcnlcbiAgaWYgKFxuICAgIGdldEhhc0Vycm9yKHtcbiAgICAgIHJlc3VsdCxcbiAgICAgIGVycm9yUmVzZXRCb3VuZGFyeSxcbiAgICAgIHRocm93T25FcnJvcjogZGVmYXVsdGVkT3B0aW9ucy50aHJvd09uRXJyb3IsXG4gICAgICBxdWVyeTogY2xpZW50XG4gICAgICAgIC5nZXRRdWVyeUNhY2hlKClcbiAgICAgICAgLmdldDxcbiAgICAgICAgICBUUXVlcnlGbkRhdGEsXG4gICAgICAgICAgVEVycm9yLFxuICAgICAgICAgIFRRdWVyeURhdGEsXG4gICAgICAgICAgVFF1ZXJ5S2V5XG4gICAgICAgID4oZGVmYXVsdGVkT3B0aW9ucy5xdWVyeUhhc2gpLFxuICAgIH0pXG4gICkge1xuICAgIHRocm93IHJlc3VsdC5lcnJvclxuICB9XG5cbiAgOyhjbGllbnQuZ2V0RGVmYXVsdE9wdGlvbnMoKS5xdWVyaWVzIGFzIGFueSk/Ll9leHBlcmltZW50YWxfYWZ0ZXJRdWVyeT8uKFxuICAgIGRlZmF1bHRlZE9wdGlvbnMsXG4gICAgcmVzdWx0LFxuICApXG5cbiAgLy8gSGFuZGxlIHJlc3VsdCBwcm9wZXJ0eSB1c2FnZSB0cmFja2luZ1xuICByZXR1cm4gIWRlZmF1bHRlZE9wdGlvbnMubm90aWZ5T25DaGFuZ2VQcm9wc1xuICAgID8gb2JzZXJ2ZXIudHJhY2tSZXN1bHQocmVzdWx0KVxuICAgIDogcmVzdWx0XG59XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJub3RpZnlNYW5hZ2VyIiwidXNlUXVlcnlFcnJvclJlc2V0Qm91bmRhcnkiLCJ1c2VRdWVyeUNsaWVudCIsInVzZUlzUmVzdG9yaW5nIiwiZW5zdXJlUHJldmVudEVycm9yQm91bmRhcnlSZXRyeSIsImdldEhhc0Vycm9yIiwidXNlQ2xlYXJSZXNldEVycm9yQm91bmRhcnkiLCJlbnN1cmVTdXNwZW5zZVRpbWVycyIsImZldGNoT3B0aW1pc3RpYyIsInNob3VsZFN1c3BlbmQiLCJ1c2VCYXNlUXVlcnkiLCJvcHRpb25zIiwiT2JzZXJ2ZXIiLCJxdWVyeUNsaWVudCIsImNsaWVudCIsInByb2Nlc3MiLCJBcnJheSIsImlzQXJyYXkiLCJFcnJvciIsImlzUmVzdG9yaW5nIiwiZXJyb3JSZXNldEJvdW5kYXJ5IiwiZGVmYXVsdGVkT3B0aW9ucyIsImRlZmF1bHRRdWVyeU9wdGlvbnMiLCJnZXREZWZhdWx0T3B0aW9ucyIsInF1ZXJpZXMiLCJfZXhwZXJpbWVudGFsX2JlZm9yZVF1ZXJ5IiwiX29wdGltaXN0aWNSZXN1bHRzIiwib2JzZXJ2ZXIiLCJ1c2VTdGF0ZSIsInJlc3VsdCIsImdldE9wdGltaXN0aWNSZXN1bHQiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZSIsInVzZUNhbGxiYWNrIiwib25TdG9yZUNoYW5nZSIsInVuc3Vic2NyaWJlIiwic3Vic2NyaWJlIiwiYmF0Y2hDYWxscyIsInVwZGF0ZVJlc3VsdCIsImdldEN1cnJlbnRSZXN1bHQiLCJ1c2VFZmZlY3QiLCJzZXRPcHRpb25zIiwibGlzdGVuZXJzIiwidGhyb3dPbkVycm9yIiwicXVlcnkiLCJnZXRRdWVyeUNhY2hlIiwiZ2V0IiwicXVlcnlIYXNoIiwiZXJyb3IiLCJfZXhwZXJpbWVudGFsX2FmdGVyUXVlcnkiLCJub3RpZnlPbkNoYW5nZVByb3BzIiwidHJhY2tSZXN1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/@tanstack/react-query/build/modern/useBaseQuery.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@tanstack/react-query/build/modern/useQuery.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/@tanstack/react-query/build/modern/useQuery.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useQuery: function() { return /* binding */ useQuery; }\n/* harmony export */ });\n/* harmony import */ var _tanstack_query_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tanstack/query-core */ \"(app-pages-browser)/../../node_modules/@tanstack/query-core/build/modern/queryObserver.js\");\n/* harmony import */ var _useBaseQuery_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./useBaseQuery.js */ \"(app-pages-browser)/../../node_modules/@tanstack/react-query/build/modern/useBaseQuery.js\");\n/* __next_internal_client_entry_do_not_use__ useQuery auto */ var _s = $RefreshSig$();\n// src/useQuery.ts\n\n\nfunction useQuery(options, queryClient) {\n    _s();\n    return (0,_useBaseQuery_js__WEBPACK_IMPORTED_MODULE_0__.useBaseQuery)(options, _tanstack_query_core__WEBPACK_IMPORTED_MODULE_1__.QueryObserver, queryClient);\n}\n_s(useQuery, \"KQLwJ9Hz54v54vEsUujw5Lh1nqo=\", false, function() {\n    return [\n        _useBaseQuery_js__WEBPACK_IMPORTED_MODULE_0__.useBaseQuery\n    ];\n});\n //# sourceMappingURL=useQuery.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXF1ZXJ5L2J1aWxkL21vZGVybi91c2VRdWVyeS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUM4QjtBQUNEO0FBMEN0QixTQUFTRSxTQUFTQyxPQUFBLEVBQTBCQyxXQUFBOztJQUNqRCxPQUFPSCw4REFBWUEsQ0FBQ0UsU0FBU0gsK0RBQWFBLEVBQUVJO0FBQzlDO0dBRmdCRjs7UUFDUEQsMERBQVlBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9zcmMvdXNlUXVlcnkudHM/YmRiZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcbmltcG9ydCB7IFF1ZXJ5T2JzZXJ2ZXIgfSBmcm9tICdAdGFuc3RhY2svcXVlcnktY29yZSdcbmltcG9ydCB7IHVzZUJhc2VRdWVyeSB9IGZyb20gJy4vdXNlQmFzZVF1ZXJ5J1xuaW1wb3J0IHR5cGUgeyBEZWZhdWx0RXJyb3IsIFF1ZXJ5Q2xpZW50LCBRdWVyeUtleSB9IGZyb20gJ0B0YW5zdGFjay9xdWVyeS1jb3JlJ1xuaW1wb3J0IHR5cGUge1xuICBEZWZpbmVkVXNlUXVlcnlSZXN1bHQsXG4gIFVzZVF1ZXJ5T3B0aW9ucyxcbiAgVXNlUXVlcnlSZXN1bHQsXG59IGZyb20gJy4vdHlwZXMnXG5pbXBvcnQgdHlwZSB7XG4gIERlZmluZWRJbml0aWFsRGF0YU9wdGlvbnMsXG4gIFVuZGVmaW5lZEluaXRpYWxEYXRhT3B0aW9ucyxcbn0gZnJvbSAnLi9xdWVyeU9wdGlvbnMnXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VRdWVyeTxcbiAgVFF1ZXJ5Rm5EYXRhID0gdW5rbm93bixcbiAgVEVycm9yID0gRGVmYXVsdEVycm9yLFxuICBURGF0YSA9IFRRdWVyeUZuRGF0YSxcbiAgVFF1ZXJ5S2V5IGV4dGVuZHMgUXVlcnlLZXkgPSBRdWVyeUtleSxcbj4oXG4gIG9wdGlvbnM6IERlZmluZWRJbml0aWFsRGF0YU9wdGlvbnM8VFF1ZXJ5Rm5EYXRhLCBURXJyb3IsIFREYXRhLCBUUXVlcnlLZXk+LFxuICBxdWVyeUNsaWVudD86IFF1ZXJ5Q2xpZW50LFxuKTogRGVmaW5lZFVzZVF1ZXJ5UmVzdWx0PFREYXRhLCBURXJyb3I+XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VRdWVyeTxcbiAgVFF1ZXJ5Rm5EYXRhID0gdW5rbm93bixcbiAgVEVycm9yID0gRGVmYXVsdEVycm9yLFxuICBURGF0YSA9IFRRdWVyeUZuRGF0YSxcbiAgVFF1ZXJ5S2V5IGV4dGVuZHMgUXVlcnlLZXkgPSBRdWVyeUtleSxcbj4oXG4gIG9wdGlvbnM6IFVuZGVmaW5lZEluaXRpYWxEYXRhT3B0aW9uczxUUXVlcnlGbkRhdGEsIFRFcnJvciwgVERhdGEsIFRRdWVyeUtleT4sXG4gIHF1ZXJ5Q2xpZW50PzogUXVlcnlDbGllbnQsXG4pOiBVc2VRdWVyeVJlc3VsdDxURGF0YSwgVEVycm9yPlxuXG5leHBvcnQgZnVuY3Rpb24gdXNlUXVlcnk8XG4gIFRRdWVyeUZuRGF0YSA9IHVua25vd24sXG4gIFRFcnJvciA9IERlZmF1bHRFcnJvcixcbiAgVERhdGEgPSBUUXVlcnlGbkRhdGEsXG4gIFRRdWVyeUtleSBleHRlbmRzIFF1ZXJ5S2V5ID0gUXVlcnlLZXksXG4+KFxuICBvcHRpb25zOiBVc2VRdWVyeU9wdGlvbnM8VFF1ZXJ5Rm5EYXRhLCBURXJyb3IsIFREYXRhLCBUUXVlcnlLZXk+LFxuICBxdWVyeUNsaWVudD86IFF1ZXJ5Q2xpZW50LFxuKTogVXNlUXVlcnlSZXN1bHQ8VERhdGEsIFRFcnJvcj5cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVF1ZXJ5KG9wdGlvbnM6IFVzZVF1ZXJ5T3B0aW9ucywgcXVlcnlDbGllbnQ/OiBRdWVyeUNsaWVudCkge1xuICByZXR1cm4gdXNlQmFzZVF1ZXJ5KG9wdGlvbnMsIFF1ZXJ5T2JzZXJ2ZXIsIHF1ZXJ5Q2xpZW50KVxufVxuIl0sIm5hbWVzIjpbIlF1ZXJ5T2JzZXJ2ZXIiLCJ1c2VCYXNlUXVlcnkiLCJ1c2VRdWVyeSIsIm9wdGlvbnMiLCJxdWVyeUNsaWVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/@tanstack/react-query/build/modern/useQuery.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/@tanstack/react-query/build/modern/utils.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/@tanstack/react-query/build/modern/utils.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   noop: function() { return /* binding */ noop; },\n/* harmony export */   shouldThrowError: function() { return /* binding */ shouldThrowError; }\n/* harmony export */ });\n// src/utils.ts\nfunction shouldThrowError(throwError, params) {\n  if (typeof throwError === \"function\") {\n    return throwError(...params);\n  }\n  return !!throwError;\n}\nfunction noop() {\n}\n\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXF1ZXJ5L2J1aWxkL21vZGVybi91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcmVhY3QtcXVlcnkvYnVpbGQvbW9kZXJuL3V0aWxzLmpzPzJkNGYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3V0aWxzLnRzXG5mdW5jdGlvbiBzaG91bGRUaHJvd0Vycm9yKHRocm93RXJyb3IsIHBhcmFtcykge1xuICBpZiAodHlwZW9mIHRocm93RXJyb3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiB0aHJvd0Vycm9yKC4uLnBhcmFtcyk7XG4gIH1cbiAgcmV0dXJuICEhdGhyb3dFcnJvcjtcbn1cbmZ1bmN0aW9uIG5vb3AoKSB7XG59XG5leHBvcnQge1xuICBub29wLFxuICBzaG91bGRUaHJvd0Vycm9yXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/@tanstack/react-query/build/modern/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/react-i18next/dist/es/I18nextProvider.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/react-i18next/dist/es/I18nextProvider.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   I18nextProvider: function() { return /* binding */ I18nextProvider; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./context.js */ \"(app-pages-browser)/../../node_modules/react-i18next/dist/es/context.js\");\n\n\nfunction I18nextProvider({\n  i18n,\n  defaultNS,\n  children\n}) {\n  const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({\n    i18n,\n    defaultNS\n  }), [i18n, defaultNS]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(_context_js__WEBPACK_IMPORTED_MODULE_1__.I18nContext.Provider, {\n    value\n  }, children);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QtaTE4bmV4dC9kaXN0L2VzL0kxOG5leHRQcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBK0M7QUFDSjtBQUNwQztBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxnQkFBZ0IsOENBQU87QUFDdkI7QUFDQTtBQUNBLEdBQUc7QUFDSCxTQUFTLG9EQUFhLENBQUMsb0RBQVc7QUFDbEM7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1pMThuZXh0L2Rpc3QvZXMvSTE4bmV4dFByb3ZpZGVyLmpzP2I5YzIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEkxOG5Db250ZXh0IH0gZnJvbSAnLi9jb250ZXh0LmpzJztcbmV4cG9ydCBmdW5jdGlvbiBJMThuZXh0UHJvdmlkZXIoe1xuICBpMThuLFxuICBkZWZhdWx0TlMsXG4gIGNoaWxkcmVuXG59KSB7XG4gIGNvbnN0IHZhbHVlID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIGkxOG4sXG4gICAgZGVmYXVsdE5TXG4gIH0pLCBbaTE4biwgZGVmYXVsdE5TXSk7XG4gIHJldHVybiBjcmVhdGVFbGVtZW50KEkxOG5Db250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWVcbiAgfSwgY2hpbGRyZW4pO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/react-i18next/dist/es/I18nextProvider.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/react-i18next/dist/es/Trans.js":
/*!*********************************************************!*\
  !*** ../../node_modules/react-i18next/dist/es/Trans.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Trans: function() { return /* binding */ Trans; },\n/* harmony export */   nodesToString: function() { return /* reexport safe */ _TransWithoutContext_js__WEBPACK_IMPORTED_MODULE_1__.nodesToString; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _TransWithoutContext_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TransWithoutContext.js */ \"(app-pages-browser)/../../node_modules/react-i18next/dist/es/TransWithoutContext.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./context.js */ \"(app-pages-browser)/../../node_modules/react-i18next/dist/es/context.js\");\n\n\n\n\nfunction Trans({\n  children,\n  count,\n  parent,\n  i18nKey,\n  context,\n  tOptions = {},\n  values,\n  defaults,\n  components,\n  ns,\n  i18n: i18nFromProps,\n  t: tFromProps,\n  shouldUnescape,\n  ...additionalProps\n}) {\n  const {\n    i18n: i18nFromContext,\n    defaultNS: defaultNSFromContext\n  } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(_context_js__WEBPACK_IMPORTED_MODULE_2__.I18nContext) || {};\n  const i18n = i18nFromProps || i18nFromContext || (0,_context_js__WEBPACK_IMPORTED_MODULE_2__.getI18n)();\n  const t = tFromProps || i18n?.t.bind(i18n);\n  return (0,_TransWithoutContext_js__WEBPACK_IMPORTED_MODULE_1__.Trans)({\n    children,\n    count,\n    parent,\n    i18nKey,\n    context,\n    tOptions,\n    values,\n    defaults,\n    components,\n    ns: ns || t?.ns || defaultNSFromContext || i18n?.options?.defaultNS,\n    i18n,\n    t: tFromProps,\n    shouldUnescape,\n    ...additionalProps\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QtaTE4bmV4dC9kaXN0L2VzL1RyYW5zLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQW1DO0FBQ29EO0FBQ25DO0FBQzNCO0FBQ2xCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLElBQUksRUFBRSxpREFBVSxDQUFDLG9EQUFXO0FBQzVCLG1EQUFtRCxvREFBTztBQUMxRDtBQUNBLFNBQVMsOERBQW1CO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1pMThuZXh0L2Rpc3QvZXMvVHJhbnMuanM/OWM1YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgbm9kZXNUb1N0cmluZywgVHJhbnMgYXMgVHJhbnNXaXRob3V0Q29udGV4dCB9IGZyb20gJy4vVHJhbnNXaXRob3V0Q29udGV4dC5qcyc7XG5pbXBvcnQgeyBnZXRJMThuLCBJMThuQ29udGV4dCB9IGZyb20gJy4vY29udGV4dC5qcyc7XG5leHBvcnQgeyBub2Rlc1RvU3RyaW5nIH07XG5leHBvcnQgZnVuY3Rpb24gVHJhbnMoe1xuICBjaGlsZHJlbixcbiAgY291bnQsXG4gIHBhcmVudCxcbiAgaTE4bktleSxcbiAgY29udGV4dCxcbiAgdE9wdGlvbnMgPSB7fSxcbiAgdmFsdWVzLFxuICBkZWZhdWx0cyxcbiAgY29tcG9uZW50cyxcbiAgbnMsXG4gIGkxOG46IGkxOG5Gcm9tUHJvcHMsXG4gIHQ6IHRGcm9tUHJvcHMsXG4gIHNob3VsZFVuZXNjYXBlLFxuICAuLi5hZGRpdGlvbmFsUHJvcHNcbn0pIHtcbiAgY29uc3Qge1xuICAgIGkxOG46IGkxOG5Gcm9tQ29udGV4dCxcbiAgICBkZWZhdWx0TlM6IGRlZmF1bHROU0Zyb21Db250ZXh0XG4gIH0gPSB1c2VDb250ZXh0KEkxOG5Db250ZXh0KSB8fCB7fTtcbiAgY29uc3QgaTE4biA9IGkxOG5Gcm9tUHJvcHMgfHwgaTE4bkZyb21Db250ZXh0IHx8IGdldEkxOG4oKTtcbiAgY29uc3QgdCA9IHRGcm9tUHJvcHMgfHwgaTE4bj8udC5iaW5kKGkxOG4pO1xuICByZXR1cm4gVHJhbnNXaXRob3V0Q29udGV4dCh7XG4gICAgY2hpbGRyZW4sXG4gICAgY291bnQsXG4gICAgcGFyZW50LFxuICAgIGkxOG5LZXksXG4gICAgY29udGV4dCxcbiAgICB0T3B0aW9ucyxcbiAgICB2YWx1ZXMsXG4gICAgZGVmYXVsdHMsXG4gICAgY29tcG9uZW50cyxcbiAgICBuczogbnMgfHwgdD8ubnMgfHwgZGVmYXVsdE5TRnJvbUNvbnRleHQgfHwgaTE4bj8ub3B0aW9ucz8uZGVmYXVsdE5TLFxuICAgIGkxOG4sXG4gICAgdDogdEZyb21Qcm9wcyxcbiAgICBzaG91bGRVbmVzY2FwZSxcbiAgICAuLi5hZGRpdGlvbmFsUHJvcHNcbiAgfSk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/react-i18next/dist/es/Trans.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/react-i18next/dist/es/TransWithoutContext.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/react-i18next/dist/es/TransWithoutContext.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Trans: function() { return /* binding */ Trans; },\n/* harmony export */   nodesToString: function() { return /* binding */ nodesToString; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var html_parse_stringify__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! html-parse-stringify */ \"(app-pages-browser)/../../node_modules/html-parse-stringify/dist/html-parse-stringify.module.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../../node_modules/react-i18next/dist/es/utils.js\");\n/* harmony import */ var _defaults_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./defaults.js */ \"(app-pages-browser)/../../node_modules/react-i18next/dist/es/defaults.js\");\n/* harmony import */ var _i18nInstance_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./i18nInstance.js */ \"(app-pages-browser)/../../node_modules/react-i18next/dist/es/i18nInstance.js\");\n\n\n\n\n\nconst hasChildren = (node, checkLength) => {\n  if (!node) return false;\n  const base = node.props?.children ?? node.children;\n  if (checkLength) return base.length > 0;\n  return !!base;\n};\nconst getChildren = node => {\n  if (!node) return [];\n  const children = node.props?.children ?? node.children;\n  return node.props?.i18nIsDynamicList ? getAsArray(children) : children;\n};\nconst hasValidReactChildren = children => Array.isArray(children) && children.every(react__WEBPACK_IMPORTED_MODULE_0__.isValidElement);\nconst getAsArray = data => Array.isArray(data) ? data : [data];\nconst mergeProps = (source, target) => {\n  const newTarget = {\n    ...target\n  };\n  newTarget.props = Object.assign(source.props, target.props);\n  return newTarget;\n};\nconst nodesToString = (children, i18nOptions) => {\n  if (!children) return '';\n  let stringNode = '';\n  const childrenArray = getAsArray(children);\n  const keepArray = i18nOptions?.transSupportBasicHtmlNodes ? i18nOptions.transKeepBasicHtmlNodesFor ?? [] : [];\n  childrenArray.forEach((child, childIndex) => {\n    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.isString)(child)) {\n      stringNode += `${child}`;\n    } else if ((0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(child)) {\n      const {\n        props,\n        type\n      } = child;\n      const childPropsCount = Object.keys(props).length;\n      const shouldKeepChild = keepArray.indexOf(type) > -1;\n      const childChildren = props.children;\n      if (!childChildren && shouldKeepChild && !childPropsCount) {\n        stringNode += `<${type}/>`;\n      } else if (!childChildren && (!shouldKeepChild || childPropsCount) || props.i18nIsDynamicList) {\n        stringNode += `<${childIndex}></${childIndex}>`;\n      } else if (shouldKeepChild && childPropsCount === 1 && (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.isString)(childChildren)) {\n        stringNode += `<${type}>${childChildren}</${type}>`;\n      } else {\n        const content = nodesToString(childChildren, i18nOptions);\n        stringNode += `<${childIndex}>${content}</${childIndex}>`;\n      }\n    } else if (child === null) {\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.warn)(`Trans: the passed in value is invalid - seems you passed in a null child.`);\n    } else if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.isObject)(child)) {\n      const {\n        format,\n        ...clone\n      } = child;\n      const keys = Object.keys(clone);\n      if (keys.length === 1) {\n        const value = format ? `${keys[0]}, ${format}` : keys[0];\n        stringNode += `{{${value}}}`;\n      } else {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.warn)(`react-i18next: the passed in object contained more than one variable - the object should look like {{ value, format }} where format is optional.`, child);\n      }\n    } else {\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.warn)(`Trans: the passed in value is invalid - seems you passed in a variable like {number} - please pass in variables for interpolation as full objects like {{number}}.`, child);\n    }\n  });\n  return stringNode;\n};\nconst renderNodes = (children, targetString, i18n, i18nOptions, combinedTOpts, shouldUnescape) => {\n  if (targetString === '') return [];\n  const keepArray = i18nOptions.transKeepBasicHtmlNodesFor || [];\n  const emptyChildrenButNeedsHandling = targetString && new RegExp(keepArray.map(keep => `<${keep}`).join('|')).test(targetString);\n  if (!children && !emptyChildrenButNeedsHandling && !shouldUnescape) return [targetString];\n  const data = {};\n  const getData = childs => {\n    const childrenArray = getAsArray(childs);\n    childrenArray.forEach(child => {\n      if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.isString)(child)) return;\n      if (hasChildren(child)) getData(getChildren(child));else if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.isObject)(child) && !(0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(child)) Object.assign(data, child);\n    });\n  };\n  getData(children);\n  const ast = html_parse_stringify__WEBPACK_IMPORTED_MODULE_1__[\"default\"].parse(`<0>${targetString}</0>`);\n  const opts = {\n    ...data,\n    ...combinedTOpts\n  };\n  const renderInner = (child, node, rootReactNode) => {\n    const childs = getChildren(child);\n    const mappedChildren = mapAST(childs, node.children, rootReactNode);\n    return hasValidReactChildren(childs) && mappedChildren.length === 0 || child.props?.i18nIsDynamicList ? childs : mappedChildren;\n  };\n  const pushTranslatedJSX = (child, inner, mem, i, isVoid) => {\n    if (child.dummy) {\n      child.children = inner;\n      mem.push((0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(child, {\n        key: i\n      }, isVoid ? undefined : inner));\n    } else {\n      mem.push(...react__WEBPACK_IMPORTED_MODULE_0__.Children.map([child], c => {\n        const props = {\n          ...c.props\n        };\n        delete props.i18nIsDynamicList;\n        return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(c.type, {\n          ...props,\n          key: i,\n          ref: c.ref\n        }, isVoid ? null : inner);\n      }));\n    }\n  };\n  const mapAST = (reactNode, astNode, rootReactNode) => {\n    const reactNodes = getAsArray(reactNode);\n    const astNodes = getAsArray(astNode);\n    return astNodes.reduce((mem, node, i) => {\n      const translationContent = node.children?.[0]?.content && i18n.services.interpolator.interpolate(node.children[0].content, opts, i18n.language);\n      if (node.type === 'tag') {\n        let tmp = reactNodes[parseInt(node.name, 10)];\n        if (rootReactNode.length === 1 && !tmp) tmp = rootReactNode[0][node.name];\n        if (!tmp) tmp = {};\n        const child = Object.keys(node.attrs).length !== 0 ? mergeProps({\n          props: node.attrs\n        }, tmp) : tmp;\n        const isElement = (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(child);\n        const isValidTranslationWithChildren = isElement && hasChildren(node, true) && !node.voidElement;\n        const isEmptyTransWithHTML = emptyChildrenButNeedsHandling && (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.isObject)(child) && child.dummy && !isElement;\n        const isKnownComponent = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.isObject)(children) && Object.hasOwnProperty.call(children, node.name);\n        if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.isString)(child)) {\n          const value = i18n.services.interpolator.interpolate(child, opts, i18n.language);\n          mem.push(value);\n        } else if (hasChildren(child) || isValidTranslationWithChildren) {\n          const inner = renderInner(child, node, rootReactNode);\n          pushTranslatedJSX(child, inner, mem, i);\n        } else if (isEmptyTransWithHTML) {\n          const inner = mapAST(reactNodes, node.children, rootReactNode);\n          pushTranslatedJSX(child, inner, mem, i);\n        } else if (Number.isNaN(parseFloat(node.name))) {\n          if (isKnownComponent) {\n            const inner = renderInner(child, node, rootReactNode);\n            pushTranslatedJSX(child, inner, mem, i, node.voidElement);\n          } else if (i18nOptions.transSupportBasicHtmlNodes && keepArray.indexOf(node.name) > -1) {\n            if (node.voidElement) {\n              mem.push((0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(node.name, {\n                key: `${node.name}-${i}`\n              }));\n            } else {\n              const inner = mapAST(reactNodes, node.children, rootReactNode);\n              mem.push((0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(node.name, {\n                key: `${node.name}-${i}`\n              }, inner));\n            }\n          } else if (node.voidElement) {\n            mem.push(`<${node.name} />`);\n          } else {\n            const inner = mapAST(reactNodes, node.children, rootReactNode);\n            mem.push(`<${node.name}>${inner}</${node.name}>`);\n          }\n        } else if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.isObject)(child) && !isElement) {\n          const content = node.children[0] ? translationContent : null;\n          if (content) mem.push(content);\n        } else {\n          pushTranslatedJSX(child, translationContent, mem, i, node.children.length !== 1 || !translationContent);\n        }\n      } else if (node.type === 'text') {\n        const wrapTextNodes = i18nOptions.transWrapTextNodes;\n        const content = shouldUnescape ? i18nOptions.unescape(i18n.services.interpolator.interpolate(node.content, opts, i18n.language)) : i18n.services.interpolator.interpolate(node.content, opts, i18n.language);\n        if (wrapTextNodes) {\n          mem.push((0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(wrapTextNodes, {\n            key: `${node.name}-${i}`\n          }, content));\n        } else {\n          mem.push(content);\n        }\n      }\n      return mem;\n    }, []);\n  };\n  const result = mapAST([{\n    dummy: true,\n    children: children || []\n  }], ast, getAsArray(children || []));\n  return getChildren(result[0]);\n};\nfunction Trans({\n  children,\n  count,\n  parent,\n  i18nKey,\n  context,\n  tOptions = {},\n  values,\n  defaults,\n  components,\n  ns,\n  i18n: i18nFromProps,\n  t: tFromProps,\n  shouldUnescape,\n  ...additionalProps\n}) {\n  const i18n = i18nFromProps || (0,_i18nInstance_js__WEBPACK_IMPORTED_MODULE_4__.getI18n)();\n  if (!i18n) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.warnOnce)('You will need to pass in an i18next instance by using i18nextReactModule');\n    return children;\n  }\n  const t = tFromProps || i18n.t.bind(i18n) || (k => k);\n  const reactI18nextOptions = {\n    ...(0,_defaults_js__WEBPACK_IMPORTED_MODULE_3__.getDefaults)(),\n    ...i18n.options?.react\n  };\n  let namespaces = ns || t.ns || i18n.options?.defaultNS;\n  namespaces = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.isString)(namespaces) ? [namespaces] : namespaces || ['translation'];\n  const nodeAsString = nodesToString(children, reactI18nextOptions);\n  const defaultValue = defaults || nodeAsString || reactI18nextOptions.transEmptyNodeValue || i18nKey;\n  const {\n    hashTransKey\n  } = reactI18nextOptions;\n  const key = i18nKey || (hashTransKey ? hashTransKey(nodeAsString || defaultValue) : nodeAsString || defaultValue);\n  if (i18n.options?.interpolation?.defaultVariables) {\n    values = values && Object.keys(values).length > 0 ? {\n      ...values,\n      ...i18n.options.interpolation.defaultVariables\n    } : {\n      ...i18n.options.interpolation.defaultVariables\n    };\n  }\n  const interpolationOverride = values || count !== undefined || !children ? tOptions.interpolation : {\n    interpolation: {\n      ...tOptions.interpolation,\n      prefix: '#$?',\n      suffix: '?$#'\n    }\n  };\n  const combinedTOpts = {\n    ...tOptions,\n    context: context || tOptions.context,\n    count,\n    ...values,\n    ...interpolationOverride,\n    defaultValue,\n    ns: namespaces\n  };\n  const translation = key ? t(key, combinedTOpts) : defaultValue;\n  if (components) {\n    Object.keys(components).forEach(c => {\n      const comp = components[c];\n      if (typeof comp.type === 'function' || !comp.props || !comp.props.children || translation.indexOf(`${c}/>`) < 0 && translation.indexOf(`${c} />`) < 0) return;\n      function Componentized() {\n        return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, comp);\n      }\n      components[c] = (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Componentized);\n    });\n  }\n  const content = renderNodes(components || children, translation, i18n, reactI18nextOptions, combinedTOpts, shouldUnescape);\n  const useAsParent = parent ?? reactI18nextOptions.defaultTransParent;\n  return useAsParent ? (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(useAsParent, additionalProps, content) : content;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QtaTE4bmV4dC9kaXN0L2VzL1RyYW5zV2l0aG91dENvbnRleHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUF3RjtBQUNoRDtBQUN3QjtBQUNwQjtBQUNBO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsaURBQWM7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsbURBQVE7QUFDaEIsdUJBQXVCLE1BQU07QUFDN0IsTUFBTSxTQUFTLHFEQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixLQUFLO0FBQy9CLFFBQVE7QUFDUiwwQkFBMEIsV0FBVyxLQUFLLFdBQVc7QUFDckQsUUFBUSxxREFBcUQsbURBQVE7QUFDckUsMEJBQTBCLEtBQUssR0FBRyxjQUFjLElBQUksS0FBSztBQUN6RCxRQUFRO0FBQ1I7QUFDQSwwQkFBMEIsV0FBVyxHQUFHLFFBQVEsSUFBSSxXQUFXO0FBQy9EO0FBQ0EsTUFBTTtBQUNOLE1BQU0sK0NBQUk7QUFDVixNQUFNLFNBQVMsbURBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUSxJQUFJLE9BQU87QUFDckQseUJBQXlCLEVBQUUsUUFBUTtBQUNuQyxRQUFRO0FBQ1IsUUFBUSwrQ0FBSSx3R0FBd0csaUJBQWlCO0FBQ3JJO0FBQ0EsTUFBTTtBQUNOLE1BQU0sK0NBQUksK0VBQStFLFFBQVEsb0VBQW9FLFFBQVE7QUFDN0s7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RixLQUFLO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1EQUFRO0FBQ2xCLDBEQUEwRCxTQUFTLG1EQUFRLFlBQVkscURBQWM7QUFDckcsS0FBSztBQUNMO0FBQ0E7QUFDQSxjQUFjLDREQUFJLGFBQWEsYUFBYTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1EQUFZO0FBQzNCO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTixrQkFBa0IsMkNBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9EQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsMEJBQTBCLHFEQUFjO0FBQ3hDO0FBQ0Esc0VBQXNFLG1EQUFRO0FBQzlFLGlDQUFpQyxtREFBUTtBQUN6QyxZQUFZLG1EQUFRO0FBQ3BCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLHVCQUF1QixvREFBYTtBQUNwQyx3QkFBd0IsVUFBVSxHQUFHLEVBQUU7QUFDdkMsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBLHVCQUF1QixvREFBYTtBQUNwQyx3QkFBd0IsVUFBVSxHQUFHLEVBQUU7QUFDdkMsZUFBZTtBQUNmO0FBQ0EsWUFBWTtBQUNaLHlCQUF5QixXQUFXO0FBQ3BDLFlBQVk7QUFDWjtBQUNBLHlCQUF5QixVQUFVLEdBQUcsTUFBTSxJQUFJLFVBQVU7QUFDMUQ7QUFDQSxVQUFVLFNBQVMsbURBQVE7QUFDM0I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvREFBYTtBQUNoQyxvQkFBb0IsVUFBVSxHQUFHLEVBQUU7QUFDbkMsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZ0NBQWdDLHlEQUFPO0FBQ3ZDO0FBQ0EsSUFBSSxtREFBUTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyx5REFBVztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1EQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJHQUEyRyxFQUFFLG1DQUFtQyxHQUFHO0FBQ25KO0FBQ0EsZUFBZSxvREFBYSxDQUFDLDJDQUFRO0FBQ3JDO0FBQ0Esc0JBQXNCLG9EQUFhO0FBQ25DLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0RBQWE7QUFDcEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1pMThuZXh0L2Rpc3QvZXMvVHJhbnNXaXRob3V0Q29udGV4dC5qcz9hZGUwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEZyYWdtZW50LCBpc1ZhbGlkRWxlbWVudCwgY2xvbmVFbGVtZW50LCBjcmVhdGVFbGVtZW50LCBDaGlsZHJlbiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBIVE1MIGZyb20gJ2h0bWwtcGFyc2Utc3RyaW5naWZ5JztcbmltcG9ydCB7IGlzT2JqZWN0LCBpc1N0cmluZywgd2Fybiwgd2Fybk9uY2UgfSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IGdldERlZmF1bHRzIH0gZnJvbSAnLi9kZWZhdWx0cy5qcyc7XG5pbXBvcnQgeyBnZXRJMThuIH0gZnJvbSAnLi9pMThuSW5zdGFuY2UuanMnO1xuY29uc3QgaGFzQ2hpbGRyZW4gPSAobm9kZSwgY2hlY2tMZW5ndGgpID0+IHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGJhc2UgPSBub2RlLnByb3BzPy5jaGlsZHJlbiA/PyBub2RlLmNoaWxkcmVuO1xuICBpZiAoY2hlY2tMZW5ndGgpIHJldHVybiBiYXNlLmxlbmd0aCA+IDA7XG4gIHJldHVybiAhIWJhc2U7XG59O1xuY29uc3QgZ2V0Q2hpbGRyZW4gPSBub2RlID0+IHtcbiAgaWYgKCFub2RlKSByZXR1cm4gW107XG4gIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5wcm9wcz8uY2hpbGRyZW4gPz8gbm9kZS5jaGlsZHJlbjtcbiAgcmV0dXJuIG5vZGUucHJvcHM/LmkxOG5Jc0R5bmFtaWNMaXN0ID8gZ2V0QXNBcnJheShjaGlsZHJlbikgOiBjaGlsZHJlbjtcbn07XG5jb25zdCBoYXNWYWxpZFJlYWN0Q2hpbGRyZW4gPSBjaGlsZHJlbiA9PiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJiBjaGlsZHJlbi5ldmVyeShpc1ZhbGlkRWxlbWVudCk7XG5jb25zdCBnZXRBc0FycmF5ID0gZGF0YSA9PiBBcnJheS5pc0FycmF5KGRhdGEpID8gZGF0YSA6IFtkYXRhXTtcbmNvbnN0IG1lcmdlUHJvcHMgPSAoc291cmNlLCB0YXJnZXQpID0+IHtcbiAgY29uc3QgbmV3VGFyZ2V0ID0ge1xuICAgIC4uLnRhcmdldFxuICB9O1xuICBuZXdUYXJnZXQucHJvcHMgPSBPYmplY3QuYXNzaWduKHNvdXJjZS5wcm9wcywgdGFyZ2V0LnByb3BzKTtcbiAgcmV0dXJuIG5ld1RhcmdldDtcbn07XG5leHBvcnQgY29uc3Qgbm9kZXNUb1N0cmluZyA9IChjaGlsZHJlbiwgaTE4bk9wdGlvbnMpID0+IHtcbiAgaWYgKCFjaGlsZHJlbikgcmV0dXJuICcnO1xuICBsZXQgc3RyaW5nTm9kZSA9ICcnO1xuICBjb25zdCBjaGlsZHJlbkFycmF5ID0gZ2V0QXNBcnJheShjaGlsZHJlbik7XG4gIGNvbnN0IGtlZXBBcnJheSA9IGkxOG5PcHRpb25zPy50cmFuc1N1cHBvcnRCYXNpY0h0bWxOb2RlcyA/IGkxOG5PcHRpb25zLnRyYW5zS2VlcEJhc2ljSHRtbE5vZGVzRm9yID8/IFtdIDogW107XG4gIGNoaWxkcmVuQXJyYXkuZm9yRWFjaCgoY2hpbGQsIGNoaWxkSW5kZXgpID0+IHtcbiAgICBpZiAoaXNTdHJpbmcoY2hpbGQpKSB7XG4gICAgICBzdHJpbmdOb2RlICs9IGAke2NoaWxkfWA7XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHR5cGVcbiAgICAgIH0gPSBjaGlsZDtcbiAgICAgIGNvbnN0IGNoaWxkUHJvcHNDb3VudCA9IE9iamVjdC5rZXlzKHByb3BzKS5sZW5ndGg7XG4gICAgICBjb25zdCBzaG91bGRLZWVwQ2hpbGQgPSBrZWVwQXJyYXkuaW5kZXhPZih0eXBlKSA+IC0xO1xuICAgICAgY29uc3QgY2hpbGRDaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICAgICAgaWYgKCFjaGlsZENoaWxkcmVuICYmIHNob3VsZEtlZXBDaGlsZCAmJiAhY2hpbGRQcm9wc0NvdW50KSB7XG4gICAgICAgIHN0cmluZ05vZGUgKz0gYDwke3R5cGV9Lz5gO1xuICAgICAgfSBlbHNlIGlmICghY2hpbGRDaGlsZHJlbiAmJiAoIXNob3VsZEtlZXBDaGlsZCB8fCBjaGlsZFByb3BzQ291bnQpIHx8IHByb3BzLmkxOG5Jc0R5bmFtaWNMaXN0KSB7XG4gICAgICAgIHN0cmluZ05vZGUgKz0gYDwke2NoaWxkSW5kZXh9PjwvJHtjaGlsZEluZGV4fT5gO1xuICAgICAgfSBlbHNlIGlmIChzaG91bGRLZWVwQ2hpbGQgJiYgY2hpbGRQcm9wc0NvdW50ID09PSAxICYmIGlzU3RyaW5nKGNoaWxkQ2hpbGRyZW4pKSB7XG4gICAgICAgIHN0cmluZ05vZGUgKz0gYDwke3R5cGV9PiR7Y2hpbGRDaGlsZHJlbn08LyR7dHlwZX0+YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBub2Rlc1RvU3RyaW5nKGNoaWxkQ2hpbGRyZW4sIGkxOG5PcHRpb25zKTtcbiAgICAgICAgc3RyaW5nTm9kZSArPSBgPCR7Y2hpbGRJbmRleH0+JHtjb250ZW50fTwvJHtjaGlsZEluZGV4fT5gO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2hpbGQgPT09IG51bGwpIHtcbiAgICAgIHdhcm4oYFRyYW5zOiB0aGUgcGFzc2VkIGluIHZhbHVlIGlzIGludmFsaWQgLSBzZWVtcyB5b3UgcGFzc2VkIGluIGEgbnVsbCBjaGlsZC5gKTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGNoaWxkKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBmb3JtYXQsXG4gICAgICAgIC4uLmNsb25lXG4gICAgICB9ID0gY2hpbGQ7XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoY2xvbmUpO1xuICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZm9ybWF0ID8gYCR7a2V5c1swXX0sICR7Zm9ybWF0fWAgOiBrZXlzWzBdO1xuICAgICAgICBzdHJpbmdOb2RlICs9IGB7eyR7dmFsdWV9fX1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybihgcmVhY3QtaTE4bmV4dDogdGhlIHBhc3NlZCBpbiBvYmplY3QgY29udGFpbmVkIG1vcmUgdGhhbiBvbmUgdmFyaWFibGUgLSB0aGUgb2JqZWN0IHNob3VsZCBsb29rIGxpa2Uge3sgdmFsdWUsIGZvcm1hdCB9fSB3aGVyZSBmb3JtYXQgaXMgb3B0aW9uYWwuYCwgY2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKGBUcmFuczogdGhlIHBhc3NlZCBpbiB2YWx1ZSBpcyBpbnZhbGlkIC0gc2VlbXMgeW91IHBhc3NlZCBpbiBhIHZhcmlhYmxlIGxpa2Uge251bWJlcn0gLSBwbGVhc2UgcGFzcyBpbiB2YXJpYWJsZXMgZm9yIGludGVycG9sYXRpb24gYXMgZnVsbCBvYmplY3RzIGxpa2Uge3tudW1iZXJ9fS5gLCBjaGlsZCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHN0cmluZ05vZGU7XG59O1xuY29uc3QgcmVuZGVyTm9kZXMgPSAoY2hpbGRyZW4sIHRhcmdldFN0cmluZywgaTE4biwgaTE4bk9wdGlvbnMsIGNvbWJpbmVkVE9wdHMsIHNob3VsZFVuZXNjYXBlKSA9PiB7XG4gIGlmICh0YXJnZXRTdHJpbmcgPT09ICcnKSByZXR1cm4gW107XG4gIGNvbnN0IGtlZXBBcnJheSA9IGkxOG5PcHRpb25zLnRyYW5zS2VlcEJhc2ljSHRtbE5vZGVzRm9yIHx8IFtdO1xuICBjb25zdCBlbXB0eUNoaWxkcmVuQnV0TmVlZHNIYW5kbGluZyA9IHRhcmdldFN0cmluZyAmJiBuZXcgUmVnRXhwKGtlZXBBcnJheS5tYXAoa2VlcCA9PiBgPCR7a2VlcH1gKS5qb2luKCd8JykpLnRlc3QodGFyZ2V0U3RyaW5nKTtcbiAgaWYgKCFjaGlsZHJlbiAmJiAhZW1wdHlDaGlsZHJlbkJ1dE5lZWRzSGFuZGxpbmcgJiYgIXNob3VsZFVuZXNjYXBlKSByZXR1cm4gW3RhcmdldFN0cmluZ107XG4gIGNvbnN0IGRhdGEgPSB7fTtcbiAgY29uc3QgZ2V0RGF0YSA9IGNoaWxkcyA9PiB7XG4gICAgY29uc3QgY2hpbGRyZW5BcnJheSA9IGdldEFzQXJyYXkoY2hpbGRzKTtcbiAgICBjaGlsZHJlbkFycmF5LmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgaWYgKGlzU3RyaW5nKGNoaWxkKSkgcmV0dXJuO1xuICAgICAgaWYgKGhhc0NoaWxkcmVuKGNoaWxkKSkgZ2V0RGF0YShnZXRDaGlsZHJlbihjaGlsZCkpO2Vsc2UgaWYgKGlzT2JqZWN0KGNoaWxkKSAmJiAhaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSBPYmplY3QuYXNzaWduKGRhdGEsIGNoaWxkKTtcbiAgICB9KTtcbiAgfTtcbiAgZ2V0RGF0YShjaGlsZHJlbik7XG4gIGNvbnN0IGFzdCA9IEhUTUwucGFyc2UoYDwwPiR7dGFyZ2V0U3RyaW5nfTwvMD5gKTtcbiAgY29uc3Qgb3B0cyA9IHtcbiAgICAuLi5kYXRhLFxuICAgIC4uLmNvbWJpbmVkVE9wdHNcbiAgfTtcbiAgY29uc3QgcmVuZGVySW5uZXIgPSAoY2hpbGQsIG5vZGUsIHJvb3RSZWFjdE5vZGUpID0+IHtcbiAgICBjb25zdCBjaGlsZHMgPSBnZXRDaGlsZHJlbihjaGlsZCk7XG4gICAgY29uc3QgbWFwcGVkQ2hpbGRyZW4gPSBtYXBBU1QoY2hpbGRzLCBub2RlLmNoaWxkcmVuLCByb290UmVhY3ROb2RlKTtcbiAgICByZXR1cm4gaGFzVmFsaWRSZWFjdENoaWxkcmVuKGNoaWxkcykgJiYgbWFwcGVkQ2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8IGNoaWxkLnByb3BzPy5pMThuSXNEeW5hbWljTGlzdCA/IGNoaWxkcyA6IG1hcHBlZENoaWxkcmVuO1xuICB9O1xuICBjb25zdCBwdXNoVHJhbnNsYXRlZEpTWCA9IChjaGlsZCwgaW5uZXIsIG1lbSwgaSwgaXNWb2lkKSA9PiB7XG4gICAgaWYgKGNoaWxkLmR1bW15KSB7XG4gICAgICBjaGlsZC5jaGlsZHJlbiA9IGlubmVyO1xuICAgICAgbWVtLnB1c2goY2xvbmVFbGVtZW50KGNoaWxkLCB7XG4gICAgICAgIGtleTogaVxuICAgICAgfSwgaXNWb2lkID8gdW5kZWZpbmVkIDogaW5uZXIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWVtLnB1c2goLi4uQ2hpbGRyZW4ubWFwKFtjaGlsZF0sIGMgPT4ge1xuICAgICAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgICAgICAuLi5jLnByb3BzXG4gICAgICAgIH07XG4gICAgICAgIGRlbGV0ZSBwcm9wcy5pMThuSXNEeW5hbWljTGlzdDtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoYy50eXBlLCB7XG4gICAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgICAga2V5OiBpLFxuICAgICAgICAgIHJlZjogYy5yZWZcbiAgICAgICAgfSwgaXNWb2lkID8gbnVsbCA6IGlubmVyKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG1hcEFTVCA9IChyZWFjdE5vZGUsIGFzdE5vZGUsIHJvb3RSZWFjdE5vZGUpID0+IHtcbiAgICBjb25zdCByZWFjdE5vZGVzID0gZ2V0QXNBcnJheShyZWFjdE5vZGUpO1xuICAgIGNvbnN0IGFzdE5vZGVzID0gZ2V0QXNBcnJheShhc3ROb2RlKTtcbiAgICByZXR1cm4gYXN0Tm9kZXMucmVkdWNlKChtZW0sIG5vZGUsIGkpID0+IHtcbiAgICAgIGNvbnN0IHRyYW5zbGF0aW9uQ29udGVudCA9IG5vZGUuY2hpbGRyZW4/LlswXT8uY29udGVudCAmJiBpMThuLnNlcnZpY2VzLmludGVycG9sYXRvci5pbnRlcnBvbGF0ZShub2RlLmNoaWxkcmVuWzBdLmNvbnRlbnQsIG9wdHMsIGkxOG4ubGFuZ3VhZ2UpO1xuICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ3RhZycpIHtcbiAgICAgICAgbGV0IHRtcCA9IHJlYWN0Tm9kZXNbcGFyc2VJbnQobm9kZS5uYW1lLCAxMCldO1xuICAgICAgICBpZiAocm9vdFJlYWN0Tm9kZS5sZW5ndGggPT09IDEgJiYgIXRtcCkgdG1wID0gcm9vdFJlYWN0Tm9kZVswXVtub2RlLm5hbWVdO1xuICAgICAgICBpZiAoIXRtcCkgdG1wID0ge307XG4gICAgICAgIGNvbnN0IGNoaWxkID0gT2JqZWN0LmtleXMobm9kZS5hdHRycykubGVuZ3RoICE9PSAwID8gbWVyZ2VQcm9wcyh7XG4gICAgICAgICAgcHJvcHM6IG5vZGUuYXR0cnNcbiAgICAgICAgfSwgdG1wKSA6IHRtcDtcbiAgICAgICAgY29uc3QgaXNFbGVtZW50ID0gaXNWYWxpZEVsZW1lbnQoY2hpbGQpO1xuICAgICAgICBjb25zdCBpc1ZhbGlkVHJhbnNsYXRpb25XaXRoQ2hpbGRyZW4gPSBpc0VsZW1lbnQgJiYgaGFzQ2hpbGRyZW4obm9kZSwgdHJ1ZSkgJiYgIW5vZGUudm9pZEVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGlzRW1wdHlUcmFuc1dpdGhIVE1MID0gZW1wdHlDaGlsZHJlbkJ1dE5lZWRzSGFuZGxpbmcgJiYgaXNPYmplY3QoY2hpbGQpICYmIGNoaWxkLmR1bW15ICYmICFpc0VsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGlzS25vd25Db21wb25lbnQgPSBpc09iamVjdChjaGlsZHJlbikgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoY2hpbGRyZW4sIG5vZGUubmFtZSk7XG4gICAgICAgIGlmIChpc1N0cmluZyhjaGlsZCkpIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGkxOG4uc2VydmljZXMuaW50ZXJwb2xhdG9yLmludGVycG9sYXRlKGNoaWxkLCBvcHRzLCBpMThuLmxhbmd1YWdlKTtcbiAgICAgICAgICBtZW0ucHVzaCh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaGFzQ2hpbGRyZW4oY2hpbGQpIHx8IGlzVmFsaWRUcmFuc2xhdGlvbldpdGhDaGlsZHJlbikge1xuICAgICAgICAgIGNvbnN0IGlubmVyID0gcmVuZGVySW5uZXIoY2hpbGQsIG5vZGUsIHJvb3RSZWFjdE5vZGUpO1xuICAgICAgICAgIHB1c2hUcmFuc2xhdGVkSlNYKGNoaWxkLCBpbm5lciwgbWVtLCBpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0VtcHR5VHJhbnNXaXRoSFRNTCkge1xuICAgICAgICAgIGNvbnN0IGlubmVyID0gbWFwQVNUKHJlYWN0Tm9kZXMsIG5vZGUuY2hpbGRyZW4sIHJvb3RSZWFjdE5vZGUpO1xuICAgICAgICAgIHB1c2hUcmFuc2xhdGVkSlNYKGNoaWxkLCBpbm5lciwgbWVtLCBpKTtcbiAgICAgICAgfSBlbHNlIGlmIChOdW1iZXIuaXNOYU4ocGFyc2VGbG9hdChub2RlLm5hbWUpKSkge1xuICAgICAgICAgIGlmIChpc0tub3duQ29tcG9uZW50KSB7XG4gICAgICAgICAgICBjb25zdCBpbm5lciA9IHJlbmRlcklubmVyKGNoaWxkLCBub2RlLCByb290UmVhY3ROb2RlKTtcbiAgICAgICAgICAgIHB1c2hUcmFuc2xhdGVkSlNYKGNoaWxkLCBpbm5lciwgbWVtLCBpLCBub2RlLnZvaWRFbGVtZW50KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGkxOG5PcHRpb25zLnRyYW5zU3VwcG9ydEJhc2ljSHRtbE5vZGVzICYmIGtlZXBBcnJheS5pbmRleE9mKG5vZGUubmFtZSkgPiAtMSkge1xuICAgICAgICAgICAgaWYgKG5vZGUudm9pZEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgbWVtLnB1c2goY3JlYXRlRWxlbWVudChub2RlLm5hbWUsIHtcbiAgICAgICAgICAgICAgICBrZXk6IGAke25vZGUubmFtZX0tJHtpfWBcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3QgaW5uZXIgPSBtYXBBU1QocmVhY3ROb2Rlcywgbm9kZS5jaGlsZHJlbiwgcm9vdFJlYWN0Tm9kZSk7XG4gICAgICAgICAgICAgIG1lbS5wdXNoKGNyZWF0ZUVsZW1lbnQobm9kZS5uYW1lLCB7XG4gICAgICAgICAgICAgICAga2V5OiBgJHtub2RlLm5hbWV9LSR7aX1gXG4gICAgICAgICAgICAgIH0sIGlubmVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChub2RlLnZvaWRFbGVtZW50KSB7XG4gICAgICAgICAgICBtZW0ucHVzaChgPCR7bm9kZS5uYW1lfSAvPmApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpbm5lciA9IG1hcEFTVChyZWFjdE5vZGVzLCBub2RlLmNoaWxkcmVuLCByb290UmVhY3ROb2RlKTtcbiAgICAgICAgICAgIG1lbS5wdXNoKGA8JHtub2RlLm5hbWV9PiR7aW5uZXJ9PC8ke25vZGUubmFtZX0+YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGNoaWxkKSAmJiAhaXNFbGVtZW50KSB7XG4gICAgICAgICAgY29uc3QgY29udGVudCA9IG5vZGUuY2hpbGRyZW5bMF0gPyB0cmFuc2xhdGlvbkNvbnRlbnQgOiBudWxsO1xuICAgICAgICAgIGlmIChjb250ZW50KSBtZW0ucHVzaChjb250ZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwdXNoVHJhbnNsYXRlZEpTWChjaGlsZCwgdHJhbnNsYXRpb25Db250ZW50LCBtZW0sIGksIG5vZGUuY2hpbGRyZW4ubGVuZ3RoICE9PSAxIHx8ICF0cmFuc2xhdGlvbkNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgIGNvbnN0IHdyYXBUZXh0Tm9kZXMgPSBpMThuT3B0aW9ucy50cmFuc1dyYXBUZXh0Tm9kZXM7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBzaG91bGRVbmVzY2FwZSA/IGkxOG5PcHRpb25zLnVuZXNjYXBlKGkxOG4uc2VydmljZXMuaW50ZXJwb2xhdG9yLmludGVycG9sYXRlKG5vZGUuY29udGVudCwgb3B0cywgaTE4bi5sYW5ndWFnZSkpIDogaTE4bi5zZXJ2aWNlcy5pbnRlcnBvbGF0b3IuaW50ZXJwb2xhdGUobm9kZS5jb250ZW50LCBvcHRzLCBpMThuLmxhbmd1YWdlKTtcbiAgICAgICAgaWYgKHdyYXBUZXh0Tm9kZXMpIHtcbiAgICAgICAgICBtZW0ucHVzaChjcmVhdGVFbGVtZW50KHdyYXBUZXh0Tm9kZXMsIHtcbiAgICAgICAgICAgIGtleTogYCR7bm9kZS5uYW1lfS0ke2l9YFxuICAgICAgICAgIH0sIGNvbnRlbnQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtZW0ucHVzaChjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1lbTtcbiAgICB9LCBbXSk7XG4gIH07XG4gIGNvbnN0IHJlc3VsdCA9IG1hcEFTVChbe1xuICAgIGR1bW15OiB0cnVlLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbiB8fCBbXVxuICB9XSwgYXN0LCBnZXRBc0FycmF5KGNoaWxkcmVuIHx8IFtdKSk7XG4gIHJldHVybiBnZXRDaGlsZHJlbihyZXN1bHRbMF0pO1xufTtcbmV4cG9ydCBmdW5jdGlvbiBUcmFucyh7XG4gIGNoaWxkcmVuLFxuICBjb3VudCxcbiAgcGFyZW50LFxuICBpMThuS2V5LFxuICBjb250ZXh0LFxuICB0T3B0aW9ucyA9IHt9LFxuICB2YWx1ZXMsXG4gIGRlZmF1bHRzLFxuICBjb21wb25lbnRzLFxuICBucyxcbiAgaTE4bjogaTE4bkZyb21Qcm9wcyxcbiAgdDogdEZyb21Qcm9wcyxcbiAgc2hvdWxkVW5lc2NhcGUsXG4gIC4uLmFkZGl0aW9uYWxQcm9wc1xufSkge1xuICBjb25zdCBpMThuID0gaTE4bkZyb21Qcm9wcyB8fCBnZXRJMThuKCk7XG4gIGlmICghaTE4bikge1xuICAgIHdhcm5PbmNlKCdZb3Ugd2lsbCBuZWVkIHRvIHBhc3MgaW4gYW4gaTE4bmV4dCBpbnN0YW5jZSBieSB1c2luZyBpMThuZXh0UmVhY3RNb2R1bGUnKTtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgY29uc3QgdCA9IHRGcm9tUHJvcHMgfHwgaTE4bi50LmJpbmQoaTE4bikgfHwgKGsgPT4gayk7XG4gIGNvbnN0IHJlYWN0STE4bmV4dE9wdGlvbnMgPSB7XG4gICAgLi4uZ2V0RGVmYXVsdHMoKSxcbiAgICAuLi5pMThuLm9wdGlvbnM/LnJlYWN0XG4gIH07XG4gIGxldCBuYW1lc3BhY2VzID0gbnMgfHwgdC5ucyB8fCBpMThuLm9wdGlvbnM/LmRlZmF1bHROUztcbiAgbmFtZXNwYWNlcyA9IGlzU3RyaW5nKG5hbWVzcGFjZXMpID8gW25hbWVzcGFjZXNdIDogbmFtZXNwYWNlcyB8fCBbJ3RyYW5zbGF0aW9uJ107XG4gIGNvbnN0IG5vZGVBc1N0cmluZyA9IG5vZGVzVG9TdHJpbmcoY2hpbGRyZW4sIHJlYWN0STE4bmV4dE9wdGlvbnMpO1xuICBjb25zdCBkZWZhdWx0VmFsdWUgPSBkZWZhdWx0cyB8fCBub2RlQXNTdHJpbmcgfHwgcmVhY3RJMThuZXh0T3B0aW9ucy50cmFuc0VtcHR5Tm9kZVZhbHVlIHx8IGkxOG5LZXk7XG4gIGNvbnN0IHtcbiAgICBoYXNoVHJhbnNLZXlcbiAgfSA9IHJlYWN0STE4bmV4dE9wdGlvbnM7XG4gIGNvbnN0IGtleSA9IGkxOG5LZXkgfHwgKGhhc2hUcmFuc0tleSA/IGhhc2hUcmFuc0tleShub2RlQXNTdHJpbmcgfHwgZGVmYXVsdFZhbHVlKSA6IG5vZGVBc1N0cmluZyB8fCBkZWZhdWx0VmFsdWUpO1xuICBpZiAoaTE4bi5vcHRpb25zPy5pbnRlcnBvbGF0aW9uPy5kZWZhdWx0VmFyaWFibGVzKSB7XG4gICAgdmFsdWVzID0gdmFsdWVzICYmIE9iamVjdC5rZXlzKHZhbHVlcykubGVuZ3RoID4gMCA/IHtcbiAgICAgIC4uLnZhbHVlcyxcbiAgICAgIC4uLmkxOG4ub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmRlZmF1bHRWYXJpYWJsZXNcbiAgICB9IDoge1xuICAgICAgLi4uaTE4bi5vcHRpb25zLmludGVycG9sYXRpb24uZGVmYXVsdFZhcmlhYmxlc1xuICAgIH07XG4gIH1cbiAgY29uc3QgaW50ZXJwb2xhdGlvbk92ZXJyaWRlID0gdmFsdWVzIHx8IGNvdW50ICE9PSB1bmRlZmluZWQgfHwgIWNoaWxkcmVuID8gdE9wdGlvbnMuaW50ZXJwb2xhdGlvbiA6IHtcbiAgICBpbnRlcnBvbGF0aW9uOiB7XG4gICAgICAuLi50T3B0aW9ucy5pbnRlcnBvbGF0aW9uLFxuICAgICAgcHJlZml4OiAnIyQ/JyxcbiAgICAgIHN1ZmZpeDogJz8kIydcbiAgICB9XG4gIH07XG4gIGNvbnN0IGNvbWJpbmVkVE9wdHMgPSB7XG4gICAgLi4udE9wdGlvbnMsXG4gICAgY29udGV4dDogY29udGV4dCB8fCB0T3B0aW9ucy5jb250ZXh0LFxuICAgIGNvdW50LFxuICAgIC4uLnZhbHVlcyxcbiAgICAuLi5pbnRlcnBvbGF0aW9uT3ZlcnJpZGUsXG4gICAgZGVmYXVsdFZhbHVlLFxuICAgIG5zOiBuYW1lc3BhY2VzXG4gIH07XG4gIGNvbnN0IHRyYW5zbGF0aW9uID0ga2V5ID8gdChrZXksIGNvbWJpbmVkVE9wdHMpIDogZGVmYXVsdFZhbHVlO1xuICBpZiAoY29tcG9uZW50cykge1xuICAgIE9iamVjdC5rZXlzKGNvbXBvbmVudHMpLmZvckVhY2goYyA9PiB7XG4gICAgICBjb25zdCBjb21wID0gY29tcG9uZW50c1tjXTtcbiAgICAgIGlmICh0eXBlb2YgY29tcC50eXBlID09PSAnZnVuY3Rpb24nIHx8ICFjb21wLnByb3BzIHx8ICFjb21wLnByb3BzLmNoaWxkcmVuIHx8IHRyYW5zbGF0aW9uLmluZGV4T2YoYCR7Y30vPmApIDwgMCAmJiB0cmFuc2xhdGlvbi5pbmRleE9mKGAke2N9IC8+YCkgPCAwKSByZXR1cm47XG4gICAgICBmdW5jdGlvbiBDb21wb25lbnRpemVkKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgY29tcCk7XG4gICAgICB9XG4gICAgICBjb21wb25lbnRzW2NdID0gY3JlYXRlRWxlbWVudChDb21wb25lbnRpemVkKTtcbiAgICB9KTtcbiAgfVxuICBjb25zdCBjb250ZW50ID0gcmVuZGVyTm9kZXMoY29tcG9uZW50cyB8fCBjaGlsZHJlbiwgdHJhbnNsYXRpb24sIGkxOG4sIHJlYWN0STE4bmV4dE9wdGlvbnMsIGNvbWJpbmVkVE9wdHMsIHNob3VsZFVuZXNjYXBlKTtcbiAgY29uc3QgdXNlQXNQYXJlbnQgPSBwYXJlbnQgPz8gcmVhY3RJMThuZXh0T3B0aW9ucy5kZWZhdWx0VHJhbnNQYXJlbnQ7XG4gIHJldHVybiB1c2VBc1BhcmVudCA/IGNyZWF0ZUVsZW1lbnQodXNlQXNQYXJlbnQsIGFkZGl0aW9uYWxQcm9wcywgY29udGVudCkgOiBjb250ZW50O1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/react-i18next/dist/es/TransWithoutContext.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/react-i18next/dist/es/Translation.js":
/*!***************************************************************!*\
  !*** ../../node_modules/react-i18next/dist/es/Translation.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Translation: function() { return /* binding */ Translation; }\n/* harmony export */ });\n/* harmony import */ var _useTranslation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./useTranslation.js */ \"(app-pages-browser)/../../node_modules/react-i18next/dist/es/useTranslation.js\");\n\nconst Translation = ({\n  ns,\n  children,\n  ...options\n}) => {\n  const [t, i18n, ready] = (0,_useTranslation_js__WEBPACK_IMPORTED_MODULE_0__.useTranslation)(ns, options);\n  return children(t, {\n    i18n,\n    lng: i18n.language\n  }, ready);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QtaTE4bmV4dC9kaXN0L2VzL1RyYW5zbGF0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXFEO0FBQzlDO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDJCQUEyQixrRUFBYztBQUN6QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1pMThuZXh0L2Rpc3QvZXMvVHJhbnNsYXRpb24uanM/NWQwNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VUcmFuc2xhdGlvbiB9IGZyb20gJy4vdXNlVHJhbnNsYXRpb24uanMnO1xuZXhwb3J0IGNvbnN0IFRyYW5zbGF0aW9uID0gKHtcbiAgbnMsXG4gIGNoaWxkcmVuLFxuICAuLi5vcHRpb25zXG59KSA9PiB7XG4gIGNvbnN0IFt0LCBpMThuLCByZWFkeV0gPSB1c2VUcmFuc2xhdGlvbihucywgb3B0aW9ucyk7XG4gIHJldHVybiBjaGlsZHJlbih0LCB7XG4gICAgaTE4bixcbiAgICBsbmc6IGkxOG4ubGFuZ3VhZ2VcbiAgfSwgcmVhZHkpO1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/react-i18next/dist/es/Translation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/react-i18next/dist/es/context.js":
/*!***********************************************************!*\
  !*** ../../node_modules/react-i18next/dist/es/context.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   I18nContext: function() { return /* binding */ I18nContext; },\n/* harmony export */   ReportNamespaces: function() { return /* binding */ ReportNamespaces; },\n/* harmony export */   composeInitialProps: function() { return /* binding */ composeInitialProps; },\n/* harmony export */   getDefaults: function() { return /* reexport safe */ _defaults_js__WEBPACK_IMPORTED_MODULE_1__.getDefaults; },\n/* harmony export */   getI18n: function() { return /* reexport safe */ _i18nInstance_js__WEBPACK_IMPORTED_MODULE_2__.getI18n; },\n/* harmony export */   getInitialProps: function() { return /* binding */ getInitialProps; },\n/* harmony export */   initReactI18next: function() { return /* reexport safe */ _initReactI18next_js__WEBPACK_IMPORTED_MODULE_3__.initReactI18next; },\n/* harmony export */   setDefaults: function() { return /* reexport safe */ _defaults_js__WEBPACK_IMPORTED_MODULE_1__.setDefaults; },\n/* harmony export */   setI18n: function() { return /* reexport safe */ _i18nInstance_js__WEBPACK_IMPORTED_MODULE_2__.setI18n; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _defaults_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./defaults.js */ \"(app-pages-browser)/../../node_modules/react-i18next/dist/es/defaults.js\");\n/* harmony import */ var _i18nInstance_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./i18nInstance.js */ \"(app-pages-browser)/../../node_modules/react-i18next/dist/es/i18nInstance.js\");\n/* harmony import */ var _initReactI18next_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./initReactI18next.js */ \"(app-pages-browser)/../../node_modules/react-i18next/dist/es/initReactI18next.js\");\n\n\n\n\n\nconst I18nContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)();\nclass ReportNamespaces {\n  constructor() {\n    this.usedNamespaces = {};\n  }\n  addUsedNamespaces(namespaces) {\n    namespaces.forEach(ns => {\n      this.usedNamespaces[ns] ??= true;\n    });\n  }\n  getUsedNamespaces() {\n    return Object.keys(this.usedNamespaces);\n  }\n}\nconst composeInitialProps = ForComponent => async ctx => {\n  const componentsInitialProps = (await ForComponent.getInitialProps?.(ctx)) ?? {};\n  const i18nInitialProps = getInitialProps();\n  return {\n    ...componentsInitialProps,\n    ...i18nInitialProps\n  };\n};\nconst getInitialProps = () => {\n  const i18n = (0,_i18nInstance_js__WEBPACK_IMPORTED_MODULE_2__.getI18n)();\n  const namespaces = i18n.reportNamespaces?.getUsedNamespaces() ?? [];\n  const ret = {};\n  const initialI18nStore = {};\n  i18n.languages.forEach(l => {\n    initialI18nStore[l] = {};\n    namespaces.forEach(ns => {\n      initialI18nStore[l][ns] = i18n.getResourceBundle(l, ns) || {};\n    });\n  });\n  ret.initialI18nStore = initialI18nStore;\n  ret.initialLanguage = i18n.language;\n  return ret;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QtaTE4bmV4dC9kaXN0L2VzL2NvbnRleHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFzQztBQUNtQjtBQUNKO0FBQ0k7QUFDZTtBQUNqRSxvQkFBb0Isb0RBQWE7QUFDakM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGVBQWUseURBQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QtaTE4bmV4dC9kaXN0L2VzL2NvbnRleHQuanM/M2NiYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZ2V0RGVmYXVsdHMsIHNldERlZmF1bHRzIH0gZnJvbSAnLi9kZWZhdWx0cy5qcyc7XG5pbXBvcnQgeyBnZXRJMThuLCBzZXRJMThuIH0gZnJvbSAnLi9pMThuSW5zdGFuY2UuanMnO1xuaW1wb3J0IHsgaW5pdFJlYWN0STE4bmV4dCB9IGZyb20gJy4vaW5pdFJlYWN0STE4bmV4dC5qcyc7XG5leHBvcnQgeyBnZXREZWZhdWx0cywgc2V0RGVmYXVsdHMsIGdldEkxOG4sIHNldEkxOG4sIGluaXRSZWFjdEkxOG5leHQgfTtcbmV4cG9ydCBjb25zdCBJMThuQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoKTtcbmV4cG9ydCBjbGFzcyBSZXBvcnROYW1lc3BhY2VzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy51c2VkTmFtZXNwYWNlcyA9IHt9O1xuICB9XG4gIGFkZFVzZWROYW1lc3BhY2VzKG5hbWVzcGFjZXMpIHtcbiAgICBuYW1lc3BhY2VzLmZvckVhY2gobnMgPT4ge1xuICAgICAgdGhpcy51c2VkTmFtZXNwYWNlc1tuc10gPz89IHRydWU7XG4gICAgfSk7XG4gIH1cbiAgZ2V0VXNlZE5hbWVzcGFjZXMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMudXNlZE5hbWVzcGFjZXMpO1xuICB9XG59XG5leHBvcnQgY29uc3QgY29tcG9zZUluaXRpYWxQcm9wcyA9IEZvckNvbXBvbmVudCA9PiBhc3luYyBjdHggPT4ge1xuICBjb25zdCBjb21wb25lbnRzSW5pdGlhbFByb3BzID0gKGF3YWl0IEZvckNvbXBvbmVudC5nZXRJbml0aWFsUHJvcHM/LihjdHgpKSA/PyB7fTtcbiAgY29uc3QgaTE4bkluaXRpYWxQcm9wcyA9IGdldEluaXRpYWxQcm9wcygpO1xuICByZXR1cm4ge1xuICAgIC4uLmNvbXBvbmVudHNJbml0aWFsUHJvcHMsXG4gICAgLi4uaTE4bkluaXRpYWxQcm9wc1xuICB9O1xufTtcbmV4cG9ydCBjb25zdCBnZXRJbml0aWFsUHJvcHMgPSAoKSA9PiB7XG4gIGNvbnN0IGkxOG4gPSBnZXRJMThuKCk7XG4gIGNvbnN0IG5hbWVzcGFjZXMgPSBpMThuLnJlcG9ydE5hbWVzcGFjZXM/LmdldFVzZWROYW1lc3BhY2VzKCkgPz8gW107XG4gIGNvbnN0IHJldCA9IHt9O1xuICBjb25zdCBpbml0aWFsSTE4blN0b3JlID0ge307XG4gIGkxOG4ubGFuZ3VhZ2VzLmZvckVhY2gobCA9PiB7XG4gICAgaW5pdGlhbEkxOG5TdG9yZVtsXSA9IHt9O1xuICAgIG5hbWVzcGFjZXMuZm9yRWFjaChucyA9PiB7XG4gICAgICBpbml0aWFsSTE4blN0b3JlW2xdW25zXSA9IGkxOG4uZ2V0UmVzb3VyY2VCdW5kbGUobCwgbnMpIHx8IHt9O1xuICAgIH0pO1xuICB9KTtcbiAgcmV0LmluaXRpYWxJMThuU3RvcmUgPSBpbml0aWFsSTE4blN0b3JlO1xuICByZXQuaW5pdGlhbExhbmd1YWdlID0gaTE4bi5sYW5ndWFnZTtcbiAgcmV0dXJuIHJldDtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/react-i18next/dist/es/context.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/react-i18next/dist/es/defaults.js":
/*!************************************************************!*\
  !*** ../../node_modules/react-i18next/dist/es/defaults.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getDefaults: function() { return /* binding */ getDefaults; },\n/* harmony export */   setDefaults: function() { return /* binding */ setDefaults; }\n/* harmony export */ });\n/* harmony import */ var _unescape_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./unescape.js */ \"(app-pages-browser)/../../node_modules/react-i18next/dist/es/unescape.js\");\n\nlet defaultOptions = {\n  bindI18n: 'languageChanged',\n  bindI18nStore: '',\n  transEmptyNodeValue: '',\n  transSupportBasicHtmlNodes: true,\n  transWrapTextNodes: '',\n  transKeepBasicHtmlNodesFor: ['br', 'strong', 'i', 'p'],\n  useSuspense: true,\n  unescape: _unescape_js__WEBPACK_IMPORTED_MODULE_0__.unescape\n};\nconst setDefaults = (options = {}) => {\n  defaultOptions = {\n    ...defaultOptions,\n    ...options\n  };\n};\nconst getDefaults = () => defaultOptions;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QtaTE4bmV4dC9kaXN0L2VzL2RlZmF1bHRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ08saUNBQWlDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWkxOG5leHQvZGlzdC9lcy9kZWZhdWx0cy5qcz84Nzg1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVuZXNjYXBlIH0gZnJvbSAnLi91bmVzY2FwZS5qcyc7XG5sZXQgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGJpbmRJMThuOiAnbGFuZ3VhZ2VDaGFuZ2VkJyxcbiAgYmluZEkxOG5TdG9yZTogJycsXG4gIHRyYW5zRW1wdHlOb2RlVmFsdWU6ICcnLFxuICB0cmFuc1N1cHBvcnRCYXNpY0h0bWxOb2RlczogdHJ1ZSxcbiAgdHJhbnNXcmFwVGV4dE5vZGVzOiAnJyxcbiAgdHJhbnNLZWVwQmFzaWNIdG1sTm9kZXNGb3I6IFsnYnInLCAnc3Ryb25nJywgJ2knLCAncCddLFxuICB1c2VTdXNwZW5zZTogdHJ1ZSxcbiAgdW5lc2NhcGVcbn07XG5leHBvcnQgY29uc3Qgc2V0RGVmYXVsdHMgPSAob3B0aW9ucyA9IHt9KSA9PiB7XG4gIGRlZmF1bHRPcHRpb25zID0ge1xuICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbn07XG5leHBvcnQgY29uc3QgZ2V0RGVmYXVsdHMgPSAoKSA9PiBkZWZhdWx0T3B0aW9uczsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/react-i18next/dist/es/defaults.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/react-i18next/dist/es/i18nInstance.js":
/*!****************************************************************!*\
  !*** ../../node_modules/react-i18next/dist/es/i18nInstance.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getI18n: function() { return /* binding */ getI18n; },\n/* harmony export */   setI18n: function() { return /* binding */ setI18n; }\n/* harmony export */ });\nlet i18nInstance;\nconst setI18n = instance => {\n  i18nInstance = instance;\n};\nconst getI18n = () => i18nInstance;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QtaTE4bmV4dC9kaXN0L2VzL2kxOG5JbnN0YW5jZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ087QUFDUDtBQUNBO0FBQ08iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1pMThuZXh0L2Rpc3QvZXMvaTE4bkluc3RhbmNlLmpzPzVmMjMiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IGkxOG5JbnN0YW5jZTtcbmV4cG9ydCBjb25zdCBzZXRJMThuID0gaW5zdGFuY2UgPT4ge1xuICBpMThuSW5zdGFuY2UgPSBpbnN0YW5jZTtcbn07XG5leHBvcnQgY29uc3QgZ2V0STE4biA9ICgpID0+IGkxOG5JbnN0YW5jZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/react-i18next/dist/es/i18nInstance.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/react-i18next/dist/es/index.js":
/*!*********************************************************!*\
  !*** ../../node_modules/react-i18next/dist/es/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   I18nContext: function() { return /* reexport safe */ _context_js__WEBPACK_IMPORTED_MODULE_11__.I18nContext; },\n/* harmony export */   I18nextProvider: function() { return /* reexport safe */ _I18nextProvider_js__WEBPACK_IMPORTED_MODULE_5__.I18nextProvider; },\n/* harmony export */   Trans: function() { return /* reexport safe */ _Trans_js__WEBPACK_IMPORTED_MODULE_0__.Trans; },\n/* harmony export */   TransWithoutContext: function() { return /* reexport safe */ _TransWithoutContext_js__WEBPACK_IMPORTED_MODULE_1__.Trans; },\n/* harmony export */   Translation: function() { return /* reexport safe */ _Translation_js__WEBPACK_IMPORTED_MODULE_4__.Translation; },\n/* harmony export */   composeInitialProps: function() { return /* reexport safe */ _context_js__WEBPACK_IMPORTED_MODULE_11__.composeInitialProps; },\n/* harmony export */   date: function() { return /* binding */ date; },\n/* harmony export */   getDefaults: function() { return /* reexport safe */ _defaults_js__WEBPACK_IMPORTED_MODULE_9__.getDefaults; },\n/* harmony export */   getI18n: function() { return /* reexport safe */ _i18nInstance_js__WEBPACK_IMPORTED_MODULE_10__.getI18n; },\n/* harmony export */   getInitialProps: function() { return /* reexport safe */ _context_js__WEBPACK_IMPORTED_MODULE_11__.getInitialProps; },\n/* harmony export */   initReactI18next: function() { return /* reexport safe */ _initReactI18next_js__WEBPACK_IMPORTED_MODULE_8__.initReactI18next; },\n/* harmony export */   number: function() { return /* binding */ number; },\n/* harmony export */   plural: function() { return /* binding */ plural; },\n/* harmony export */   select: function() { return /* binding */ select; },\n/* harmony export */   selectOrdinal: function() { return /* binding */ selectOrdinal; },\n/* harmony export */   setDefaults: function() { return /* reexport safe */ _defaults_js__WEBPACK_IMPORTED_MODULE_9__.setDefaults; },\n/* harmony export */   setI18n: function() { return /* reexport safe */ _i18nInstance_js__WEBPACK_IMPORTED_MODULE_10__.setI18n; },\n/* harmony export */   time: function() { return /* binding */ time; },\n/* harmony export */   useSSR: function() { return /* reexport safe */ _useSSR_js__WEBPACK_IMPORTED_MODULE_7__.useSSR; },\n/* harmony export */   useTranslation: function() { return /* reexport safe */ _useTranslation_js__WEBPACK_IMPORTED_MODULE_2__.useTranslation; },\n/* harmony export */   withSSR: function() { return /* reexport safe */ _withSSR_js__WEBPACK_IMPORTED_MODULE_6__.withSSR; },\n/* harmony export */   withTranslation: function() { return /* reexport safe */ _withTranslation_js__WEBPACK_IMPORTED_MODULE_3__.withTranslation; }\n/* harmony export */ });\n/* harmony import */ var _Trans_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Trans.js */ \"(app-pages-browser)/../../node_modules/react-i18next/dist/es/Trans.js\");\n/* harmony import */ var _TransWithoutContext_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TransWithoutContext.js */ \"(app-pages-browser)/../../node_modules/react-i18next/dist/es/TransWithoutContext.js\");\n/* harmony import */ var _useTranslation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./useTranslation.js */ \"(app-pages-browser)/../../node_modules/react-i18next/dist/es/useTranslation.js\");\n/* harmony import */ var _withTranslation_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./withTranslation.js */ \"(app-pages-browser)/../../node_modules/react-i18next/dist/es/withTranslation.js\");\n/* harmony import */ var _Translation_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Translation.js */ \"(app-pages-browser)/../../node_modules/react-i18next/dist/es/Translation.js\");\n/* harmony import */ var _I18nextProvider_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./I18nextProvider.js */ \"(app-pages-browser)/../../node_modules/react-i18next/dist/es/I18nextProvider.js\");\n/* harmony import */ var _withSSR_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./withSSR.js */ \"(app-pages-browser)/../../node_modules/react-i18next/dist/es/withSSR.js\");\n/* harmony import */ var _useSSR_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./useSSR.js */ \"(app-pages-browser)/../../node_modules/react-i18next/dist/es/useSSR.js\");\n/* harmony import */ var _initReactI18next_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./initReactI18next.js */ \"(app-pages-browser)/../../node_modules/react-i18next/dist/es/initReactI18next.js\");\n/* harmony import */ var _defaults_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./defaults.js */ \"(app-pages-browser)/../../node_modules/react-i18next/dist/es/defaults.js\");\n/* harmony import */ var _i18nInstance_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./i18nInstance.js */ \"(app-pages-browser)/../../node_modules/react-i18next/dist/es/i18nInstance.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./context.js */ \"(app-pages-browser)/../../node_modules/react-i18next/dist/es/context.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nconst date = () => '';\nconst time = () => '';\nconst number = () => '';\nconst select = () => '';\nconst plural = () => '';\nconst selectOrdinal = () => '';//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QtaTE4bmV4dC9kaXN0L2VzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBbUM7QUFDcUM7QUFDbkI7QUFDRTtBQUNSO0FBQ1E7QUFDaEI7QUFDRjtBQUNvQjtBQUNBO0FBQ0o7QUFDNEI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QtaTE4bmV4dC9kaXN0L2VzL2luZGV4LmpzPzNjMTgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgVHJhbnMgfSBmcm9tICcuL1RyYW5zLmpzJztcbmV4cG9ydCB7IFRyYW5zIGFzIFRyYW5zV2l0aG91dENvbnRleHQgfSBmcm9tICcuL1RyYW5zV2l0aG91dENvbnRleHQuanMnO1xuZXhwb3J0IHsgdXNlVHJhbnNsYXRpb24gfSBmcm9tICcuL3VzZVRyYW5zbGF0aW9uLmpzJztcbmV4cG9ydCB7IHdpdGhUcmFuc2xhdGlvbiB9IGZyb20gJy4vd2l0aFRyYW5zbGF0aW9uLmpzJztcbmV4cG9ydCB7IFRyYW5zbGF0aW9uIH0gZnJvbSAnLi9UcmFuc2xhdGlvbi5qcyc7XG5leHBvcnQgeyBJMThuZXh0UHJvdmlkZXIgfSBmcm9tICcuL0kxOG5leHRQcm92aWRlci5qcyc7XG5leHBvcnQgeyB3aXRoU1NSIH0gZnJvbSAnLi93aXRoU1NSLmpzJztcbmV4cG9ydCB7IHVzZVNTUiB9IGZyb20gJy4vdXNlU1NSLmpzJztcbmV4cG9ydCB7IGluaXRSZWFjdEkxOG5leHQgfSBmcm9tICcuL2luaXRSZWFjdEkxOG5leHQuanMnO1xuZXhwb3J0IHsgc2V0RGVmYXVsdHMsIGdldERlZmF1bHRzIH0gZnJvbSAnLi9kZWZhdWx0cy5qcyc7XG5leHBvcnQgeyBzZXRJMThuLCBnZXRJMThuIH0gZnJvbSAnLi9pMThuSW5zdGFuY2UuanMnO1xuZXhwb3J0IHsgSTE4bkNvbnRleHQsIGNvbXBvc2VJbml0aWFsUHJvcHMsIGdldEluaXRpYWxQcm9wcyB9IGZyb20gJy4vY29udGV4dC5qcyc7XG5leHBvcnQgY29uc3QgZGF0ZSA9ICgpID0+ICcnO1xuZXhwb3J0IGNvbnN0IHRpbWUgPSAoKSA9PiAnJztcbmV4cG9ydCBjb25zdCBudW1iZXIgPSAoKSA9PiAnJztcbmV4cG9ydCBjb25zdCBzZWxlY3QgPSAoKSA9PiAnJztcbmV4cG9ydCBjb25zdCBwbHVyYWwgPSAoKSA9PiAnJztcbmV4cG9ydCBjb25zdCBzZWxlY3RPcmRpbmFsID0gKCkgPT4gJyc7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/react-i18next/dist/es/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/react-i18next/dist/es/initReactI18next.js":
/*!********************************************************************!*\
  !*** ../../node_modules/react-i18next/dist/es/initReactI18next.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   initReactI18next: function() { return /* binding */ initReactI18next; }\n/* harmony export */ });\n/* harmony import */ var _defaults_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defaults.js */ \"(app-pages-browser)/../../node_modules/react-i18next/dist/es/defaults.js\");\n/* harmony import */ var _i18nInstance_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./i18nInstance.js */ \"(app-pages-browser)/../../node_modules/react-i18next/dist/es/i18nInstance.js\");\n\n\nconst initReactI18next = {\n  type: '3rdParty',\n  init(instance) {\n    (0,_defaults_js__WEBPACK_IMPORTED_MODULE_0__.setDefaults)(instance.options.react);\n    (0,_i18nInstance_js__WEBPACK_IMPORTED_MODULE_1__.setI18n)(instance);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QtaTE4bmV4dC9kaXN0L2VzL2luaXRSZWFjdEkxOG5leHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTRDO0FBQ0E7QUFDckM7QUFDUDtBQUNBO0FBQ0EsSUFBSSx5REFBVztBQUNmLElBQUkseURBQU87QUFDWDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QtaTE4bmV4dC9kaXN0L2VzL2luaXRSZWFjdEkxOG5leHQuanM/YTUyYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzZXREZWZhdWx0cyB9IGZyb20gJy4vZGVmYXVsdHMuanMnO1xuaW1wb3J0IHsgc2V0STE4biB9IGZyb20gJy4vaTE4bkluc3RhbmNlLmpzJztcbmV4cG9ydCBjb25zdCBpbml0UmVhY3RJMThuZXh0ID0ge1xuICB0eXBlOiAnM3JkUGFydHknLFxuICBpbml0KGluc3RhbmNlKSB7XG4gICAgc2V0RGVmYXVsdHMoaW5zdGFuY2Uub3B0aW9ucy5yZWFjdCk7XG4gICAgc2V0STE4bihpbnN0YW5jZSk7XG4gIH1cbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/react-i18next/dist/es/initReactI18next.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/react-i18next/dist/es/unescape.js":
/*!************************************************************!*\
  !*** ../../node_modules/react-i18next/dist/es/unescape.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   unescape: function() { return /* binding */ unescape; }\n/* harmony export */ });\nconst matchHtmlEntity = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g;\nconst htmlEntities = {\n  '&amp;': '&',\n  '&#38;': '&',\n  '&lt;': '<',\n  '&#60;': '<',\n  '&gt;': '>',\n  '&#62;': '>',\n  '&apos;': \"'\",\n  '&#39;': \"'\",\n  '&quot;': '\"',\n  '&#34;': '\"',\n  '&nbsp;': ' ',\n  '&#160;': ' ',\n  '&copy;': '',\n  '&#169;': '',\n  '&reg;': '',\n  '&#174;': '',\n  '&hellip;': '',\n  '&#8230;': '',\n  '&#x2F;': '/',\n  '&#47;': '/'\n};\nconst unescapeHtmlEntity = m => htmlEntities[m];\nconst unescape = text => text.replace(matchHtmlEntity, unescapeHtmlEntity);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QtaTE4bmV4dC9kaXN0L2VzL3VuZXNjYXBlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSx5SEFBeUg7QUFDekg7QUFDQSxRQUFRO0FBQ1IsUUFBUTtBQUNSLE9BQU87QUFDUCxRQUFRO0FBQ1IsT0FBTztBQUNQLFFBQVE7QUFDUixTQUFTO0FBQ1QsUUFBUTtBQUNSLFNBQVM7QUFDVCxRQUFRO0FBQ1IsU0FBUztBQUNULFNBQVM7QUFDVCxTQUFTO0FBQ1QsU0FBUztBQUNULFFBQVE7QUFDUixTQUFTO0FBQ1QsV0FBVztBQUNYLFVBQVU7QUFDVixTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDTyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWkxOG5leHQvZGlzdC9lcy91bmVzY2FwZS5qcz80MjFjIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IG1hdGNoSHRtbEVudGl0eSA9IC8mKD86YW1wfCMzOHxsdHwjNjB8Z3R8IzYyfGFwb3N8IzM5fHF1b3R8IzM0fG5ic3B8IzE2MHxjb3B5fCMxNjl8cmVnfCMxNzR8aGVsbGlwfCM4MjMwfCN4MkZ8IzQ3KTsvZztcbmNvbnN0IGh0bWxFbnRpdGllcyA9IHtcbiAgJyZhbXA7JzogJyYnLFxuICAnJiMzODsnOiAnJicsXG4gICcmbHQ7JzogJzwnLFxuICAnJiM2MDsnOiAnPCcsXG4gICcmZ3Q7JzogJz4nLFxuICAnJiM2MjsnOiAnPicsXG4gICcmYXBvczsnOiBcIidcIixcbiAgJyYjMzk7JzogXCInXCIsXG4gICcmcXVvdDsnOiAnXCInLFxuICAnJiMzNDsnOiAnXCInLFxuICAnJm5ic3A7JzogJyAnLFxuICAnJiMxNjA7JzogJyAnLFxuICAnJmNvcHk7JzogJ8KpJyxcbiAgJyYjMTY5Oyc6ICfCqScsXG4gICcmcmVnOyc6ICfCricsXG4gICcmIzE3NDsnOiAnwq4nLFxuICAnJmhlbGxpcDsnOiAn4oCmJyxcbiAgJyYjODIzMDsnOiAn4oCmJyxcbiAgJyYjeDJGOyc6ICcvJyxcbiAgJyYjNDc7JzogJy8nXG59O1xuY29uc3QgdW5lc2NhcGVIdG1sRW50aXR5ID0gbSA9PiBodG1sRW50aXRpZXNbbV07XG5leHBvcnQgY29uc3QgdW5lc2NhcGUgPSB0ZXh0ID0+IHRleHQucmVwbGFjZShtYXRjaEh0bWxFbnRpdHksIHVuZXNjYXBlSHRtbEVudGl0eSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/react-i18next/dist/es/unescape.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/react-i18next/dist/es/useSSR.js":
/*!**********************************************************!*\
  !*** ../../node_modules/react-i18next/dist/es/useSSR.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSSR: function() { return /* binding */ useSSR; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./context.js */ \"(app-pages-browser)/../../node_modules/react-i18next/dist/es/context.js\");\n\n\nconst useSSR = (initialI18nStore, initialLanguage, props = {}) => {\n  const {\n    i18n: i18nFromProps\n  } = props;\n  const {\n    i18n: i18nFromContext\n  } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(_context_js__WEBPACK_IMPORTED_MODULE_1__.I18nContext) || {};\n  const i18n = i18nFromProps || i18nFromContext || (0,_context_js__WEBPACK_IMPORTED_MODULE_1__.getI18n)();\n  if (i18n.options?.isClone) return;\n  if (initialI18nStore && !i18n.initializedStoreOnce) {\n    i18n.services.resourceStore.data = initialI18nStore;\n    i18n.options.ns = Object.values(initialI18nStore).reduce((mem, lngResources) => {\n      Object.keys(lngResources).forEach(ns => {\n        if (mem.indexOf(ns) < 0) mem.push(ns);\n      });\n      return mem;\n    }, i18n.options.ns);\n    i18n.initializedStoreOnce = true;\n    i18n.isInitialized = true;\n  }\n  if (initialLanguage && !i18n.initializedLanguageOnce) {\n    i18n.changeLanguage(initialLanguage);\n    i18n.initializedLanguageOnce = true;\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QtaTE4bmV4dC9kaXN0L2VzL3VzZVNTUi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBbUM7QUFDaUI7QUFDN0MsNkRBQTZEO0FBQ3BFO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUksRUFBRSxpREFBVSxDQUFDLG9EQUFXO0FBQzVCLG1EQUFtRCxvREFBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWkxOG5leHQvZGlzdC9lcy91c2VTU1IuanM/MjZmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZ2V0STE4biwgSTE4bkNvbnRleHQgfSBmcm9tICcuL2NvbnRleHQuanMnO1xuZXhwb3J0IGNvbnN0IHVzZVNTUiA9IChpbml0aWFsSTE4blN0b3JlLCBpbml0aWFsTGFuZ3VhZ2UsIHByb3BzID0ge30pID0+IHtcbiAgY29uc3Qge1xuICAgIGkxOG46IGkxOG5Gcm9tUHJvcHNcbiAgfSA9IHByb3BzO1xuICBjb25zdCB7XG4gICAgaTE4bjogaTE4bkZyb21Db250ZXh0XG4gIH0gPSB1c2VDb250ZXh0KEkxOG5Db250ZXh0KSB8fCB7fTtcbiAgY29uc3QgaTE4biA9IGkxOG5Gcm9tUHJvcHMgfHwgaTE4bkZyb21Db250ZXh0IHx8IGdldEkxOG4oKTtcbiAgaWYgKGkxOG4ub3B0aW9ucz8uaXNDbG9uZSkgcmV0dXJuO1xuICBpZiAoaW5pdGlhbEkxOG5TdG9yZSAmJiAhaTE4bi5pbml0aWFsaXplZFN0b3JlT25jZSkge1xuICAgIGkxOG4uc2VydmljZXMucmVzb3VyY2VTdG9yZS5kYXRhID0gaW5pdGlhbEkxOG5TdG9yZTtcbiAgICBpMThuLm9wdGlvbnMubnMgPSBPYmplY3QudmFsdWVzKGluaXRpYWxJMThuU3RvcmUpLnJlZHVjZSgobWVtLCBsbmdSZXNvdXJjZXMpID0+IHtcbiAgICAgIE9iamVjdC5rZXlzKGxuZ1Jlc291cmNlcykuZm9yRWFjaChucyA9PiB7XG4gICAgICAgIGlmIChtZW0uaW5kZXhPZihucykgPCAwKSBtZW0ucHVzaChucyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBtZW07XG4gICAgfSwgaTE4bi5vcHRpb25zLm5zKTtcbiAgICBpMThuLmluaXRpYWxpemVkU3RvcmVPbmNlID0gdHJ1ZTtcbiAgICBpMThuLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICB9XG4gIGlmIChpbml0aWFsTGFuZ3VhZ2UgJiYgIWkxOG4uaW5pdGlhbGl6ZWRMYW5ndWFnZU9uY2UpIHtcbiAgICBpMThuLmNoYW5nZUxhbmd1YWdlKGluaXRpYWxMYW5ndWFnZSk7XG4gICAgaTE4bi5pbml0aWFsaXplZExhbmd1YWdlT25jZSA9IHRydWU7XG4gIH1cbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/react-i18next/dist/es/useSSR.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/react-i18next/dist/es/useTranslation.js":
/*!******************************************************************!*\
  !*** ../../node_modules/react-i18next/dist/es/useTranslation.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useTranslation: function() { return /* binding */ useTranslation; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./context.js */ \"(app-pages-browser)/../../node_modules/react-i18next/dist/es/context.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../../node_modules/react-i18next/dist/es/utils.js\");\n\n\n\nconst usePrevious = (value, ignore) => {\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    ref.current = ignore ? ref.current : value;\n  }, [value, ignore]);\n  return ref.current;\n};\nconst alwaysNewT = (i18n, language, namespace, keyPrefix) => i18n.getFixedT(language, namespace, keyPrefix);\nconst useMemoizedT = (i18n, language, namespace, keyPrefix) => (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(alwaysNewT(i18n, language, namespace, keyPrefix), [i18n, language, namespace, keyPrefix]);\nconst useTranslation = (ns, props = {}) => {\n  const {\n    i18n: i18nFromProps\n  } = props;\n  const {\n    i18n: i18nFromContext,\n    defaultNS: defaultNSFromContext\n  } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(_context_js__WEBPACK_IMPORTED_MODULE_1__.I18nContext) || {};\n  const i18n = i18nFromProps || i18nFromContext || (0,_context_js__WEBPACK_IMPORTED_MODULE_1__.getI18n)();\n  if (i18n && !i18n.reportNamespaces) i18n.reportNamespaces = new _context_js__WEBPACK_IMPORTED_MODULE_1__.ReportNamespaces();\n  if (!i18n) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.warnOnce)('You will need to pass in an i18next instance by using initReactI18next');\n    const notReadyT = (k, optsOrDefaultValue) => {\n      if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.isString)(optsOrDefaultValue)) return optsOrDefaultValue;\n      if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.isObject)(optsOrDefaultValue) && (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.isString)(optsOrDefaultValue.defaultValue)) return optsOrDefaultValue.defaultValue;\n      return Array.isArray(k) ? k[k.length - 1] : k;\n    };\n    const retNotReady = [notReadyT, {}, false];\n    retNotReady.t = notReadyT;\n    retNotReady.i18n = {};\n    retNotReady.ready = false;\n    return retNotReady;\n  }\n  if (i18n.options.react?.wait) (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.warnOnce)('It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.');\n  const i18nOptions = {\n    ...(0,_context_js__WEBPACK_IMPORTED_MODULE_1__.getDefaults)(),\n    ...i18n.options.react,\n    ...props\n  };\n  const {\n    useSuspense,\n    keyPrefix\n  } = i18nOptions;\n  let namespaces = ns || defaultNSFromContext || i18n.options?.defaultNS;\n  namespaces = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.isString)(namespaces) ? [namespaces] : namespaces || ['translation'];\n  i18n.reportNamespaces.addUsedNamespaces?.(namespaces);\n  const ready = (i18n.isInitialized || i18n.initializedStoreOnce) && namespaces.every(n => (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.hasLoadedNamespace)(n, i18n, i18nOptions));\n  const memoGetT = useMemoizedT(i18n, props.lng || null, i18nOptions.nsMode === 'fallback' ? namespaces : namespaces[0], keyPrefix);\n  const getT = () => memoGetT;\n  const getNewT = () => alwaysNewT(i18n, props.lng || null, i18nOptions.nsMode === 'fallback' ? namespaces : namespaces[0], keyPrefix);\n  const [t, setT] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(getT);\n  let joinedNS = namespaces.join();\n  if (props.lng) joinedNS = `${props.lng}${joinedNS}`;\n  const previousJoinedNS = usePrevious(joinedNS);\n  const isMounted = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const {\n      bindI18n,\n      bindI18nStore\n    } = i18nOptions;\n    isMounted.current = true;\n    if (!ready && !useSuspense) {\n      if (props.lng) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.loadLanguages)(i18n, props.lng, namespaces, () => {\n          if (isMounted.current) setT(getNewT);\n        });\n      } else {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.loadNamespaces)(i18n, namespaces, () => {\n          if (isMounted.current) setT(getNewT);\n        });\n      }\n    }\n    if (ready && previousJoinedNS && previousJoinedNS !== joinedNS && isMounted.current) {\n      setT(getNewT);\n    }\n    const boundReset = () => {\n      if (isMounted.current) setT(getNewT);\n    };\n    if (bindI18n) i18n?.on(bindI18n, boundReset);\n    if (bindI18nStore) i18n?.store.on(bindI18nStore, boundReset);\n    return () => {\n      isMounted.current = false;\n      if (i18n) bindI18n?.split(' ').forEach(e => i18n.off(e, boundReset));\n      if (bindI18nStore && i18n) bindI18nStore.split(' ').forEach(e => i18n.store.off(e, boundReset));\n    };\n  }, [i18n, joinedNS]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (isMounted.current && ready) {\n      setT(getT);\n    }\n  }, [i18n, keyPrefix, ready]);\n  const ret = [t, i18n, ready];\n  ret.t = t;\n  ret.i18n = i18n;\n  ret.ready = ready;\n  if (ready) return ret;\n  if (!ready && !useSuspense) return ret;\n  throw new Promise(resolve => {\n    if (props.lng) {\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.loadLanguages)(i18n, props.lng, namespaces, () => resolve());\n    } else {\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.loadNamespaces)(i18n, namespaces, () => resolve());\n    }\n  });\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QtaTE4bmV4dC9kaXN0L2VzL3VzZVRyYW5zbGF0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBNkU7QUFDTTtBQUMwQjtBQUM3RztBQUNBLGNBQWMsNkNBQU07QUFDcEIsRUFBRSxnREFBUztBQUNYO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxrREFBVztBQUNuRSxzQ0FBc0M7QUFDN0M7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJLEVBQUUsaURBQVUsQ0FBQyxvREFBVztBQUM1QixtREFBbUQsb0RBQU87QUFDMUQsa0VBQWtFLHlEQUFnQjtBQUNsRjtBQUNBLElBQUksbURBQVE7QUFDWjtBQUNBLFVBQVUsbURBQVE7QUFDbEIsVUFBVSxtREFBUSx3QkFBd0IsbURBQVE7QUFDbEQ7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG1EQUFRO0FBQ3hDO0FBQ0EsT0FBTyx3REFBVztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxlQUFlLG1EQUFRO0FBQ3ZCO0FBQ0EsMkZBQTJGLDZEQUFrQjtBQUM3RztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0NBQVE7QUFDNUI7QUFDQSwrQkFBK0IsVUFBVSxFQUFFLFNBQVM7QUFDcEQ7QUFDQSxvQkFBb0IsNkNBQU07QUFDMUIsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdEQUFhO0FBQ3JCO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUixRQUFRLHlEQUFjO0FBQ3RCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHdEQUFhO0FBQ25CLE1BQU07QUFDTixNQUFNLHlEQUFjO0FBQ3BCO0FBQ0EsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QtaTE4bmV4dC9kaXN0L2VzL3VzZVRyYW5zbGF0aW9uLmpzP2UyNzkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlQ29udGV4dCwgdXNlUmVmLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGdldEkxOG4sIGdldERlZmF1bHRzLCBSZXBvcnROYW1lc3BhY2VzLCBJMThuQ29udGV4dCB9IGZyb20gJy4vY29udGV4dC5qcyc7XG5pbXBvcnQgeyB3YXJuT25jZSwgbG9hZE5hbWVzcGFjZXMsIGxvYWRMYW5ndWFnZXMsIGhhc0xvYWRlZE5hbWVzcGFjZSwgaXNTdHJpbmcsIGlzT2JqZWN0IH0gZnJvbSAnLi91dGlscy5qcyc7XG5jb25zdCB1c2VQcmV2aW91cyA9ICh2YWx1ZSwgaWdub3JlKSA9PiB7XG4gIGNvbnN0IHJlZiA9IHVzZVJlZigpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJlZi5jdXJyZW50ID0gaWdub3JlID8gcmVmLmN1cnJlbnQgOiB2YWx1ZTtcbiAgfSwgW3ZhbHVlLCBpZ25vcmVdKTtcbiAgcmV0dXJuIHJlZi5jdXJyZW50O1xufTtcbmNvbnN0IGFsd2F5c05ld1QgPSAoaTE4biwgbGFuZ3VhZ2UsIG5hbWVzcGFjZSwga2V5UHJlZml4KSA9PiBpMThuLmdldEZpeGVkVChsYW5ndWFnZSwgbmFtZXNwYWNlLCBrZXlQcmVmaXgpO1xuY29uc3QgdXNlTWVtb2l6ZWRUID0gKGkxOG4sIGxhbmd1YWdlLCBuYW1lc3BhY2UsIGtleVByZWZpeCkgPT4gdXNlQ2FsbGJhY2soYWx3YXlzTmV3VChpMThuLCBsYW5ndWFnZSwgbmFtZXNwYWNlLCBrZXlQcmVmaXgpLCBbaTE4biwgbGFuZ3VhZ2UsIG5hbWVzcGFjZSwga2V5UHJlZml4XSk7XG5leHBvcnQgY29uc3QgdXNlVHJhbnNsYXRpb24gPSAobnMsIHByb3BzID0ge30pID0+IHtcbiAgY29uc3Qge1xuICAgIGkxOG46IGkxOG5Gcm9tUHJvcHNcbiAgfSA9IHByb3BzO1xuICBjb25zdCB7XG4gICAgaTE4bjogaTE4bkZyb21Db250ZXh0LFxuICAgIGRlZmF1bHROUzogZGVmYXVsdE5TRnJvbUNvbnRleHRcbiAgfSA9IHVzZUNvbnRleHQoSTE4bkNvbnRleHQpIHx8IHt9O1xuICBjb25zdCBpMThuID0gaTE4bkZyb21Qcm9wcyB8fCBpMThuRnJvbUNvbnRleHQgfHwgZ2V0STE4bigpO1xuICBpZiAoaTE4biAmJiAhaTE4bi5yZXBvcnROYW1lc3BhY2VzKSBpMThuLnJlcG9ydE5hbWVzcGFjZXMgPSBuZXcgUmVwb3J0TmFtZXNwYWNlcygpO1xuICBpZiAoIWkxOG4pIHtcbiAgICB3YXJuT25jZSgnWW91IHdpbGwgbmVlZCB0byBwYXNzIGluIGFuIGkxOG5leHQgaW5zdGFuY2UgYnkgdXNpbmcgaW5pdFJlYWN0STE4bmV4dCcpO1xuICAgIGNvbnN0IG5vdFJlYWR5VCA9IChrLCBvcHRzT3JEZWZhdWx0VmFsdWUpID0+IHtcbiAgICAgIGlmIChpc1N0cmluZyhvcHRzT3JEZWZhdWx0VmFsdWUpKSByZXR1cm4gb3B0c09yRGVmYXVsdFZhbHVlO1xuICAgICAgaWYgKGlzT2JqZWN0KG9wdHNPckRlZmF1bHRWYWx1ZSkgJiYgaXNTdHJpbmcob3B0c09yRGVmYXVsdFZhbHVlLmRlZmF1bHRWYWx1ZSkpIHJldHVybiBvcHRzT3JEZWZhdWx0VmFsdWUuZGVmYXVsdFZhbHVlO1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoaykgPyBrW2subGVuZ3RoIC0gMV0gOiBrO1xuICAgIH07XG4gICAgY29uc3QgcmV0Tm90UmVhZHkgPSBbbm90UmVhZHlULCB7fSwgZmFsc2VdO1xuICAgIHJldE5vdFJlYWR5LnQgPSBub3RSZWFkeVQ7XG4gICAgcmV0Tm90UmVhZHkuaTE4biA9IHt9O1xuICAgIHJldE5vdFJlYWR5LnJlYWR5ID0gZmFsc2U7XG4gICAgcmV0dXJuIHJldE5vdFJlYWR5O1xuICB9XG4gIGlmIChpMThuLm9wdGlvbnMucmVhY3Q/LndhaXQpIHdhcm5PbmNlKCdJdCBzZWVtcyB5b3UgYXJlIHN0aWxsIHVzaW5nIHRoZSBvbGQgd2FpdCBvcHRpb24sIHlvdSBtYXkgbWlncmF0ZSB0byB0aGUgbmV3IHVzZVN1c3BlbnNlIGJlaGF2aW91ci4nKTtcbiAgY29uc3QgaTE4bk9wdGlvbnMgPSB7XG4gICAgLi4uZ2V0RGVmYXVsdHMoKSxcbiAgICAuLi5pMThuLm9wdGlvbnMucmVhY3QsXG4gICAgLi4ucHJvcHNcbiAgfTtcbiAgY29uc3Qge1xuICAgIHVzZVN1c3BlbnNlLFxuICAgIGtleVByZWZpeFxuICB9ID0gaTE4bk9wdGlvbnM7XG4gIGxldCBuYW1lc3BhY2VzID0gbnMgfHwgZGVmYXVsdE5TRnJvbUNvbnRleHQgfHwgaTE4bi5vcHRpb25zPy5kZWZhdWx0TlM7XG4gIG5hbWVzcGFjZXMgPSBpc1N0cmluZyhuYW1lc3BhY2VzKSA/IFtuYW1lc3BhY2VzXSA6IG5hbWVzcGFjZXMgfHwgWyd0cmFuc2xhdGlvbiddO1xuICBpMThuLnJlcG9ydE5hbWVzcGFjZXMuYWRkVXNlZE5hbWVzcGFjZXM/LihuYW1lc3BhY2VzKTtcbiAgY29uc3QgcmVhZHkgPSAoaTE4bi5pc0luaXRpYWxpemVkIHx8IGkxOG4uaW5pdGlhbGl6ZWRTdG9yZU9uY2UpICYmIG5hbWVzcGFjZXMuZXZlcnkobiA9PiBoYXNMb2FkZWROYW1lc3BhY2UobiwgaTE4biwgaTE4bk9wdGlvbnMpKTtcbiAgY29uc3QgbWVtb0dldFQgPSB1c2VNZW1vaXplZFQoaTE4biwgcHJvcHMubG5nIHx8IG51bGwsIGkxOG5PcHRpb25zLm5zTW9kZSA9PT0gJ2ZhbGxiYWNrJyA/IG5hbWVzcGFjZXMgOiBuYW1lc3BhY2VzWzBdLCBrZXlQcmVmaXgpO1xuICBjb25zdCBnZXRUID0gKCkgPT4gbWVtb0dldFQ7XG4gIGNvbnN0IGdldE5ld1QgPSAoKSA9PiBhbHdheXNOZXdUKGkxOG4sIHByb3BzLmxuZyB8fCBudWxsLCBpMThuT3B0aW9ucy5uc01vZGUgPT09ICdmYWxsYmFjaycgPyBuYW1lc3BhY2VzIDogbmFtZXNwYWNlc1swXSwga2V5UHJlZml4KTtcbiAgY29uc3QgW3QsIHNldFRdID0gdXNlU3RhdGUoZ2V0VCk7XG4gIGxldCBqb2luZWROUyA9IG5hbWVzcGFjZXMuam9pbigpO1xuICBpZiAocHJvcHMubG5nKSBqb2luZWROUyA9IGAke3Byb3BzLmxuZ30ke2pvaW5lZE5TfWA7XG4gIGNvbnN0IHByZXZpb3VzSm9pbmVkTlMgPSB1c2VQcmV2aW91cyhqb2luZWROUyk7XG4gIGNvbnN0IGlzTW91bnRlZCA9IHVzZVJlZih0cnVlKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBiaW5kSTE4bixcbiAgICAgIGJpbmRJMThuU3RvcmVcbiAgICB9ID0gaTE4bk9wdGlvbnM7XG4gICAgaXNNb3VudGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgIGlmICghcmVhZHkgJiYgIXVzZVN1c3BlbnNlKSB7XG4gICAgICBpZiAocHJvcHMubG5nKSB7XG4gICAgICAgIGxvYWRMYW5ndWFnZXMoaTE4biwgcHJvcHMubG5nLCBuYW1lc3BhY2VzLCAoKSA9PiB7XG4gICAgICAgICAgaWYgKGlzTW91bnRlZC5jdXJyZW50KSBzZXRUKGdldE5ld1QpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvYWROYW1lc3BhY2VzKGkxOG4sIG5hbWVzcGFjZXMsICgpID0+IHtcbiAgICAgICAgICBpZiAoaXNNb3VudGVkLmN1cnJlbnQpIHNldFQoZ2V0TmV3VCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVhZHkgJiYgcHJldmlvdXNKb2luZWROUyAmJiBwcmV2aW91c0pvaW5lZE5TICE9PSBqb2luZWROUyAmJiBpc01vdW50ZWQuY3VycmVudCkge1xuICAgICAgc2V0VChnZXROZXdUKTtcbiAgICB9XG4gICAgY29uc3QgYm91bmRSZXNldCA9ICgpID0+IHtcbiAgICAgIGlmIChpc01vdW50ZWQuY3VycmVudCkgc2V0VChnZXROZXdUKTtcbiAgICB9O1xuICAgIGlmIChiaW5kSTE4bikgaTE4bj8ub24oYmluZEkxOG4sIGJvdW5kUmVzZXQpO1xuICAgIGlmIChiaW5kSTE4blN0b3JlKSBpMThuPy5zdG9yZS5vbihiaW5kSTE4blN0b3JlLCBib3VuZFJlc2V0KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaXNNb3VudGVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIGlmIChpMThuKSBiaW5kSTE4bj8uc3BsaXQoJyAnKS5mb3JFYWNoKGUgPT4gaTE4bi5vZmYoZSwgYm91bmRSZXNldCkpO1xuICAgICAgaWYgKGJpbmRJMThuU3RvcmUgJiYgaTE4bikgYmluZEkxOG5TdG9yZS5zcGxpdCgnICcpLmZvckVhY2goZSA9PiBpMThuLnN0b3JlLm9mZihlLCBib3VuZFJlc2V0KSk7XG4gICAgfTtcbiAgfSwgW2kxOG4sIGpvaW5lZE5TXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGlzTW91bnRlZC5jdXJyZW50ICYmIHJlYWR5KSB7XG4gICAgICBzZXRUKGdldFQpO1xuICAgIH1cbiAgfSwgW2kxOG4sIGtleVByZWZpeCwgcmVhZHldKTtcbiAgY29uc3QgcmV0ID0gW3QsIGkxOG4sIHJlYWR5XTtcbiAgcmV0LnQgPSB0O1xuICByZXQuaTE4biA9IGkxOG47XG4gIHJldC5yZWFkeSA9IHJlYWR5O1xuICBpZiAocmVhZHkpIHJldHVybiByZXQ7XG4gIGlmICghcmVhZHkgJiYgIXVzZVN1c3BlbnNlKSByZXR1cm4gcmV0O1xuICB0aHJvdyBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICBpZiAocHJvcHMubG5nKSB7XG4gICAgICBsb2FkTGFuZ3VhZ2VzKGkxOG4sIHByb3BzLmxuZywgbmFtZXNwYWNlcywgKCkgPT4gcmVzb2x2ZSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9hZE5hbWVzcGFjZXMoaTE4biwgbmFtZXNwYWNlcywgKCkgPT4gcmVzb2x2ZSgpKTtcbiAgICB9XG4gIH0pO1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/react-i18next/dist/es/useTranslation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/react-i18next/dist/es/utils.js":
/*!*********************************************************!*\
  !*** ../../node_modules/react-i18next/dist/es/utils.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getDisplayName: function() { return /* binding */ getDisplayName; },\n/* harmony export */   hasLoadedNamespace: function() { return /* binding */ hasLoadedNamespace; },\n/* harmony export */   isObject: function() { return /* binding */ isObject; },\n/* harmony export */   isString: function() { return /* binding */ isString; },\n/* harmony export */   loadLanguages: function() { return /* binding */ loadLanguages; },\n/* harmony export */   loadNamespaces: function() { return /* binding */ loadNamespaces; },\n/* harmony export */   warn: function() { return /* binding */ warn; },\n/* harmony export */   warnOnce: function() { return /* binding */ warnOnce; }\n/* harmony export */ });\nconst warn = (...args) => {\n  if (console?.warn) {\n    if (isString(args[0])) args[0] = `react-i18next:: ${args[0]}`;\n    console.warn(...args);\n  }\n};\nconst alreadyWarned = {};\nconst warnOnce = (...args) => {\n  if (isString(args[0]) && alreadyWarned[args[0]]) return;\n  if (isString(args[0])) alreadyWarned[args[0]] = new Date();\n  warn(...args);\n};\nconst loadedClb = (i18n, cb) => () => {\n  if (i18n.isInitialized) {\n    cb();\n  } else {\n    const initialized = () => {\n      setTimeout(() => {\n        i18n.off('initialized', initialized);\n      }, 0);\n      cb();\n    };\n    i18n.on('initialized', initialized);\n  }\n};\nconst loadNamespaces = (i18n, ns, cb) => {\n  i18n.loadNamespaces(ns, loadedClb(i18n, cb));\n};\nconst loadLanguages = (i18n, lng, ns, cb) => {\n  if (isString(ns)) ns = [ns];\n  ns.forEach(n => {\n    if (i18n.options.ns.indexOf(n) < 0) i18n.options.ns.push(n);\n  });\n  i18n.loadLanguages(lng, loadedClb(i18n, cb));\n};\nconst hasLoadedNamespace = (ns, i18n, options = {}) => {\n  if (!i18n.languages || !i18n.languages.length) {\n    warnOnce('i18n.languages were undefined or empty', i18n.languages);\n    return true;\n  }\n  return i18n.hasLoadedNamespace(ns, {\n    lng: options.lng,\n    precheck: (i18nInstance, loadNotPending) => {\n      if (options.bindI18n?.indexOf('languageChanging') > -1 && i18nInstance.services.backendConnector.backend && i18nInstance.isLanguageChangingTo && !loadNotPending(i18nInstance.isLanguageChangingTo, ns)) return false;\n    }\n  });\n};\nconst getDisplayName = Component => Component.displayName || Component.name || (isString(Component) && Component.length > 0 ? Component : 'Unknown');\nconst isString = obj => typeof obj === 'string';\nconst isObject = obj => typeof obj === 'object' && obj !== null;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QtaTE4bmV4dC9kaXN0L2VzL3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQU87QUFDUDtBQUNBLHdEQUF3RCxRQUFRO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDTyxrREFBa0Q7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ087QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QtaTE4bmV4dC9kaXN0L2VzL3V0aWxzLmpzPzkwNzkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHdhcm4gPSAoLi4uYXJncykgPT4ge1xuICBpZiAoY29uc29sZT8ud2Fybikge1xuICAgIGlmIChpc1N0cmluZyhhcmdzWzBdKSkgYXJnc1swXSA9IGByZWFjdC1pMThuZXh0OjogJHthcmdzWzBdfWA7XG4gICAgY29uc29sZS53YXJuKC4uLmFyZ3MpO1xuICB9XG59O1xuY29uc3QgYWxyZWFkeVdhcm5lZCA9IHt9O1xuZXhwb3J0IGNvbnN0IHdhcm5PbmNlID0gKC4uLmFyZ3MpID0+IHtcbiAgaWYgKGlzU3RyaW5nKGFyZ3NbMF0pICYmIGFscmVhZHlXYXJuZWRbYXJnc1swXV0pIHJldHVybjtcbiAgaWYgKGlzU3RyaW5nKGFyZ3NbMF0pKSBhbHJlYWR5V2FybmVkW2FyZ3NbMF1dID0gbmV3IERhdGUoKTtcbiAgd2FybiguLi5hcmdzKTtcbn07XG5jb25zdCBsb2FkZWRDbGIgPSAoaTE4biwgY2IpID0+ICgpID0+IHtcbiAgaWYgKGkxOG4uaXNJbml0aWFsaXplZCkge1xuICAgIGNiKCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgaW5pdGlhbGl6ZWQgPSAoKSA9PiB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaTE4bi5vZmYoJ2luaXRpYWxpemVkJywgaW5pdGlhbGl6ZWQpO1xuICAgICAgfSwgMCk7XG4gICAgICBjYigpO1xuICAgIH07XG4gICAgaTE4bi5vbignaW5pdGlhbGl6ZWQnLCBpbml0aWFsaXplZCk7XG4gIH1cbn07XG5leHBvcnQgY29uc3QgbG9hZE5hbWVzcGFjZXMgPSAoaTE4biwgbnMsIGNiKSA9PiB7XG4gIGkxOG4ubG9hZE5hbWVzcGFjZXMobnMsIGxvYWRlZENsYihpMThuLCBjYikpO1xufTtcbmV4cG9ydCBjb25zdCBsb2FkTGFuZ3VhZ2VzID0gKGkxOG4sIGxuZywgbnMsIGNiKSA9PiB7XG4gIGlmIChpc1N0cmluZyhucykpIG5zID0gW25zXTtcbiAgbnMuZm9yRWFjaChuID0+IHtcbiAgICBpZiAoaTE4bi5vcHRpb25zLm5zLmluZGV4T2YobikgPCAwKSBpMThuLm9wdGlvbnMubnMucHVzaChuKTtcbiAgfSk7XG4gIGkxOG4ubG9hZExhbmd1YWdlcyhsbmcsIGxvYWRlZENsYihpMThuLCBjYikpO1xufTtcbmV4cG9ydCBjb25zdCBoYXNMb2FkZWROYW1lc3BhY2UgPSAobnMsIGkxOG4sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBpZiAoIWkxOG4ubGFuZ3VhZ2VzIHx8ICFpMThuLmxhbmd1YWdlcy5sZW5ndGgpIHtcbiAgICB3YXJuT25jZSgnaTE4bi5sYW5ndWFnZXMgd2VyZSB1bmRlZmluZWQgb3IgZW1wdHknLCBpMThuLmxhbmd1YWdlcyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGkxOG4uaGFzTG9hZGVkTmFtZXNwYWNlKG5zLCB7XG4gICAgbG5nOiBvcHRpb25zLmxuZyxcbiAgICBwcmVjaGVjazogKGkxOG5JbnN0YW5jZSwgbG9hZE5vdFBlbmRpbmcpID0+IHtcbiAgICAgIGlmIChvcHRpb25zLmJpbmRJMThuPy5pbmRleE9mKCdsYW5ndWFnZUNoYW5naW5nJykgPiAtMSAmJiBpMThuSW5zdGFuY2Uuc2VydmljZXMuYmFja2VuZENvbm5lY3Rvci5iYWNrZW5kICYmIGkxOG5JbnN0YW5jZS5pc0xhbmd1YWdlQ2hhbmdpbmdUbyAmJiAhbG9hZE5vdFBlbmRpbmcoaTE4bkluc3RhbmNlLmlzTGFuZ3VhZ2VDaGFuZ2luZ1RvLCBucykpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xufTtcbmV4cG9ydCBjb25zdCBnZXREaXNwbGF5TmFtZSA9IENvbXBvbmVudCA9PiBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgKGlzU3RyaW5nKENvbXBvbmVudCkgJiYgQ29tcG9uZW50Lmxlbmd0aCA+IDAgPyBDb21wb25lbnQgOiAnVW5rbm93bicpO1xuZXhwb3J0IGNvbnN0IGlzU3RyaW5nID0gb2JqID0+IHR5cGVvZiBvYmogPT09ICdzdHJpbmcnO1xuZXhwb3J0IGNvbnN0IGlzT2JqZWN0ID0gb2JqID0+IHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/react-i18next/dist/es/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/react-i18next/dist/es/withSSR.js":
/*!***********************************************************!*\
  !*** ../../node_modules/react-i18next/dist/es/withSSR.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   withSSR: function() { return /* binding */ withSSR; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _useSSR_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./useSSR.js */ \"(app-pages-browser)/../../node_modules/react-i18next/dist/es/useSSR.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./context.js */ \"(app-pages-browser)/../../node_modules/react-i18next/dist/es/context.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../../node_modules/react-i18next/dist/es/utils.js\");\n\n\n\n\nconst withSSR = () => function Extend(WrappedComponent) {\n  function I18nextWithSSR({\n    initialI18nStore,\n    initialLanguage,\n    ...rest\n  }) {\n    (0,_useSSR_js__WEBPACK_IMPORTED_MODULE_1__.useSSR)(initialI18nStore, initialLanguage);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(WrappedComponent, {\n      ...rest\n    });\n  }\n  I18nextWithSSR.getInitialProps = (0,_context_js__WEBPACK_IMPORTED_MODULE_2__.composeInitialProps)(WrappedComponent);\n  I18nextWithSSR.displayName = `withI18nextSSR(${(0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.getDisplayName)(WrappedComponent)})`;\n  I18nextWithSSR.WrappedComponent = WrappedComponent;\n  return I18nextWithSSR;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QtaTE4bmV4dC9kaXN0L2VzL3dpdGhTU1IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBc0M7QUFDRDtBQUNjO0FBQ1A7QUFDckM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxJQUFJLGtEQUFNO0FBQ1YsV0FBVyxvREFBYTtBQUN4QjtBQUNBLEtBQUs7QUFDTDtBQUNBLG1DQUFtQyxnRUFBbUI7QUFDdEQsaURBQWlELHlEQUFjLG1CQUFtQjtBQUNsRjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1pMThuZXh0L2Rpc3QvZXMvd2l0aFNTUi5qcz9mMDc3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUVsZW1lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VTU1IgfSBmcm9tICcuL3VzZVNTUi5qcyc7XG5pbXBvcnQgeyBjb21wb3NlSW5pdGlhbFByb3BzIH0gZnJvbSAnLi9jb250ZXh0LmpzJztcbmltcG9ydCB7IGdldERpc3BsYXlOYW1lIH0gZnJvbSAnLi91dGlscy5qcyc7XG5leHBvcnQgY29uc3Qgd2l0aFNTUiA9ICgpID0+IGZ1bmN0aW9uIEV4dGVuZChXcmFwcGVkQ29tcG9uZW50KSB7XG4gIGZ1bmN0aW9uIEkxOG5leHRXaXRoU1NSKHtcbiAgICBpbml0aWFsSTE4blN0b3JlLFxuICAgIGluaXRpYWxMYW5ndWFnZSxcbiAgICAuLi5yZXN0XG4gIH0pIHtcbiAgICB1c2VTU1IoaW5pdGlhbEkxOG5TdG9yZSwgaW5pdGlhbExhbmd1YWdlKTtcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChXcmFwcGVkQ29tcG9uZW50LCB7XG4gICAgICAuLi5yZXN0XG4gICAgfSk7XG4gIH1cbiAgSTE4bmV4dFdpdGhTU1IuZ2V0SW5pdGlhbFByb3BzID0gY29tcG9zZUluaXRpYWxQcm9wcyhXcmFwcGVkQ29tcG9uZW50KTtcbiAgSTE4bmV4dFdpdGhTU1IuZGlzcGxheU5hbWUgPSBgd2l0aEkxOG5leHRTU1IoJHtnZXREaXNwbGF5TmFtZShXcmFwcGVkQ29tcG9uZW50KX0pYDtcbiAgSTE4bmV4dFdpdGhTU1IuV3JhcHBlZENvbXBvbmVudCA9IFdyYXBwZWRDb21wb25lbnQ7XG4gIHJldHVybiBJMThuZXh0V2l0aFNTUjtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/react-i18next/dist/es/withSSR.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/react-i18next/dist/es/withTranslation.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/react-i18next/dist/es/withTranslation.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   withTranslation: function() { return /* binding */ withTranslation; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _useTranslation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./useTranslation.js */ \"(app-pages-browser)/../../node_modules/react-i18next/dist/es/useTranslation.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../../node_modules/react-i18next/dist/es/utils.js\");\n\n\n\nconst withTranslation = (ns, options = {}) => function Extend(WrappedComponent) {\n  function I18nextWithTranslation({\n    forwardedRef,\n    ...rest\n  }) {\n    const [t, i18n, ready] = (0,_useTranslation_js__WEBPACK_IMPORTED_MODULE_1__.useTranslation)(ns, {\n      ...rest,\n      keyPrefix: options.keyPrefix\n    });\n    const passDownProps = {\n      ...rest,\n      t,\n      i18n,\n      tReady: ready\n    };\n    if (options.withRef && forwardedRef) {\n      passDownProps.ref = forwardedRef;\n    } else if (!options.withRef && forwardedRef) {\n      passDownProps.forwardedRef = forwardedRef;\n    }\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(WrappedComponent, passDownProps);\n  }\n  I18nextWithTranslation.displayName = `withI18nextTranslation(${(0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.getDisplayName)(WrappedComponent)})`;\n  I18nextWithTranslation.WrappedComponent = WrappedComponent;\n  const forwardRef = (props, ref) => (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(I18nextWithTranslation, Object.assign({}, props, {\n    forwardedRef: ref\n  }));\n  return options.withRef ? (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(forwardRef) : I18nextWithTranslation;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QtaTE4bmV4dC9kaXN0L2VzL3dpdGhUcmFuc2xhdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXFFO0FBQ2hCO0FBQ1Q7QUFDckMseUNBQXlDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCw2QkFBNkIsa0VBQWM7QUFDM0M7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxXQUFXLG9EQUFhO0FBQ3hCO0FBQ0EsaUVBQWlFLHlEQUFjLG1CQUFtQjtBQUNsRztBQUNBLHFDQUFxQyxvREFBYSx5Q0FBeUM7QUFDM0Y7QUFDQSxHQUFHO0FBQ0gsMkJBQTJCLGlEQUFlO0FBQzFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QtaTE4bmV4dC9kaXN0L2VzL3dpdGhUcmFuc2xhdGlvbi5qcz8wZDE2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIGZvcndhcmRSZWYgYXMgZm9yd2FyZFJlZlJlYWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlVHJhbnNsYXRpb24gfSBmcm9tICcuL3VzZVRyYW5zbGF0aW9uLmpzJztcbmltcG9ydCB7IGdldERpc3BsYXlOYW1lIH0gZnJvbSAnLi91dGlscy5qcyc7XG5leHBvcnQgY29uc3Qgd2l0aFRyYW5zbGF0aW9uID0gKG5zLCBvcHRpb25zID0ge30pID0+IGZ1bmN0aW9uIEV4dGVuZChXcmFwcGVkQ29tcG9uZW50KSB7XG4gIGZ1bmN0aW9uIEkxOG5leHRXaXRoVHJhbnNsYXRpb24oe1xuICAgIGZvcndhcmRlZFJlZixcbiAgICAuLi5yZXN0XG4gIH0pIHtcbiAgICBjb25zdCBbdCwgaTE4biwgcmVhZHldID0gdXNlVHJhbnNsYXRpb24obnMsIHtcbiAgICAgIC4uLnJlc3QsXG4gICAgICBrZXlQcmVmaXg6IG9wdGlvbnMua2V5UHJlZml4XG4gICAgfSk7XG4gICAgY29uc3QgcGFzc0Rvd25Qcm9wcyA9IHtcbiAgICAgIC4uLnJlc3QsXG4gICAgICB0LFxuICAgICAgaTE4bixcbiAgICAgIHRSZWFkeTogcmVhZHlcbiAgICB9O1xuICAgIGlmIChvcHRpb25zLndpdGhSZWYgJiYgZm9yd2FyZGVkUmVmKSB7XG4gICAgICBwYXNzRG93blByb3BzLnJlZiA9IGZvcndhcmRlZFJlZjtcbiAgICB9IGVsc2UgaWYgKCFvcHRpb25zLndpdGhSZWYgJiYgZm9yd2FyZGVkUmVmKSB7XG4gICAgICBwYXNzRG93blByb3BzLmZvcndhcmRlZFJlZiA9IGZvcndhcmRlZFJlZjtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoV3JhcHBlZENvbXBvbmVudCwgcGFzc0Rvd25Qcm9wcyk7XG4gIH1cbiAgSTE4bmV4dFdpdGhUcmFuc2xhdGlvbi5kaXNwbGF5TmFtZSA9IGB3aXRoSTE4bmV4dFRyYW5zbGF0aW9uKCR7Z2V0RGlzcGxheU5hbWUoV3JhcHBlZENvbXBvbmVudCl9KWA7XG4gIEkxOG5leHRXaXRoVHJhbnNsYXRpb24uV3JhcHBlZENvbXBvbmVudCA9IFdyYXBwZWRDb21wb25lbnQ7XG4gIGNvbnN0IGZvcndhcmRSZWYgPSAocHJvcHMsIHJlZikgPT4gY3JlYXRlRWxlbWVudChJMThuZXh0V2l0aFRyYW5zbGF0aW9uLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywge1xuICAgIGZvcndhcmRlZFJlZjogcmVmXG4gIH0pKTtcbiAgcmV0dXJuIG9wdGlvbnMud2l0aFJlZiA/IGZvcndhcmRSZWZSZWFjdChmb3J3YXJkUmVmKSA6IEkxOG5leHRXaXRoVHJhbnNsYXRpb247XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/react-i18next/dist/es/withTranslation.js\n"));

/***/ })

}]);