type Account = record { owner : principal; subaccount : opt vec nat8 };
type Account_1 = variant {
  account_id : text;
  "principal" : principal;
  extensible : CandyShared;
  account : record { owner : principal; sub_account : opt vec nat8 };
};
type AskFeature = variant {
  kyc : principal;
  start_price : nat;
  token : TokenSpec;
  notify : vec principal;
  wait_for_quiet : record { max : nat; fade : float64; extension : nat64 };
  reserve : nat;
  start_date : int;
  min_increase : AskFeature_min_increase;
  allow_list : vec principal;
  buy_now : nat;
  nifty_settlement : record {
    fixed : bool;
    interestRatePerSecond : float64;
    duration : opt int;
    expiration : opt int;
    lenderOffer : bool;
  };
  atomic;
  dutch : DutchParams;
  ending : AskFeature_ending;
};
type AskFeature_ending = variant { date : int; timeout : nat };
type AskFeature_min_increase = variant { amount : nat; percentage : float64 };
type AuctionConfig__1 = record {
  start_price : nat;
  token : TokenSpec;
  reserve : opt nat;
  start_date : int;
  min_increase : AskFeature_min_increase;
  allow_list : opt vec principal;
  buy_now : opt nat;
  ending : AuctionConfig__1_ending;
};
type AuctionConfig__1_ending = variant {
  date : int;
  wait_for_quiet : record {
    max : nat;
    date : int;
    fade : float64;
    extension : nat64;
  };
};
type AuctionStateShared = record {
  status : AuctionStateShared_status;
  participants : vec record { principal; int };
  token : TokenSpec;
  current_bid_amount : nat;
  winner : opt Account_1;
  end_date : int;
  start_date : int;
  wait_for_quiet_count : opt nat;
  current_escrow : opt EscrowReceipt;
  allow_list : opt vec record { principal; bool };
  current_broker_id : opt principal;
  min_next_bid : nat;
  config : PricingConfigShared__1;
};
type AuctionStateShared_status = variant { closed; open; not_started };
type Box = variant {
  Int : int;
  Map : vec record { Box; Box };
  Nat : nat;
  Set : vec CandyShared;
  Nat16 : nat16;
  Nat32 : nat32;
  Nat64 : nat64;
  Blob : vec nat8;
  Bool : bool;
  Int8 : int8;
  Ints : vec int;
  Nat8 : nat8;
  Nats : vec nat;
  Text : text;
  Bytes : vec nat8;
  Int16 : int16;
  Int32 : int32;
  Int64 : int64;
  Option : opt Box;
  Floats : vec float64;
  Float : float64;
  Principal : principal;
  Array : vec CandyShared;
  Class : vec record { value : Box; name : text; immutable : bool };
};
type CandyShared = variant {
  Int : int;
  Map : vec record { Box; Box };
  Nat : nat;
  Set : vec CandyShared;
  Nat16 : nat16;
  Nat32 : nat32;
  Nat64 : nat64;
  Blob : vec nat8;
  Bool : bool;
  Int8 : int8;
  Ints : vec int;
  Nat8 : nat8;
  Nats : vec nat;
  Text : text;
  Bytes : vec nat8;
  Int16 : int16;
  Int32 : int32;
  Int64 : int64;
  Option : opt Box;
  Floats : vec float64;
  Float : float64;
  Principal : principal;
  Array : vec CandyShared;
  Class : vec PropertyShared;
};
type CanisterLogFeature = variant {
  filterMessageByContains;
  filterMessageByRegex;
};
type CanisterLogMessages = record {
  data : vec LogMessageData;
  lastAnalyzedMessageTimeNanos : opt nat64;
};
type CanisterLogMessagesInfo = record {
  features : vec opt CanisterLogFeature;
  lastTimeNanos : opt nat64;
  count : nat32;
  firstTimeNanos : opt nat64;
};
type CanisterLogRequest = variant {
  getMessagesInfo;
  getMessages : GetLogMessagesParameters;
  getLatestMessages : GetLatestLogMessagesParameters;
};
type CanisterLogResponse = variant {
  messagesInfo : CanisterLogMessagesInfo;
  messages : CanisterLogMessages;
};
type CanisterMetrics = record { data : CanisterMetricsData };
type CanisterMetricsData = variant {
  hourly : vec HourlyMetricsData;
  daily : vec DailyMetricsData;
};
type CollectMetricsRequestType = variant { force; normal };
type Conf = record {
  gld_nft_canister_ids : vec record { principal; NftCanisterConf };
  gldt_ledger_canister_id : principal;
};
type DailyMetricsData = record {
  updateCalls : nat64;
  canisterHeapMemorySize : NumericEntity;
  canisterCycles : NumericEntity;
  canisterMemorySize : NumericEntity;
  timeMillis : int;
};
type DutchParams = record {
  time_unit : DutchParams_time_unit;
  decay_type : DutchParams_decay_type;
};
type DutchParams_decay_type = variant { flat : nat; percent : float64 };
type DutchParams_time_unit = variant { day : nat; hour : nat; minute : nat };
type EscrowReceipt = record {
  token : TokenSpec;
  token_id : text;
  seller : Account_1;
  buyer : Account_1;
  amount : nat;
};
type GetInformationRequest = record {
  status : opt StatusRequest;
  metrics : opt MetricsRequest;
  logs : opt CanisterLogRequest;
  version : bool;
};
type GetInformationResponse = record {
  status : opt StatusResponse;
  metrics : opt MetricsResponse;
  logs : opt CanisterLogResponse;
  version : opt nat;
};
type GetLatestLogMessagesParameters = record {
  upToTimeNanos : opt nat64;
  count : nat32;
  filter : opt GetLogMessagesFilter;
};
type GetLogMessagesFilter = record {
  analyzeCount : nat32;
  messageRegex : opt text;
  messageContains : opt text;
};
type GetLogMessagesParameters = record {
  count : nat32;
  filter : opt GetLogMessagesFilter;
  fromTimeNanos : opt nat64;
};
type GetMetricsParameters = record {
  dateToMillis : nat;
  granularity : MetricsGranularity;
  dateFromMillis : nat;
};
type GetRecordsRequest = record { page : opt nat32; limit : opt nat32 };
type GetRecordsResponse = record { total : nat32; data : opt vec GldtRecord };
type GetStatusRequest = record {
  nft_id : text;
  gld_nft_canister_id : principal;
  sale_id : text;
};
type GetStatusResponse = record { status : opt SwappingStates };
type GldNft = record {
  requested_memo : vec nat8;
  older_record : opt GldNft;
  to_subaccount : vec nat8;
  minted : opt GldtMinted;
  swapped : opt GldtSwapped;
  receiving_account : Account;
  grams : nat16;
  gldt_minting_timestamp_seconds : nat64;
  nft_sale_id : text;
  gld_nft_canister_id : principal;
};
type GldtBurned = record { burn_block_height : nat64 };
type GldtMinted = record {
  num_tokens : opt GldtNumTokens;
  mint_block_height : opt nat;
  last_audited_timestamp_seconds : nat64;
  burned : opt GldtBurned;
};
type GldtNumTokens = record { value : nat };
type GldtRecord = record {
  nft_id : text;
  record_type : RecordType;
  memo : vec nat8;
  num_tokens : GldtNumTokens;
  escrow_subaccount : opt vec nat8;
  counterparty : Account;
  grams : nat16;
  timestamp : nat64;
  nft_sale_id : text;
  gld_nft_canister_id : principal;
  block_height : nat;
};
type GldtSwapped = record { index : nat; sale_id : text };
type HourlyMetricsData = record {
  updateCalls : vec nat64;
  canisterHeapMemorySize : vec nat64;
  canisterCycles : vec nat64;
  canisterMemorySize : vec nat64;
  timeMillis : int;
};
type ICTokenSpec = record {
  id : opt nat;
  fee : opt nat;
  decimals : nat;
  canister : principal;
  standard : ICTokenSpec_standard;
  symbol : text;
};
type ICTokenSpec_standard = variant {
  ICRC1;
  EXTFungible;
  DIP20;
  Other : CandyShared;
  Ledger;
};
type InfoRequest = record { nft_id : text; source_canister : principal };
type LogMessageData = record { timeNanos : nat64; message : text };
type MetricsGranularity = variant { hourly; daily };
type MetricsRequest = record { parameters : GetMetricsParameters };
type MetricsResponse = record { metrics : opt CanisterMetrics };
type NftCanisterConf = record { grams : nat16 };
type NftInfo = record { info : opt GldNft };
type NumericEntity = record {
  avg : nat64;
  max : nat64;
  min : nat64;
  first : nat64;
  last : nat64;
};
type PricingConfigShared__1 = variant {
  ask : opt vec AskFeature;
  extensible : CandyShared;
  instant;
  auction : AuctionConfig__1;
};
type PropertyShared = record { value : Box; name : text; immutable : bool };
type RecordType = variant { Burn; Mint };
type Result = variant { Ok : GetRecordsResponse; Err : text };
type Result_1 = variant { Ok : GetStatusResponse; Err : text };
type Result_2 = variant { Ok : text; Err : text };
type SaleStatusShared = record {
  token_id : text;
  sale_type : SaleStatusShared_sale_type;
  broker_id : opt principal;
  original_broker_id : opt principal;
  sale_id : text;
};
type SaleStatusShared_sale_type = variant { auction : AuctionStateShared };
type StatusRequest = record {
  memory_size : bool;
  cycles : bool;
  heap_memory_size : bool;
};
type StatusResponse = record {
  memory_size : opt nat64;
  cycles : opt nat64;
  heap_memory_size : opt nat64;
};
type SubAccountInfo = record {
  account_id : vec nat8;
  "principal" : principal;
  account_id_text : text;
  account : SubAccountInfo_account;
};
type SubAccountInfo_account = record {
  "principal" : principal;
  sub_account : vec nat8;
};
type SubscriberNotification = record {
  collection : principal;
  sale : SaleStatusShared;
  seller : Account_1;
  escrow_info : SubAccountInfo;
};
type SwappingStates = variant {
  Burned;
  Initialised;
  Swapped;
  Finalised;
  Minted;
};
type TokenSpec = variant { ic : ICTokenSpec; extensible : CandyShared };
type UpdateInformationRequest = record {
  metrics : opt CollectMetricsRequestType;
};
service : (opt Conf) -> {
  __get_candid_interface_tmp_hack : () -> (text) query;
  getCanistergeekInformation : (GetInformationRequest) -> (
      GetInformationResponse,
    ) query;
  get_conf : () -> (Conf);
  get_records : (GetRecordsRequest) -> (Result) query;
  get_status_of_swap : (GetStatusRequest) -> (Result_1) query;
  get_swaps_by_user : (opt Account, opt nat32, opt nat32) -> (Result) query;
  nft_info : (InfoRequest) -> (NftInfo);
  notify_sale_nft_origyn : (SubscriberNotification) -> (Result_2);
  updateCanistergeekInformation : (UpdateInformationRequest) -> ();
}
