type Account = record { owner : principal; subaccount : opt vec nat8 };
type Account_1 = variant {
  account_id : text;
  "principal" : principal;
  extensible : CandyShared;
  account : record { owner : principal; sub_account : opt vec nat8 };
};
type AskFeature = variant {
  kyc : principal;
  start_price : nat;
  token : TokenSpec;
  notify : vec principal;
  wait_for_quiet : record { max : nat; fade : float64; extension : nat64 };
  reserve : nat;
  start_date : int;
  min_increase : AskFeature_min_increase;
  allow_list : vec principal;
  buy_now : nat;
  nifty_settlement : record {
    fixed : bool;
    interestRatePerSecond : float64;
    duration : opt int;
    expiration : opt int;
    lenderOffer : bool;
  };
  atomic;
  dutch : DutchParams;
  ending : AskFeature_ending;
};
type AskFeature_ending = variant { date : int; timeout : nat };
type AskFeature_min_increase = variant { amount : nat; percentage : float64 };
type AuctionConfig = record {
  start_price : nat;
  token : TokenSpec;
  reserve : opt nat;
  start_date : int;
  min_increase : AskFeature_min_increase;
  allow_list : opt vec principal;
  buy_now : opt nat;
  ending : AuctionConfig_ending;
};
type AuctionConfig_ending = variant {
  date : int;
  wait_for_quiet : record {
    max : nat;
    date : int;
    fade : float64;
    extension : nat64;
  };
};
type AuctionStateShared = record {
  status : AuctionStateShared_status;
  participants : vec record { principal; int };
  token : TokenSpec;
  current_bid_amount : nat;
  winner : opt Account_1;
  end_date : int;
  start_date : int;
  wait_for_quiet_count : opt nat;
  current_escrow : opt EscrowReceipt;
  allow_list : opt vec record { principal; bool };
  current_broker_id : opt principal;
  min_next_bid : nat;
  config : PricingConfigShared;
};
type AuctionStateShared_status = variant { closed; open; not_started };
type Box = variant {
  Int : int;
  Map : vec record { Box; Box };
  Nat : nat;
  Set : vec CandyShared;
  Nat16 : nat16;
  Nat32 : nat32;
  Nat64 : nat64;
  Blob : vec nat8;
  Bool : bool;
  Int8 : int8;
  Ints : vec int;
  Nat8 : nat8;
  Nats : vec nat;
  Text : text;
  Bytes : blob;
  Int16 : int16;
  Int32 : int32;
  Int64 : int64;
  Option : opt Box;
  Floats : vec float64;
  Float : float64;
  Principal : principal;
  Array : vec CandyShared;
  Class : vec record { value : Box; name : text; immutable : bool };
};
type CandyShared = variant {
  Int : int;
  Map : vec record { Box; Box };
  Nat : nat;
  Set : vec CandyShared;
  Nat16 : nat16;
  Nat32 : nat32;
  Nat64 : nat64;
  Blob : vec nat8;
  Bool : bool;
  Int8 : int8;
  Ints : vec int;
  Nat8 : nat8;
  Nats : vec nat;
  Text : text;
  Bytes : vec nat8;
  Int16 : int16;
  Int32 : int32;
  Int64 : int64;
  Option : opt Box;
  Floats : vec float64;
  Float : float64;
  Principal : principal;
  Array : vec CandyShared;
  Class : vec PropertyShared;
};
type Conf = record {
  gldt_fee_compensation_canister_id : principal;
  gld_nft_canister_ids : vec record { principal; NftCanisterConf };
  gldt_ledger_canister_id : principal;
};
type Custom = record { error_message : opt text; error_type : Type };
type DutchParams = record {
  time_unit : DutchParams_time_unit;
  decay_type : DutchParams_decay_type;
};
type DutchParams_decay_type = variant { flat : nat; percent : float64 };
type DutchParams_time_unit = variant { day : nat; hour : nat; minute : nat };
type Error = record { error_message : text; error_code : nat };
type EscrowReceipt = record {
  token : TokenSpec;
  token_id : text;
  seller : Account_1;
  buyer : Account_1;
  amount : nat;
};
type GetRecordsRequest = record { page : opt nat64; limit : opt nat64 };
type GetRecordsResponse = record { total : nat64; data : opt vec GldtRecord };
type GetStatusRequest = record {
  nft_id : text;
  gld_nft_canister_id : principal;
  sale_id : text;
};
type GetStatusResponse = record { status : opt SwappingStates };
type GetSwapsRequest = record {
  page : opt nat64;
  limit : opt nat64;
  account : opt Account;
};
type GldtError = variant {
  MintingError : opt Error;
  Other : opt Error;
  SwappingError : opt Error;
};
type GldtLedgerEntry = variant {
  Burned : GldtLedgerInfo;
  Minted : GldtLedgerInfo;
};
type GldtLedgerInfo = record { num_tokens : GldtNumTokens; block_height : nat };
type GldtNumTokens = record { value : nat };
type GldtRecord = record {
  nft_id : text;
  status : RecordStatusInfo;
  record_type : RecordType;
  num_tokens : GldtNumTokens;
  escrow_subaccount : vec nat8;
  counterparty : Account;
  grams : nat16;
  timestamp : nat64;
  nft_sale_id : text;
  gld_nft_canister_id : principal;
  block_height : nat;
};
type GldtRegistryEntry = record {
  older_record : opt GldtRegistryEntry;
  gldt_issue : SwapInfo;
  gldt_redeem : opt SwapInfo;
};
type GldtSwapped = record { index : nat; sale_id : text };
type ICTokenSpec = record {
  id : opt nat;
  fee : opt nat;
  decimals : nat;
  canister : principal;
  standard : ICTokenSpec_standard;
  symbol : text;
};
type ICTokenSpec_standard = variant {
  ICRC1;
  EXTFungible;
  DIP20;
  Other : CandyShared;
  Ledger;
};
type InfoRequest = record { nft_id : text; source_canister : principal };
type LockedInfoResponse = record {
  total_weight_locked : nat64;
  total_number_of_bars_locked : nat64;
};
type NftCanisterConf = record { grams : nat16 };
type NftInfo = record { info : opt GldtRegistryEntry };
type PricingConfigShared = variant {
  ask : opt vec AskFeature;
  extensible : CandyShared;
  instant;
  auction : AuctionConfig;
};
type PropertyShared = record { value : Box; name : text; immutable : bool };
type RecordStatus = variant { Failed; Ongoing; Success };
type RecordStatusInfo = record { status : RecordStatus; message : opt text };
type RecordType = variant { Burn; Mint };
type Result = variant { Ok : GetRecordsResponse; Err : text };
type Result_1 = variant { Ok : GetStatusResponse; Err : text };
type Result_2 = variant { Ok : text; Err : Custom };
type SaleStatusShared = record {
  token_id : text;
  sale_type : SaleStatusShared_sale_type;
  broker_id : opt principal;
  original_broker_id : opt principal;
  sale_id : text;
};
type SaleStatusShared_sale_type = variant { auction : AuctionStateShared };
type SubAccountInfo = record {
  account_id : vec nat8;
  "principal" : principal;
  account_id_text : text;
  account : SubAccountInfo_account;
};
type SubAccountInfo_account = record {
  "principal" : principal;
  sub_account : vec nat8;
};
type SubscriberNotification = record {
  collection : principal;
  sale : SaleStatusShared;
  seller : Account_1;
  escrow_info : SubAccountInfo;
};
type SwapInfo = record {
  requested_memo : vec nat8;
  ledger_entry : opt GldtLedgerEntry;
  num_tokens : GldtNumTokens;
  escrow_subaccount : vec nat8;
  swapped : opt GldtSwapped;
  receiving_account : Account;
  swap_request_timestamp : nat64;
  nft_sale_id : text;
  failed : opt GldtError;
};
type SwappingStates = variant { Burned; Initialised; Swapped; Minted };
type TokenSpec = variant { ic : ICTokenSpec; extensible : CandyShared };
type Type = variant {
  TransferError;
  Unauthorized;
  CompensationDisabled;
  Other;
};
service : (opt Conf) -> {
  fetch_metadata : () -> (text) query;
  get_conf : () -> (Conf) query;
  get_historical_swaps_by_user : (GetSwapsRequest) -> (Result) query;
  get_locked_info : () -> (LockedInfoResponse) query;
  get_ongoing_swaps_by_user : (GetSwapsRequest) -> (Result) query;
  get_records : (GetRecordsRequest) -> (Result) query;
  get_status_of_swap : (GetStatusRequest) -> (Result_1) query;
  import_data : (text) -> (Result_2);
  nft_info : (InfoRequest) -> (NftInfo) query;
  notify_sale_nft_origyn : (SubscriberNotification) -> ();
}
